// Machine generated by peg-sharp 1.0.0.0 from ../../HandRichTextParser/Parser.peg.

using System;
using System.Collections.Generic;
using System.Globalization;
//using System.Linq;								// TODO: this is handy enough that we'd like to include it by default, but we want the generated parsers to work with .NET 2.0 for now
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Text;
using RichTextParser;

[Serializable]
internal sealed partial class ParserException : Exception
{
	public ParserException(int line, int col, int offset, string file, string input, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
	{
		File = file;
		Line = line;
		Col = col;
	}
	
	public string File {get; private set;}
	public int Line {get; private set;}
	public int Col {get; private set;}
}

// Thread safe if Parser instances are not shared across threads.
internal sealed partial class Parser
{
	public Parser()
	{
		m_nonterminals[(int)NonTerminalEnum.Start] = new ParseMethod[]{this.DoParseStartRule};
		m_nonterminals[(int)NonTerminalEnum.Words] = new ParseMethod[]{this.DoParseWordsRule};
		m_nonterminals[(int)NonTerminalEnum.Word] = new ParseMethod[]{this.DoParseWordRule};
		m_nonterminals[(int)NonTerminalEnum.String] = new ParseMethod[]{this.DoParseStringRule};
		m_nonterminals[(int)NonTerminalEnum.MixString] = new ParseMethod[]{this.DoParseMixStringRule};
		m_nonterminals[(int)NonTerminalEnum.EscapeLeftTag] = new ParseMethod[]{this.DoParseEscapeLeftTagRule};
		m_nonterminals[(int)NonTerminalEnum.LeftTag] = new ParseMethod[]{this.DoParseLeftTagRule};
		m_nonterminals[(int)NonTerminalEnum.EscapeRightTag] = new ParseMethod[]{this.DoParseEscapeRightTagRule};
		m_nonterminals[(int)NonTerminalEnum.RightTag] = new ParseMethod[]{this.DoParseRightTagRule};
		m_nonterminals[(int)NonTerminalEnum.EscapeEscape] = new ParseMethod[]{this.DoParseEscapeEscapeRule};
		m_nonterminals[(int)NonTerminalEnum.HyperText] = new ParseMethod[]{this.DoParseHyperTextRule};
		m_nonterminals[(int)NonTerminalEnum.HyperWord] = new ParseMethod[]{this.DoParseHyperWordRule};
		m_nonterminals[(int)NonTerminalEnum.EmbedWord] = new ParseMethod[]{this.DoParseEmbedWordRule};
		m_nonterminals[(int)NonTerminalEnum.Attrs] = new ParseMethod[]{this.DoParseAttrsRule};
		m_nonterminals[(int)NonTerminalEnum.Attr] = new ParseMethod[]{this.DoParseAttrRule};
		m_nonterminals[(int)NonTerminalEnum.TagAttr] = new ParseMethod[]{this.DoParseTagAttrRule};
		m_nonterminals[(int)NonTerminalEnum.SimpleTag] = new ParseMethod[]{this.DoParseSimpleTagRule};
		m_nonterminals[(int)NonTerminalEnum.SimpleTagValue] = new ParseMethod[]{this.DoParseSimpleTagValueRule};
		m_nonterminals[(int)NonTerminalEnum.BraceAttr] = new ParseMethod[]{this.DoParseBraceAttrRule};
		m_nonterminals[(int)NonTerminalEnum.AttrValue] = new ParseMethod[]{this.DoParseAttrValueRule};
		m_nonterminals[(int)NonTerminalEnum.KeyValue] = new ParseMethod[]{this.DoParseKeyValueRule};
		m_nonterminals[(int)NonTerminalEnum.KeyNoValue] = new ParseMethod[]{this.DoParseKeyNoValueRule};
		m_nonterminals[(int)NonTerminalEnum.Id] = new ParseMethod[]{this.DoParseIdRule};
		m_nonterminals[(int)NonTerminalEnum.Value] = new ParseMethod[]{this.DoParseValueRule};
		m_nonterminals[(int)NonTerminalEnum.NotStrId] = new ParseMethod[]{this.DoParseNotStrIdRule};
		m_nonterminals[(int)NonTerminalEnum.NotStrVal] = new ParseMethod[]{this.DoParseNotStrValRule};
		m_nonterminals[(int)NonTerminalEnum.Str1] = new ParseMethod[]{this.DoParseStr1Rule};
		m_nonterminals[(int)NonTerminalEnum.Str2] = new ParseMethod[]{this.DoParseStr2Rule};
		m_nonterminals[(int)NonTerminalEnum.S0] = new ParseMethod[]{this.DoParseS0Rule};
		m_nonterminals[(int)NonTerminalEnum.S] = new ParseMethod[]{this.DoParseSRule};
		m_nonterminals[(int)NonTerminalEnum.EOF] = new ParseMethod[]{this.DoParseEOFRule};

		m_ParseMethod1 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Words);};
		m_ParseMethod2 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EOF);};
		m_ParseMethod3 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Word);};
		m_ParseMethod4 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.String);};
		m_ParseMethod5 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.MixString);};
		m_ParseMethod6 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, true, "[]`", string.Empty, null, "[^[\\]`]");};
		m_ParseMethod7 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.HyperText);};
		m_ParseMethod8 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeLeftTag);};
		m_ParseMethod9 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.LeftTag);};
		m_ParseMethod10 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeRightTag);};
		m_ParseMethod11 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.RightTag);};
		m_ParseMethod12 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeEscape);};
		m_ParseMethod13 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "[");};
		m_ParseMethod14 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Attrs);};
		m_ParseMethod15 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.HyperWord);};
		m_ParseMethod16 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "]");};
		m_ParseMethod17 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EmbedWord);};
		m_ParseMethod18 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.String);};
		m_ParseMethod19 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.HyperText);};
		m_ParseMethod20 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeLeftTag);};
		m_ParseMethod21 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeRightTag);};
		m_ParseMethod22 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeEscape);};
		m_ParseMethod23 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Attr);};
		m_ParseMethod24 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.TagAttr);};
		m_ParseMethod25 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.BraceAttr);};
		m_ParseMethod26 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod27 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.SimpleTag);};
		m_ParseMethod28 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod29 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.SimpleTagValue);};
		m_ParseMethod30 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod31 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "-");};
		m_ParseMethod32 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, false, "!@#$%&*+=\\:?|~^", string.Empty, null, "[!@#$%&*+=\\:?|~^]");};
		m_ParseMethod33 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, true, "!@#$%&*+=\\:?|~^`{[]\t\r\n -", string.Empty, null, "[^!@#$%&*+=\\:?|~^`{[\\]\t\r\n -]");};
		m_ParseMethod34 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod35 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "{");};
		m_ParseMethod36 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.AttrValue);};
		m_ParseMethod37 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "}");};
		m_ParseMethod38 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.KeyValue);};
		m_ParseMethod39 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.KeyNoValue);};
		m_ParseMethod40 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Id);};
		m_ParseMethod41 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, ":");};
		m_ParseMethod42 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Value);};
		m_ParseMethod43 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.NotStrId);};
		m_ParseMethod44 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str1);};
		m_ParseMethod45 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str2);};
		m_ParseMethod46 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.NotStrVal);};
		m_ParseMethod47 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str1);};
		m_ParseMethod48 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str2);};
		m_ParseMethod49 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, true, "'\":}", string.Empty, null, "[^'\":}]");};
		m_ParseMethod50 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod51);};
		m_ParseMethod51 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, ":}", string.Empty, null, "[^:}]");};
		m_ParseMethod52 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, true, "'\":}", string.Empty, null, "[^'\":}]");};
		m_ParseMethod53 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod54);};
		m_ParseMethod54 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, "}", string.Empty, null, "[^}]");};
		m_ParseMethod55 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "\"");};
		m_ParseMethod56 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod57);};
		m_ParseMethod57 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, "\"", string.Empty, null, "[^\"]");};
		m_ParseMethod58 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "\"");};
		m_ParseMethod59 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "'");};
		m_ParseMethod60 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod61);};
		m_ParseMethod61 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, "'", string.Empty, null, "[^']");};
		m_ParseMethod62 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "'");};
		m_ParseMethod63 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S);};
		m_ParseMethod64 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, false, string.Empty, "\x0001\xFFFF", null, ".");};


        OnCtorEpilog();
	}
	
	public ParserValue Parse(string input)
	{
		return DoParseFile(input, null, (int)NonTerminalEnum.Start);
	}
	
	// File is used for error reporting.
	public ParserValue Parse(string input, string file)
	{
		return DoParseFile(input, file, (int)NonTerminalEnum.Start);
	}
	
	#region Non-Terminal Parse Methods
	// Start := Words EOF
	private State DoParseStartRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod1,
			m_ParseMethod2);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Words := Word*
	private State DoParseWordsRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod3);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.TextValues = new IRichTextList();foreach(var v in results)value.TextValues.Add(v.Value.TextValue);
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Word := String / MixString
	private State DoParseWordRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod4,
			m_ParseMethod5);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// String := [^[\\]`]+
	private State DoParseStringRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoRepetition(_state, results, 1, 2147483647,
			m_ParseMethod6);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.TextValue = new NormalText{ Text = text };
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// MixString := HyperText / EscapeLeftTag / LeftTag / EscapeRightTag / RightTag / EscapeEscape
	private State DoParseMixStringRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod7,
			m_ParseMethod8,
			m_ParseMethod9,
			m_ParseMethod10,
			m_ParseMethod11,
			m_ParseMethod12);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EscapeLeftTag := '`['
	private State DoParseEscapeLeftTagRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoParseLiteral(_state, null, "`[");
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			value.TextValue = new NormalText{ Text = "[" };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// LeftTag := '['
	private State DoParseLeftTagRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoParseLiteral(_state, null, "[");
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			value.TextValue = new NormalText{ Text = "[" };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EscapeRightTag := '`]'
	private State DoParseEscapeRightTagRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoParseLiteral(_state, null, "`]");
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			value.TextValue = new NormalText{ Text = "]" };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// RightTag := ']'
	private State DoParseRightTagRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoParseLiteral(_state, null, "]");
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			value.TextValue = new NormalText{ Text = "]" };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EscapeEscape := '``'
	private State DoParseEscapeEscapeRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoParseLiteral(_state, null, "``");
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			value.TextValue = new NormalText{ Text = "`" };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// HyperText := '[' Attrs HyperWord ']'
	private State DoParseHyperTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod13,
			m_ParseMethod14,
			m_ParseMethod15,
			m_ParseMethod16);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			var ht = new HyperText();ht.Attrs.AddRange(results[0].Value.AttrValues);ht.Texts.AddRange(results[1].Value.TextValues);value.TextValue = ht;
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// HyperWord := EmbedWord*
	private State DoParseHyperWordRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod17);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.TextValues = new IRichTextList();foreach(var v in results)value.TextValues.Add(v.Value.TextValue);
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EmbedWord := String / HyperText / EscapeLeftTag / EscapeRightTag / EscapeEscape
	private State DoParseEmbedWordRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod18,
			m_ParseMethod19,
			m_ParseMethod20,
			m_ParseMethod21,
			m_ParseMethod22);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Attrs := Attr*
	private State DoParseAttrsRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod23);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.AttrValues = new HyperTextAttrList();foreach(var v in results)value.AttrValues.Add(v.Value.AttrValue);
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Attr := TagAttr / BraceAttr
	private State DoParseAttrRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod24,
			m_ParseMethod25);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// TagAttr := S0 SimpleTag S0 SimpleTagValue S0
	private State DoParseTagAttrRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod26,
			m_ParseMethod27,
			m_ParseMethod28,
			m_ParseMethod29,
			m_ParseMethod30);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.AttrValue = new HyperTextAttr{ Key = results[0].Value.StringValue, Value = results.Count > 1 ? results[1].Value.StringValue : string.Empty };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// SimpleTag := '-' / [!@#$%&*+=\\:?|~^]
	private State DoParseSimpleTagRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoChoice(_state, results,
			m_ParseMethod31,
			m_ParseMethod32);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// SimpleTagValue := [^!@#$%&*+=\\:?|~^`{[\\]\t\r\n -]*
	private State DoParseSimpleTagValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod33);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// BraceAttr := S0 '{' AttrValue '}'
	private State DoParseBraceAttrRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod34,
			m_ParseMethod35,
			m_ParseMethod36,
			m_ParseMethod37);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value = results[results.Count-1].Value;
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// AttrValue := KeyValue / KeyNoValue
	private State DoParseAttrValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod38,
			m_ParseMethod39);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// KeyValue := Id ':' Value
	private State DoParseKeyValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod40,
			m_ParseMethod41,
			m_ParseMethod42);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.AttrValue = new HyperTextAttr{ Key = results[0].Value.StringValue, Value = results[1].Value.StringValue };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// KeyNoValue := Id
	private State DoParseKeyNoValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoParse(_state, results, (int)NonTerminalEnum.Id);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.AttrValue = new HyperTextAttr{ Key = results[0].Value.StringValue };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Id := NotStrId / Str1 / Str2
	private State DoParseIdRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoChoice(_state, results,
			m_ParseMethod43,
			m_ParseMethod44,
			m_ParseMethod45);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text.Trim();
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Value := NotStrVal / Str1 / Str2
	private State DoParseValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoChoice(_state, results,
			m_ParseMethod46,
			m_ParseMethod47,
			m_ParseMethod48);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text.Trim();
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// NotStrId := [^'\":}] [^:}]*
	private State DoParseNotStrIdRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod49,
			m_ParseMethod50);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// NotStrVal := [^'\":}] [^}]*
	private State DoParseNotStrValRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod52,
			m_ParseMethod53);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Str1 := '"' [^\"]* '"'
	private State DoParseStr1Rule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod55,
			m_ParseMethod56,
			m_ParseMethod58);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Str2 := ''' [^']* '''
	private State DoParseStr2Rule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod59,
			m_ParseMethod60,
			m_ParseMethod62);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// S0 := S*
	private State DoParseS0Rule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod63);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			text=null;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// S := [\r\n\t ]
	private State DoParseSRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoParseRange(_state, null, false, "\r\n\t ", string.Empty, null, "[\r\n\t ]");
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EOF := !.
	private State DoParseEOFRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoNAssert(_state, results,
			m_ParseMethod64);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	#endregion
	
	#region Private Helper Methods
	partial void OnCtorEpilog();
	partial void OnParseProlog();
	partial void OnParseEpilog(State state);
    partial void useliteralresult();
    partial void userangeresult();

	private void DoBuildLineStarts()
	{
		m_lineStarts = new List<int>();
		
		m_lineStarts.Add(0);		// line 1 starts at index 0 (even if we have no text)
		
		int i = 0;
		while (i < m_input.Length)
		{
			char ch = m_input[i++];
			
			if (ch == '\r' && m_input[i] == '\n')
			{
				m_lineStarts.Add(++i);
			}
			else if (ch == '\r')
			{
				m_lineStarts.Add(i);
			}
			else if (ch == '\n')
			{
				m_lineStarts.Add(i);
			}
		}
	}
	
	private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
	{
		int startIndex = state.Index;
		int startResult = null == results ? 0 : results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
				break;
			}
			else
			{
				state = new State(startIndex, false);
                if(null != results)
                    results.RemoveRange(startResult, results.Count - startResult);
			}
		}
		
		return state;
	}
	
	public string DoEscapeAll(string s)
	{
		System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);
		
		foreach (char ch in s)
		{
			if (ch == '\n')
				builder.Append("\\n");
			
			else if (ch == '\r')
				builder.Append("\\r");
			
			else if (ch == '\t')
				builder.Append("\\t");
			
			else if (ch < ' ')
				builder.AppendFormat("\\x{0:X2}", (int) ch);
			
			else
				builder.Append(ch);
		}
		
		return builder.ToString();
	}
	
	private int DoGetCol(int index)
	{
		int start = index;
		
		while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
		{
			--index;
		}
		
		return start - index;
	}
	
	// This is most often used just for error handling where it is a bit overkill.
	// However it's also sometimes used in rule prologs where efficiency is more
	// important (and doing a bit of extra work in the error case is not very harmful).
	private int DoGetLine(int index)
	{
		if (m_lineStarts == null)
			DoBuildLineStarts();
			
		int line = m_lineStarts.BinarySearch(index);
		if (line >= 0)
			return line + 1;
			
		return ~line;
	}
	
	private State DoNAssert(State state, List<Result> results, ParseMethod method)
	{
		State temp = method(state, results);
		
		state = new State(state.Index, !temp.Parsed);
		
		return state;
	}
	
	private State DoParse(State state, List<Result> results, int nonterminal)
	{
		int startIndex = state.Index;
		
		CacheValue cache;
        long key = CacheValue.CalcKey(nonterminal, startIndex);
        if (!m_cache.TryGetValue(key, out cache)) {
            if (nonterminal < 0 || nonterminal >= (int)NonTerminalEnum.NonTerminalNum)
                throw new Exception("Couldn't find a " + nonterminal + " parse method");

            ParseMethod[] methods = m_nonterminals[(int)nonterminal];
            int oldCount = null == results ? 0 : results.Count;
			state = DoChoice(state, results, methods);
			
			bool hasResult = state.Parsed && null!= results && results.Count > oldCount;
			ParserValue value = hasResult ? results[results.Count - 1].Value : default(ParserValue);
			cache = new CacheValue(ref state, ref value, hasResult);
			m_cache.Add(key, cache);
		}
		else
		{
			if (cache.HasResult && null != results)
                results.Add(new Result(this, startIndex, cache.State.Index - startIndex, m_input, ref cache.Value));

		}
		
		return cache.State;
	}
	
	private ParserValue DoParseFile(string input, string file, int rule)
	{
		m_file = file;
		m_input = m_file;				                    // we need to ensure that m_file is used or we will (in some cases) get a compiler warning
		m_input = input + "\x0";		                    // add a sentinel so we can avoid range checks
		m_cache.Clear();
		m_lineStarts = null;
		
		State state = new State(0, true);
		List<Result> results = new List<Result>();
		OnParseProlog();
		state = DoParse(state, results, rule);
			
		int i = state.Index;
        if (!state.Parsed) {
            DoThrow(i, "Input syntax error !");
        } else if (i < input.Length) {
            DoThrow(i, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
        }
		OnParseEpilog(state);
		
		return results[0].Value;
	}
	
	private State DoParseLiteral(State state, List<Result> results, string literal)
	{
		State result;
		
		if (string.Compare(m_input, state.Index, literal, 0, literal.Length) == 0)
		{
            if (null != results) {
                results.Add(new Result(this, state.Index, literal.Length, m_input));
            }
			result = new State(state.Index + literal.Length, true);
		}
		else
		{
			result = new State(state.Index, false);
		}
		
		return result;
	}
	
	private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
	{
		char ch = m_input[state.Index];
		
		bool matched = chars.IndexOf(ch) >= 0;
		for (int i = 0; i < ranges.Length && !matched; i += 2)
		{
			matched = ranges[i] <= ch && ch <= ranges[i + 1];
		}
		for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
		{
			matched = char.GetUnicodeCategory(ch) == categories[i];
		}
		
		if (inverted)
			matched = !matched && ch != '\x0';
		
		if (matched)
		{
            if (null != results) {
                results.Add(new Result(this, state.Index, 1, m_input));
            }
			return new State(state.Index + 1, true);
		}
		
		return new State(state.Index, false);
	}
	
	private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
	{
		int startIndex = state.Index;
		
		int count = 0;
		while (count <= max)
		{
			State temp = method(state, results);
			if (temp.Parsed && temp.Index > state.Index)
			{
				state = temp;
				++count;
			}
			else
			{
                if (count >= min && count <= max) {
                    state = new State(state.Index, true);
                }
				break;
			}
		}

        if (count < min || count > max) {
            state = new State(startIndex, false);
        }
		return state;
	}
	
	private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
	{
		int startIndex = state.Index;
		int startResult = null == results ? 0 :results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
			}
			else
			{
				state = new State(startIndex, false);
                if(null != results)
                    results.RemoveRange(startResult, results.Count - startResult);
                break;
			}
		}
		
		return state;
	}
	
	private void DoThrow(int index, string format, params object[] args)
	{
		int line = DoGetLine(index);
		int col = DoGetCol(index) + 1;	// editors seem to usually use 1-based cols so that's what we will report
		
		// We need this retarded if or string.Format will throw an error if it
		// gets a format string like "Expected { or something".
		if (args != null && args.Length > 0)
			throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(string.Format(format, args)));
		else
			throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(format));
	}
    #endregion

    #region Private Types
    private struct CacheValue
	{
		public CacheValue(ref State state, ref ParserValue value, bool hasResult)	
		{
			State = state;
			Value = value;
			HasResult = hasResult;
		}
		
		public State State;
		public ParserValue Value;
		public bool HasResult;

        public static long CalcKey(int rule, int index)
        {
            long v1 = rule;
            long v2 = index;
            return (v1 << 32) + v2;
        }
    }
	
	private delegate State ParseMethod(State state, List<Result> results);
		
	// The state of the parser.
	private struct State
	{
		public State(int index, bool parsed)
		{
			Index = index;
			Parsed = parsed;
		}
		
		// Index of the first unconsumed character.
		public int Index;
		
		// True if the expression associated with the state successfully parsed.
		public bool Parsed;
	}
	
	// The result of parsing a literal or non-terminal.
	private struct Result
	{
        public Result(Parser parser, int index, int length, string input)
        {
            m_parser = parser;
            m_index = index;
            m_length = length;
            m_input = input;
            Value = default(ParserValue);
        }

        public Result(Parser parser, int index, int length, string input, ref ParserValue value)
        {
			m_parser = parser;
			m_index = index;
			m_length = length;
			m_input = input;
			Value = value;
		}
		
		// The text which was parsed by the terminal or non-terminal.
		public string Text {get {return m_input.Substring(m_index, m_length);}}
		
		// The 0-based character index the (non)terminal started on.
		public int Index {get {return m_index;}}
		
		// The 1-based line number the (non)terminal started on.
		public int Line {get {return m_parser.DoGetLine(m_index);}}
		
		// The 1-based column number the (non)terminal started on.
		public int Col {get {return m_parser.DoGetCol(m_index);}}
			
		// For non-terminals this will be the result of the semantic action,
		// otherwise it will be the default value.
		public ParserValue Value;
		
		private Parser m_parser;
		private int m_index;
		private int m_length;
		private string m_input;
	}
    #endregion

    #region Fields
    private enum NonTerminalEnum
    {
		Start,
		Words,
		Word,
		String,
		MixString,
		EscapeLeftTag,
		LeftTag,
		EscapeRightTag,
		RightTag,
		EscapeEscape,
		HyperText,
		HyperWord,
		EmbedWord,
		Attrs,
		Attr,
		TagAttr,
		SimpleTag,
		SimpleTagValue,
		BraceAttr,
		AttrValue,
		KeyValue,
		KeyNoValue,
		Id,
		Value,
		NotStrId,
		NotStrVal,
		Str1,
		Str2,
		S0,
		S,
		EOF,
        NonTerminalNum
    }

	private ParseMethod m_ParseMethod1;
	private ParseMethod m_ParseMethod2;
	private ParseMethod m_ParseMethod3;
	private ParseMethod m_ParseMethod4;
	private ParseMethod m_ParseMethod5;
	private ParseMethod m_ParseMethod6;
	private ParseMethod m_ParseMethod7;
	private ParseMethod m_ParseMethod8;
	private ParseMethod m_ParseMethod9;
	private ParseMethod m_ParseMethod10;
	private ParseMethod m_ParseMethod11;
	private ParseMethod m_ParseMethod12;
	private ParseMethod m_ParseMethod13;
	private ParseMethod m_ParseMethod14;
	private ParseMethod m_ParseMethod15;
	private ParseMethod m_ParseMethod16;
	private ParseMethod m_ParseMethod17;
	private ParseMethod m_ParseMethod18;
	private ParseMethod m_ParseMethod19;
	private ParseMethod m_ParseMethod20;
	private ParseMethod m_ParseMethod21;
	private ParseMethod m_ParseMethod22;
	private ParseMethod m_ParseMethod23;
	private ParseMethod m_ParseMethod24;
	private ParseMethod m_ParseMethod25;
	private ParseMethod m_ParseMethod26;
	private ParseMethod m_ParseMethod27;
	private ParseMethod m_ParseMethod28;
	private ParseMethod m_ParseMethod29;
	private ParseMethod m_ParseMethod30;
	private ParseMethod m_ParseMethod31;
	private ParseMethod m_ParseMethod32;
	private ParseMethod m_ParseMethod33;
	private ParseMethod m_ParseMethod34;
	private ParseMethod m_ParseMethod35;
	private ParseMethod m_ParseMethod36;
	private ParseMethod m_ParseMethod37;
	private ParseMethod m_ParseMethod38;
	private ParseMethod m_ParseMethod39;
	private ParseMethod m_ParseMethod40;
	private ParseMethod m_ParseMethod41;
	private ParseMethod m_ParseMethod42;
	private ParseMethod m_ParseMethod43;
	private ParseMethod m_ParseMethod44;
	private ParseMethod m_ParseMethod45;
	private ParseMethod m_ParseMethod46;
	private ParseMethod m_ParseMethod47;
	private ParseMethod m_ParseMethod48;
	private ParseMethod m_ParseMethod49;
	private ParseMethod m_ParseMethod50;
	private ParseMethod m_ParseMethod51;
	private ParseMethod m_ParseMethod52;
	private ParseMethod m_ParseMethod53;
	private ParseMethod m_ParseMethod54;
	private ParseMethod m_ParseMethod55;
	private ParseMethod m_ParseMethod56;
	private ParseMethod m_ParseMethod57;
	private ParseMethod m_ParseMethod58;
	private ParseMethod m_ParseMethod59;
	private ParseMethod m_ParseMethod60;
	private ParseMethod m_ParseMethod61;
	private ParseMethod m_ParseMethod62;
	private ParseMethod m_ParseMethod63;
	private ParseMethod m_ParseMethod64;


    private string m_input;
	private string m_file;
    private ParseMethod[][] m_nonterminals = new ParseMethod[(int)NonTerminalEnum.NonTerminalNum][];
    private Dictionary<long, CacheValue> m_cache = new Dictionary<long, CacheValue>();
	private List<int> m_lineStarts;		// offsets at which each line starts
	#endregion
}


