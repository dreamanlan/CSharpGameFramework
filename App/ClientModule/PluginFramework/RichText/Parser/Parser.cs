// Machine generated by peg-sharp 1.0.0.0 from ../../HandRichTextParser/Parser.peg.

using System;
using System.Collections.Generic;
using System.Globalization;
//using System.Linq;
// TODO: this is handy enough that we'd like to include it by default, but we want the generated parsers to work with .NET 2.0 for now
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Text;
using RichTextParser;

[Serializable]
internal sealed partial class ParserException : Exception
{
    public ParserException(int line, int col, int offset, string file, string input, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
    {
        File = file;
        Line = line;
        Col = col;
    }

    public string File { get; private set; }
    public int Line { get; private set; }
    public int Col { get; private set; }
}

// Thread safe if Parser instances are not shared across threads.
internal sealed partial class Parser
{
    public Parser()
    {
        m_nonterminals[(int)NonTerminalEnum.Start] = new ParseMethod[] { this.DoParseStartRule };
        m_nonterminals[(int)NonTerminalEnum.Words] = new ParseMethod[] { this.DoParseWordsRule };
        m_nonterminals[(int)NonTerminalEnum.Word] = new ParseMethod[] { this.DoParseWordRule };
        m_nonterminals[(int)NonTerminalEnum.String] = new ParseMethod[] { this.DoParseStringRule };
        m_nonterminals[(int)NonTerminalEnum.MixString] = new ParseMethod[] { this.DoParseMixStringRule };
        m_nonterminals[(int)NonTerminalEnum.EscapeLeftTag] = new ParseMethod[] { this.DoParseEscapeLeftTagRule };
        m_nonterminals[(int)NonTerminalEnum.LeftTag] = new ParseMethod[] { this.DoParseLeftTagRule };
        m_nonterminals[(int)NonTerminalEnum.EscapeRightTag] = new ParseMethod[] { this.DoParseEscapeRightTagRule };
        m_nonterminals[(int)NonTerminalEnum.RightTag] = new ParseMethod[] { this.DoParseRightTagRule };
        m_nonterminals[(int)NonTerminalEnum.EscapeEscape] = new ParseMethod[] { this.DoParseEscapeEscapeRule };
        m_nonterminals[(int)NonTerminalEnum.HyperText] = new ParseMethod[] { this.DoParseHyperTextRule };
        m_nonterminals[(int)NonTerminalEnum.HyperWord] = new ParseMethod[] { this.DoParseHyperWordRule };
        m_nonterminals[(int)NonTerminalEnum.EmbedWord] = new ParseMethod[] { this.DoParseEmbedWordRule };
        m_nonterminals[(int)NonTerminalEnum.Attrs] = new ParseMethod[] { this.DoParseAttrsRule };
        m_nonterminals[(int)NonTerminalEnum.Attr] = new ParseMethod[] { this.DoParseAttrRule };
        m_nonterminals[(int)NonTerminalEnum.TagAttr] = new ParseMethod[] { this.DoParseTagAttrRule };
        m_nonterminals[(int)NonTerminalEnum.SimpleTag] = new ParseMethod[] { this.DoParseSimpleTagRule };
        m_nonterminals[(int)NonTerminalEnum.SimpleTagValue] = new ParseMethod[] { this.DoParseSimpleTagValueRule };
        m_nonterminals[(int)NonTerminalEnum.BraceAttr] = new ParseMethod[] { this.DoParseBraceAttrRule };
        m_nonterminals[(int)NonTerminalEnum.AttrValue] = new ParseMethod[] { this.DoParseAttrValueRule };
        m_nonterminals[(int)NonTerminalEnum.KeyValue] = new ParseMethod[] { this.DoParseKeyValueRule };
        m_nonterminals[(int)NonTerminalEnum.KeyNoValue] = new ParseMethod[] { this.DoParseKeyNoValueRule };
        m_nonterminals[(int)NonTerminalEnum.Id] = new ParseMethod[] { this.DoParseIdRule };
        m_nonterminals[(int)NonTerminalEnum.Value] = new ParseMethod[] { this.DoParseValueRule };
        m_nonterminals[(int)NonTerminalEnum.NotStrId] = new ParseMethod[] { this.DoParseNotStrIdRule };
        m_nonterminals[(int)NonTerminalEnum.NotStrVal] = new ParseMethod[] { this.DoParseNotStrValRule };
        m_nonterminals[(int)NonTerminalEnum.Str1] = new ParseMethod[] { this.DoParseStr1Rule };
        m_nonterminals[(int)NonTerminalEnum.Str2] = new ParseMethod[] { this.DoParseStr2Rule };
        m_nonterminals[(int)NonTerminalEnum.S0] = new ParseMethod[] { this.DoParseS0Rule };
        m_nonterminals[(int)NonTerminalEnum.S] = new ParseMethod[] { this.DoParseSRule };
        m_nonterminals[(int)NonTerminalEnum.EOF] = new ParseMethod[] { this.DoParseEOFRule };

        m_ParseMethod1 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Words); };
        m_ParseMethod2 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EOF); };
        m_ParseMethod3 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Word); };
        m_ParseMethod4 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.String); };
        m_ParseMethod5 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.MixString); };
        m_ParseMethod6 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseRange(s, null, true, "[]`", string.Empty, null, "[^[\\]`]"); };
        m_ParseMethod7 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.HyperText); };
        m_ParseMethod8 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EscapeLeftTag); };
        m_ParseMethod9 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.LeftTag); };
        m_ParseMethod10 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EscapeRightTag); };
        m_ParseMethod11 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.RightTag); };
        m_ParseMethod12 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EscapeEscape); };
        m_ParseMethod13 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "["); };
        m_ParseMethod14 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Attrs); };
        m_ParseMethod15 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.HyperWord); };
        m_ParseMethod16 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "]"); };
        m_ParseMethod17 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EmbedWord); };
        m_ParseMethod18 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.String); };
        m_ParseMethod19 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.HyperText); };
        m_ParseMethod20 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EscapeLeftTag); };
        m_ParseMethod21 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EscapeRightTag); };
        m_ParseMethod22 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.EscapeEscape); };
        m_ParseMethod23 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Attr); };
        m_ParseMethod24 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.TagAttr); };
        m_ParseMethod25 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.BraceAttr); };
        m_ParseMethod26 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.S0); };
        m_ParseMethod27 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.SimpleTag); };
        m_ParseMethod28 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.S0); };
        m_ParseMethod29 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.SimpleTagValue); };
        m_ParseMethod30 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.S0); };
        m_ParseMethod31 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "-"); };
        m_ParseMethod32 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseRange(s, null, false, "!@#$%&*+=\\:?|~^", string.Empty, null, "[!@#$%&*+=\\:?|~^]"); };
        m_ParseMethod33 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseRange(s, null, true, "!@#$%&*+=\\:?|~^`{[]\t\r\n -", string.Empty, null, "[^!@#$%&*+=\\:?|~^`{[\\]\t\r\n -]"); };
        m_ParseMethod34 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.S0); };
        m_ParseMethod35 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "{"); };
        m_ParseMethod36 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.AttrValue); };
        m_ParseMethod37 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "}"); };
        m_ParseMethod38 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.KeyValue); };
        m_ParseMethod39 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.KeyNoValue); };
        m_ParseMethod40 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Id); };
        m_ParseMethod41 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, ":"); };
        m_ParseMethod42 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Value); };
        m_ParseMethod43 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.NotStrId); };
        m_ParseMethod44 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Str1); };
        m_ParseMethod45 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Str2); };
        m_ParseMethod46 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.NotStrVal); };
        m_ParseMethod47 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Str1); };
        m_ParseMethod48 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.Str2); };
        m_ParseMethod49 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseRange(s, null, true, "'\":}", string.Empty, null, "[^'\":}]"); };
        m_ParseMethod50 = (ParseMethod)delegate (State s, List<Result> r) {
            return DoRepetition(s, r, 0, 2147483647,
                m_ParseMethod51);
        };
        m_ParseMethod51 = (ParseMethod)delegate (State s2, List<Result> r2) { return DoParseRange(s2, null, true, ":}", string.Empty, null, "[^:}]"); };
        m_ParseMethod52 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseRange(s, null, true, "'\":}", string.Empty, null, "[^'\":}]"); };
        m_ParseMethod53 = (ParseMethod)delegate (State s, List<Result> r) {
            return DoRepetition(s, r, 0, 2147483647,
                m_ParseMethod54);
        };
        m_ParseMethod54 = (ParseMethod)delegate (State s2, List<Result> r2) { return DoParseRange(s2, null, true, "}", string.Empty, null, "[^}]"); };
        m_ParseMethod55 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "\""); };
        m_ParseMethod56 = (ParseMethod)delegate (State s, List<Result> r) {
            return DoRepetition(s, r, 0, 2147483647,
                m_ParseMethod57);
        };
        m_ParseMethod57 = (ParseMethod)delegate (State s2, List<Result> r2) { return DoParseRange(s2, null, true, "\"", string.Empty, null, "[^\"]"); };
        m_ParseMethod58 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "\""); };
        m_ParseMethod59 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "'"); };
        m_ParseMethod60 = (ParseMethod)delegate (State s, List<Result> r) {
            return DoRepetition(s, r, 0, 2147483647,
                m_ParseMethod61);
        };
        m_ParseMethod61 = (ParseMethod)delegate (State s2, List<Result> r2) { return DoParseRange(s2, null, true, "'", string.Empty, null, "[^']"); };
        m_ParseMethod62 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseLiteral(s, null, "'"); };
        m_ParseMethod63 = (ParseMethod)delegate (State s, List<Result> r) { return DoParse(s, r, (int)NonTerminalEnum.S); };
        m_ParseMethod64 = (ParseMethod)delegate (State s, List<Result> r) { return DoParseRange(s, null, false, string.Empty, "\x0001\xFFFF", null, "."); };

        OnCtorEpilog();
    }

    public ParserValue Parse(string input)
    {
        return DoParseFile(input, null, (int)NonTerminalEnum.Start);
    }

    // File is used for error reporting.
    public ParserValue Parse(string input, string file)
    {
        return DoParseFile(input, file, (int)NonTerminalEnum.Start);
    }

    #region Non-Terminal Parse Methods
    // Start := Words EOF
    private State DoParseStartRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod1,
        m_ParseMethod2);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Words := Word*
    private State DoParseWordsRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoRepetition(_state, results, 0, 2147483647,
        m_ParseMethod3);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            value.TextValues = new IRichTextList(); foreach (var v in results) value.TextValues.Add(v.Value.TextValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Word := String / MixString
    private State DoParseWordRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoChoice(_state, results,
        m_ParseMethod4,
        m_ParseMethod5);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // String := [^[\\]`]+
    private State DoParseStringRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = null;
        _state = DoRepetition(_state, results, 1, 2147483647,
        m_ParseMethod6);

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
            value.TextValue = new NormalText { Text = text };
            if (null != text && null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // MixString := HyperText / EscapeLeftTag / LeftTag / EscapeRightTag / RightTag / EscapeEscape
    private State DoParseMixStringRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoChoice(_state, results,
        m_ParseMethod7,
        m_ParseMethod8,
        m_ParseMethod9,
        m_ParseMethod10,
        m_ParseMethod11,
        m_ParseMethod12);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // EscapeLeftTag := '`['
    private State DoParseEscapeLeftTagRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        _state = DoParseLiteral(_state, null, "`[");

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            value.TextValue = new NormalText { Text = "[" };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // LeftTag := '['
    private State DoParseLeftTagRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        _state = DoParseLiteral(_state, null, "[");

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            value.TextValue = new NormalText { Text = "[" };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // EscapeRightTag := '`]'
    private State DoParseEscapeRightTagRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        _state = DoParseLiteral(_state, null, "`]");

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            value.TextValue = new NormalText { Text = "]" };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // RightTag := ']'
    private State DoParseRightTagRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        _state = DoParseLiteral(_state, null, "]");

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            value.TextValue = new NormalText { Text = "]" };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // EscapeEscape := '``'
    private State DoParseEscapeEscapeRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        _state = DoParseLiteral(_state, null, "``");

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            value.TextValue = new NormalText { Text = "`" };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // HyperText := '[' Attrs HyperWord ']'
    private State DoParseHyperTextRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod13,
        m_ParseMethod14,
        m_ParseMethod15,
        m_ParseMethod16);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            var ht = new HyperText(); ht.Attrs.AddRange(results[0].Value.AttrValues); ht.Texts.AddRange(results[1].Value.TextValues); value.TextValue = ht;
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // HyperWord := EmbedWord*
    private State DoParseHyperWordRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoRepetition(_state, results, 0, 2147483647,
        m_ParseMethod17);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            value.TextValues = new IRichTextList(); foreach (var v in results) value.TextValues.Add(v.Value.TextValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // EmbedWord := String / HyperText / EscapeLeftTag / EscapeRightTag / EscapeEscape
    private State DoParseEmbedWordRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoChoice(_state, results,
        m_ParseMethod18,
        m_ParseMethod19,
        m_ParseMethod20,
        m_ParseMethod21,
        m_ParseMethod22);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Attrs := Attr*
    private State DoParseAttrsRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoRepetition(_state, results, 0, 2147483647,
        m_ParseMethod23);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            value.AttrValues = new HyperTextAttrList();
            foreach (var v in results)
                value.AttrValues.Add(v.Value.AttrValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Attr := TagAttr / BraceAttr
    private State DoParseAttrRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoChoice(_state, results,
        m_ParseMethod24,
        m_ParseMethod25);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // TagAttr := S0 SimpleTag S0 SimpleTagValue S0
    private State DoParseTagAttrRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod26,
        m_ParseMethod27,
        m_ParseMethod28,
        m_ParseMethod29,
        m_ParseMethod30);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            value.AttrValue = new HyperTextAttr { Key = results[0].Value.StringValue, Value = results.Count > 1 ? results[1].Value.StringValue : string.Empty };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // SimpleTag := '-' / [!@#$%&*+=\\:?|~^]
    private State DoParseSimpleTagRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = null;
        _state = DoChoice(_state, results,
        m_ParseMethod31,
        m_ParseMethod32);

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
            value.StringValue = text;
            if (null != text && null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // SimpleTagValue := [^!@#$%&*+=\\:?|~^`{[\\]\t\r\n -]*
    private State DoParseSimpleTagValueRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = null;
        _state = DoRepetition(_state, results, 0, 2147483647,
        m_ParseMethod33);

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
            value.StringValue = text;
            if (null != text && null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // BraceAttr := S0 '{' AttrValue '}'
    private State DoParseBraceAttrRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod34,
        m_ParseMethod35,
        m_ParseMethod36,
        m_ParseMethod37);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            value = results[results.Count - 1].Value;
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // AttrValue := KeyValue / KeyNoValue
    private State DoParseAttrValueRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoChoice(_state, results,
        m_ParseMethod38,
        m_ParseMethod39);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // KeyValue := Id ':' Value
    private State DoParseKeyValueRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod40,
        m_ParseMethod41,
        m_ParseMethod42);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            value.AttrValue = new HyperTextAttr { Key = results[0].Value.StringValue, Value = results[1].Value.StringValue };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // KeyNoValue := Id
    private State DoParseKeyNoValueRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoParse(_state, results, (int)NonTerminalEnum.Id);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            value.AttrValue = new HyperTextAttr { Key = results[0].Value.StringValue };
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Id := NotStrId / Str1 / Str2
    private State DoParseIdRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = null;
        _state = DoChoice(_state, results,
        m_ParseMethod43,
        m_ParseMethod44,
        m_ParseMethod45);

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
            value.StringValue = text.Trim();
            if (null != text && null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Value := NotStrVal / Str1 / Str2
    private State DoParseValueRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = null;
        _state = DoChoice(_state, results,
        m_ParseMethod46,
        m_ParseMethod47,
        m_ParseMethod48);

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
            value.StringValue = text.Trim();
            if (null != text && null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // NotStrId := [^'\":}] [^:}]*
    private State DoParseNotStrIdRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod49,
        m_ParseMethod50);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // NotStrVal := [^'\":}] [^}]*
    private State DoParseNotStrValRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod52,
        m_ParseMethod53);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Str1 := '"' [^\"]* '"'
    private State DoParseStr1Rule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoSequence(_state, results,
        m_ParseMethod55,
        m_ParseMethod56,
        m_ParseMethod58);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // Str2 := ''' [^']* '''
    private State DoParseStr2Rule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();

        _state = DoSequence(_state, results,
        m_ParseMethod59,
        m_ParseMethod60,
        m_ParseMethod62);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // S0 := S*
    private State DoParseS0Rule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = null;
        _state = DoRepetition(_state, results, 0, 2147483647,
        m_ParseMethod63);

        if (_state.Parsed) {
            ParserValue value = default(ParserValue);
            string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
            text = null;
            if (null != text && null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // S := [\r\n\t ]
    private State DoParseSRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoParseRange(_state, null, false, "\r\n\t ", string.Empty, null, "[\r\n\t ]");

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    // EOF := !.
    private State DoParseEOFRule(State _state, List<Result> _outResults)
    {
        int _startIndex = _state.Index;
        List<Result> results = new List<Result>();
        _state = DoNAssert(_state, results,
        m_ParseMethod64);

        if (_state.Parsed) {
            ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
            if (null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
        }

        return _state;
    }

    #endregion

    #region Private Helper Methods
    partial void OnCtorEpilog();
    partial void OnParseProlog();
    partial void OnParseEpilog(State state);
    partial void useliteralresult();
    partial void userangeresult();

    private void DoBuildLineStarts()
    {
        m_lineStarts = new List<int>();

        m_lineStarts.Add(0);        // line 1 starts at index 0 (even if we have no text)

        int i = 0;
        while (i < m_input.Length) {
            char ch = m_input[i++];

            if (ch == '\r' && m_input[i] == '\n') {
                m_lineStarts.Add(++i);
            }
            else if (ch == '\r') {
                m_lineStarts.Add(i);
            }
            else if (ch == '\n') {
                m_lineStarts.Add(i);
            }
        }
    }

    private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
    {
        int startIndex = state.Index;
        int startResult = null == results ? 0 : results.Count;

        foreach (ParseMethod method in methods) {
            State temp = method(state, results);
            if (temp.Parsed) {
                state = temp;
                break;
            }
            else {
                state = new State(startIndex, false);
                if (null != results)
                    results.RemoveRange(startResult, results.Count - startResult);
            }
        }

        return state;
    }

    public string DoEscapeAll(string s)
    {
        System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);

        foreach (char ch in s) {
            if (ch == '\n')
                builder.Append("\\n");

            else if (ch == '\r')
                builder.Append("\\r");

            else if (ch == '\t')
                builder.Append("\\t");

            else if (ch < ' ')
                builder.AppendFormat("\\x{0:X2}", (int)ch);

            else
                builder.Append(ch);
        }

        return builder.ToString();
    }

    private int DoGetCol(int index)
    {
        int start = index;

        while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r') {
            --index;
        }

        return start - index;
    }

    // This is most often used just for error handling where it is a bit overkill.
    // However it's also sometimes used in rule prologs where efficiency is more
    // important (and doing a bit of extra work in the error case is not very harmful).
    private int DoGetLine(int index)
    {
        if (m_lineStarts == null)
            DoBuildLineStarts();

        int line = m_lineStarts.BinarySearch(index);
        if (line >= 0)
            return line + 1;

        return ~line;
    }

    private State DoNAssert(State state, List<Result> results, ParseMethod method)
    {
        State temp = method(state, results);

        state = new State(state.Index, !temp.Parsed);

        return state;
    }

    private State DoParse(State state, List<Result> results, int nonterminal)
    {
        int startIndex = state.Index;

        CacheValue cache;
        long key = CacheValue.CalcKey(nonterminal, startIndex);
        if (!m_cache.TryGetValue(key, out cache)) {
            if (nonterminal < 0 || nonterminal >= (int)NonTerminalEnum.NonTerminalNum)
                throw new Exception("Couldn't find a " + nonterminal + " parse method");

            ParseMethod[] methods = m_nonterminals[(int)nonterminal];
            int oldCount = null == results ? 0 : results.Count;
            state = DoChoice(state, results, methods);

            bool hasResult = state.Parsed && null != results && results.Count > oldCount;
            ParserValue value = hasResult ? results[results.Count - 1].Value : default(ParserValue);
            cache = new CacheValue(ref state, ref value, hasResult);
            m_cache.Add(key, cache);
        }
        else {
            if (cache.HasResult && null != results)
                results.Add(new Result(this, startIndex, cache.State.Index - startIndex, m_input, ref cache.Value));

        }

        return cache.State;
    }

    private ParserValue DoParseFile(string input, string file, int rule)
    {
        m_file = file;
        m_input = m_file;                                   // we need to ensure that m_file is used or we will (in some cases) get a compiler warning
        m_input = input + "\x0";                            // add a sentinel so we can avoid range checks
        m_cache.Clear();
        m_lineStarts = null;

        State state = new State(0, true);
        List<Result> results = new List<Result>();
        OnParseProlog();
        state = DoParse(state, results, rule);

        int i = state.Index;
        if (!state.Parsed) {
            DoThrow(i, "Input syntax error !");
        }
        else if (i < input.Length) {
            DoThrow(i, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
        }
        OnParseEpilog(state);

        return results[0].Value;
    }

    private State DoParseLiteral(State state, List<Result> results, string literal)
    {
        State result;

        if (string.Compare(m_input, state.Index, literal, 0, literal.Length) == 0) {
            if (null != results) {
                results.Add(new Result(this, state.Index, literal.Length, m_input));
            }
            result = new State(state.Index + literal.Length, true);
        }
        else {
            result = new State(state.Index, false);
        }

        return result;
    }

    private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
    {
        char ch = m_input[state.Index];

        bool matched = chars.IndexOf(ch) >= 0;
        for (int i = 0; i < ranges.Length && !matched; i += 2) {
            matched = ranges[i] <= ch && ch <= ranges[i + 1];
        }
        for (int i = 0; categories != null && i < categories.Length && !matched; ++i) {
            matched = char.GetUnicodeCategory(ch) == categories[i];
        }

        if (inverted)
            matched = !matched && ch != '\x0';

        if (matched) {
            if (null != results) {
                results.Add(new Result(this, state.Index, 1, m_input));
            }
            return new State(state.Index + 1, true);
        }

        return new State(state.Index, false);
    }

    private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
    {
        int startIndex = state.Index;

        int count = 0;
        while (count <= max) {
            State temp = method(state, results);
            if (temp.Parsed && temp.Index > state.Index) {
                state = temp;
                ++count;
            }
            else {
                if (count >= min && count <= max) {
                    state = new State(state.Index, true);
                }
                break;
            }
        }

        if (count < min || count > max) {
            state = new State(startIndex, false);
        }
        return state;
    }

    private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
    {
        int startIndex = state.Index;
        int startResult = null == results ? 0 : results.Count;

        foreach (ParseMethod method in methods) {
            State temp = method(state, results);
            if (temp.Parsed) {
                state = temp;
            }
            else {
                state = new State(startIndex, false);
                if (null != results)
                    results.RemoveRange(startResult, results.Count - startResult);
                break;
            }
        }

        return state;
    }

    private void DoThrow(int index, string format, params object[] args)
    {
        int line = DoGetLine(index);
        int col = DoGetCol(index) + 1;  // editors seem to usually use 1-based cols so that's what we will report

        // We need this retarded if or string.Format will throw an error if it
        // gets a format string like "Expected { or something".
        if (args != null && args.Length > 0)
            throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(string.Format(format, args)));
        else
            throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(format));
    }
    #endregion

    #region Private Types
    private struct CacheValue
    {
        public CacheValue(ref State state, ref ParserValue value, bool hasResult)
        {
            State = state;
            Value = value;
            HasResult = hasResult;
        }

        public State State;
        public ParserValue Value;
        public bool HasResult;

        public static long CalcKey(int rule, int index)
        {
            long v1 = rule;
            long v2 = index;
            return (v1 << 32) + v2;
        }
    }

    private delegate State ParseMethod(State state, List<Result> results);

    // The state of the parser.
    private struct State
    {
        public State(int index, bool parsed)
        {
            Index = index;
            Parsed = parsed;
        }

        // Index of the first unconsumed character.
        public int Index;

        // True if the expression associated with the state successfully parsed.
        public bool Parsed;
    }

    // The result of parsing a literal or non-terminal.
    private struct Result
    {
        public Result(Parser parser, int index, int length, string input)
        {
            m_parser = parser;
            m_index = index;
            m_length = length;
            m_input = input;
            Value = default(ParserValue);
        }

        public Result(Parser parser, int index, int length, string input, ref ParserValue value)
        {
            m_parser = parser;
            m_index = index;
            m_length = length;
            m_input = input;
            Value = value;
        }

        // The text which was parsed by the terminal or non-terminal.
        public string Text { get { return m_input.Substring(m_index, m_length); } }

        // The 0-based character index the (non)terminal started on.
        public int Index { get { return m_index; } }

        // The 1-based line number the (non)terminal started on.
        public int Line { get { return m_parser.DoGetLine(m_index); } }

        // The 1-based column number the (non)terminal started on.
        public int Col { get { return m_parser.DoGetCol(m_index); } }

        // For non-terminals this will be the result of the semantic action,
        // otherwise it will be the default value.
        public ParserValue Value;

        private Parser m_parser;
        private int m_index;
        private int m_length;
        private string m_input;
    }
    #endregion

    #region Fields
    private enum NonTerminalEnum
    {
        Start,
        Words,
        Word,
        String,
        MixString,
        EscapeLeftTag,
        LeftTag,
        EscapeRightTag,
        RightTag,
        EscapeEscape,
        HyperText,
        HyperWord,
        EmbedWord,
        Attrs,
        Attr,
        TagAttr,
        SimpleTag,
        SimpleTagValue,
        BraceAttr,
        AttrValue,
        KeyValue,
        KeyNoValue,
        Id,
        Value,
        NotStrId,
        NotStrVal,
        Str1,
        Str2,
        S0,
        S,
        EOF,
        NonTerminalNum
    }

    private ParseMethod m_ParseMethod1;
    private ParseMethod m_ParseMethod2;
    private ParseMethod m_ParseMethod3;
    private ParseMethod m_ParseMethod4;
    private ParseMethod m_ParseMethod5;
    private ParseMethod m_ParseMethod6;
    private ParseMethod m_ParseMethod7;
    private ParseMethod m_ParseMethod8;
    private ParseMethod m_ParseMethod9;
    private ParseMethod m_ParseMethod10;
    private ParseMethod m_ParseMethod11;
    private ParseMethod m_ParseMethod12;
    private ParseMethod m_ParseMethod13;
    private ParseMethod m_ParseMethod14;
    private ParseMethod m_ParseMethod15;
    private ParseMethod m_ParseMethod16;
    private ParseMethod m_ParseMethod17;
    private ParseMethod m_ParseMethod18;
    private ParseMethod m_ParseMethod19;
    private ParseMethod m_ParseMethod20;
    private ParseMethod m_ParseMethod21;
    private ParseMethod m_ParseMethod22;
    private ParseMethod m_ParseMethod23;
    private ParseMethod m_ParseMethod24;
    private ParseMethod m_ParseMethod25;
    private ParseMethod m_ParseMethod26;
    private ParseMethod m_ParseMethod27;
    private ParseMethod m_ParseMethod28;
    private ParseMethod m_ParseMethod29;
    private ParseMethod m_ParseMethod30;
    private ParseMethod m_ParseMethod31;
    private ParseMethod m_ParseMethod32;
    private ParseMethod m_ParseMethod33;
    private ParseMethod m_ParseMethod34;
    private ParseMethod m_ParseMethod35;
    private ParseMethod m_ParseMethod36;
    private ParseMethod m_ParseMethod37;
    private ParseMethod m_ParseMethod38;
    private ParseMethod m_ParseMethod39;
    private ParseMethod m_ParseMethod40;
    private ParseMethod m_ParseMethod41;
    private ParseMethod m_ParseMethod42;
    private ParseMethod m_ParseMethod43;
    private ParseMethod m_ParseMethod44;
    private ParseMethod m_ParseMethod45;
    private ParseMethod m_ParseMethod46;
    private ParseMethod m_ParseMethod47;
    private ParseMethod m_ParseMethod48;
    private ParseMethod m_ParseMethod49;
    private ParseMethod m_ParseMethod50;
    private ParseMethod m_ParseMethod51;
    private ParseMethod m_ParseMethod52;
    private ParseMethod m_ParseMethod53;
    private ParseMethod m_ParseMethod54;
    private ParseMethod m_ParseMethod55;
    private ParseMethod m_ParseMethod56;
    private ParseMethod m_ParseMethod57;
    private ParseMethod m_ParseMethod58;
    private ParseMethod m_ParseMethod59;
    private ParseMethod m_ParseMethod60;
    private ParseMethod m_ParseMethod61;
    private ParseMethod m_ParseMethod62;
    private ParseMethod m_ParseMethod63;
    private ParseMethod m_ParseMethod64;


    private string m_input;
    private string m_file;
    private ParseMethod[][] m_nonterminals = new ParseMethod[(int)NonTerminalEnum.NonTerminalNum][];
    private Dictionary<long, CacheValue> m_cache = new Dictionary<long, CacheValue>();
    private List<int> m_lineStarts;     // offsets at which each line starts
    #endregion
}
