function get_tranform_position(funcInfo, obj)
	local _,x,y,z = Utility.GetPosition(obj, Slua.out, Slua.out, Slua.out)
	local v = UnityEngine.Vector3.New(x,y,z)
	table.insert(funcInfo.v3_list, v)
	return v
end

function wrap_quaternion(funcInfo, v)
	local obj = UnityEngine.Quaternion.New(v.x,v.y,v.z,v.w)
	table.insert(funcInfo.q_list, obj)
	return obj
end

function boxedvalue_list_get(funcInfo, obj, argCount, ...)
	local index = ...
	local _, type, objVal, numVal, boolVal = Utility.BoxedValueListGet(obj, index, Slua.out, Slua.out, Slua.out, Slua.out)
	local retObj = BoxedValuePool.Alloc()
	table.insert(funcInfo.bv_list, retObj)
	if type==15 then --vector2
	    local _,x,y = Utility.BoxedValueListGetV2(obj, index, Slua.out, Slua.out)
	    retObj:SetVector2(x,y)
	elseif type==16 then --vector3
	    local _,x,y,z = Utility.BoxedValueListGetV3(obj, index, Slua.out, Slua.out, Slua.out)
	    retObj:SetVector3(x,y,z)
	elseif type==17 then --vector4
	    local _,x,y,z,w = Utility.BoxedValueListGetV4(obj, index, Slua.out, Slua.out, Slua.out, Slua.out)
	    retObj:SetVector4(x,y,z,w)
	elseif type==18 then --quaternion
	    local _,x,y,z,w = Utility.BoxedValueListGetQuaternion(obj, index, Slua.out, Slua.out, Slua.out, Slua.out)
	    retObj:SetQuaternion(x,y,z,w)
	elseif type==19 then --color
	    local _,r,g,b,a = Utility.BoxedValueListGetColor(obj, index, Slua.out, Slua.out, Slua.out, Slua.out)
	    retObj:SetColor(r,g,b,a)
	elseif type==20 then --color32
	    local _,r,g,b,a = Utility.BoxedValueListGetColor32(obj, index, Slua.out, Slua.out, Slua.out, Slua.out)
	    retObj:SetColor32(r,g,b,a)
	elseif type==0 then --object
	    retObj:SetObject(objVal)
	elseif type==1 then --string
	    retObj:SetString(objVal)
	elseif type==2 then --bool
	    retObj:SetBool(boolVal)
	else --number
	    retObj:SetNumber(numVal)
	end
	return retObj
end

function get_vector3_forward(funcInfo)
	local obj = UnityEngine.Vector3.New(0,0,1)
	table.insert(funcInfo.v3_list,obj)
	return obj
end

function wrap_vector3(funcInfo, v)
	local obj = UnityEngine.Vector3.New(v.x,v.y,v.z)
	table.insert(funcInfo.v3_list, obj)
	return obj
end

function get_vector3_one(funcInfo)
	local obj = UnityEngine.Vector3.New(1,1,1)
	table.insert(funcInfo.v3_list, obj)
	return obj
end

function get_vector3_zero(funcInfo)
	local obj = UnityEngine.Vector3.New(0,0,0)
	table.insert(funcInfo.v3_list, obj)
	return obj
end

function wrap_vector2(funcInfo, v)
	local obj = UnityEngine.Vector2.New(v.x,v.y)
	table.insert(funcInfo.v2_list, obj)
	return obj
end

function new_quaternion(funcInfo, initializer, ...)
	local x,y,z,w = ...
	local obj = UnityEngine.Quaternion.New(x,y,z,w)
	table.insert(funcInfo.q_list, obj)
	if obj and initializer then
	    initializer(obj)
	end
	return obj
end

function new_vector2(funcInfo, initializer, ...)
	local x,y = ...
	local obj = UnityEngine.Vector2.New(x,y)
	table.insert(funcInfo.v2_list, obj)
	if obj and initializer then
	    initializer(obj)
	end
	return obj
end

function new_vector3(funcInfo, initializer, ...)
	local x,y,z = ...
	local obj = UnityEngine.Vector3.New(x,y,z)
	table.insert(funcInfo.v3_list, obj)
	if obj and initializer then
	    initializer(obj)
	end
	return obj
end

function call_quaternion_lookrotation(funcInfo, ...)
	local forward, upwards = ...
	if upwards==nil then
	    upwards = UnityEngine.Vector3.New(0,1,0)
	    table.insert(funcInfo.v3_list, upwards)
	end
	local _,x,y,z,w = Utility.QuaternionFromLookRotation(forward, upwards, Slua.out, Slua.out, Slua.out, Slua.out)
	local q = UnityEngine.Quaternion.New(x,y,z,w)
	table.insert(funcInfo.q_list , q)
	return q
end

function recycle_and_keep_vector3(funcInfo, fieldType, oldVal, newVal)
	recycleandkeepcheck(funcInfo, fieldType, oldVal, newVal)
	if not rawequal(oldVal,newVal) and oldVal~=nil then
	    Vector3Pool.Recycle(oldVal)
	end
	if newVal~=nil then
	    luatableremove(funcInfo.v3_list, newVal)
	end
end

function get_quaternion_identity(funcInfo)
	local obj = UnityEngine.Quaternion.New(0,0,0,1)
	table.insert(funcInfo.q_list, obj)
	return obj
end

function recycle_and_keep_quaternion(funcInfo, fieldType, oldVal, newVal)
	recycleandkeepcheck(funcInfo, fieldType, oldVal, newVal)
	if not rawequal(oldVal,newVal) and oldVal~=nil then
	    QuaternionPool.Recycle(oldVal)
	end
	if newVal~=nil then
	    luatableremove(funcInfo.q_list, newVal)
	end
end

function call_transform_transformpoint_xyz(funcInfo, obj, ...)
	local x,y,z = ...
	local _,ox,oy,oz = Utility.TransformPointXYZ(obj, x, y, z, Slua.out, Slua.out, Slua.out)
	local v = UnityEngine.Vector3.New(ox,oy,oz)
	table.insert(funcInfo.v3_list, v)
	return v
end

function call_quaternion_euler(funcInfo, ...)
	local x, y, z = ...
	local qua = UnityEngine.Quaternion.Euler__Single__Single__Single(x,y,z)
	table.insert(funcInfo.q_list , qua)
	return qua
end

