<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Build.Utilities.Core</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Build.Utilities.ApiContract">
            <summary>
            Represents an API contract definition
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ApiContract.Name">
            <summary>
            Name of the contract
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ApiContract.Version">
            <summary>
            Version of the contract
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ApiContract.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ApiContract.IsContainedApiContractsElement(System.String)">
            <summary>
            Returns true if this element is a "ContainedApiContracts" element. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ApiContract.ReadContractsElement(System.Xml.XmlElement,System.Collections.Generic.ICollection{Microsoft.Build.Utilities.ApiContract})">
            <summary>
            Given an XML element containing API contracts, read out all contracts within that element. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.ApiContract.Elements">
            <summary>
            Helper class with ApiContract element names
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ApiContract.Elements.ContainedApiContracts">
            <summary>
            Element containing a bucket of contracts
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ApiContract.Elements.ApiContract">
            <summary>
            Element representing an individual API contract
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ApiContract.Elements.VersionedContent">
            <summary>
            Element representing a flag to indicate if the SDK content is versioned
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.ApiContract.Attributes">
            <summary>
            Helper class with attribute names
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ApiContract.Attributes.Name">
            <summary>
            Name associated with this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ApiContract.Attributes.Version">
            <summary>
            Version associated with this element
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.AppDomainIsolatedTask">
            <summary>
            This class provides the same functionality as the Task class, but derives from MarshalByRefObject so that it can be
            instantiated in its own app domain.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.AppDomainIsolatedTask.#ctor">
            <summary>
            Default (family) constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.AppDomainIsolatedTask.#ctor(System.Resources.ResourceManager)">
            <summary>
            This (family) constructor allows derived task classes to register their resources.
            </summary>
            <param name="taskResources">The task resources.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.AppDomainIsolatedTask.#ctor(System.Resources.ResourceManager,System.String)">
            <summary>
            This (family) constructor allows derived task classes to register their resources, as well as provide a prefix for
            composing help keywords from string resource names. If the prefix is an empty string, then string resource names will
            be used verbatim as help keywords. For an example of how the prefix is used, see the
            <see cref="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(System.String,System.Object[])"/> method.
            </summary>
            <param name="taskResources">The task resources.</param>
            <param name="helpKeywordPrefix">The help keyword prefix.</param>
        </member>
        <member name="P:Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine">
            <summary>
            The build engine automatically sets this property to allow tasks to call back into it.
            </summary>
            <value>The build engine interface available to tasks.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject">
            <summary>
            The build engine sets this property if the host IDE has associated a host object with this particular task.
            </summary>
            <value>The host object instance (can be null).</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.AppDomainIsolatedTask.Log">
            <summary>
            Gets an instance of a TaskLoggingHelper class containing task logging methods.
            </summary>
            <value>The logging helper object.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources">
            <summary>
            Gets or sets the task's culture-specific resources. Derived classes should register their resources either during
            construction, or via this property, if they have localized strings.
            </summary>
            <value>The task's resources (can be null).</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix">
            <summary>
            Gets or sets the prefix used to compose help keywords from string resource names. If a task does not have help
            keywords associated with its messages, it can ignore this property or set it to null. If the prefix is set to an empty
            string, then string resource names will be used verbatim as help keywords. For an example of how this prefix is used,
            see the <see cref="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(System.String,System.Object[])"/> method.
            </summary>
            <value>The help keyword prefix string (can be null).</value>
        </member>
        <member name="M:Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute">
            <summary>
            Must be implemented by derived class.
            </summary>
            <returns>true, if successful</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService">
            <summary>
            Overridden to give tasks deriving from this class infinite lease time. Otherwise we end up with a limited
            lease (5 minutes I think) and task instances can expire if they take long time processing.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.AssemblyFoldersExInfo">
            <summary>
            Contains information about entries in the AssemblyFoldersEx registry keys.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.AssemblyFoldersExInfo.#ctor(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView,System.String,System.String,System.Version)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive">
            <summary>
            Registry hive used
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.AssemblyFoldersExInfo.View">
            <summary>
            Registry view used
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key">
            <summary>
            The registry key to the component
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath">
            <summary>
            Folder found at the registry keys default value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion">
            <summary>
            Target framework version for the registry key
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo">
            <summary>
            Represents information about assembly folders.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.#ctor(System.String,System.Version)">
            <summary>
            Initializes a new instance of the AssemblyFoldersFromConfigInfo class.
            </summary>
            <param name="directoryPath">The directory path.</param>
            <param name="targetFrameworkVersion">The <see cref="T:System.Version"/> of the target framework.</param>
        </member>
        <member name="P:Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath">
            <summary>
            Gets the path to the assembly folder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.TargetFrameworkVersion">
            <summary>
            Gets the <see cref="T:System.Version"/> of the target framework.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.CommandLineBuilder">
             <summary>
             (1) Make sure values containing hyphens are quoted (RC at least requires this)
             (2) Escape any embedded quotes. 
                 -- Literal double quotes should be written in the form \" not ""
                 -- Backslashes falling just before doublequotes must be doubled.
                 -- Literal double quotes can only occur in pairs (you cannot pass a single literal double quote)
             	-- Functional double quotes (for example to handle spaces) are best put around both name and value
             	    in switches like /Dname=value.
             </summary>
             <remarks>
             
             Below are some quoting experiments, using the /D switch with the CL and RC preprocessor.
             The /D switch is a little more tricky than most switches, because it has a name=value pair.
             The table below contains what the preprocessor actually embeds when passed the switch in the
             first column:
             
                                  CL via cmd line         CL via response file       RC
                 /DFOO="A"                A                   A   
                 /D"FOO="A""              A                   A                       A
                 /DFOO=A                  A                   A   
                 /D"FOO=A"                A                   A   
                 /DFOO=""A""              A                   A                       A
                     
                 /DFOO=\"A\"             "A"                                         "A"
                 /DFOO="""A"""           "A"                broken                   "A"
                 /D"FOO=\"A\""           "A"                                         "A"
                 /D"FOO=""A"""           "A"                                         "A"
                     
                 /DFOO="A B"             A B                 A B 
                 /D"FOO=A B"             A B                 A B 
                     
                 /D"FOO="A B""          broken      
                 /DFOO=\"A B\"          broken      
                 /D"FOO=\"A B\""        "A B"               "A B"                   "A B"
                 /D"FOO=""A B"""        "A B"               broken                  broken
            
             From my experiments (with CL and RC only) it seems that 
                -- Literal double quotes are most reliably written in the form \" not ""
                -- Backslashes falling just before doublequotes must be doubled.
                -- Values containing literal double quotes must be quoted.
                -- Literal double quotes can only occur in pairs (you cannot pass a single literal double quote)
                -- For /Dname=value style switches, functional double quotes (for example to handle spaces) are best put around both 
                       name and value (in other words, these kinds of switches don't need special treatment for their '=' signs).
                -- Values containing hyphens should be quoted; RC requires this, and CL does not mind.
             </remarks>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.#ctor(System.Boolean)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.Length">
            <summary>
            Returns the length of the current command
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.CommandLine">
            <summary>
            Retrieves the private StringBuilder instance for inheriting classes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.ToString">
            <summary>
            Return the command-line as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Build.Utilities.CommandLineBuilder._quoteHyphens">
            <summary>
             Should hyphens be quoted or not
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.CommandLineBuilder._useNewLineSeparator">
            <summary>
            Should use new line separators instead of spaces to separate arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.CommandLineBuilder._allowedUnquoted">
            <summary>
            Instead of defining which characters must be quoted, define 
            which characters we know its safe to not quote. This way leads
            to more false-positives (which still work, but don't look as 
            nice coming out of the logger), but is less likely to leave a 
            security hole.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.CommandLineBuilder._definitelyNeedQuotes">
            <summary>
            Also, define the characters that we know for certain need quotes.
            This is partly to document which characters we know can cause trouble
            and partly as a sanity check against a bug creeping in.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.DefinitelyNeedQuotes">
            <summary>
            Use a private property so that we can lazy initialize the regex
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.AllowedUnquoted">
            <summary>
            Use a private getter property to we can lazy initialize the regex
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(System.String)">
            <summary>
            Checks the given switch parameter to see if it must/can be quoted.
            </summary>
            <param name="parameter">the string to examine for characters that require quoting</param>
            <returns>true, if parameter should be quoted</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty">
            <summary>
            Add a space or newline to the specified string if and only if it's not empty.
            </summary>
            <remarks>
            This is a pretty obscure method and so it's only available to inherited classes.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(System.String)">
            <summary>
            Appends a string. Quotes are added if they are needed.
            This method does not append a space to the command line before executing.
            </summary>
            <remarks>
            Escapes any double quotes in the string.
            </remarks>
            <param name="textToAppend">The string to append</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder,System.String)">
            <summary>
            Appends given text to the buffer after first quoting the text if necessary.
            </summary>
            <param name="buffer"></param>
            <param name="unquotedTextToAppend"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(System.String)">
            <summary>
            Appends a string. No quotes are added.
            This method does not append a space to the command line before executing.
            </summary>
            <example>
            AppendTextUnquoted(@"Folder name\filename.cs") => "Folder name\\filename.cs"
            </example>
            <remarks>
            In the future, this function may fixup 'textToAppend' to handle
            literal embedded quotes.
            </remarks>
            <param name="textToAppend">The string to append</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(System.String)">
            <summary>
            Appends a file name. Quotes are added if they are needed. 
            If the first character of the file name is a dash, ".\" is prepended to avoid confusing the file name with a switch
            This method does not append a space to the command line before executing.
            </summary>
            <example>
            AppendFileNameWithQuoting("-StrangeFileName.cs") => ".\-StrangeFileName.cs"
            </example>
            <remarks>
            In the future, this function may fixup 'text' to handle
            literal embedded quotes.
            </remarks>
            <param name="fileName">The file name to append</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(System.String)">
            <summary>
            Appends a file name quoting it if necessary.
            This method appends a space to the command line (if it's not currently empty) before the file name.
            </summary>
            <example>
            AppendFileNameIfNotNull("-StrangeFileName.cs") => ".\-StrangeFileName.cs"
            </example>
            <param name="fileName">File name to append, if it's null this method has no effect</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Appends a file name quoting it if necessary.
            This method appends a space to the command line (if it's not currently empty) before the file name.
            </summary>
            <example>
            See the string overload version
            </example>
            <param name="fileItem">File name to append, if it's null this method has no effect</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(System.String[],System.String)">
            <summary>
            Appends array of file name strings, quoting them if necessary, delimited by a delimiter.
            This method appends a space to the command line (if it's not currently empty) before the file names.
            </summary>
            <example>
            AppendFileNamesIfNotNull(new string[] {"Alpha.cs", "Beta.cs"}, ",") => "Alpha.cs,Beta.cs"
            </example>
            <param name="fileNames">File names to append, if it's null this method has no effect</param>
            <param name="delimiter">The delimiter between file names</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[],System.String)">
            <summary>
            Appends array of ITaskItem specs as file names, quoting them if necessary, delimited by a delimiter.
            This method appends a space to the command line (if it's not currently empty) before the file names.
            </summary>
            <example>
            See the string[] overload version
            </example>
            <param name="fileItems">Task items to append, if null this method has no effect</param>
            <param name="delimiter">Delimiter to put between items in the command line</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(System.String)">
            <summary>
            Appends a command-line switch that has no separate value, without any quoting.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitch("/utf8output") => "/utf8output"
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(System.String,System.String)">
            <summary>
            Appends a command-line switch that takes a single string parameter, quoting the parameter if necessary.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchIfNotNull("/source:", "File Name.cs") => "/source:\"File Name.cs\""
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameter">Switch parameter to append, quoted if necessary. If null, this method has no effect.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(System.String,System.String)">
            <summary>
            Throws if the parameter has a double-quote in it. This is used to prevent parameter
            injection. It's virtual so that tools can override this method if they want to have quotes escaped in filenames
            </summary>
            <param name="switchName">Switch name for error message</param>
            <param name="parameter">Switch parameter to scan</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(System.String,Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Append a switch [overload]
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            See the string overload version
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameter">Switch parameter to append, quoted if necessary. If null, this method has no effect.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(System.String,System.String[],System.String)">
            <summary>
            Appends a command-line switch that takes a string[] parameter,
            and add double-quotes around the individual filenames if necessary.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchIfNotNull("/sources:", new string[] {"Alpha.cs", "Be ta.cs"}, ";") => "/sources:Alpha.cs;\"Be ta.cs\""
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameters">Switch parameters to append, quoted if necessary. If null, this method has no effect.</param>
            <param name="delimiter">Delimiter to put between individual parameters, may not be null (may be empty)</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(System.String,Microsoft.Build.Framework.ITaskItem[],System.String)">
            <summary>
            Appends a command-line switch that takes a ITaskItem[] parameter,
            and add double-quotes around the individual filenames if necessary.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            See the string[] overload version
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameters">Switch parameters to append, quoted if necessary. If null, this method has no effect.</param>
            <param name="delimiter">Delimiter to put between individual parameters, may not be null (may be empty)</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(System.String,System.String)">
            <summary>
            Appends the literal parameter without trying to quote.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchUnquotedIfNotNull("/source:", "File Name.cs") => "/source:File Name.cs"
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameter">Switch parameter to append, not quoted. If null, this method has no effect.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(System.String,Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Appends the literal parameter without trying to quote.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            See the string overload version
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameter">Switch parameter to append, not quoted. If null, this method has no effect.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(System.String,System.String[],System.String)">
            <summary>
            Appends a command-line switch that takes a string[] parameter, not quoting the individual parameters
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchUnquotedIfNotNull("/sources:", new string[] {"Alpha.cs", "Be ta.cs"}, ";") => "/sources:Alpha.cs;Be ta.cs"
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameters">Switch parameters to append, not quoted. If null, this method has no effect.</param>
            <param name="delimiter">Delimiter to put between individual parameters, may not be null (may be empty)</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(System.String,Microsoft.Build.Framework.ITaskItem[],System.String)">
            <summary>
            Appends a command-line switch that takes a ITaskItem[] parameter, not quoting the individual parameters
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            See the string[] overload version
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameters">Switch parameters to append, not quoted. If null, this method has no effect.</param>
            <param name="delimiter">Delimiter to put between individual parameters, may not be null (may be empty)</param>
        </member>
        <member name="T:Microsoft.Build.Utilities.ExtensionSDK">
            <summary>
            Structure to represent an extension sdk
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ExtensionSDK._path">
            <summary>
            Path to the platform sdk may be null if not a platform sdk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ExtensionSDK._sdkMoniker">
            <summary>
            Extension SDK moniker
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ExtensionSDK._sdkVersion">
            <summary>
            SDK version
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ExtensionSDK._sdkIdentifier">
            <summary>
            SDK identifier
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ExtensionSDK._manifest">
            <summary>
            Object containing the properties in the SDK manifest
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ExtensionSDK._minVSVersion">
            <summary>
            Caches minimum Visual Studio version from the manifest
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ExtensionSDK._maxPlatformVersion">
            <summary>
            Caches max platform version from the manifest
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ExtensionSDK.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ExtensionSDK.Version">
            <summary>
            SDK version from the moniker
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ExtensionSDK.Identifier">
            <summary>
            SDK identifier from the moniker
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ExtensionSDK.SDKType">
            <summary>
            The type of the SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ExtensionSDK.MinVSVersion">
            <summary>
            Minimum Visual Studio version from SDKManifest.xml
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ExtensionSDK.MaxPlatformVersion">
            <summary>
            Maximum platform version from SDKManifest.xml
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ExtensionSDK.ApiContracts">
            <summary>
            Api contracts from the SDKManifest, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ExtensionSDK.Manifest">
            <summary>
            Reference to the manifest object
            Makes sure manifest is instantiated only once
            </summary>
            <remarks>Load manifest from disk the first time it is needed</remarks>
        </member>
        <member name="M:Microsoft.Build.Utilities.ExtensionSDK.ParseMoniker(System.String)">
            <summary>
            Parse SDK moniker
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.Logger">
            <summary>
            This helper base class provides default functionality for loggers that handle events raised by the build engine. This
            class can only be instantiated in a derived form.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.Logger.Verbosity">
            <summary>
            Gets or sets the level of detail to show in the event log.
            </summary>
            <value>The verbosity level.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.Logger.Parameters">
            <summary>
            Gets or sets the user-specified parameters to the logger. Derived class can ignore if it doesn't take parameters.
            </summary>
            <value>The parameter string (can be null).</value>
        </member>
        <member name="M:Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Must be implemented by derived class to subscribe to build events.
            </summary>
            <param name="eventSource">The available events that a logger can subscribe to.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.Logger.Shutdown">
            <summary>
            Derived class should override if it needs to release any resources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.Logger.FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Generates a message in the default format from a BuildErrorEventArgs object.
            </summary>
            <param name="args">Error event arguments</param>
            <returns>Error message in canonical format</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.Logger.FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Generates a message in the default format from a BuildWarningEventArgs object.
            </summary>
            <param name="args">Warning event arguments</param>
            <returns>Warning message in canonical format</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.Logger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Determines whether the current verbosity setting is at least the value
            passed in.
            </summary>
            <param name="checkVerbosity"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Utilities.MuxLogger">
            <summary>
            This is a multiplexing logger. The purpose of this logger is to allow the registration and deregistration of 
            multiple loggers during the build. This is to support the VS IDE scenario where loggers are registered and unregistered
            for each project system's build request. This means one physical build may have multiple logical builds
            each with their own set of loggers. 
            
            The Mux logger will register itself with the build manager as a regular central /l style logger. 
            It will be responsible for receiving messages from the build manager and route them to the correct
            logger based on the logical build the message came from.
            
            Requirements:
                1) Multiplexing logger will be registered at the beginning of the build manager's Begin build
                    Any loggers registered before the build manager actually started building will get the build started event at the same time as the MUX logger
                    Any loggers registered after the build manager starts the build will get a synthesised build started event. The event cannot be cached because the 
                    timestamp of the build started event is determined when the event is created, caching the event would give incorrect build times in the loggers registered to the MUX.
                    
                2) The MUX logger will be initialized by the build manager.
                    The mux will listen to all events on the event source from the build manager and will route events correctly to the registered loggers.
                
                3) The MUX logger will be shutdown when the build is finished in end build . At this time it will un-register any loggers attached to it.
                
                4) The MUX logger will log the build finished event when the project finished event for the first project started event is seen for each logger.
               
            Registering Loggers:
            
            The multiplexing logger will function in the following way:
                A logger will be passed to the MUX Register logger method with a submission ID which will be used to route a the message to the correct logger.
                A new event source will be created so that the logger passed in can be registered to that event source
                If the build started event has already been logged the MUX logger will create a new BuildStartedEvent and send that to the event source.
                
            UnregisterLoggers:
                When a build submission is completed the UnregisterLoggers method will be called with the submission ID.
                At this point we will look up the success state of the project finished event for the submission ID and log a build finished event to the logger.
                The event source will be cleaned up.  This may be interesting because the unregister will come from a thread other than what is doing the logging.
                This may create a Synchronization issue, if unregister is called while events are being logged.
                
            UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
            
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._submissionRecords">
            <summary>
            The mapping of submission IDs to the submission record.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._buildStartedEvent">
            <summary>
             Keep the build started event if it has been seen, we need the message off it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._eventSourceForBuild">
            <summary>
            Event source which events from the build manager will be raised on.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._buildStartedEventHandler">
            <summary>
            The handler for the build started event
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._buildFinishedEventHandler">
            <summary>
            The handler for the build finished event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._projectStartedEventHandler">
            <summary>
            The handler for the project started event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._projectFinishedEventHandler">
            <summary>
            The handler for the project finished event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._submissionProjectsInProgress">
            <summary>
            Dictionary mapping submission id to projects in progress.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger._maxNodeCount">
            <summary>
            The maximum node count as specified in the call to Initialize()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.MuxLogger.Verbosity">
            <summary>
            Required for ILogger interface
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.MuxLogger.Parameters">
            <summary>
            Required for the ILoggerInterface
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects">
            <summary>
            Should evaluation events include generated metaprojects?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles">
            <summary>
            Should evaluation events include profiling information?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs">
            <summary>
            Should task events include task inputs?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Initialize the logger.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            Initialize the logger.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.Shutdown">
            <summary>
            Shutdown the mux logger and clear out any state
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.RegisterLogger(System.Int32,Microsoft.Build.Framework.ILogger)">
            <summary>
            This method will register a logger on the MUX logger and then raise a build started event if the build started event has already been logged
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.UnregisterLoggers(System.Int32)">
            <summary>
            Unregisters all the loggers for a given submission id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.BuildStarted(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Receives the build started event for the whole build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.BuildFinished(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Receives the build finished event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.ProjectStarted(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Receives the project started event and records the submission as being in-progress.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.ProjectFinished(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Receives the project finished event.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord">
            <summary>
            This class holds everything the logger needs to know about a particular submission, including the event source.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._syncLock">
            <summary>
            Object used to synchronize access to internals.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._loggers">
            <summary>
            List of loggers
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._maxNodeCount">
            <summary>
            The maximum node count
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._eventSourceForBuild">
            <summary>
            The event source which will have events raised from the buld manager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._buildStartedEvent">
            <summary>
            The buildStartedEvent to use when synthesizing the build started event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._firstProjectStartedEventContext">
            <summary>
            The project build event coontext for the first project started event seen, this is the root of the submission.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._submissionId">
            <summary>
            SubmissionId for this submission record
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._shutdown">
            <summary>
            Has the record been shutdown yet.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._anyEventHandler">
            <summary>
            Even hander for "anyEvent" this is a handler which will be called from each of the other event handlers
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._buildFinishedEventHandler">
            <summary>
            Handle the Build Finished event
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._buildStartedEventHandler">
            <summary>
            Handle the Build started event
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._customBuildEventHandler">
            <summary>
            Handle custom build events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._buildErrorEventHandler">
            <summary>
            Handle error events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._buildMessageEventHandler">
            <summary>
            Handle message events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._projectFinishedEventHandler">
            <summary>
            Handle project finished events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._projectStartedEventHandler">
            <summary>
            Handle project started events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._buildStatusEventHandler">
            <summary>
            Handle build sttus events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._targetFinishedEventHandler">
            <summary>
            Handle target finished events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._targetStartedEventHandler">
            <summary>
            Handle target started events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._taskFinishedEventHandler">
            <summary>
            Handle task finished
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._taskStartedEventHandler">
            <summary>
            Handle task started
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._buildWarningEventHandler">
            <summary>
            Handle warning events
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord._telemetryEventHandler">
            <summary>
            Handle telemetry events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.#ctor(System.Int32,Microsoft.Build.Framework.IEventSource,Microsoft.Build.Framework.BuildStartedEventArgs,System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.MessageRaised">
            <summary>
            This event is raised to log a message.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.ErrorRaised">
            <summary>
            This event is raised to log an error.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.WarningRaised">
            <summary>
            This event is raised to log a warning.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.BuildStarted">
            <summary>
            this event is raised to log the start of a build
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.BuildFinished">
            <summary>
            this event is raised to log the end of a build
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.ProjectStarted">
            <summary>
            this event is raised to log the start of a project build
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.ProjectFinished">
            <summary>
            this event is raised to log the end of a project build
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.TargetStarted">
            <summary>
            this event is raised to log the start of a target build
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.TargetFinished">
            <summary>
            this event is raised to log the end of a target build
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.TaskStarted">
            <summary>
            this event is raised to log the start of task execution
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.TaskFinished">
            <summary>
            this event is raised to log the end of task execution
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.CustomEventRaised">
            <summary>
            this event is raised to log a custom event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.StatusEventRaised">
            <summary>
            this event is raised to log build status events, such as 
            build/project/target/task started/stopped 
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.AnyEventRaised">
            <summary>
            This event is raised to log that some event has
            occurred.  It is raised on every event.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.TelemetryLogged">
            <summary>
            This event is raised when telemetry is sent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.AddLogger(Microsoft.Build.Framework.ILogger)">
            <summary>
            Adds the specified logger to the set of loggers for this submission.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.Shutdown">
            <summary>
            Shuts down the loggers and removes them
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.SetGlobalBuildStartedEvent(Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Sets the build started event for this event source if it hasn't already been set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseMessageEvent(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Raises a message event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildMessageEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseErrorEvent(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Raises an error event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildErrorEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseWarningEvent(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Raises a warning event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildWarningEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseBuildStartedEvent(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Raises a "build started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildStartedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseBuildFinishedEvent(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Raises a "build finished" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildFinishedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseProjectStartedEvent(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Raises a "project build started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">ProjectStartedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseProjectFinishedEvent(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Raises a "project build finished" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">ProjectFinishedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseTargetStartedEvent(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs)">
            <summary>
            Raises a "target build started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TargetStartedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseTargetFinishedEvent(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Raises a "target build finished" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TargetFinishedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseTaskStartedEvent(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs)">
            <summary>
            Raises a "task execution started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TaskStartedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseTaskFinishedEvent(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs)">
            <summary>
            Raises a "task finished executing" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TaskFinishedEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseCustomEvent(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Raises a custom event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">CustomBuildEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseStatusEvent(System.Object,Microsoft.Build.Framework.BuildStatusEventArgs)">
            <summary>
            Raises a catch-all build status event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildStatusEventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseStatusEvent(System.Object,Microsoft.Build.Framework.BuildStatusEventArgs,System.Boolean)">
            <summary>
            Raises a status event, optionally cascading to an any event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseAnyEvent(System.Object,Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Raises a catch-all build event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">Build EventArgs</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.RaiseTelemetryEvent(System.Object,Microsoft.Build.Framework.TelemetryEventArgs)">
            <summary>
            Raises a telemetry event to all registered loggers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.InitializeInternalEventSource">
            <summary>
            Initialize the internal event source which is used to raise events on loggers registered to this submission
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.MuxLogger.SubmissionRecord.UnregisterAllEventHandlers">
            <summary>
            Clears out all events.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.PlatformManifest">
            <summary>
            Structure to represent the information contained in Platform.xml
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest._pathToManifest">
            <summary>
            Location of Platform.xml 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.PlatformManifest.#ctor(System.String)">
            <summary>
            Constructor
            Takes the location of Platform.xml and populates the structure with manifest data
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.PlatformManifest.Name">
            <summary>
            Platform name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.PlatformManifest.FriendlyName">
            <summary>
            Platform friendly name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.PlatformManifest.PlatformVersion">
            <summary>
            Platform version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.PlatformManifest.DependentPlatforms">
            <summary>
            The platforms that this platform depends on.  
            Item1: Platform name
            Item2: Platform version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.PlatformManifest.ApiContracts">
            <summary>
            The contracts contained by this platform
            Item1: Contract name
            Item2: Contract version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.PlatformManifest.ReadError">
            <summary>
            Flag set to true if an exception occurred while reading the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.PlatformManifest.ReadErrorMessage">
            <summary>
            Message from exception thrown while reading manifest
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.PlatformManifest.LoadManifestFile">
            <summary>
            Load content of Platform.xml
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.PlatformManifest.DependentPlatform">
            <summary>
            Represents a dependency on another platform
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest.DependentPlatform.Name">
            <summary>
            Name of the platform on which this platform depends
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest.DependentPlatform.Version">
            <summary>
            Version of the platform on which this platform depends 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.PlatformManifest.DependentPlatform.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.PlatformManifest.Elements">
            <summary>
            Helper class with element names in Platform.xml
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest.Elements.ApplicationPlatform">
            <summary>
            Root element 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest.Elements.DependentPlatform">
            <summary>
            Element describing a platform this platform is dependent on
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.PlatformManifest.Attributes">
            <summary>
            Helper class with attribute names in Platform.xml
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest.Attributes.Name">
            <summary>
            Name associated with this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest.Attributes.FriendlyName">
            <summary>
            Friendly name associated with this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.PlatformManifest.Attributes.Version">
            <summary>
            Version associated with this element
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.ProcessorArchitecture">
            <summary>
            Processor architecture utilities
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ProcessorArchitecture.X86">
            <summary>
            Represents the 32-bit x86 processor architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ProcessorArchitecture.IA64">
            <summary>
            Represents the 64-bit IA64 processor architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ProcessorArchitecture.AMD64">
            <summary>
            Represents the 64-bit AMD64 processor architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ProcessorArchitecture.MSIL">
            <summary>
            Represents the Microsoft Intermediate Language processor architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ProcessorArchitecture.ARM">
            <summary>
            Represents the ARM processor architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ProcessorArchitecture.ARM64">
            <summary>
            Represents the ARM64 processor architecture.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture">
            <summary>
            Lazy-initted property for getting the architecture of the currently running process
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ProcessorArchitecture.GetCurrentProcessArchitecture">
            <summary>
            Gets the processor architecture of the currently running process
            </summary>
            <returns>null if unknown architecture or error, one of the known architectures otherwise</returns>
        </member>
        <member name="T:Microsoft.Build.Utilities.MultipleVersionSupport">
            <summary>
            What should happen if multiple versions of a given productfamily or sdk name are found
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MultipleVersionSupport.Allow">
            <summary>
            No action should be taken if multiple versions are detected
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MultipleVersionSupport.Warning">
            <summary>
            Log  warning
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.MultipleVersionSupport.Error">
            <summary>
            Log an error
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.SDKManifest">
            <summary>
            Structure to represent the information contained in SDKManifest.xml
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.s_extensionSDKPathPattern">
            <summary>
            Pattern in path to extension SDK used to help determine if manifest is from a framework SDK
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.s_defaultMaxPlatformVersion">
            <summary>
            Default version of MaxPlatformVersion in framework extension SDKs with manifest not containing such a property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.s_defaultMinOSVersion">
            <summary>
            Default version of MinOSVersion in framework extension SDKs with manifest not containing such a property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.s_defaultMaxOSVersionTested">
            <summary>
            Default version of MaxOSVersionTested in framework extension SDKs with manifest not containing such a property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._supportsMultipleVersions">
            <summary>
            What should happen if this sdk is resolved with other sdks of the same productfamily or same sdk name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._pathToSdk">
            <summary>
            Path to where the file SDKManifest.xml is stored
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._appxLocations">
            <summary>
            Whatever appx locations we found in the manifest
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._frameworkIdentities">
            <summary>
            Whatever framework identities we found in the manifest.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._maxOSVersionTested">
            <summary>
            Whatever MaxOSVersionTested we found in the manifest.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._minOSVersion">
            <summary>
            Whatever MinOSVersion we found in the manifest
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._maxPlatformVersion">
            <summary>
            Whatever MaxPlatformVersion we found in the manifest
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest._sdkType">
            <summary>
            The SDKType, default of unspecified
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.SDKManifest.#ctor(System.String)">
            <summary>
            Constructor
            Takes the path to SDKManifest.xml and populates the structure with manifest data
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.SupportsMultipleVersions">
            <summary>
            Whatever information regarding support for multiple versions is found in the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.FrameworkIdentities">
            <summary>
            Whatever framework identities we found in the manifest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.AppxLocations">
            <summary>
            Whatever appx locations we found in the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.PlatformIdentity">
            <summary>
            PlatformIdentity if it exists in the appx manifest for this sdk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.FrameworkIdentity">
            <summary>
            The FrameworkIdentity for the sdk, this may be a single name or a | delimited name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.SupportPrefer32Bit">
            <summary>
            Support Prefer32bit found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.SDKType">
            <summary>
            SDKType found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.CopyRedistToSubDirectory">
            <summary>
            CopyRedistToSubDirectory specifies where the redist files should be copied to relative to the root of the package.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.SupportedArchitectures">
            <summary>
            Supported Architectures is a semicolon delimited list of architectures that the SDK supports.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.DependsOnSDK">
            <summary>
            DependsOnSDK is a semicolon delimited list of SDK identities that the SDK requires be resolved in order to function.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.ProductFamilyName">
            <summary>
            ProductFamilyName specifies the product family for the SDK. This is offered up as metadata on the resolved sdkreference and is used to detect sdk conflicts.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.TargetPlatform">
            <summary>
            The platform the SDK targets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.TargetPlatformMinVersion">
            <summary>
            Minimum version of the platform the SDK supports.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.TargetPlatformVersion">
            <summary>
            Maximum version of the platform that the SDK supports.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.DisplayName">
            <summary>
            DisplayName found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.MinVSVersion">
            <summary>
            MinVSVersion found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.MinOSVersion">
            <summary>
            MinOSVersion found in the sdk manifest, defaults to 6.2.1 for framework extension SDKs when manifest does not have this property set
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.MaxPlatformVersion">
            <summary>
            MaxPlatformVersion found in the sdk manifest, defaults to 8.0 for framework extension SDKs when manifest does not have this property set
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.MaxOSVersionTested">
            <summary>
            MaxOSVersionTested found in the sdk manifest, defaults to 6.2.1 for framework extension SDKs when manifest does not have this property set
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.MoreInfo">
            <summary>
            MoreInfo as found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.ReadError">
            <summary>
            Flag set to true if an exception occurred while reading the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.ReadErrorMessage">
            <summary>
            Message from exception thrown while reading manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.ApiContracts">
            <summary>
            The contracts contained by this manifest, if any
            Item1: Contract name
            Item2: Contract version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.SDKManifest.IsFrameworkExtensionSdkManifest">
            <summary>
            Decide on whether it is a framework extension sdk based on manifest's FrameworkIdentify and path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.SDKManifest.LoadManifestFile">
            <summary>
            Load content of SDKManifest.xml
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.SDKManifest.ReadFileListAttributes(System.Xml.XmlAttributeCollection)">
            <summary>
            Reads the attributes from the "FileList" element of the SDK manifest.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.SDKManifest.ParseSupportMultipleVersions(System.String)">
            <summary>
            Parse the multipleversions string. Returns MultipleVersionSupport.Allow if it cannot be parsed correctly.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.SDKManifest.Attributes">
            <summary>
            Helper class with attributes of SDKManifest.xml
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform">
            <summary>
            Platform that the SDK targets
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion">
            <summary>
            The minimum version of the platform that the SDK targets
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion">
            <summary>
            The max version of the platform that the SDK targets
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.FrameworkIdentity">
            <summary>
            Framework Identity metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.SupportedArchitectures">
            <summary>
            Supported Architectures metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.SupportPrefer32Bit">
            <summary>
            Prefer32BitSupport metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.AppxLocation">
            <summary>
            AppxLocation metadata
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.APPX">
            <summary>
            APPX manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.PlatformIdentity">
            <summary>
            PlatformIdentity  metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.SDKType">
            <summary>
            SDKType metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.DisplayName">
            <summary>
            DisplayName metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedistToSubDirectory">
            <summary>
            CopyRedistToSubDirectory metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.ProductFamilyName">
            <summary>
            ProductFamilyName metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.SupportsMultipleVersions">
            <summary>
            SupportsMultipleVersions metadata name and manifest attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDK">
            <summary>
            TargetedSDKArchitecture metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration">
            <summary>
            TargetedSDKConfiguration metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.ExpandReferenceAssemblies">
            <summary>
            ExpandReferenceAssemblies metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.DependsOnSDK">
            <summary>
            DependsOn metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedist">
            <summary>
            CopyRedist metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies">
            <summary>
            CopyLocalExpandedReferenceAssemblies metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.MinOSVersion">
            <summary>
            MinOSVersion metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.MinVSVersion">
            <summary>
            MinVSVersion metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.MaxPlatformVersion">
            <summary>
            MaxPlatformVersionAttribute metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.MoreInfo">
            <summary>
            MoreInfoAttribute metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Attributes.MaxOSVersionTested">
            <summary>
            MaxOSVersionTestedAttribute metadata name
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.SDKManifest.Elements">
            <summary>
            Helper class with elements of SDKManifest.xml
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKManifest.Elements.FileList">
            <summary>
            Root element 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.SDKType">
            <summary>
            Type of SDK
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKType.Unspecified">
            <summary>
            Not specified
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKType.External">
            <summary>
            Traditional 3rd party SDK
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKType.Platform">
            <summary>
            Platform extension SDK
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.SDKType.Framework">
            <summary>
            Framework extension SDK
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.TargetPlatformSDK">
            <summary>
            Structure to represent a target platform sdk
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetPlatformSDK._path">
            <summary>
            Path to the platform sdk may be null if not a platform sdk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetPlatformSDK._manifest">
            <summary>
            Object containing the properties in the SDK manifest
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetPlatformSDK._minVSVersion">
            <summary>
            Cache for min Visual Studio version from manifest
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetPlatformSDK._minOSVersion">
            <summary>
            Cache for min OS version from manifest
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TargetPlatformSDK.#ctor(System.String,System.Version,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.MinVSVersion">
            <summary>
            Min Visual Studio version from manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.MinOSVersion">
            <summary>
            Min OS version from manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformIdentifier">
            <summary>
            Target platform identifier
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformVersion">
            <summary>
            Target platform version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.Path">
            <summary>
            Path to target platform sdk if it exists, it may not if there is no target platform is installed
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.DisplayName">
            <summary>
            The SDK's display name, or null if one is not defined. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.ExtensionSDKs">
            <summary>
            Extension sdks within this platform, 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.Platforms">
            <summary>
            Set of platforms supported by this SDK. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TargetPlatformSDK.Manifest">
            <summary>
            Reference to manifest object
            Makes it is instantiated only once 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode">
            <summary>
            Override GetHashCode
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TargetPlatformSDK.Equals(System.Object)">
            <summary>
            Override equals
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TargetPlatformSDK.Equals(Microsoft.Build.Utilities.TargetPlatformSDK)">
            <summary>
            Implement IEquatable
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TargetPlatformSDK.ContainsPlatform(System.String,System.String)">
            <summary>
            Returns true if this SDK supports the given platform, or false otherwise. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TargetPlatformSDK.GetSdkKey(System.String,System.String)">
            <summary>
            Given an identifier and version, construct a string to use as a key for that combination. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.Task">
            <summary>
            This helper base class provides default functionality for tasks. This class can only be instantiated in a derived form.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.Task.#ctor">
            <summary>
            Default (family) constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.Task.#ctor(System.Resources.ResourceManager)">
            <summary>
            This (family) constructor allows derived task classes to register their resources.
            </summary>
            <param name="taskResources">The task resources.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.Task.#ctor(System.Resources.ResourceManager,System.String)">
            <summary>
            This (family) constructor allows derived task classes to register their resources, as well as provide a prefix for
            composing help keywords from string resource names. If the prefix is an empty string, then string resource names will
            be used verbatim as help keywords. For an example of how the prefix is used, see the
            TaskLoggingHelper.LogErrorWithCodeFromResources(string, object[]) method.
            </summary>
            <param name="taskResources">The task resources.</param>
            <param name="helpKeywordPrefix">The help keyword prefix.</param>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.BuildEngine">
            <summary>
            The build engine automatically sets this property to allow tasks to call back into it.
            </summary>
            <value>The build engine interface available to tasks.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.BuildEngine2">
            <summary>
            The build engine automatically sets this property to allow tasks to call back into it.
            This is a convenience property so that task authors inheriting from this class do not
            have to cast the value from IBuildEngine to IBuildEngine2.
            </summary>
            <value>The build engine interface available to tasks.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.BuildEngine3">
            <summary>
            Retrieves the <see cref="T:Microsoft.Build.Framework.IBuildEngine3" /> version of the build engine interface provided by the host.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.BuildEngine4">
            <summary>
            Retrieves the <see cref="T:Microsoft.Build.Framework.IBuildEngine4" /> version of the build engine interface provided by the host.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.BuildEngine5">
            <summary>
            Retrieves the <see cref="T:Microsoft.Build.Framework.IBuildEngine5" /> version of the build engine interface provided by the host.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.BuildEngine6">
            <summary>
            Retrieves the <see cref="T:Microsoft.Build.Framework.IBuildEngine6" /> version of the build engine interface provided by the host.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.HostObject">
            <summary>
            The build engine sets this property if the host IDE has associated a host object with this particular task.
            </summary>
            <value>The host object instance (can be null).</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.Log">
            <summary>
            Gets an instance of a TaskLoggingHelper class containing task logging methods.
            The taskLoggingHelper is a MarshallByRef object which needs to have MarkAsInactive called
            if the parent task is making the appdomain and marshaling this object into it. If the appdomain is not unloaded at the end of 
            the task execution and the MarkAsInactive method is not called this will result in a leak of the task instances in the appdomain the task was created within.
            </summary>
            <value>The logging helper object.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.TaskResources">
            <summary>
            Gets or sets the task's culture-specific resources. Derived classes should register their resources either during
            construction, or via this property, if they have localized strings.
            </summary>
            <value>The task's resources (can be null).</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.Task.HelpKeywordPrefix">
            <summary>
            Gets or sets the prefix used to compose help keywords from string resource names. If a task does not have help
            keywords associated with its messages, it can ignore this property or set it to null. If the prefix is set to an empty
            string, then string resource names will be used verbatim as help keywords. For an example of how this prefix is used,
            see the TaskLoggingHelper.LogErrorWithCodeFromResources(string, object[]) method.
            </summary>
            <value>The help keyword prefix string (can be null).</value>
        </member>
        <member name="M:Microsoft.Build.Utilities.Task.Execute">
            <summary>
            Must be implemented by derived class.
            </summary>
            <returns>true, if successful</returns>
        </member>
        <member name="T:Microsoft.Build.Utilities.TaskItem">
            <summary>
            This class represents a single item of the project, as it is passed into a task. TaskItems do not exactly correspond to
            item elements in project files, because then tasks would have access to data that wasn't explicitly passed into the task
            via the project file. It's not a security issue, but more just an issue with project file clarity and transparency.
            
            Note: This class has to be sealed.  It has to be sealed because the engine instantiates it's own copy of this type and
            thus if someone were to extend it, they would not get the desired behavior from the engine.  
            </summary>
            <comment>
            Surprisingly few of these Utilities TaskItems are created: typically several orders of magnitude fewer than the number of engine TaskItems.
            </comment>
        </member>
        <member name="F:Microsoft.Build.Utilities.TaskItem._definingProject">
            <summary>
            May be defined if we're copying this item from a pre-existing one.  Otherwise, 
            we simply don't know enough to set it properly, so it will stay null. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.#ctor">
            <summary>
            Default constructor -- we need it so this type is COM-createable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.#ctor(System.String)">
            <summary>
            This constructor creates a new task item, given the item spec.
            </summary>
            <comments>Assumes the itemspec passed in is escaped.</comments>
            <param name="itemSpec">The item-spec string.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.#ctor(System.String,System.Collections.IDictionary)">
            <summary>
            This constructor creates a new TaskItem, using the given item spec and metadata.
            </summary>
            <comments>
            Assumes the itemspec passed in is escaped, and also that any escapable metadata values
            are passed in escaped form.
            </comments>
            <param name="itemSpec">The item-spec string.</param>
            <param name="itemMetadata">Custom metadata on the item.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.#ctor(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            This constructor creates a new TaskItem, using the given ITaskItem.
            </summary>
            <param name="sourceItem">The item to copy.</param>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskItem.ItemSpec">
            <summary>
            Gets or sets the item-spec.
            </summary>
            <comments>
            This one is a bit tricky.  Orcas assumed that the value being set was escaped, but 
            that the value being returned was unescaped.  Maintain that behaviour here.  To get
            the escaped value, use ITaskItem2.EvaluatedIncludeEscaped. 
            </comments>
            <value>The item-spec string.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskItem.Microsoft#Build#Framework#ITaskItem2#EvaluatedIncludeEscaped">
            <summary>
            Gets or sets the escaped include, or "name", for the item.
            </summary>
            <remarks>
            Taking the opportunity to fix the property name, although this doesn't
            make it obvious it's an improvement on ItemSpec.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskItem.MetadataNames">
            <summary>
            Gets the names of all the item's metadata.
            </summary>
            <value>List of metadata names.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskItem.MetadataCount">
            <summary>
            Gets the number of metadata set on the item.
            </summary>
            <value>Count of metadata.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskItem.Metadata">
            <summary>
            Gets the metadata dictionary
            Property is required so that we can access the metadata dictionary in an item from 
            another appdomain, as the CLR has implemented remoting policies that disallow accessing 
            private fields in remoted items. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.RemoveMetadata(System.String)">
            <summary>
            Removes one of the arbitrary metadata on the item.
            </summary>
            <param name="metadataName">Name of metadata to remove.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.SetMetadata(System.String,System.String)">
            <summary>
            Sets one of the arbitrary metadata on the item.
            </summary>
            <comments>
            Assumes that the value being passed in is in its escaped form. 
            </comments>
            <param name="metadataName">Name of metadata to set or change.</param>
            <param name="metadataValue">Value of metadata.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.GetMetadata(System.String)">
            <summary>
            Retrieves one of the arbitrary metadata on the item.
            If not found, returns empty string.
            </summary>
            <comments>
            Returns the unescaped value of the metadata requested. 
            </comments>
            <param name="metadataName">The name of the metadata to retrieve.</param>
            <returns>The metadata value.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Copy the metadata (but not the ItemSpec) to destinationItem. If a particular metadata already exists on the
            destination item, then it is not overwritten -- the original value wins.
            </summary>
            <param name="destinationItem">The item to copy metadata to.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.CloneCustomMetadata">
            <summary>
            Get the collection of custom metadata. This does not include built-in metadata.
            </summary>
            <remarks>
            RECOMMENDED GUIDELINES FOR METHOD IMPLEMENTATIONS:
            1) this method should return a clone of the metadata
            2) writing to this dictionary should not be reflected in the underlying item.
            </remarks>
            <comments>
            Returns an UNESCAPED version of the custom metadata. For the escaped version (which 
            is how it is stored internally), call ITaskItem2.CloneCustomMetadataEscaped. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.ToString">
            <summary>
            Gets the item-spec.
            </summary>
            <returns>The item-spec string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.InitializeLifetimeService">
            <summary>
            Overridden to give this class infinite lease time. Otherwise we end up with a limited
            lease (5 minutes I think) and instances can expire if they take long time processing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.op_Explicit(Microsoft.Build.Utilities.TaskItem)~System.String">
            <summary>
            This allows an explicit typecast from a "TaskItem" to a "string", returning the escaped ItemSpec for this item.
            </summary>
            <param name="taskItemToCast">The item to operate on.</param>
            <returns>The item-spec of the item.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.Microsoft#Build#Framework#ITaskItem2#GetMetadataValueEscaped(System.String)">
            <summary>
            Returns the escaped value of the metadata with the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.Microsoft#Build#Framework#ITaskItem2#SetMetadataValueLiteral(System.String,System.String)">
            <summary>
            Sets the escaped value of the metadata with the specified name.
            </summary>
            <comments>
            Assumes the value is passed in unescaped. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskItem.Microsoft#Build#Framework#ITaskItem2#CloneCustomMetadataEscaped">
            <summary>
            ITaskItem2 implementation which returns a clone of the metadata on this object.
            Values returned are in their original escaped form. 
            </summary>
            <returns>The cloned metadata.</returns>
        </member>
        <member name="T:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion">
            <summary>
            Used to specify the targeted version of the .NET Framework for some methods of ToolLocationHelper.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version11">
            <summary>
            version 1.1
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version20">
            <summary>
            version 2.0
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version30">
            <summary>
            version 3.0
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version35">
            <summary>
            version 3.5
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version40">
            <summary>
            version 4.0
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version45">
            <summary>
            version 4.5
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version451">
            <summary>
            version 4.5.1
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version46">
            <summary>
            version 4.6
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461">
            <summary>
            version 4.6.1
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version452">
            <summary>
            version 4.5.2. Enum is out of order because it was shipped out of band from a Visual Studio update
            without a corresponding SDK release.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version462">
            <summary>
            version 4.6.2
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version47">
            <summary>
            version 4.7
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version471">
            <summary>
            version 4.7.1
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version472">
            <summary>
            version 4.7.2
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version48">
            <summary>
            version 4.8
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest">
            <summary>
            The latest version available at the time of major release. This
            value should not be updated in minor releases as it could be a
            breaking change. Use 'Latest' if possible, but note the
            compatibility implications.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Latest">
            <summary>
            Sentinel value for the latest version that this version of MSBuild is aware of. Similar
            to VersionLatest except the compiled value in the calling application will not need to
            change for the update in MSBuild to be used.
            </summary>
            <remarks>
            This value was introduced in Visual Studio 15.1. It is incompatible with previous
            versions of MSBuild.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Utilities.VisualStudioVersion">
            <summary>
            Used to specify the version of Visual Studio from which to select associated 
            tools for some methods of ToolLocationHelper
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.VisualStudioVersion.Version100">
            <summary>
            Visual Studio 2010 and SP1
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.VisualStudioVersion.Version110">
            <summary>
            Visual Studio Dev11
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.VisualStudioVersion.Version120">
            <summary>
            Visual Studio Dev12
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.VisualStudioVersion.Version140">
            <summary>
            Visual Studio Dev14
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.VisualStudioVersion.Version150">
            <summary>
            Visual Studio Dev15
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest">
            <summary>
            The latest version available at the time of release
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.DotNetFrameworkArchitecture">
            <summary>
            Used to specify the targeted bitness of the .NET Framework for some methods of ToolLocationHelper
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current">
            <summary>
            Indicates the .NET Framework that is currently being run under.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness32">
            <summary>
            Indicates the 32-bit .NET Framework
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness64">
            <summary>
            Indicates the 64-bit .NET Framework
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.ToolLocationHelper">
            <summary>
            ToolLocationHelper provides utility methods for locating .NET Framework and .NET Framework SDK directories and files.
            NOTE: All public methods of this class are available to MSBuild projects for use in functions - they must be safe for
            use during project evaluation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_chainedReferenceAssemblyPath">
            <summary>
            Cache the results of reading the redist list so that we do not have to read the redist list over and over again to get the chains.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_locker">
            <summary>
            Lock object to synchronize chainedReferenceAssemblyPath dictionary
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_cachedReferenceAssemblyPaths">
            <summary>
            Cache the results of calling the GetPathToReferenceAssemblies so that we do not recalculate it every time we call the method
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_cachedHighestFrameworkNameForTargetFrameworkIdentifier">
            <summary>
            Cache the frameworkName of the highest version of a framework given its root path and identifier. 
            This is to optimize calls to GetHighestVersionOfTargetFramework
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_cachedTargetPlatforms">
            <summary>
            Cache the sdk structure as found by enumerating the disk and registry.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_cachedExtensionSdks">
            <summary>
            Cache new style extension sdks that we've enumerated
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_cachedTargetFrameworkDisplayNames">
            <summary>
            Cache the display name for the TFM/FrameworkName, keyed by the target framework directory.
            This is generated by the "Name" attribute on the root tag of the primary matching redist list.
            Value is never an empty string or null: a name will be synthesized if necessary.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_cachedTargetPlatformReferences">
            <summary>
            Cache the set of target platform references for a particular combination of inputs.  For legacy 
            target platforms, this is just grabbing all winmds from the References\CommonConfiguration\Neutral
            folder; for OneCore-based platforms, this involves reading the list from Platform.xml and synthesizing
            the locations.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_cachedExtensionSdkReferences">
            <summary>
            Cache the set of extension Sdk references for a particular combination of inputs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_targetFrameworkMonikers">
            <summary>
            Cache the list of supported frameworks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper.s_vsInstallFolders">
            <summary>
            Cache the VS Install folders for particular range of VS versions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolLocationHelper._separatorForFallbackSearchPaths">
            <summary>
            Character used to separate search paths specified for MSBuildExtensionsPath* in
            the config file
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath">
            <summary>
            Delegate to a method which takes a version enumeration and return a string path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion">
            <summary>
            The current ToolsVersion. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(System.String,System.String,System.String,System.String,System.String,System.Reflection.ProcessorArchitecture)">
            <summary>
            Get a sorted list of AssemblyFoldersExInfo which contain information about what directories the 3rd party assemblies are registered under for use during build and design time.
            
            This method will enumerate the AssemblyFoldersEx registry location and return a list of AssemblyFoldersExInfo in the same order in which
            they will be searched during both design and build time for reference assemblies.
            </summary>
            <param name="registryRoot">The root registry location for the targeted framework. For .NET this is SOFTWARE\MICROSOFT\.NETFramework</param>
            <param name="targetFrameworkVersion">The targeted framework version (2.0, 3.0, 3.5, 4.0, etc)</param>
            <param name="registryKeySuffix">The name of the folder (AssemblyFoldersEx) could also be PocketPC\AssemblyFoldersEx, or others</param>
            <param name="osVersion">Components may declare Min and Max OSVersions in the registry this value can be used filter directories returned based on whether or not the osversion is bounded by the Min  and Max versions declared by the component. If this value is blank or null no filtering is done</param>
            <param name="platform">Components may declare platform guids in the registry this can be used to return only directories which have a certain platform guid. If this value is blank or null no filtering is done</param>
            <param name="targetProcessorArchitecture">What processor architecture is being targeted. This determines which registry hives are searched in what order.
            On a 64 bit operating system we do the following
                    If you are targeting 64 bit (target x64 or ia64)
                        Add in the 64 bit hive first
                        Add in the 32 bit hive second
                    If you are not targeting a 64 bit
                       Add in the 32 bit hive first
                       Add in the 64 bit hive second
            On a 32 bit machine we only add in the 32 bit hive.
            </param>
            <returns>List of AssemblyFoldersExInfo</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(System.String,System.String,System.Reflection.ProcessorArchitecture)">
             <summary>
             Get a sorted list of AssemblyFoldersFromConfigInfo which contain information about what directories the 3rd party assemblies are registered under for use during build and design time.
            
             This method will read the specified configuration file and enumerate the and return a list of AssemblyFoldersFromConfigInfo in the same order in which
             they will be searched during both design and build time for reference assemblies.
             </summary>
             <param name="configFile">Full path to the Assembly Folders config file.</param>
             <param name="targetFrameworkVersion">The targeted framework version (2.0, 3.0, 3.5, 4.0, etc).</param>
             <param name="targetProcessorArchitecture">What processor architecture is being targeted. This determines which registry hives are searched in what order.
             On a 64 bit operating system we do the following
                     If you are targeting 64 bit (target x64 or ia64)
                         Add in the 64 bit assembly folders first
                         Add in the 32 bit assembly folders second
                     If you are not targeting a 64 bit
                        Add in the 32 bit assembly folders first
                        Add in the 64 bit assembly folders second
             On a 32 bit machine we only add in the 32 bit assembly folders.
             </param>
             <returns>List of AssemblyFoldersFromConfigInfo</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(System.String,System.Version)">
            <summary>
            Get a list of SDK's installed on the machine for a given target platform
            </summary>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>IDictionary of installed SDKS and their location. K:SDKName V:SDK installation location</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(System.String[],System.String,System.String,System.Version)">
            <summary>
            Get a list of SDK's installed on the machine for a given target platform
            </summary>
            <param name="diskRoots">Array of disk locations to search for sdks</param>
            <param name="registryRoot">Root registry location to look for sdks</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>IDictionary of installed SDKS and their location. K:SDKName V:SDK installation location</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(System.String[],System.String[],System.String,System.String,System.Version)">
            <summary>
            Get a list of SDK's installed on the machine for a given target platform
            </summary>
            <param name="diskRoots">Array of disk locations to search for sdks</param>
            <param name="extensionDiskRoots">New style extension SDK roots</param>
            <param name="registryRoot">Root registry location to look for sdks</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>IDictionary of installed SDKS and their location. K:SDKName V:SDK installation location</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(System.String,System.Version)">
            <summary>
            Get a list of SDK's installed on the machine for a given target platform
            </summary>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>IDictionary of installed SDKS and their tuples containing (location, platform version).</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(System.String[],System.String,System.String,System.Version)">
            <summary>
            Set of installed SDKs and their location and platform versions
            </summary>
            <param name="diskRoots">Array of disk locations to search for sdks</param>
            <param name="registryRoot">Root registry location to look for sdks</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>IDictionary of installed SDKS and their tuples containing (location, platform version).</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(System.String[],System.String[],System.String,System.String,System.Version)">
            <summary>
            Set of installed SDKs and their location and platform versions
            </summary>
            <param name="diskRoots">Array of disk locations to search for sdks</param>
            <param name="multiPlatformDiskRoots">Array of disk locations to search for SDKs that target multiple versions</param>
            <param name="registryRoot">Root registry location to look for sdks</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>IDictionary of installed SDKS and their tuples containing (location, platform version). Version may be null if the SDK targets multiple versions.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformMonikers(System.String[],System.String[],System.String,System.String,System.Version)">
            <summary>
            Get target platform monikers used to extract ESDK information in the methods GetPlatformExtensionSDKLocationsAndVersions and GetPlatformExtensionSDKLocations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(System.String,System.String,System.Version)">
            <summary>
            Given an SDKName, targetPlatformIdentifier and TargetPlatformVersion search the default sdk locations for the passed in sdk name.
            The format of the sdk moniker is  SDKName, Version=X.X
            </summary>
            <param name="sdkMoniker">Name of the SDK to determine the installation location for.</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>Location of the SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(System.String,System.String,System.Version,System.String[],System.String)">
            <summary>
            Given an SDKName, targetPlatformIdentifier and TargetPlatformVersion search the default sdk locations for the passed in sdk name.
            The format of the sdk moniker is  SDKName, Version=X.X
            </summary>
            <param name="sdkMoniker">Name of the SDK to determine the installation location for.</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="registryRoot">Registry root to look for sdks within</param>
            <returns>Location of the SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(System.String,System.String,System.Version,System.String[],System.String[],System.String)">
            <summary>
            Given an SDKName, targetPlatformIdentifier and TargetPlatformVersion search the default sdk locations for the passed in sdk name.
            The format of the sdk moniker is  SDKName, Version=X.X
            </summary>
            <param name="sdkMoniker">Name of the SDK to determine the installation location for.</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="extensionDiskRoots">List of disk roots to look for manifest driven extension sdks</param>
            <param name="registryRoot">Registry root to look for sdks within</param>
            <returns>Location of the SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(System.String,System.String,System.String)">
            <summary>
            Given an SDK moniker and the targeted platform get the path to the SDK root if it exists.
            </summary>
            <param name="sdkMoniker">Moniker for the sdk</param>
            <param name="targetPlatformIdentifier">Identifier for the platform</param>
            <param name="targetPlatformVersion">Version of the platform</param>
            <returns>A full path to the sdk root if the sdk exists in the targeted platform or an empty string if it does not exist.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Given an SDKName, targetPlatformIdentifier and TargetPlatformVersion search the default sdk locations for the passed in sdk name.
            The format of the sdk moniker is  SDKName, Version=X.X
            </summary>
            <param name="sdkMoniker">Name of the SDK to determine the installation location for.</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="registryRoot">Registry root to look for sdks within</param>
            <returns>Location of the SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Given an SDKName, targetPlatformIdentifier and TargetPlatformVersion search the default sdk locations for the passed in sdk name.
            The format of the sdk moniker is  SDKName, Version=X.X
            </summary>
            <param name="sdkMoniker">Name of the SDK to determine the installation location for.</param>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="extensionDiskRoots">List of disk roots to look for manifest driven extension sdks</param>
            <param name="registryRoot">Registry root to look for sdks within</param>
            <returns>Location of the SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Gets a dictionary containing a collection of extension SDKs and filter it based on the target platform version
            if max platform version isn't set in the extension sdk manifest, add the extension sdk to the filtered list
            </summary>
            <param name="targetPlatformVersion"></param>
            <param name="extensionSdks"></param>
            <returns>A IDictionary collection of filtered extension SDKs</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(System.String)">
            <summary>
            Get the list of SDK folders which contains the references for the sdk at the sdkRoot provided
            in the order in which they should be searched for references.
            </summary>
            <param name="sdkRoot">Root folder for the SDK</param>
            <returns>A list of folders in the order which they should be used when looking for references in the SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(System.String,System.String,System.String)">
            <summary>
            Get the list of SDK folders which contains the references for the sdk at the sdkRoot provided
            in the order in which they should be searched for references.
            </summary>
            <param name="sdkRoot">Root folder for the SDK</param>
            <param name="targetConfiguration">The configuration the SDK is targeting. This should be Debug or Retail</param>
            <param name="targetArchitecture">The architecture the SDK is targeting</param>
            <returns>A list of folders in the order which they should be used when looking for references in the SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.AddSDKPaths(System.String,System.String,System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Add the set of paths for where sdk files should be found. Where &lt;folderType&gt; is redist, references, designtime
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(System.String)">
            <summary>
            Get the list of SDK folders which contains the redist files for the sdk at the sdkRoot provided
            in the order in which they should be searched for references.
            </summary>
            <param name="sdkRoot">Root folder for the SDK must contain a redist folder</param>
            <returns>A list of folders in the order which they should be used when looking for redist files in the SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(System.String,System.String,System.String)">
            <summary>
            Get the list of SDK folders which contains the redist files for the sdk at the sdkRoot provided
            in the order in which they should be searched for references.
            </summary>
            <param name="sdkRoot">Root folder for the SDK must contain a redist folder</param>
            <param name="targetConfiguration">The configuration the SDK is targeting. This should be Debug or Retail</param>
            <param name="targetArchitecture">The architecture the SDK is targeting</param>
            <returns>A list of folders in the order which they should be used when looking for redist files in the SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(System.String)">
            <summary>
            Get the list of SDK folders which contains the designtime files for the sdk at the sdkRoot provided
            in the order in which they should be searched for references.
            </summary>
            <param name="sdkRoot">Root folder for the SDK must contain a Designtime folder</param>
            <returns>A list of folders in the order which they should be used when looking for DesignTime files in the SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(System.String,System.String,System.String)">
            <summary>
            Get the list of SDK folders which contains the DesignTime files for the sdk at the sdkRoot provided
            in the order in which they should be searched for references.
            </summary>
            <param name="sdkRoot">Root folder for the SDK must contain a DesignTime folder</param>
            <param name="targetConfiguration">The configuration the SDK is targeting. This should be Debug or Retail</param>
            <param name="targetArchitecture">The architecture the SDK is targeting</param>
            <returns>A list of folders in the order which they should be used when looking for DesignTime files in the SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks">
            <summary>
            Get a list target platform sdks on the machine.
            </summary>
            <returns>List of Target Platform SDKs, Item1: TargetPlatformName Item2: Version of SDK Item3: Path to sdk root</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks(System.String[],System.String)">
            <summary>
            Get a list target platform sdks on the machine.
            </summary>
            <param name="diskRoots">List of disk locations to search for platform sdks</param>
            <param name="registryRoot">Registry root location to look for platform sdks</param>
            <returns>List of Target Platform SDKs</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList{Microsoft.Build.Utilities.TargetPlatformSDK},System.Version,System.Version)">
            <summary>
            Filter list of platform sdks based on minimum OS and VS versions
            </summary>
            <param name="targetPlatformSdkList">List of platform sdks</param>
            <param name="osVersion">Operating System version. Pass null to not filter based on this parameter</param>
            <param name="vsVersion">Visual Studio version. Pass null not to filter based on this parameter</param>
            <returns>List of Target Platform SDKs</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Get the location of the target platform SDK props file for a given {SDKI, SDKV, TPI, TPMinV, TPV} combination.
            </summary>
            <param name="sdkIdentifier">The OneCore SDK identifier that defines OnceCore SDK root</param>
            <param name="sdkVersion">The verision of the OneCore SDK</param>
            <param name="targetPlatformIdentifier">Identifier for the targeted platform</param>
            <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
            <param name="targetPlatformVersion">The version of the targeted platform</param>
            <returns>Location of the target platform SDK props file without .props filename</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Get the location of the target platform SDK props file for a given {SDKI, SDKV, TPI, TPMinV, TPV} combination.
            </summary>
            <param name="sdkIdentifier">The OneCore SDK identifier that defines OnceCore SDK root</param>
            <param name="sdkVersion">The verision of the OneCore SDK</param>
            <param name="targetPlatformIdentifier">Identifier for the targeted platform</param>
            <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
            <param name="targetPlatformVersion">The version of the targeted platform</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="registryRoot">Registry root to look for sdks within</param> 
            <returns>Location of the target platform SDK props file without .props filename</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Gathers the specified extension SDK references for the given target SDK
            </summary>
            <param name="extensionSdkMoniker">The moniker is the Name/Version string. Example: "Windows Desktop, Version=10.0.0.1"</param>
            <param name="targetSdkIdentifier">The target SDK name.</param>
            <param name="targetSdkVersion">The target SDK version.</param>
            <param name="diskRoots">The disk roots used to gather installed SDKs.</param>
            <param name="extensionDiskRoots">The disk roots used to gather installed extension SDKs.</param>
            <param name="registryRoot">The registry root used to gather installed extension SDKs.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Gathers the specified extension SDK references for the given target SDK
            </summary>
            <param name="extensionSdkMoniker">The moniker is the Name/Version string. Example: "Windows Desktop, Version=10.0.0.1"</param>
            <param name="targetSdkIdentifier">The target SDK name.</param>
            <param name="targetSdkVersion">The target SDK version.</param>
            <param name="targetPlatformIdentifier">The target platform name.</param>
            <param name="targetPlatformVersion">The target platform version.</param>
            <param name="diskRoots">The disk roots used to gather installed SDKs.</param>
            <param name="extensionDiskRoots">The disk roots used to gather installed extension SDKs.</param>
            <param name="registryRoot">The registry root used to gather installed extension SDKs.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformVersion(Microsoft.Build.Utilities.TargetPlatformSDK,System.String,System.String)">
            <summary>
            Get platform version string which is used to generate versioned path
            </summary>
            <param name="targetSdk">The target SDK</param>
            <param name="targetPlatformIdentifier">The target platform name.</param>
            <param name="targetPlatformVersion">The target platform version.</param>
            <returns>Return the version string if the platform is versioned, otherwise return empty string</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetLegacyTargetPlatformReferences(System.String,System.String,System.String,System.String)">
            <summary>
            Gathers the set of platform winmds based on the assumption that they come from 
            an SDK that is specified solely by TPI / TPV.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferencesFromManifest(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination, 
            based on the assumption that it is an SDK that has both {SDKI, SDKV} and TP* specifiers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetApiContractReferences(System.Collections.Generic.IEnumerable{Microsoft.Build.Utilities.ApiContract},System.String)">
            <summary>
            Return the WinMD paths referenced by the given api contracts and target sdk root
            </summary>
            <param name="apiContracts">The API contract definitions</param>
            <param name="targetPlatformSdkRoot">The root of the target platform SDK</param>
            <returns>List of matching WinMDs</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetApiContractReferences(System.Collections.Generic.IEnumerable{Microsoft.Build.Utilities.ApiContract},System.String,System.String)">
            <summary>
            Return the WinMD paths referenced by the given api contracts and target sdk root
            </summary>
            <param name="apiContracts">The API contract definitions</param>
            <param name="targetPlatformSdkRoot">The root of the target platform SDK</param>
            <param name="targetPlatformSdkVersion">The version of the target platform SDK</param>
            <returns>List of matching WinMDs</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSDKContentFolderPath(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Return the versioned/unversioned SDK content folder path
            </summary>
            <param name="sdkIdentifier">The identifier of the SDK</param>
            <param name="sdkVersion">The verision of the SDK</param>
            <param name="targetPlatformIdentifier">The identifier of the targeted platform</param>
            <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
            <param name="targetPlatformVersion">The version of the targeted platform</param> 
            <param name="folderName">The content folder name under SDK path</param>
            <param name="diskRoot">An optional disk root to search.  A value should only be passed from a unit test.</param>
            <returns>The SDK content folder path</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(System.String,System.Version)">
            <summary>
            Given a target platform identifier and a target platform version search the default sdk locations for the platform sdk for the target platform.
            </summary>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <returns>Location of the SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(System.String,System.Version,System.String[],System.String)">
            <summary>
            Given a target platform identifier and a target platform version search the default sdk locations for the platform sdk for the target platform.
            </summary>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="registryRoot">Registry root to look for sdks within</param>
            <returns>Location of the SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(System.String,System.String)">
            <summary>
            Given a target platform identifier and a target platform version search the default sdk locations for the platform sdk for the target platform.
            </summary>
            <param name="targetPlatformIdentifier">Identifier for the platform</param>
            <param name="targetPlatformVersion">Version of the platform</param>
            <returns>A full path to the sdk root if the sdk exists in the targeted platform or an empty string if it does not exist.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(System.String,System.String,System.String,System.String)">
            <summary>
            Given a target platform identifier and a target platform version search the default sdk locations for the platform sdk for the target platform.
            </summary>
            <param name="targetPlatformIdentifier">Targeted platform to find SDKs for</param>
            <param name="targetPlatformVersion">Targeted platform version to find SDKs for</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="registryRoot">Registry root to look for sdks within</param>
            <returns>Location of the platform SDK if it is found, empty string if it could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(System.String,System.String)">
            <summary>
            Given a target platform identifier and version, get the display name for that platform SDK. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(System.String,System.String,System.String,System.String)">
            <summary>
            Given a target platform identifier and version, get the display name for that platform SDK. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(System.String,System.Version)">
            <summary>
            Given an SDK identifier and an SDK version, return a list of installed platforms.
            </summary>
            <param name="sdkIdentifier">SDK for which to find the installed platforms</param>
            <param name="sdkVersion">SDK version for which to find the installed platforms</param>
            <returns>A list of keys for the installed platforms for the given SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(System.String,System.Version,System.String[],System.String)">
            <summary>
            Given an SDK identifier and an SDK version, return a list of installed platforms.
            </summary>
            <param name="sdkIdentifier">SDK for which to find the installed platforms</param>
            <param name="sdkVersion">SDK version for which to find the installed platforms</param>
            <param name="diskRoots">List of disk roots to search for sdks within</param>
            <param name="registryRoot">Registry root to look for sdks within</param>
            <returns>A list of keys for the installed platforms for the given SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(System.String,System.String)">
            <summary>
            Given an SDK Identifier and SDK version, return the latest installed platform.
            </summary>
            <param name="sdkIdentifier">SDK for which to find the latest installed platform</param>
            <param name="sdkVersion">SDK version for which to find the latest installed platform</param>
            <returns>The latest installed version for the given SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(System.String,System.String,System.String[])">
            <summary>
            Given an SDK Identifier and SDK version, return the latest installed platform.
            </summary>
            <param name="sdkIdentifier">SDK for which to find the latest installed platform</param>
            <param name="sdkVersion">SDK version for which to find the latest installed platform</param>
            <param name="sdkRoots">SDK Root folders</param>
            <returns>The latest installed version for the given SDK</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstalls(System.Version,System.Version,System.String)">
            <summary>
             Returns folders in VS installs of specifid range of versions, starting with 15.0.
            </summary>
            <param name="minVersion">Optional. If specified, only VS instances with this or bigger version will be included.</param>
            <param name="maxVersion">Optional. If specified, only VS instances with smaller versions will be included. For instance, 16.0 means that only 15.* versions will be included.</param>
            <param name="subFolder">Optional. If specified, the returned list will contain [VSInstallDir][subFolder] paths</param>
            <returns>Returns folders in VS installs in VS version descending order</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstallsAsString(System.String,System.String,System.String)">
            <summary>
             Returns folders in VS installs of specified range of versions (starting with 15.0) separated by ';'.
            </summary>
            <param name="minVersionString">Optional. If specified, only VS instances with this or bigger version will be included.</param>
            <param name="maxVersionString">Optional. If specified, only VS instances with smaller versions will be included. For instance, 16.0 means that only 15.* versions will be included.</param>
            <param name="subFolder">Optional. If specified, the returned list will contain [VSInstallDir][subFolder] paths</param>
            <returns>Returns folders in VS installs in VS version descending order separated by ';'</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(System.String,System.String)">
            <summary>
            Finds first folder in the list which contains all given files. Returns an empty string if not found.
            </summary>
            <param name="possibleRoots">Root folders separated by ';'</param>
            <param name="relativeFilePaths">Relative file paths to find under root folders, separated by ';'.</param>
            <returns>The first root folder in the given list, which contains all files. Empty string if not found.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.TryParsePlatformVersion(System.String,System.Version@)">
            <summary>
            Tries to parse the "version" out of a platformMoniker. 
            </summary>
            <param name="platformMoniker">PlatformMoniker, in the form "PlatformName, Version=version"</param>
            <param name="platformVersion">The version of the platform, if the parse was successful - Else set to null</param>
            <returns>True if parse was successful, false otherwise </returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetMatchingPlatformSDK(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
            object that matches.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetMatchingPlatformSDK(System.String,System.Version,System.String[],System.String[],System.String)">
            <summary>
            Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
            object that matches.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GenerateDefaultSDKDisplayName(System.String,System.String)">
            <summary>
            Given a target platform identifier and version, generate a reasonable default display name. 
            </summary>
            <param name="targetPlatformIdentifier"></param>
            <param name="targetPlatformVersion"></param>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolLocationHelper.PathToSystem">
            <summary>
            Gets the fully qualified path to the system directory i.e. %SystemRoot%\System32
            </summary>
            <returns>The system path.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Returns the prefix of the .NET Framework version folder (e.g. "v2.0")
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Returns the full name of the .NET Framework root registry key
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Returns the full name of the .NET Framework SDK root registry key.  When targeting .NET 3.5 or
            above, looks in the locations associated with Visual Studio 2010.  If you wish to target the 
            .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
            specifies a VisualStudioVersion. 
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Returns the full name of the .NET Framework SDK root registry key
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="visualStudioVersion">Version of Visual Studio the requested SDK is associated with</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path. When 
            targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish 
            to target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
            that specifies a VisualStudioVersion. 
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="visualStudioVersion">Version of Visual Studio the requested SDK is associated with</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Get a fully qualified path to the frameworks root directory.
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <returns>Will return 'null' if there is no target frameworks on this machine.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Get a fully qualified path to the framework's root directory. 
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="architecture">Desired architecture, or DotNetFrameworkArchitecture.Current for the architecture this process is currently running under.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk">
            <summary>
            Returns the path to the "bin" directory of the latest .NET Framework SDK. When targeting .NET 3.5 
            or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
            the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
            that specifies a VisualStudioVersion. 
            </summary>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Returns the path to the "bin" directory of the .NET Framework SDK. When targeting .NET 3.5 
            or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
            the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
            that specifies a VisualStudioVersion. 
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Returns the path to the .NET Framework SDK.
            </summary>
            <param name="version">The <see cref="T:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion"/> of the .NET Framework.</param>
            <param name="visualStudioVersion">The <see cref="T:Microsoft.Build.Utilities.VisualStudioVersion"/> of Visual Studio.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Returns the path to the reference assemblies location for the given framework version.
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(System.String,System.String,System.String)">
            <summary>
            Returns the path to the reference assemblies location for the given target framework's standard libraries (i.e. mscorlib).
            This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
            In additon when the .NETFramework or .NET Framework targetFrameworkIdentifiers are seen and targetFrameworkVersion is 2.0, 3.0, 3.5 or 4.0 we will return the correctly chained reference assembly paths
            for the legacy .net frameworks. This chaining will use the existing GetPathToDotNetFrameworkReferenceAssemblies to build up the list of reference assembly paths.
            </summary>
            <param name="targetFrameworkIdentifier">Identifier being targeted</param>
            <param name="targetFrameworkVersion">Version being targeted</param>
            <param name="targetFrameworkProfile">Profile being targeted</param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(System.String,System.String,System.String,System.String)">
            <summary>
            Returns the path to mscorlib and system.dll
            </summary>
            <param name="targetFrameworkIdentifier">Identifier being targeted</param>
            <param name="targetFrameworkVersion">Version being targeted</param>
            <param name="targetFrameworkProfile">Profile being targeted</param>
            <param name="platformTarget">What is the targeted platform, this is used to determine where we should look for the standard libraries. Note, this parameter is only used for .net frameworks less than 4.0</param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Returns the path to mscorlib and system.dll
            </summary>
            <param name="targetFrameworkIdentifier">Identifier being targeted</param>
            <param name="targetFrameworkVersion">Version being targeted</param>
            <param name="targetFrameworkProfile">Profile being targeted</param>
            <param name="platformTarget">What is the targeted platform, this is used to determine where we should look for the standard libraries. Note, this parameter is only used for .net frameworks less than 4.0</param>
            <param name="targetFrameworkRootPath">Root directory where the target framework will be looked for. Uses default path if this is null</param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Returns the path to mscorlib and system.dll
            </summary>
            <param name="targetFrameworkIdentifier">Identifier being targeted</param>
            <param name="targetFrameworkVersion">Version being targeted</param>
            <param name="targetFrameworkProfile">Profile being targeted</param>
            <param name="platformTarget">What is the targeted platform, this is used to determine where we should look for the standard libraries. Note, this parameter is only used for .net frameworks less than 4.0</param>
            <param name="targetFrameworkRootPath">Root directory where the target framework will be looked for. Uses default path if this is null</param>
            <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.String,System.String,System.String)">
            <summary>
            Returns the paths to the reference assemblies location for the given target framework.
            This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
            In additon when the .NETFramework or .NET Framework targetFrameworkIdentifiers are seen and targetFrameworkVersion is 2.0, 3.0, 3.5 or 4.0 we will return the correctly chained reference assembly paths
            for the legacy .net frameworks. This chaining will use the existing GetPathToDotNetFrameworkReferenceAssemblies to build up the list of reference assembly paths.
            </summary>
            <param name="targetFrameworkIdentifier">Identifier being targeted</param>
            <param name="targetFrameworkVersion">Version being targeted</param>
            <param name="targetFrameworkProfile">Profile being targeted</param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.String,System.String,System.String,System.String)">
            <summary>
            Returns the paths to the reference assemblies location for the given target framework.
            This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
            In additon when the .NETFramework or .NET Framework targetFrameworkIdentifiers are seen and targetFrameworkVersion is 2.0, 3.0, 3.5 or 4.0 we will return the correctly chained reference assembly paths
            for the legacy .net frameworks. This chaining will use the existing GetPathToDotNetFrameworkReferenceAssemblies to build up the list of reference assembly paths.
            </summary>
            <param name="targetFrameworkIdentifier">Identifier being targeted</param>
            <param name="targetFrameworkVersion">Version being targeted</param>
            <param name="targetFrameworkProfile">Profile being targeted</param>
            <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
            generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
            Uses the default path if this is null.
            </param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Returns the paths to the reference assemblies location for the given target framework.
            This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
            In additon when the .NETFramework or .NET Framework targetFrameworkIdentifiers are seen and targetFrameworkVersion is 2.0, 3.0, 3.5 or 4.0 we will return the correctly chained reference assembly paths
            for the legacy .net frameworks. This chaining will use the existing GetPathToDotNetFrameworkReferenceAssemblies to build up the list of reference assembly paths.
            </summary>
            <param name="targetFrameworkIdentifier">Identifier being targeted</param>
            <param name="targetFrameworkVersion">Version being targeted</param>
            <param name="targetFrameworkProfile">Profile being targeted</param>
            <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
            <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
            generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
            Uses the default path if this is null.
            </param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName)">
            <summary>
            Returns the paths to the reference assemblies location for the given target framework.
            This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
            In additon when the .NETFramework or .NET Framework targetFrameworkIdentifiers are seen and targetFrameworkVersion is 2.0, 3.0, 3.5 or 4.0 we will return the correctly chained reference assembly paths
            for the legacy .net frameworks. This chaining will use the existing GetPathToDotNetFrameworkReferenceAssemblies to build up the list of reference assembly paths.
            </summary>
            <param name="frameworkName">Framework required</param>
            <exception cref="T:System.ArgumentNullException">When the frameworkName is null</exception>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.VersionToDotNetFrameworkPath(Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Call either the static method or the delegate. This is done purely for performance as the delegate is only required for ease of unit testing and since
            the methods being called are static this will be a non 0 cost to use delegates vs the static methods directly.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.VersionToDotNetReferenceAssemblies(Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Call either the static method or the delegate. This is done purely for performance as the delegate is only required for ease of unit testing and since
            the methods being called are static this will be a non 0 cost to use delegates vs the static methods directly.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.HandleLegacyDotNetFrameworkReferenceAssemblyPaths(Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath,Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Generate the list of reference assembly paths for well known .net framework versions
            </summary>
            <param name="frameworkName">Target framework moniker class which contains the targetframeworkVersion</param>
            <param name="PathToDotNetFramework"></param>
            <param name="PathToReferenceAssemblies"></param>
            <returns>A collection of strings which list the chained reference assembly paths with the highest version being first</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkToolsFolderRoot(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Returns the path to the "bin" directory of the .NET Framework SDK.
            </summary>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="visualStudioVersion">Version of Visual Studio the requested SDK is associated with</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GenerateReferenceAssemblyCacheKey(System.String,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Generate the key which will be used for the reference assembly cache so that multiple static methods will generate it in the same way.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.CreateReferenceAssemblyPathsCache">
            <summary>
            Create the shared cache if it is not null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.HandleLegacy35(Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath,Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath)">
            <summary>
            Do the correct chaining of .net 3.5, 3.0 and 2.0. Throw an exception if any of the chain is missing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.HandleLegacy30(Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath,Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath)">
            <summary>
            Do the correct chaining of .net 3.5, 3.0 and 2.0. Throw an exception if any of the chain is missing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.HandleLegacy20(Microsoft.Build.Utilities.ToolLocationHelper.VersionToPath)">
            <summary>
            Check to see if .net 2.0 is installed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.String,System.String,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Returns the paths to the reference assemblies location for the given framework version relative to a given targetFrameworkRoot.
            The method will not check to see if the path exists or not.
            </summary>
            <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
            generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
            </param>
            <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
            <param name="frameworkName">A frameworkName class which represents a TargetFrameworkMoniker. This cannot be null.</param>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.String,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Returns the paths to the reference assemblies location for the given framework version relative to a given targetFrameworkRoot.
            The method will not check to see if the path exists or not.
            </summary>
            <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
            generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
            </param>
            <param name="frameworkName">A frameworkName class which represents a TargetFrameworkMoniker. This cannot be null.</param>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(System.String,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Figures out a display name given the target framework details. 
            This is the equivalent of the target framework moniker, but for display.
            If one cannot be found from the redist list file, a synthesized one is returned, so there is always a display name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathAndChainReferenceAssemblyLocations(System.String,System.Runtime.Versioning.FrameworkName,System.Boolean)">
            <summary>
            Returns the paths to the reference assemblies location for the given framework version and properly chains the reference assemblies if required.
            </summary>
            <returns>Collection of reference assembly locations.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.ClearSDKStaticCache">
            <summary>
            Clear out the appdomain wide cache of Platform and Extension SDKs.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.ClearStaticCaches">
            <summary>
            Clear our the appdomain wide caches
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.RemapSdkArchitecture(System.String)">
            <summary>
            Remap some common architectures to a single one that will be in the SDK.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.AddSDKPath(System.String,System.String,System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Add the reference folder to the list of reference directories if it exists.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.RetrieveTargetPlatformList(System.String[],System.String[],System.String)">
            <summary>
            Get the list of extension sdks for a given platform and version
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GatherExtensionSDKListFromDirectory(System.Collections.Generic.IEnumerable{System.String},Microsoft.Build.Utilities.TargetPlatformSDK)">
            <summary>
            Gets new style extension SDKs (those that are under the target SDK name and version and are driven by manifest, not directory structure).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GatherSDKListFromDirectory(System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{Microsoft.Build.Utilities.TargetPlatformSDK,Microsoft.Build.Utilities.TargetPlatformSDK})">
            <summary>
            Given a root disk location and the target platform properties find all of the SDKs installed in that location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GatherSDKsFromRegistryImpl(System.Collections.Generic.Dictionary{Microsoft.Build.Utilities.TargetPlatformSDK,Microsoft.Build.Utilities.TargetPlatformSDK},System.String,Microsoft.Win32.RegistryView,Microsoft.Win32.RegistryHive,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,Microsoft.Build.Shared.OpenBaseKey,Microsoft.Build.Shared.FileExists)">
            <summary>
            Given a registry location enumerate the registry and find the installed SDKs.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GatherSDKListFromRegistry(System.String,System.Collections.Generic.Dictionary{Microsoft.Build.Utilities.TargetPlatformSDK,Microsoft.Build.Utilities.TargetPlatformSDK})">
            <summary>
             Gather the list of SDKs installed on the machine from the registry.
             Do not parallelize the getting of these entries, order is important, we want the first ones in to win.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetDefaultSDKDiskRoots(System.Collections.Generic.List{System.String})">
            <summary>
            Get the disk locations to search for sdks under. This can be overridden by an environment variable
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.ExtractSdkDiskRootsFromEnvironment(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Extract the disk roots from the environment
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformMonikerDiskRoots(System.String[])">
            <summary>
            Get the disk roots to search for both platform and extension sdks in. The environment variable can 
            override the defaults.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetExtensionSdkDiskRoots(System.String[])">
            <summary>
            Get the disk roots to search for multi platform extension sdks in. The environment variable can 
            override the defaults.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformMonikerRegistryRoots(System.String)">
            <summary>
            Get the registry root to find sdks under. The registry can be disabled if we are in a checked in scenario
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GatherPlatformsForSdk(Microsoft.Build.Utilities.TargetPlatformSDK)">
            <summary>
            Given a platform SDK object, populate its supported platforms. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.ChainReferenceAssemblyPath(System.String)">
            <summary>
            Take the path to a reference assembly directory which contains a RedistList folder which then contains a FrameworkList.xml file. 
            We will read in the xml file and determine if it has an IncludedFramework element in the redist list. If it does it will calculate
            the path where the next link in the chain should be and return that path.
            Also, when reading the redist list, if any display name is found it will be cached, keyed off the path passed in.
            </summary>
            <returns>Return null if we could not chain due to an error or the path not being found. return String.Empty if there is no next element in the chain</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String)">
            <summary>
            Get a fully qualified path to a file in the latest .NET Framework SDK. Error if the .NET Framework SDK can't be found.
            When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
            target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
            specifies a VisualStudioVersion. 
            </summary>
            <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
            When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
            target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
            specifies a VisualStudioVersion. 
            </summary>
            <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
            <param name="version">Version of the targeted .NET Framework</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
            </summary>
            <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="visualStudioVersion">Version of Visual Studio the requested SDK is associated with</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
            </summary>
            <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="architecture">The required architecture of the requested file.</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion,Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
            </summary>
            <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="visualStudioVersion">Version of Visual Studio</param>
            <param name="architecture">The required architecture of the requested file.</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion,Microsoft.Build.Utilities.DotNetFrameworkArchitecture,System.Boolean)">
            <summary>
            Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
            </summary>
            <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="visualStudioVersion">Version of Visual Studio</param>
            <param name="architecture">The required architecture of the requested file.</param>
            <param name="canFallBackIfNecessary">If true, will follow the fallback pattern -- from requested architecture, to 
            current architecture, to x86.  Otherwise, if the requested architecture path doesn't exist, that's it -- no path 
            will be returned.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String,System.String,System.String)">
            <summary>
            Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
            If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.ConvertDotNetFrameworkArchitectureToProcessorArchitecture(Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Given a member of the DotNetFrameworkArchitecture enumeration, returns the equivalent ProcessorArchitecture string.
            Internal for Testing Purposes Only
            </summary>
            <param name="architecture"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Returns the path to the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
            this is only supported for a targeted .NET Framework version of 4.5 and above. 
            </summary>
            <param name="version">Target .NET Framework version</param>
            <param name="visualStudioVersion">Version of Visual Studio associated with the SDK.</param>
            <returns>Path to the appropriate Windows SDK location</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
            this is only supported for a targeted .NET Framework version of 4.5 and above. 
            </summary>
            <param name="fileName">The name of the file being requested.</param>
            <param name="version">Target .NET Framework version.</param>
            <param name="visualStudioVersion">Version of Visual Studio associated with the SDK.</param>
            <returns>Path to the appropriate Windows SDK file</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion,Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
            architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
            </summary>
            <param name="fileName">The name of the file being requested.</param>
            <param name="version">Target .NET Framework version.</param>
            <param name="visualStudioVersion">Version of Visual Studio associated with the SDK.</param>
            <param name="architecture">Desired architecture of the resultant file.</param>
            <returns>Path to the appropriate Windows SDK file</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion,Microsoft.Build.Utilities.DotNetFrameworkArchitecture,System.Boolean)">
            <summary>
            Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
            architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
            </summary>
            <param name="fileName">The name of the file being requested.</param>
            <param name="version">Target .NET Framework version.</param>
            <param name="visualStudioVersion">Version of Visual Studio associated with the SDK.</param>
            <param name="architecture">Desired architecture of the resultant file.</param>
            <param name="canFallBackIfNecessary"><code>true</code> to fallback, otherwise <code>false</code>.</param>
            <returns>Path to the appropriate Windows SDK file</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(System.String,System.String,System.String)">
            <summary>
            Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
            If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(System.String)">
            <summary>
            Given a ToolsVersion, return the path to the MSBuild tools for that ToolsVersion
            </summary>
            <param name="toolsVersion">The ToolsVersion for which to get the tools path</param>
            <returns>The tools path folder of the appropriate ToolsVersion if it exists, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(System.String,Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Given a ToolsVersion, return the path to the MSBuild tools for that ToolsVersion
            </summary>
            <param name="toolsVersion">The ToolsVersion for which to get the tools path</param>
            <param name="architecture">The architecture of the build tools location to get</param>
            <returns>The tools path folder of the appropriate ToolsVersion if it exists, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(System.String,System.String)">
            <summary>
            Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
            tools path for that ToolsVersion
            </summary>
            <param name="fileName">The file to find the path to</param>
            <param name="toolsVersion">The ToolsVersion in which to find the file</param>
            <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
            exists, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(System.String,System.String,Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
            tools path for that ToolsVersion
            </summary>
            <param name="fileName">The file to find the path to</param>
            <param name="toolsVersion">The ToolsVersion in which to find the file</param>
            <param name="architecture">The architecture of the build tools file to get</param>
            <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
            exists, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion)">
            <summary>
            Get a fully qualified path to a file in the frameworks root directory.
            </summary>
            <param name="fileName">File name to locate in the .NET Framework directory</param>
            <param name="version">Version of the targeted .NET Framework</param>
            <returns>Will return 'null' if there is no target frameworks on this machine.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Get a fully qualified path to a file in the frameworks root directory for the specified architecture.
            </summary>
            <param name="fileName">File name to locate in the .NET Framework directory</param>
            <param name="version">Version of the targeted .NET Framework</param>
            <param name="architecture">Desired architecture, or DotNetFrameworkArchitecture.Current for the architecture this process is currently running under.</param>
            <returns>Will return 'null' if there is no target frameworks on this machine.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetPathToSystemFile(System.String)">
            <summary>
            Get a fully qualified path to a file in the system directory (i.e. %SystemRoot%\System32)
            </summary>
            <param name="fileName">File name to locate in the system directory</param>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetSupportedTargetFrameworks">
            <summary>
            Gets a IList of supported target framework monikers.
            </summary>
            <returns>list of supported target framework monikers</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(System.String,System.String)">
            <summary>
            This method will return the highest version of a target framework moniker based on the identifier. This method will only 
            find full frameworks, this means no profiles will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot">
            <summary>
            Will return the root location for the reference assembly directory under the program files directory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.ConvertToSharedDotNetFrameworkArchitecture(Microsoft.Build.Utilities.DotNetFrameworkArchitecture)">
            <summary>
            Converts a member of the Microsoft.Build.Utilities.DotNetFrameworkArchitecture enum to the equivalent member of the 
            Microsoft.Build.Shared.DotNetFrameworkArchitecture enum. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.ConvertTargetFrameworkVersionToVersion(System.String)">
            <summary>
            Given a string which may start with a "v" convert the string to a version object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetFrameworkIdentifiers(System.String)">
            <summary>
            Gets the installed framework identifiers
            </summary>
            <param name="frameworkReferenceRoot"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetFrameworkVersions(System.String,System.String)">
            <summary>
            Gets the installed versions for a given framework
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetFrameworkProfiles(System.String,System.String,System.String)">
            <summary>
            Get installed framework profiles
            </summary>
            <param name="frameworkReferenceRoot"></param>
            <param name="frameworkIdentifier"></param>
            <param name="frameworkVersion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolLocationHelper.GetFx35AndEarlierVersions(System.String)">
            <summary>
            returns the .NETFramework versions lessthanOrEqualTo 3.5 installed in the machine
            Only returns Fx versions lessthanOrEqualTo 3.5 if DNFx3.5 is installed
            </summary>
            <param name="frameworkReferenceRoot"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Utilities.ToolLocationHelper.VersionComparer">
            <summary>
            Compares framework version strings of the format v4.1.2.3
            major version and minor version are mandatory others are optional
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.HostObjectInitializationStatus">
            <summary>
            The return value from InitializeHostObject.  This enumeration defines what action the ToolTask
            should take next, after we've tried to initialize the host object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.HostObjectInitializationStatus.UseHostObjectToExecute">
            <summary>
            This means that there exists an appropriate host object for this task, it can support
            all of the parameters passed in, and it should be invoked to do the real work of the task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.HostObjectInitializationStatus.UseAlternateToolToExecute">
            <summary>
            This means that either there is no host object available, or that the host object is 
            not capable of supporting all of the features required for this build.  Therefore,
            ToolTask should fallback to an alternate means of doing the build, such as invoking
            the command-line tool.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnSuccess">
            <summary>
            This means that the host object is already up-to-date, and no further action is necessary.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnFailure">
            <summary>
            This means that some of the parameters being passed into the task are invalid, and the
            task should fail immediately.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.ToolTask">
            <summary>
            Base class used for tasks that spawn an executable. This class implements the ToolPath property which can be used to
            override the default path.
            </summary>
            <remarks>
            INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
            we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.#ctor">
            <summary>
            Protected constructor 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.#ctor(System.Resources.ResourceManager)">
            <summary>
            Protected constructor 
            </summary>
            <param name="taskResources">The resource manager for task resources</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.#ctor(System.Resources.ResourceManager,System.String)">
            <summary>
            Protected constructor 
            </summary>
            <param name="taskResources">The resource manager for task resources</param>
            <param name="helpKeywordPrefix">The help keyword prefix for task's messages</param>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.ExitCode">
            <summary>
            The return code of the spawned process. If the task logged any errors, but the process 
            had an exit code of 0 (success), this will be set to -1.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution">
            <summary>
            When set to true, this task will yield the node when its task is executing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.UseCommandProcessor">
            <summary>
            When set to true, the tool task will create a batch file for the command-line and execute that using the command-processor,
            rather than executing the command directly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.EchoOff">
            <summary>
            When set to true, it passes /Q to the cmd.exe command line such that the command line does not get echo-ed on stdout
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout">
            <summary>
            A timeout to wait for a task to terminate before killing it.  In milliseconds.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.ToolCanceled">
            <summary>
            Used to signal when a tool has been cancelled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._temporaryBatchFile">
            <summary>
            This is the batch file created when UseCommandProcessor is set to true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.ToolName">
            <summary>
            Implemented by the derived class. Returns a string which is the name of the underlying .EXE to run e.g. "resgen.exe"
            Only used by the ToolExe getter.
            </summary>
            <value>Name of tool.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.ToolExe">
            <summary>
            Projects may set this to override a task's ToolName.
            Tasks may override this to prevent that.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.ToolPath">
            <summary>
            Project-visible property allows the user to override the path to the executable.
            </summary>
            <value>Path to tool.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.EnvironmentVariables">
            <summary>
            Array of equals-separated pairs of environment
            variables that should be passed to the spawned executable,
            in addition to (or selectively overriding) the regular environment block.
            </summary>
            <remarks>
            Using this instead of EnvironmentOverride as that takes a Dictionary,
            which cannot be set from an MSBuild project.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.Timeout">
            <summary>
            Project visible property that allows the user to specify an amount of time after which the task executable
            is terminated. 
            </summary>
            <value>Time-out in milliseconds. Default is <see cref="F:System.Threading.Timeout.Infinite"/> (no time-out).</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.ResponseFileEncoding">
            <summary>
            Overridable property specifying the encoding of the response file, UTF8 by default
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ResponseFileEscape(System.String)">
            <summary>
            Overridable method to escape content of the response file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardOutputEncoding">
            <summary>
            Overridable property specifying the encoding of the captured task standard output stream
            </summary>
            <remarks>
            Console-based output uses the current system OEM code page by default. Note that we should not use Console.OutputEncoding
            here since processes we run don't really have much to do with our console window (and also Console.OutputEncoding
            doesn't return the OEM code page if the running application that hosts MSBuild is not a console application).
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardErrorEncoding">
            <summary>
            Overridable property specifying the encoding of the captured task standard error stream
            </summary>
            <remarks>
            Console-based output uses the current system OEM code page by default. Note that we should not use Console.OutputEncoding
            here since processes we run don't really have much to do with our console window (and also Console.OutputEncoding
            doesn't return the OEM code page if the running application that hosts MSBuild is not a console application).
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.EnvironmentOverride">
            <summary>
            Gets the Path override value.
            </summary>
            <returns>The new value for the Environment for the task.</returns>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardErrorLoggingImportance">
            <summary>
            Importance with which to log text from the
            standard error stream.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.HasLoggedErrors">
            <summary>
            Whether this ToolTask has logged any errors
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardOutputImportance">
            <summary>
            Task Parameter: Importance with which to log text from the
            standard out stream.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardErrorImportance">
            <summary>
            Task Parameter: Importance with which to log text from the
            standard error stream.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError">
            <summary>
            Should ALL messages received on the standard error stream be logged as errors.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardOutputLoggingImportance">
            <summary>
            Importance with which to log text from in the
            standard out stream.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardOutputImportanceToUse">
            <summary>
            The actual importance at which standard out messages will be logged.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.StandardErrorImportanceToUse">
            <summary>
            The actual importance at which standard error messages will be logged.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.LogPrivate">
            <summary>
            Gets an instance of a private TaskLoggingHelper class containing task logging methods.
            This is necessary because ToolTask lives in a different assembly than the task inheriting from it
            and needs its own separate resources.
            </summary>
            <value>The logging helper object.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.ToolTask.LogShared">
            <summary>
            Gets an instance of a shared resources TaskLoggingHelper class containing task logging methods.
            This is necessary because ToolTask lives in a different assembly than the task inheriting from it
            and needs its own separate resources.
            </summary>
            <value>The logging helper object.</value>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ProcessStarted">
            <summary>
            Overridable function called after <see cref="M:System.Diagnostics.Process.Start"/> in <see cref="M:Microsoft.Build.Utilities.ToolTask.ExecuteTool(System.String,System.String,System.String)"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool">
            <summary>
            Gets the fully qualified tool name. Should return ToolExe if ToolTask should search for the tool 
            in the system path. If ToolPath is set, this is ignored.
            </summary>
            <returns>Path string.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.GetWorkingDirectory">
            <summary>
            Gets the working directory to use for the process. Should return null if ToolTask should use the
            current directory. 
            </summary>
            <remarks>This is a method rather than a property so that derived classes (like Exec) can choose to
            expose a public WorkingDirectory property, and it would be confusing to have two properties.</remarks>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ValidateParameters">
            <summary>
            Implemented in the derived class
            </summary>
            <returns>true, if successful</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.SkipTaskExecution">
            <summary>
            Returns true if task execution is not necessary. Executed after ValidateParameters
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.GenerateResponseFileCommands">
            <summary>
            Returns a string with those switches and other information that can go into a response file.
            Called after ValidateParameters and SkipTaskExecution
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.GenerateCommandLineCommands">
            <summary>
            Returns a string with those switches and other information that can't go into a response file and
            must go directly onto the command line.
            Called after ValidateParameters and SkipTaskExecution
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.GetResponseFileSwitch(System.String)">
            <summary>
            Returns the command line switch used by the tool executable to specify the response file.
            Will only be called if the task returned a non empty string from GetResponseFileCommands
            Called after ValidateParameters, SkipTaskExecution and GetResponseFileCommands
            </summary>
            <param name="responseFilePath">full path to the temporarily created response file</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.HandleTaskExecutionErrors">
            <summary>
            Allows tool to handle the return code.
            This method will only be called with non-zero exitCode.
            </summary>
            <returns>The return value of this method will be used as the task return value</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.CallHostObjectToExecute">
            <summary>
            We expect the tasks to override this method, if they support host objects. The implementation should call into the
            host object to perform the real work of the task. For example, for compiler tasks like Csc and Vbc, this method would
            call Compile() on the host object.
            </summary>
            <returns>The return value indicates success (true) or failure (false) if the host object was actually called to do the work.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.InitializeHostObject">
            <summary>
            We expect tasks to override this method if they support host objects.  The implementation should
            make sure that the host object is ready to perform the real work of the task.  
            </summary>
            <returns>The return value indicates what steps to take next.  The default is to assume that there
            is no host object provided, and therefore we should fallback to calling the command-line tool.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.LogToolCommand(System.String)">
            <summary>
            Logs the actual command line about to be executed (or what the task wants the log to show)
            </summary>
            <param name="message">
            Descriptive message about what is happening - usually the command line to be executed.
            </param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.LogPathToTool(System.String,System.String)">
            <summary>
            Logs the tool name and the path from where it is being run.
            </summary>
            <param name="toolName">
            The tool to Log. This is the actual tool being used, ie. if ToolExe has been specified it will be used, otherwise it will be ToolName
            </param>
            <param name="pathToTool">
            The path from where the tool is being run.
            </param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ComputePathToTool">
            <summary>
            Figures out the path to the tool (including the .exe), either by using the ToolPath
            parameter, or by asking the derived class to tell us where it should be located.
            </summary>
            <returns>path to the tool, or null</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.GetTemporaryResponseFile(System.String,System.String@)">
            <summary>
            Creates a temporary response file for the given command line arguments.
            We put as many command line arguments as we can into a response file to
            prevent the command line from getting too long. An overly long command
            line can cause the process creation to fail.
            </summary>
            <remarks>
            Command line arguments that cannot be put into response files, and which
            must appear on the command line, should not be passed to this method.
            </remarks>
            <param name="responseFileCommands">The command line arguments that need
            to go into the temporary response file.</param>
            <param name="responseFileSwitch">[out] The command line switch for using
            the temporary response file, or null if the response file is not needed.
            </param>
            <returns>The path to the temporary response file, or null if the response
            file is not needed.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.GetProcessStartInfo(System.String,System.String,System.String)">
            <summary>
            Initializes the information required to spawn the process executing the tool.
            </summary>
            <param name="pathToTool"></param>
            <param name="commandLineCommands"></param>
            <param name="responseFileSwitch"></param>
            <returns>The information required to start the process.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ExecuteTool(System.String,System.String,System.String)">
            <summary>
            Writes out a temporary response file and shell-executes the tool requested.  Enables concurrent
            logging of the output of the tool.
            </summary>
            <param name="pathToTool">The computed path to tool executable on disk</param>
            <param name="responseFileCommands">Command line arguments that should go into a temporary response file</param>
            <param name="commandLineCommands">Command line arguments that should be passed to the tool executable directly</param>
            <returns>exit code from the tool - if errors were logged and the tool has an exit code of zero, then we sit it to -1</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.Cancel">
            <summary>
            Cancels the process executing the task by asking it to close nicely, then after a short period, forcing termination.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.DeleteTempFile(System.String)">
            <summary>
            Delete temporary file. If the delete fails for some reason (e.g. file locked by anti-virus) then
            the call will not throw an exception. Instead a warning will be logged, but the build will not fail.
            </summary>
            <param name="fileName">File to delete</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.HandleToolNotifications(System.Diagnostics.Process)">
            <summary>
            Handles all the notifications sent while the tool is executing. The
            notifications can be for tool output, tool time-out, or tool completion.
            </summary>
            <remarks>
            The slightly convoluted use of the async stderr/stdout streams of the
            Process class is necessary because we want to log all our messages from
            the main thread, instead of from a worker or callback thread.
            </remarks>
            <param name="proc"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.KillToolProcessOnTimeout(System.Diagnostics.Process,System.Boolean)">
            <summary>
            Kills the given process that is executing the tool, because the tool's
            time-out period expired.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.TerminateToolProcess(System.Diagnostics.Process,System.Boolean)">
            <summary>
            Kills the specified process
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.WaitForProcessExit(System.Diagnostics.Process)">
            <summary>
            Confirms that the given process has really and truly exited. If the
            process is still finishing up, this method waits until it is done.
            </summary>
            <remarks>
            This method is a hack, but it needs to be called after both
            Process.WaitForExit() and Process.Kill().
            </remarks>
            <param name="proc"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.LogMessagesFromStandardError">
            <summary>
            Logs all the messages that the tool wrote to stderr. The messages
            are read out of the stderr data queue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.LogMessagesFromStandardOutput">
            <summary>
            Logs all the messages that the tool wrote to stdout. The messages
            are read out of the stdout data queue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.LogMessagesFromStandardErrorOrOutput(System.Collections.Queue,System.Threading.ManualResetEvent,Microsoft.Build.Framework.MessageImportance,Microsoft.Build.Utilities.ToolTask.StandardOutputOrErrorQueueType)">
            <summary>
            Logs all the messages that the tool wrote to either stderr or stdout.
            The messages are read out of the given data queue. This method is a
            helper for the <see cref="M:Microsoft.Build.Utilities.ToolTask.LogMessagesFromStandardError"/>() and <see
            cref="M:Microsoft.Build.Utilities.ToolTask.LogMessagesFromStandardOutput"/>() methods.
            </summary>
            <param name="dataQueue"></param>
            <param name="dataAvailableSignal"></param>
            <param name="messageImportance"></param>
            <param name="queueType"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.LogEventsFromTextOutput(System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Calls a method on the TaskLoggingHelper to parse a single line of text to
            see if there are any errors or warnings in canonical format.  This can
            be overridden by the derived class if necessary.
            </summary>
            <param name="singleLine"></param>
            <param name="messageImportance"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ReceiveTimeoutNotification(System.Object)">
            <summary>
            Signals when the tool times-out. The tool timer calls this method
            when the time-out period on the tool expires.
            </summary>
            <remarks>This method is used as a System.Threading.TimerCallback delegate.</remarks>
            <param name="unused"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ReceiveExitNotification(System.Object,System.EventArgs)">
            <summary>
            Signals when the tool exits. The Process object executing the tool
            calls this method when the tool exits.
            </summary>
            <remarks>This method is used as a System.EventHandler delegate.</remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ReceiveStandardErrorData(System.Object,System.Diagnostics.DataReceivedEventArgs)">
            <summary>
            Queues up the output from the stderr stream of the process executing
            the tool, and signals the availability of the data. The Process object
            executing the tool calls this method for every line of text that the
            tool writes to stderr.
            </summary>
            <remarks>This method is used as a System.Diagnostics.DataReceivedEventHandler delegate.</remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ReceiveStandardOutputData(System.Object,System.Diagnostics.DataReceivedEventArgs)">
            <summary>
            Queues up the output from the stdout stream of the process executing
            the tool, and signals the availability of the data. The Process object
            executing the tool calls this method for every line of text that the
            tool writes to stdout.
            </summary>
            <remarks>This method is used as a System.Diagnostics.DataReceivedEventHandler delegate.</remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.ReceiveStandardErrorOrOutputData(System.Diagnostics.DataReceivedEventArgs,System.Collections.Queue,System.Threading.ManualResetEvent)">
            <summary>
            Queues up the output from either the stderr or stdout stream of the
            process executing the tool, and signals the availability of the data.
            This method is a helper for the <see cref="M:Microsoft.Build.Utilities.ToolTask.ReceiveStandardErrorData(System.Object,System.Diagnostics.DataReceivedEventArgs)"/>()
            and <see cref="M:Microsoft.Build.Utilities.ToolTask.ReceiveStandardOutputData(System.Object,System.Diagnostics.DataReceivedEventArgs)"/>() methods.
            </summary>
            <param name="e"></param>
            <param name="dataQueue"></param>
            <param name="dataAvailableSignal"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.AssignStandardStreamLoggingImportance">
            <summary>
            Assign the importances that will be used for stdout/stderr logging of messages from this tool task.
            This takes into account (1 is highest precedence):
            1. the override value supplied as a task parameter.
            2. those overridden by any derived class and
            3. the defaults given by tooltask
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.FindOnPath(System.String)">
            <summary>
            Looks for the given file in the system path i.e. all locations in the %PATH% environment variable.
            </summary>
            <param name="filename"></param>
            <returns>The location of the file, or null if file not found.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.Execute">
            <summary>
            This method invokes the tool with the given parameters.
            </summary>
            <returns>true, if task executes successfully</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.AdjustCommandsForOperatingSystem(System.String)">
            <summary>
            Replace backslashes with OS-specific path separators,
            except when likely that the backslash is intentional.
            </summary>
            <remarks>
            Not a static method so that an implementation can
            override with more-specific knowledge of what backslashes
            are likely to be correct.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Utilities.ToolTask.LogEnvironmentVariable(System.Boolean,System.String,System.String)">
            <summary>
            Log a single environment variable that's about to be applied to the tool
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._eventCloseLock">
            <summary>
            An object to hold the event shutdown lock
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask.s_equalsSplitter">
            <summary>
            Splitter for environment variables
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._standardOutputImportanceToUse">
            <summary>
            The actual importance at which standard out messages will be logged 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._standardErrorImportanceToUse">
            <summary>
            The actual importance at which standard error messages will be logged 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._standardErrorData">
            <summary>
            Holds the stderr output from the tool.
            </summary>
            <remarks>This collection is NOT thread-safe.</remarks>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._standardOutputData">
            <summary>
            Holds the stdout output from the tool.
            </summary>
            <remarks>This collection is NOT thread-safe.</remarks>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._standardErrorDataAvailable">
            <summary>
            Used for signalling when the tool writes to stderr.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._standardOutputDataAvailable">
            <summary>
            Used for signalling when the tool writes to stdout.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._toolExited">
            <summary>
            Used for signalling when the tool exits.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._terminatedTool">
            <summary>
            Set to true if the tool process was terminated, 
            either because the timeout was reached or it was canceled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._toolTimeoutExpired">
            <summary>
            Used for signalling when the tool times-out.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._toolTimer">
            <summary>
            Used for timing-out the tool.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._toolExe">
            <summary>
            Used to support overriding the toolExe name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._eventsDisposed">
            <summary>
            Set when the events are about to be disposed, so that tardy
            calls on the event handlers don't try to reset a disposed event
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.ToolTask._environmentVariablePairs">
            <summary>
            List of name, value pairs to be passed to the spawned tool's environment.
            May be null.
            Object is used instead of string to avoid NGen/JIT FXcop flagging.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.ToolTask.StandardOutputOrErrorQueueType">
            <summary>
            Enumeration which indicates what kind of queue is being passed
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.TrackedDependencies">
            <summary>
            This class contains utility functions to assist with tracking dependencies
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TrackedDependencies.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[])">
            <summary>
            Expand wildcards in the item list.
            </summary>
            <param name="expand"></param>
            <returns>Array of items expanded</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.TrackedDependencies.ItemsExist(Microsoft.Build.Framework.ITaskItem[])">
            <summary>
            This method checks that all the files exist
            </summary>
            <param name="files"></param>
            <returns>bool</returns>
        </member>
        <member name="T:Microsoft.Build.Utilities.TaskLoggingHelper">
            <summary>
            Helper logging class - contains all the logging methods used by tasks.
            A TaskLoggingHelper object is passed to every task by MSBuild. For tasks that derive
            from the Task class, it is provided in the Log property.
            This class is thread safe: tasks can log from any threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.#ctor(Microsoft.Build.Framework.ITask)">
            <summary>
            public constructor
            </summary>
            <param name="taskInstance">task containing an instance of this class</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.#ctor(Microsoft.Build.Framework.IBuildEngine,System.String)">
            <summary>
            Public constructor which can be used by task factories to assist them in logging messages.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TaskLoggingHelper._sponsor">
            <summary>
            A client sponsor is a class
            which will respond to a lease renewal request and will
            increase the lease time allowing the object to stay in memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.TaskLoggingHelper._locker">
            <summary>
            Object to make this class thread-safe.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskLoggingHelper.TaskName">
            <summary>
            Gets the name of the parent task.
            </summary>
            <value>Task name string.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskLoggingHelper.TaskNameUpperCase">
            <summary>
            Gets the upper-case version of the parent task's name.
            </summary>
            <value>Upper-case task name string.</value>
        </member>
        <member name="F:Microsoft.Build.Utilities.TaskLoggingHelper._buildEngine">
            <summary>
            The build engine we are going to log against
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskLoggingHelper.BuildEngine">
            <summary>
            Shortcut property for getting our build engine - we retrieve it from the task instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources">
            <summary>
            Used to load culture-specific resources. Derived classes should register their resources either during construction, or
            via this property, if they have localized strings.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix">
            <summary>
            Gets or sets the prefix used to compose help keywords from string resource names.
            </summary>
            <value>The help keyword prefix string.</value>
        </member>
        <member name="P:Microsoft.Build.Utilities.TaskLoggingHelper.HasLoggedErrors">
            <summary>
            Has the task logged any errors through this logging helper object?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.ExtractMessageCode(System.String,System.String@)">
            <summary>
            Extracts the message code (if any) prefixed to the given message string. Message code prefixes must match the
            following .NET regular expression in order to be recognized: <c>^\s*[A-Za-z]+\d+:\s*</c>
            Thread safe.
            </summary>
            <example>
            If this method is given the string "MYTASK1001: This is an error message.", it will return "MYTASK1001" for the
            message code, and "This is an error message." for the message.
            </example>
            <param name="message">The message to parse.</param>
            <param name="messageWithoutCodePrefix">The message with the code prefix removed (if any).</param>
            <returns>The message code extracted from the prefix, or null if there was no code.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.FormatResourceString(System.String,System.Object[])">
            <summary>
            Loads the specified resource string and optionally formats it using the given arguments. The current thread's culture
            is used for formatting.
            
            Requires the owner task to have registered its resources either via the Task (or TaskMarshalByRef) base
            class constructor, or the Task.TaskResources (or AppDomainIsolatedTask.TaskResources) property.
            
            Thread safe.
            </summary>
            <param name="resourceName">The name of the string resource to load.</param>
            <param name="args">Optional arguments for formatting the loaded string.</param>
            <returns>The formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>resourceName</c> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the string resource indicated by <c>resourceName</c> does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.FormatString(System.String,System.Object[])">
            <summary>
            Formats the given string using the variable arguments passed in. The current thread's culture is used for formatting.
            Thread safe.
            </summary>
            <param name="unformatted">The string to format.</param>
            <param name="args">Arguments for formatting.</param>
            <returns>The formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>unformatted</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.GetResourceMessage(System.String)">
            <summary>
            Get the message from resource in task library.
            Thread safe.
            </summary>
            <param name="resourceName">The resource name.</param>
            <returns>The message from resource.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(System.String,System.Object[])">
            <summary>
            Logs a message using the specified string.
            Thread safe.
            </summary>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Logs a message of the given importance using the specified string.
            Thread safe.
            </summary>
            <remarks>
            Take care to order the parameters correctly or the other overload will be called inadvertently.
            </remarks>
            <param name="importance">The importance level of the message.</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Logs a message using the specified string and other message details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the warning type (can be null).</param>
            <param name="code">Message code (can be null)</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the message (can be null).</param>
            <param name="lineNumber">The line in the file causing the message (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the message (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the message (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the message (set to zero if not available).</param>
            <param name="importance">Importance of the message.</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogCriticalMessage(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a critical message using the specified string and other message details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the warning type (can be null).</param>
            <param name="code">Message code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the message (can be null).</param>
            <param name="lineNumber">The line in the file causing the message (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the message (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the message (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the message (set to zero if not available).</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(System.String,System.Object[])">
            <summary>
            Logs a message using the specified resource string.
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Logs a message of the given importance using the specified resource string.
            Thread safe.
            </summary>
            <remarks>
            Take care to order the parameters correctly or the other overload will be called inadvertently.
            </remarks>
            <param name="importance">The importance level of the message.</param>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectStarted(System.String,System.String,System.String,System.String)">
            <summary>
            Small helper for logging the custom ExternalProjectStarted build event
            Thread safe.
            </summary>
            <param name="message">text message</param>
            <param name="helpKeyword">help keyword</param>
            <param name="projectFile">project name</param>
            <param name="targetNames">targets we are going to build (empty indicates default targets)</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectFinished(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Small helper for logging the custom ExternalProjectFinished build event.
            Thread safe.
            </summary>
            <param name="message">text message</param>
            <param name="helpKeyword">help keyword</param>
            <param name="projectFile">project name</param>
            <param name="succeeded">true indicates project built successfully</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(System.String)">
            <summary>
            Logs the command line for a task's underlying tool/executable/shell command.
            Thread safe.
            </summary>
            <param name="commandLine">The command line string.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance,System.String)">
            <summary>
            Logs the command line for a task's underlying tool/executable/shell
            command, using the given importance level.
            Thread safe.
            </summary>
            <param name="importance">The importance level of the command line.</param>
            <param name="commandLine">The command line string.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogError(System.String,System.Object[])">
            <summary>
            Logs an error using the specified string.
            Thread safe.
            </summary>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogError(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs an error using the specified string and other error details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the error type (can be null).</param>
            <param name="errorCode">The error code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file containing the error (can be null).</param>
            <param name="lineNumber">The line in the file where the error occurs (set to zero if not available).</param>
            <param name="columnNumber">The column in the file where the error occurs (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string.
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string and other error details.
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the error type (can be null).</param>
            <param name="errorCode">The error code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file containing the error (can be null).</param>
            <param name="lineNumber">The line in the file where the error occurs (set to zero if not available).</param>
            <param name="columnNumber">The column in the file where the error occurs (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the error message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string. 
            If the message has an error code prefixed to it, the code is extracted and logged with the message. If a help keyword
            prefix has been provided, a help keyword for the host IDE is also logged with the message. The help keyword is
            composed by appending the string resource name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
               
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string and other error details. 
            If the message has an error code prefixed, the code is extracted and logged with the message. If a
            help keyword prefix has been provided, a help keyword for the host IDE is also logged with the message. The help
            keyword is composed by appending the error message resource string name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
               
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the error type (can be null).</param>
            <param name="file">The path to the file containing the error (can be null).</param>
            <param name="lineNumber">The line in the file where the error occurs (set to zero if not available).</param>
            <param name="columnNumber">The column in the file where the error occurs (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the error message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception)">
            <summary>
            Logs an error using the message from the given exception context.
            No callstack will be shown.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>e</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception,System.Boolean)">
            <summary>
            Logs an error using the message (and optionally the stack-trace) from the given exception context.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <param name="showStackTrace">If true, callstack will be appended to message.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception,System.Boolean,System.Boolean,System.String)">
            <summary>
            Logs an error using the message, and optionally the stack-trace from the given exception, and
            optionally inner exceptions too.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <param name="showStackTrace">If true, callstack will be appended to message.</param>
            <param name="showDetail">Whether to log exception types and any inner exceptions.</param>
            <param name="file">File related to the exception, or null if the project file should be logged</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(System.String,System.Object[])">
            <summary>
            Logs a warning using the specified string.
            Thread safe.
            </summary>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a warning using the specified string and other warning details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the warning type (can be null).</param>
            <param name="warningCode">The warning code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the warning (can be null).</param>
            <param name="lineNumber">The line in the file causing the warning (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the warning (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the warning (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the warning (set to zero if not available).</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string.
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string and other warning details.
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the warning type (can be null).</param>
            <param name="warningCode">The warning code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the warning (can be null).</param>
            <param name="lineNumber">The line in the file causing the warning (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the warning (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the warning (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the warning (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the warning message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string. 
            If the message has a warning code prefixed to it, the code is extracted and logged with the message. If a help keyword
            prefix has been provided, a help keyword for the host IDE is also logged with the message. The help keyword is
            composed by appending the string resource name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
            
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string and other warning details. 
            If the message has a warning code, the code is extracted and logged with the message.
            If a help keyword prefix has been provided, a help keyword for the host IDE is also logged with the message. The help
            keyword is composed by appending the warning message resource string name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
            
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the warning type (can be null).</param>
            <param name="file">The path to the file causing the warning (can be null).</param>
            <param name="lineNumber">The line in the file causing the warning (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the warning (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the warning (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the warning (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the warning message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception)">
            <summary>
            Logs a warning using the message from the given exception context.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception,System.Boolean)">
            <summary>
            Logs a warning using the message (and optionally the stack-trace) from the given exception context.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <param name="showStackTrace">If true, the exception callstack is appended to the message.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(System.String)">
            <summary>
            Logs errors/warnings/messages for each line of text in the given file. Errors/warnings are only logged for lines that
            fit a particular (canonical) format -- the remaining lines are treated as messages.
            Thread safe.
            </summary>
            <param name="fileName">The file to log from.</param>
            <returns>true, if any errors were logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>filename</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Logs errors/warnings/messages for each line of text in the given file. Errors/warnings are only logged for lines that
            fit a particular (canonical) format -- the remaining lines are treated as messages.
            Thread safe.
            </summary>
            <param name="fileName">The file to log from.</param>
            <param name="messageImportance">The importance level for messages that are neither errors nor warnings.</param>
            <returns>true, if any errors were logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>filename</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Logs errors/warnings/messages for each line of text in the given stream. Errors/warnings are only logged for lines
            that fit a particular (canonical) format -- the remaining lines are treated as messages.
            Thread safe.
            </summary>
            <param name="stream">The stream to log from.</param>
            <param name="messageImportance">The importance level for messages that are neither errors nor warnings.</param>
            <returns>true, if any errors were logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>stream</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromText(System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Logs an error/warning/message from the given line of text. Errors/warnings are only logged for lines that fit a
            particular (canonical) format -- all other lines are treated as messages.
            Thread safe.
            </summary>
            <param name="lineOfText">The line of text to log from.</param>
            <param name="messageImportance">The importance level for messages that are neither errors nor warnings.</param>
            <returns>true, if an error was logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>lineOfText</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.LogTelemetry(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Logs telemetry with the specified event name and properties.
            </summary>
            <param name="eventName">The event name.</param>
            <param name="properties">The list of properties associated with the event.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.InitializeLifetimeService">
            <summary>
            InitializeLifetimeService is called when the remote object is activated. 
            This method will determine how long the lifetime for the object will be.
            Thread safe. However, InitializeLifetimeService and MarkAsInactive should
            only be called in that order, together or not at all, and no more than once.
            </summary>
            <returns>The lease object to control this object's lifetime.</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.TaskLoggingHelper.MarkAsInactive">
            <summary>
            Notifies this object that its work is done.
            Thread safe. However, InitializeLifetimeService and MarkAsInactive should
            only be called in that order, together or not at all, and no more than once.
            </summary>
            <remarks>
            Indicates to the TaskLoggingHelper that it is no longer needed.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Utilities.Traits">
            <summary>
                Represents toggleable features of the MSBuild engine
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.UseLazyWildCardEvaluation">
            <summary>
            Do not expand wildcards that match a certain pattern
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.CacheFileExistence">
            <summary>
            Cache file existence for the entire process
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.UseSimpleInternConcurrency">
            <summary>
            Eliminate locking in OpportunisticIntern at the expense of memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.MSBuildCacheFileEnumerations">
            <summary>
            Cache wildcard expansions for the entire process
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.EnableRestoreFirst">
            <summary>
            Enable restore first functionality in MSBuild.exe
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.CopyTaskParallelism">
            <summary>
            Setting the associated environment variable to 1 restores the pre-15.8 single
            threaded (slower) copy behavior. Zero implies Int32.MaxValue, less than zero
            (default) uses the empirical default in Copy.cs, greater than zero can allow
            perf tuning beyond the defaults chosen.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.EmitSolutionMetaproj">
            <summary>
            Instruct MSBuild to write out the generated "metaproj" file to disk when building a solution file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.LogPropertyFunctionsRequiringReflection">
            <summary>
            Log statistics about property functions which require reflection
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.LogPropertyTracking">
            <summary>
            Log property tracking information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DoNotSendDeferredMessagesToBuildManager">
            <summary>
            Do not log command line information to build loggers. Useful to unbreak people who parse the msbuild log and who are unwilling to change their code.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DoNotExpandQualifiedMetadataInUpdateOperation">
            <summary>
            https://github.com/microsoft/msbuild/pull/4975 started expanding qualified metadata in Update operations. Before they'd expand to empty strings.
            This escape hatch turns back the old empty string behavior.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.EvaluateElementsWithFalseConditionInProjectEvaluation">
            <summary>
            Force whether Project based evaluations should evaluate elements with false conditions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.AlwaysUseContentTimestamp">
            <summary>
            Always use the accurate-but-slow CreateFile approach to timestamp extraction.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.TruncateTaskInputs">
            <summary>
            Truncate task inputs when logging them. This can reduce memory pressure
            at the expense of log usefulness.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches._logProjectImports">
            <summary>
            Emit events for project imports.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.EscapeHatches.LogProjectImports">
            <summary>
            Emit events for project imports.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.CacheAssemblyInformation">
            <summary>
            Read information only once per file per ResolveAssemblyReference invocation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime">
            <summary>
            Never use the slow (but more accurate) CreateFile approach to timestamp extraction.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.ReuseTaskHostNodes">
            <summary>
            Allow node reuse of TaskHost nodes. This results in task assemblies locked past the build lifetime, preventing them from being rebuilt if custom tasks change, but may improve performance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.IgnoreEmptyImports">
            <summary>
            Whether or not to ignore imports that are considered empty.  See ProjectRootElement.IsEmptyXmlFile() for more info.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.IgnoreTreatAsLocalProperty">
            <summary>
            Whether to to respect the TreatAsLocalProperty parameter on the Project tag. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DebugEvaluation">
            <summary>
            Whether to write information about why we evaluate to debug output.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.WarnOnUninitializedProperty">
            <summary>
            Whether to warn when we set a property for the first time, after it was previously used.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseCaseSensitiveItemNames">
            <summary>
            MSBUILDUSECASESENSITIVEITEMNAMES is an escape hatch for the fix
            for https://github.com/Microsoft/msbuild/issues/1751. It should
            be removed (permanently set to false) after establishing that
            it's unneeded (at least by the 16.0 timeframe).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableLongPaths">
            <summary>
            Disable the use of paths longer than Windows MAX_PATH limits (260 characters) when running on a long path enabled OS.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableSdkResolutionCache">
            <summary>
            Disable the use of any caching when resolving SDKs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableNuGetSdkResolver">
            <summary>
            Disable the NuGet-based SDK resolver.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.TargetPathForRelatedFiles">
            <summary>
            Don't delete TargetPath metadata from associated files found by RAR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseSingleLoadContext">
            <summary>
            Disable AssemblyLoadContext isolation for plugins.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseAutoRunWhenLaunchingProcessUnderCmd">
            <summary>
            Enables the user of autorun functionality in CMD.exe on Windows which is disabled by default in MSBuild.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.AvoidUnicodeWhenWritingToolTaskBatch">
            <summary>
            Disables switching codepage to UTF-8 after detection of characters that can't be represented in the current codepage.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout">
            <summary>
            Workaround for https://github.com/Microsoft/vstest/issues/1503.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseMinimalResxParsingInCoreScenarios">
            <summary>
            Use the original, string-only resx parsing in .NET Core scenarios.
            </summary>
            <remarks>
            Escape hatch for problems arising from https://github.com/microsoft/msbuild/pull/4420.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyResources">
            <summary>
            This class provides access to the assembly's resources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.GetString(System.String)">
            <summary>
            Loads the specified resource string, either from the assembly's primary resources, or its shared resources.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="name"></param>
            <returns>The resource string, or null if not found.</returns>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyResources.PrimaryResources">
            <summary>
            Gets the assembly's primary resources i.e. the resources exclusively owned by this assembly.
            </summary>
            <remarks>This property is thread-safe.</remarks>
            <value>ResourceManager for primary resources.</value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyResources.SharedResources">
            <summary>
            Gets the assembly's shared resources i.e. the resources this assembly shares with other assemblies.
            </summary>
            <remarks>This property is thread-safe.</remarks>
            <value>ResourceManager for shared resources.</value>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.FormatString(System.String,System.Object[])">
            <summary>
            Formats the given string using the variable arguments passed in. The current thread's culture is used for formatting.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="unformatted">The string to format.</param>
            <param name="args">Arguments for formatting.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.FormatResourceString(System.String,System.Object[])">
            <summary>
            Loads the specified resource string and optionally formats it using the given arguments. The current thread's culture
            is used for formatting.
            </summary>
            <remarks>
            1) This method requires the owner task to have registered its resources either via the Task (or TaskMarshalByRef) base
               class constructor, or the Task.TaskResources (or AppDomainIsolatedTask.TaskResources) property.
            2) This method is thread-safe.
            </remarks>
            <param name="resourceName">The name of the string resource to load.</param>
            <param name="args">Optional arguments for formatting the loaded string.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.FileSystems">
            <summary>
            Factory for <see cref="T:Microsoft.Build.Shared.FileSystem.IFileSystem"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.IFileSystem">
            <summary>
            Abstracts away some file system operations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of file names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of directory names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of file names and directory names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.DirectoryExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing directory on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.FileExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.DirectoryEntryExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing entry in the directory service.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.ManagedFileSystem">
            <summary>
            Implementation of file system operations directly over the dot net managed layer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem">
            <summary>
            Implementation of file system operations directly over the dot net managed layer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.NativeWin32Exception">
            <summary>
            A possibly-recoverable exception wrapping a failed native call. The <see cref="P:System.ComponentModel.Win32Exception.NativeErrorCode" /> captures the
            associated recent error code (<see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />). The <see cref="P:System.Exception.Message" />
            accounts for the native code as well as a human readable portion.
            </summary>
            <remarks>
            This is much like <see cref="T:System.ComponentModel.Win32Exception"/>, but the message field contains the caller-provided part in addition
            to the system-provided message (rather than replacing the system provided message).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.#ctor(System.Int32,System.String)">
            <summary>
            Creates an exception representing a native failure (with a corresponding Win32 error code).
            The exception's <see cref="P:System.Exception.Message" /> includes the error code, a system-provided message describing it,
            and the provided application-specific message prefix (e.g. "Unable to open log file").
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.#ctor(System.Int32)">
            <summary>
            Creates an exception representing a native failure (with a corresponding Win32 error code).
            The exception's <see cref="P:System.Exception.Message" /> includes the error code and a system-provided message describing it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.GetFormattedMessageForNativeErrorCode(System.Int32,System.String)">
            <summary>
            Returns a human readable error string for a native error code, like <c>Native: Can't access the log file (0x5: Access is denied)</c>.
            The message prefix (e.g. "Can't access the log file") is optional.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.HResultFromWin32(System.Int32)">
            <summary>
            Converts a Win32 error code to HResult
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle">
            <summary>
            Handle for a volume iteration as returned by WindowsNative.FindFirstVolumeW />
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle.#ctor">
            <summary>
            Private constructor for the PInvoke marshaller.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle.ReleaseHandle">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.FileArtifactType">
            <summary>
            The type of file artifact to search for
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.File">
            <nodoc/>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.Directory">
            <nodoc/>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.FileOrDirectory">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsFileSystem">
            <summary>
            Windows-specific implementation of file system operations using Windows native invocations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative">
            <summary>
            Native implementation of file system operations
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.MaxPath">
            <summary>
            Maximum path length.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorSuccess">
            <summary>
            ERROR_SUCCESS
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorFileNotFound">
            <summary>
            ERROR_FILE_NOT_FOUND
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorPathNotFound">
            <summary>
            ERROR_PATH_NOT_FOUND
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorDirectory">
            <summary>
            ERROR_DIRECTORY
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorAccessDenied">
            <summary>
            ERROR_ACCESS_DENIED
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorNoMoreFiles">
            <summary>
            ERROR_NO_MORE_FILES
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags">
            <summary>
            Modifies the search condition of PathMatchSpecEx
            </summary>
            <remarks>
            <see ref="https://msdn.microsoft.com/en-us/library/windows/desktop/bb773728(v=vs.85).aspx"/>
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfNormal">
            <summary>
            The pszSpec parameter points to a single file name pattern to be matched.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfMultiple">
            <summary>
            The pszSpec parameter points to a semicolon-delimited list of file name patterns to be matched.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfDontStripSpaces">
            <summary>
            If PMSF_NORMAL is used, ignore leading spaces in the string pointed to by pszSpec. If PMSF_MULTIPLE is used, 
            ignore leading spaces in each file type contained in the string pointed to by pszSpec. This flag can be combined with PMSF_NORMAL and PMSF_MULTIPLE.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus">
            <summary>
            Status of attempting to enumerate a directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.Success">
            <summary>
            Enumeration of an existent directory succeeded.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound">
            <summary>
            One or more path components did not exist, so the search directory could not be opened.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.CannotEnumerateFile">
            <summary>
            A path component in the search path refers to a file. Only directories can be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.AccessDenied">
            <summary>
            Directory enumeration could not complete due to denied access to the search directory or a file inside.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.UnknownError">
            <summary>
            Directory enumeration failed without a well-known status (see <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.NativeErrorCode"/>).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult">
            <summary>
            Represents the result of attempting to enumerate a directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Directory">
            <summary>
            Enumerated directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Status">
            <summary>
            Overall status indication.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.NativeErrorCode">
            <summary>
            Native error code. Note that an error code other than <c>ERROR_SUCCESS</c> may be present even on success.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.#ctor(System.String,Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus,System.Int32)">
            <nodoc />
        </member>
        <member name="P:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Succeeded">
            <summary>
            Indicates if enumeration succeeded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.ThrowForUnknownError">
            <summary>
            Throws an exception if the native error code could not be canonicalized (a fairly exceptional circumstance).
            This is allowed when <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Status"/> is <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.UnknownError"/>.
            </summary>
            <remarks>
            This is a good <c>default:</c> case when switching on every possible <see cref="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus"/>
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.ThrowForKnownError">
            <summary>
            Throws an exception if the native error code was corresponds to a known <see cref="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus"/>
            (and enumeration was not successful).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.CreateExceptionForError">
            <summary>
            Creates (but does not throw) an exception for this result. The result must not be successful.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData">
            <summary>
            <c>Win32FindData</c>
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwFileAttributes">
            <summary>
            The file attributes of a file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtCreationTime">
            <summary>
            Specified when a file or directory was created
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtLastAccessTime">
            <summary>
            Specifies when the file was last read from, written to, or for executable files, run.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtLastWriteTime">
            <summary>
            For a file, the structure specifies when the file was last written to, truncated, or overwritten.
            For a directory, the structure specifies when the directory is created.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.NFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.NFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.CFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.CAlternate">
            <summary>
            An alternative name for the file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindFirstFileW(System.String,Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData@)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindNextFileW(System.Runtime.InteropServices.SafeHandle,Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData@)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.PathMatchSpecExW(System.String,System.String,System.Int32)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindClose(System.IntPtr)">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.Debugging.PrintLineDebugger">
            <summary>
                A class to help with printline debugging in difficult environments like CI, or when debugging msbuild through other
                tools like VS or CLI.
                See example usages in PrintLineDebugger_Tests
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.Debugging.PrintLineDebuggerWriters">
            <summary>
                A collection of useful writers
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyFoldersEx">
             <summary>
             Implements the rules for finding component directories using the AssemblyFoldersEx scheme.
            
             This is the normal schema:
            
              [HKLM | HKCU]\SOFTWARE\MICROSOFT\.NetFramework\ 
                v1.0.3705 
                  AssemblyFoldersEx 
                      Infragistics.GridControl.1.0:  
                          @Default = c:\program files\infragistics\grid control\1.0\bin 
                          @Description = Infragistics Grid Control for .NET version 1.0 
                          9466 
                              @Default = c:\program files\infragistics\grid control\1.0sp1\bin 
                              @Description = SP1 for Infragistics Grid Control for .NET version 1.0 
            
             
             The root registry path is the following:
            
                 [HKLM | HKCU]\{AssemblyFoldersBase}\{RuntimeVersion}\{AssemblyFoldersSuffix}
            
             Where:
            
                 {AssemblyFoldersBase} = Software\Microsoft\[.NetFramework | .NetCompactFramework]
                 {RuntimeVersion} = the runtime version property from the project file
                 {AssemblyFoldersSuffix} = [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx
            
             </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyFoldersEx._directoryNames">
            <summary>
            The list of directory names found from the registry.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.#ctor(System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,System.Reflection.ProcessorArchitecture,Microsoft.Build.Shared.OpenBaseKey)">
            <summary>
            Construct.
            </summary>
            <param name="registryKeyRoot">Like Software\Microsoft\[.NetFramework | .NetCompactFramework]</param>
            <param name="targetRuntimeVersion">The runtime version property from the project file.</param>
            <param name="registryKeySuffix">Like [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx</param>
            <param name="osVersion">Operating system version</param>
            <param name="platform">Current platform</param>
            <param name="getRegistrySubKeyNames">Used to find registry subkey names.</param>
            <param name="getRegistrySubKeyDefaultValue">Used to find registry key default values.</param>
            <param name="targetProcessorArchitecture">Architecture to seek.</param>
            <param name="openBaseKey">Key object to open.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.FindDirectories(Microsoft.Win32.RegistryView,Microsoft.Win32.RegistryHive,System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,Microsoft.Build.Shared.OpenBaseKey)">
            <summary>
            Finds directories for a specific registry key.
            </summary>
            <param name="view">The registry view to examine.</param>
            <param name="hive">The registry hive to examine.</param>
            <param name="registryKeyRoot">Like Software\Microsoft\[.NetFramework | .NetCompactFramework]</param>
            <param name="targetRuntimeVersion">The runtime version property from the project file.</param>
            <param name="registryKeySuffix">Like [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx</param>
            <param name="osVersion">Operating system version</param>
            <param name="platform">Current platform</param>
            <param name="getRegistrySubKeyNames">Used to find registry subkey names.</param>
            <param name="getRegistrySubKeyDefaultValue">Used to find registry key default values.</param>
            <param name="openBaseKey">Key object to open.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.GatherVersionStrings(System.String,System.Collections.Generic.IEnumerable{System.String})">
             <summary>
              The algorithm for gathering versions from the registry is as follows:
                 1) targetRuntimeVersion is the target framework version you are targeting
                 2) versions is a string list from reading the registry, this list is in what ever order the registry returns 
                    the keys to us in, this is usually alphabetical.
                 
                 We will go through each version string and do the following:
                     1) Check to see if the string is a version
                         If the string is not a version we will check to see if the string starts with the framework we are targeting,
                         if it does we will add it to a list which will be added at the end 
                         of the versions list, if not it gets ignored. We do this to stay compatible to what we have been doing since whidbey.
                         
                         If the string is a version
                             We check to see if the version is a valid target framework version. Meaning.  It has a Maj.Minor version and may have 
                             build, Build is less than or equal to 255 and there is no revision. The reason the build number needs to be less than 255 is because
                             255 is the largest build number for a target framework version that visual studio 2010 supports. The build number is supposed to 
                             represent a service pack on the 4.0 framework.
                             
                             If the string is a valid target framework version we check to see we already have a dictionary entry and if not we 
                             add one. 
                             If the string is not a valid target framework then we will ignore the part of the version which makes it invalid
                             (either the build or the revision, or both) and see where that version would fit in the dictionary as a key and
                             then put the original version string into the list for that entry.
                             
                     Since the dictionary is sorted in reverse order to generate the list to return we do the following:
                     Go through the list of dictionary entries 
                         For each entry sort the list in reverse alphabetical order and add the entries in their internal list to the listToreturn.
            
                     This way we have a reverse sorted list of all of the version keys.
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.AddCandidateVersion(System.Collections.Generic.SortedDictionary{System.Version,System.Collections.Generic.List{System.String}},System.String,System.Version)">
            <summary>
            Given a candidate version we need to add it to the dictionary of targetFrameworkToRegistry versions. This involves determining if we need to add it to
            an existing entry or create a new one.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.System#Collections#Generic#IEnumerable{Microsoft#Build#Utilities#AssemblyFoldersExInfo}#GetEnumerator">
            <summary>
            Get Enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderCollection.Load(System.String)">
            <summary>
            Deserialize the file into an AssemblyFolderCollection.
            </summary>
            <param name="filePath">Path to the AssemblyFolder.config file.</param>
            <returns>New deserialized collection instance.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_visualStudioProcess" -->
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_msBuildProcess">
            <summary>
            Name of the MSBuild process(es)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_msBuildExeNames">
            <summary>
            Name of MSBuild executable files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironmentHelper.Instance">
            <summary>
            Gets the cached Build Environment instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.Initialize">
            <summary>
            Find the location of MSBuild.exe based on the current environment.
            </summary>
            <remarks>
            This defines the order and precedence for various methods of discovering MSBuild and associated toolsets.
            At a high level, an install under Visual Studio is preferred as the user may have SDKs installed to a
            specific instance of Visual Studio and build will only succeed if we can discover those. See
            https://github.com/Microsoft/msbuild/issues/1461 for details.
            </remarks>
            <returns>Build environment.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.IsProcessInList(System.String,System.String[])">
            <summary>
            Returns true if processName appears in the processList
            </summary>
            <param name="processName">Name of the process</param>
            <param name="processList">List of processes to check</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(System.Func{System.String},System.Func{System.String},System.Func{System.String},System.Func{System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.VisualStudioInstance}},System.Func{System.String,System.String},System.Func{System.Boolean})">
            <summary>
            Resets the current singleton instance (for testing).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.BuildEnvironmentMode">
            <summary>
            Enum which defines which environment / mode MSBuild is currently running.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.VisualStudio">
            <summary>
            Running from Visual Studio directly or from MSBuild installed under an instance of Visual Studio.
            Toolsets and extensions will be loaded from the Visual Studio instance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.Standalone">
            <summary>
            Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app 
            running and not dependent on Visual Studio. (e.g. dotnet CLI, open source clone of our repo)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.None">
            <summary>
            Running without any defined toolsets. Most functionality limited. Likely will not be able to
            build or evaluate a project. (e.g. reference to Microsoft.*.dll without a toolset definition
            or Visual Studio instance installed).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.BuildEnvironment">
            <summary>
            Defines the current environment for build tools.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.RunningTests">
            <summary>
            Gets the flag that indicates if we are running in a test harness.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.RunningInVisualStudio">
            <summary>
            Returns true when the entry point application is Visual Studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildToolsDirectory32">
            <summary>
            Path to the MSBuild 32-bit tools directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildToolsDirectory64">
            <summary>
            Path to the MSBuild 64-bit (AMD64) tools directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildSDKsPath">
            <summary>
            Path to the Sdks folder for this MSBuild instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildConfigurationFile">
            <summary>
            Full path to the current MSBuild configuration file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildExePath">
            <summary>
            Full path to current MSBuild.exe.
            <remarks>
            This path is likely not the current running process. We may be inside
            Visual Studio or a test harness. In that case this will point to the
            version of MSBuild found to be associated with the current environment.
            </remarks>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildToolsDirectory">
            <summary>
            Full path to the current MSBuild tools directory. This will be 32-bit unless
            we're executing from the 'AMD64' folder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.VisualStudioInstallRootDirectory">
            <summary>
            Path to the root Visual Studio install directory
            (e.g. 'C:\Program Files (x86)\Microsoft Visual Studio\Preview\Enterprise')
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildExtensionsPath">
            <summary>
            MSBuild extensions path. On Standalone this defaults to the MSBuild folder. In
            VisualStudio mode this folder will be %VSINSTALLDIR%\MSBuild.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError">
             <summary>
             Functions for dealing with the specially formatted errors returned by
             build tools.
             </summary>
             <remarks>
             Various tools produce and consume CanonicalErrors in various formats.
            
             DEVENV Format When Clicking on Items in the Output Window
             (taken from env\msenv\core\findutil.cpp ParseLocation function)
            
                  v:\dir\file.ext (loc) : msg
                  \\server\share\dir\file.ext(loc):msg
                  url
            
                  loc:
                  (line)
                  (line-line)
                  (line,col)
                  (line,col-col)
                  (line,col,len)
                  (line,col,line,col)
            
             DevDiv Build Process
             (taken from tools\devdiv2.def)
            
                  To echo warnings and errors to the build console, the
                  "description block" must be recognized by build. To do this,
                  add a $(ECHO_COMPILING_COMMAND) or $(ECHO_PROCESSING_COMMAND)
                  to the first line of the description block, e.g.
            
                      $(ECHO_COMPILING_CMD) Resgen_$&lt;
            
                  Errors must have the format:
            
                      &lt;text&gt; : error [num]: &lt;msg&gt;
            
                  Warnings must have the format:
            
                      &lt;text&gt; : warning [num]: &lt;msg&gt;
             </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError.Parts">
            <summary>
            Represents the parts of a decomposed canonical message.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError.Parts.Category">
            <summary>
            Defines the error category\severity level.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.numberNotSpecified">
            <summary>
            Value used for unspecified line and column numbers, which are 1-relative.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.Parts.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Shared.CanonicalError.Parts"/> class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.origin">
            <summary>
            Name of the file or tool (not localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.line">
            <summary>
            The line number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.column">
            <summary>
            The column number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.endLine">
            <summary>
            The ending line number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.endColumn">
            <summary>
            The ending column number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.category">
            <summary>
            The category/severity level
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.subcategory">
            <summary>
            The sub category (localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.code">
            <summary>
            The error code (not localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.text">
            <summary>
            The error message text (localized)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.ConvertToIntWithDefault(System.String)">
            <summary>
            A small custom int conversion method that treats invalid entries as missing (0). This is done to work around tools
            that don't fully conform to the canonical message format - we still want to salvage what we can from the message.
            </summary>
            <param name="value"></param>
            <returns>'value' converted to int or 0 if it can't be parsed or is negative</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.Parse(System.String)">
            <summary>
            Decompose an error or warning message into constituent parts. If the message isn't in the canonical form, return null.
            </summary>
            <remarks>This method is thread-safe, because the Regex class is thread-safe (per MSDN).</remarks>
            <param name="message"></param>
            <returns>Decomposed canonical message, or null.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.ExtensionFoldersRegistryKey">
            <summary>
            Contains information about entries in the AssemblyFoldersEx registry keys.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExtensionFoldersRegistryKey.#ctor(System.String,System.Version)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExtensionFoldersRegistryKey.RegistryKey">
            <summary>
            The registry key to the component
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExtensionFoldersRegistryKey.TargetFrameworkVersion">
            <summary>
            Target framework version for the registry key
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.DirectoryGetFiles">
            <summary>
            delegate for System.IO.Directory.GetFiles, used for testing
            </summary>
            <param name="path">Directory path to start search for files in</param>
            <param name="searchPattern">pattern of files to match</param>
            <returns>string array of files which match search pattern</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.GetDirectories">
            <summary>
            delegate for Directory.GetDirectories.
            </summary>
            <param name="path">The path to get directories for.</param>
            <param name="pattern">The pattern to search for.</param>
            <returns>An array of directories.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.DirectoryExists">
            <summary>
            Delegate for System.IO.Directory.Exists
            </summary>
            <param name="path">Directory path to check if it exists</param>
            <returns>true if directory exists</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileExists">
            <summary>
            File exists delegate
            </summary>
            <param name="path">The path to check for existence.</param>
            <returns>'true' if the file exists.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileCopy">
            <summary>
            File.Copy delegate
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileDelete">
            <summary>
            File.Delete delegate
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileCreate">
            <summary>
            File create delegate
            </summary>
            <param name="path">The path to create.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.EncodingUtilities">
            <summary>
            This class contains utility methods for dealing with encoding.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.EncodingUtilities.CurrentSystemOemEncoding">
            <summary>
            Get the current system locale code page, OEM version. OEM code pages are used for console-based input/output
            for historical reasons.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.SimilarToEncoding(System.Text.Encoding,System.Text.Encoding)">
            <summary>
            Checks two encoding types to determine if they are similar to each other (equal or if
            the Encoding Name is the same).
            </summary>
            <param name="encoding1"></param>
            <param name="encoding2"></param>
            <returns>True if the two Encoding objects are equal or similar.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.IsUtf8Encoding(System.Text.Encoding)">
            <summary>
            Check if an encoding type is UTF8 (with or without BOM).
            </summary>
            <param name="encoding"></param>
            <returns>True if the encoding is UTF8.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.StartsWithPreamble(System.IO.Stream)">
            <summary>
            Check the first 3 bytes of a stream to determine if it matches the UTF8 preamble.
            </summary>
            <param name="stream">Steam to check.</param>
            <returns>True when the first 3 bytes of the Stream are equal to the UTF8 preamble (BOM).</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.StartsWithPreamble(System.IO.Stream,System.Byte[])">
            <summary>
            Check the first 3 bytes of a stream to determine if it matches the given preamble.
            </summary>
            <param name="stream">Steam to check.</param>
            <param name="preamble">Preamble to look for.</param>
            <returns>True when the first 3 bytes of the Stream are equal to the preamble.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.FileStartsWithPreamble(System.String)">
            <summary>
            Check the first 3 bytes of a file to determine if it matches the 3-byte UTF8 preamble (BOM).
            </summary>
            <param name="file">Path to file to check.</param>
            <returns>True when the first 3 bytes of the file are equal to the UTF8 BOM.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.CanEncodeString(System.Int32,System.String)">
            <summary>
            Checks to see if a string can be encoded in a specified code page.
            </summary>
            <remarks>Internal for testing purposes.</remarks>
            <param name="codePage">Code page for encoding.</param>
            <param name="stringToEncode">String to encode.</param>
            <returns>True if the string can be encoded in the specified code page.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.BatchFileEncoding(System.String,System.String)">
             <summary>
             Find the encoding for the batch file.
             </summary>
             <remarks>
             The "best" encoding is the current OEM encoding, unless it's not capable of representing
             the characters we plan to put in the file. If it isn't, we can fall back to UTF-8.
            
             Why not always UTF-8? Because tools don't always handle it well. See
             https://github.com/Microsoft/msbuild/issues/397
             </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.ErrorUtilities">
            <summary>
            This class contains methods that are useful for error checking and validation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ErrorUtilities.s_throwExceptions">
            <summary>
            Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
            and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
            then we can give them this undocumented environment variable as an immediate workaround.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Object[])">
            <summary>
            Throws InternalErrorException. 
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Exception,System.Object[])">
            <summary>
            Throws InternalErrorException. 
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalErrorUnreachable">
            <summary>
            Throws InternalErrorException. 
            Indicates the code path followed should not have been possible.
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowIfTypeDoesNotImplementToString(System.Object)">
            <summary>
            Throws InternalErrorException. 
            Indicates the code path followed should not have been possible.
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalNull(System.Object,System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is null.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="parameter">The value of the argument.</param>
            <param name="parameterName">Parameter that should not be null</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalLockHeld(System.Object)">
            <summary>
            Helper to throw an InternalErrorException when a lock on the specified object is not already held.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="locker">The object that should already have been used as a lock.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalLength(System.String,System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is null or zero length.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="parameterValue">The value of the argument.</param>
            <param name="parameterName">Parameter that should not be null or zero length</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalRooted(System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is not a rooted path.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="value">Parameter that should be a rooted path</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String)">
            <summary>
            This method should be used in places where one would normally put
            an "assert". It should be used to validate that our assumptions are
            true, where false would indicate that there must be a bug in our
            code somewhere. This should not be used to throw errors based on bad
            user input or anything that the user did wrong.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInvalidOperation(System.String,System.Object[])">
            <summary>
            Throws an InvalidOperationException with the specified resource string
            </summary>
            <param name="resourceName">Resource to use in the exception</param>
            <param name="args">Formatting args.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String)">
            <summary>
            Throws an InvalidOperationException if the given condition is false.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgument(System.String,System.Object[])">
            <summary>
            Throws an ArgumentException that can include an inner exception.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgument(System.Exception,System.String,System.Object[])">
            <summary>
            Throws an ArgumentException that can include an inner exception.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>
            This method is thread-safe.
            </remarks>
            <param name="innerException">Can be null.</param>
            <param name="resourceName"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String)">
            <summary>
            Throws an ArgumentException if the given condition is false.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String)">
            <summary>
            Throws an ArgumentException that includes an inner exception, if
            the given condition is false.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException">Can be null.</param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgumentOutOfRange(System.String)">
            <summary>
            Throws an argument out of range exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentOutOfRange(System.Boolean,System.String)">
            <summary>
            Throws an ArgumentOutOfRangeException using the given parameter name
            if the condition is false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentLength(System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given string parameter is null
            and ArgumentException if it has zero length.
            </summary>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentInvalidPath(System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given string parameter is null
            and ArgumentException if it has zero length.
            </summary>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(System.String,System.String)">
            <summary>
            Throws an ArgumentException if the string has zero length, unless it is 
            null, in which case no exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentNull(System.Object,System.String)">
            <summary>
            Throws an ArgumentNullException if the given parameter is null.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentNull(System.Object,System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given parameter is null.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentArraysSameLength(System.Array,System.Array,System.String,System.String)">
            <summary>
            Verifies the given arrays are not null and have the same length
            </summary>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="parameter1Name"></param>
            <param name="parameter2Name"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.EscapingUtilities">
            <summary>
            This class implements static methods to assist with unescaping of %XX codes
            in the MSBuild file format.
            </summary>
            <remarks>
            PERF: since we escape and unescape relatively frequently, it may be worth caching
            the last N strings that were (un)escaped
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.EscapingUtilities.s_unescapedToEscapedStrings">
            <summary>
            Optional cache of escaped strings for use when needing to escape in performance-critical scenarios with significant
            expected string reuse.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.UnescapeAll(System.String)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.UnescapeAll(System.String,System.Boolean@)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <param name="escapingWasNecessary">Whether any replacements were made.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.EscapeWithCaching(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Interns and caches the result.
            </summary>
            <comment>
            NOTE:  Only recommended for use in scenarios where there's expected to be significant
            repetition of the escaped string.  Cache currently grows unbounded.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.Escape(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <returns>escaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.EscapeWithOptionalCaching(System.String,System.Boolean)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Caches if requested.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <param name="cache">
            True if the cache should be checked, and if the resultant string
            should be cached.
            </param>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.ContainsReservedCharacters(System.String)">
            <summary>
            Before trying to actually escape the string, it can be useful to call this method to determine
            if escaping is necessary at all.  This can save lots of calls to copy around item metadata
            that is really the same whether escaped or not.
            </summary>
            <param name="unescapedString"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.ContainsEscapedWildcards(System.String)">
            <summary>
            Determines whether the string contains the escaped form of '*' or '?'.
            </summary>
            <param name="escapedString"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.HexDigitChar(System.Int32)">
            <summary>
            Convert the given integer into its hexadecimal representation.
            </summary>
            <param name="x">The number to convert, which must be non-negative and less than 16</param>
            <returns>The character which is the hexadecimal representation of <paramref name="x"/>.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.AppendEscapedChar(System.Text.StringBuilder,System.Char)">
            <summary>
            Append the escaped version of the given character to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/> to which to append.</param>
            <param name="ch">The character to escape.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.AppendEscapedString(System.Text.StringBuilder,System.String)">
            <summary>
            Append the escaped version of the given string to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/> to which to append.</param>
            <param name="unescapedString">The unescaped string.</param>
        </member>
        <member name="F:Microsoft.Build.Shared.EscapingUtilities.s_charsToEscape">
            <summary>
            Special characters that need escaping.
            It's VERY important that the percent character is the FIRST on the list - since it's both a character
            we escape and use in escape sequences, we can unintentionally escape other escape sequences if we
            don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits
            (that would require rewriting the algorithm) but since it seems unlikely that we ever do, this should
            be good enough to avoid complicating the algorithm at this point.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.EventArgsFormatting">
            <summary>
            Offers a default string format for Error and Warning events
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Format the error event message and all the other event data into
            a single string.
            </summary>
            <param name="e">Error to format</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildErrorEventArgs,System.Boolean)">
            <summary>
            Format the error event message and all the other event data into
            a single string.
            </summary>
            <param name="e">Error to format</param>
            <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Format the warning message and all the other event data into a
            single string.
            </summary>
            <param name="e">Warning to format</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildWarningEventArgs,System.Boolean)">
            <summary>
            Format the warning message and all the other event data into a
            single string.
            </summary>
            <param name="e">Warning to format</param>
            <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Format the message and all the other event data into a
            single string.
            </summary>
            <param name="e">Message to format</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildMessageEventArgs,System.Boolean)">
            <summary>
            Format the message and all the other event data into a
            single string.
            </summary>
            <param name="e">Message to format</param>
            <param name="showProjectFile">Show project file or not</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Format the event message and all the other event data into a
            single string.
            </summary>
            <param name="category">category ("error" or "warning")</param>
            <param name="subcategory">subcategory</param>
            <param name="message">event message</param>
            <param name="code">error or warning code number</param>
            <param name="file">file name</param>
            <param name="lineNumber">line number (0 if n/a)</param>
            <param name="endLineNumber">end line number (0 if n/a)</param>
            <param name="columnNumber">column number (0 if n/a)</param>
            <param name="endColumnNumber">end column number (0 if n/a)</param>
            <param name="threadId">thread id</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Format the event message and all the other event data into a
            single string.
            </summary>
            <param name="category">category ("error" or "warning")</param>
            <param name="subcategory">subcategory</param>
            <param name="message">event message</param>
            <param name="code">error or warning code number</param>
            <param name="file">file name</param>
            <param name="projectFile">the project file name</param>
            <param name="lineNumber">line number (0 if n/a)</param>
            <param name="endLineNumber">end line number (0 if n/a)</param>
            <param name="columnNumber">column number (0 if n/a)</param>
            <param name="endColumnNumber">end column number (0 if n/a)</param>
            <param name="threadId">thread id</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.SplitStringOnNewLines(System.String)">
            <summary>
            Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
            </summary>
            <param name="s">String to split.</param>
        </member>
        <member name="F:Microsoft.Build.Shared.EventArgsFormatting.s_newLines">
            <summary>
            The kinds of newline breaks we expect.
            </summary>
            <remarks>Currently we're not supporting "\r".</remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.ExceptionHandling">
            <summary>
            Utility methods for classifying and handling exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.GetDebugDumpPath">
            <summary>
            Gets the location of the directory used for diagnostic log files.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.DebugDumpPath">
            <summary>
            The directory used for diagnostic log files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ExceptionHandling.s_dumpFileName">
            <summary>
            The filename that exceptions will be dumped to
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(System.Exception)">
            <summary>
            If the given exception is "ignorable under some circumstances" return false.
            Otherwise it's "really bad", and return true.
            This makes it possible to catch(Exception ex) without catching disasters.
            </summary>
            <param name="e"> The exception to check. </param>
            <returns> True if exception is critical. </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedException(System.Exception)">
            <summary>
            If the given exception is file IO related or expected return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
            <returns>True if exception is not IO related or expected otherwise false.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsIoRelatedException(System.Exception)">
            <summary>
            Determine whether the exception is file-IO related.
            </summary>
            <param name="e">The exception to check.</param>
            <returns>True if exception is IO related.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsXmlException(System.Exception)">
            <summary> Checks if the exception is an XML one. </summary>
            <param name="e"> Exception to check. </param>
            <returns> True if exception is related to XML parsing. </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.GetXmlLineAndColumn(System.Exception)">
            <summary> Extracts line and column numbers from the exception if it is XML-related one. </summary>
            <param name="e"> XML-related exception. </param>
            <returns> Line and column numbers if available, (0,0) if not. </returns>
            <remarks> This function works around the fact that XmlException and XmlSchemaException are not directly related. </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedIoOrXmlException(System.Exception)">
            <summary>
            If the given exception is file IO related or Xml related return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedReflectionException(System.Exception)">
            <summary>
            If the given exception is reflection-related return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedSerializationException(System.Exception)">
            <summary>
            Serialization has been observed to throw TypeLoadException as
            well as SerializationException and IO exceptions. (Obviously
            it has to do reflection but it ought to be wrapping the exceptions.)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedRegistryException(System.Exception)">
            <summary>
            Returns false if this is a known exception thrown by the registry API.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedFunctionException(System.Exception)">
            <summary>
            Returns false if this is a known exception thrown by function evaluation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.UnhandledExceptionHandler(System.Object,System.UnhandledExceptionEventArgs)">
            <summary>
            Dump any unhandled exceptions to a file so they can be diagnosed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.DumpExceptionToFile(System.Exception)">
            <summary>
            Dump the exception information to a file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.ReadAnyExceptionFromFile(System.DateTime)">
            <summary>
            Returns the content of any exception dump files modified
            since the provided time, otherwise returns an empty string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn">
            <summary> Line and column pair. </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn.Line">
            <summary> Gets or sets line number. </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn.Column">
            <summary> Gets or sets column position. </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilities">
            <summary>
            This class contains utility methods for file IO.
            PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
            each class get pulled into the resulting assembly.
            </summary>
            <summary>
            This class contains utility methods for file IO.
            </summary>
            <comment>
            Partial class in order to reduce the amount of sharing into different assemblies
            </comment>
            <summary>
            This class contains utility methods for file IO.
            It is in a separate file so that it can be selectively included into an assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.cacheDirectory">
            <summary>
            The directory where MSBuild stores cache information used during the build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearCacheDirectoryPath">
            <summary>
            FOR UNIT TESTS ONLY
            Clear out the static variable used for the cache directory so that tests that
            modify it can validate their modifications.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.InvalidPathChars">
            <summary>
            Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
            MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.InvalidFileNameChars">
            <summary>
            Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
            MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetCacheDirectory">
            <summary>
            Retrieves the MSBuild runtime cache directory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetHexHash(System.String)">
            <summary>
            Get the hex hash string for the string
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetPathsHash(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Get the hash for the assemblyPaths
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearCacheDirectory">
            <summary>
            Clears the MSBuild runtime cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureTrailingSlash(System.String)">
            <summary>
            If the given path doesn't have a trailing slash then add one.
            If the path is an empty string, does not modify it.
            </summary>
            <param name="fileSpec">The path to check.</param>
            <returns>A path with a slash.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureNoLeadingSlash(System.String)">
            <summary>
            Ensures the path does not have a leading slash.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureNoTrailingSlash(System.String)">
            <summary>
            Ensures the path does not have a trailing slash.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EndsWithSlash(System.String)">
            <summary>
            Indicates if the given file-spec ends with a slash.
            </summary>
            <param name="fileSpec">The file spec.</param>
            <returns>true, if file-spec has trailing slash</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsSlash(System.Char)">
            <summary>
            Indicates if the given character is a slash.
            </summary>
            <param name="c"></param>
            <returns>true, if slash</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.TrimAndStripAnyQuotes(System.String)">
            <summary>
            Trims the string and removes any double quotes around it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectoryNameOfFullPath(System.String)">
            <summary>
            Get the directory name of a rooted full path
            </summary>
            <param name="fullPath"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.NormalizePath(System.String)">
            <summary>
            Gets the canonicalized full path of the provided path.
            Guidance for use: call this on all paths accepted through public entry
            points that need normalization. After that point, only verify the path
            is rooted, using ErrorUtilities.VerifyThrowPathRooted.
            ASSUMES INPUT IS ALREADY UNESCAPED.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.MaybeAdjustFilePath(System.String,System.String)">
             <summary>
             If on Unix, convert backslashes to slashes for strings that resemble paths.
             The heuristic is if something resembles paths (contains slashes) check if the
             first segment exists and is a directory.
             Use a native shared method to massage file path. If the file is adjusted,
             that qualifies is as a path.
            
             @baseDirectory is just passed to LooksLikeUnixFilePath, to help with the check
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.LooksLikeUnixFilePath(System.String,System.String)">
             <summary>
             If on Unix, check if the string looks like a file path.
             The heuristic is if something resembles paths (contains slashes) check if the
             first segment exists and is a directory.
            
             If @baseDirectory is not null, then look for the first segment exists under
             that
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectory(System.String)">
            <summary>
            Extracts the directory from the given file-spec.
            </summary>
            <param name="fileSpec">The filespec.</param>
            <returns>directory path</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.HasExtension(System.String,System.String[])">
            <summary>
            Determines whether the given assembly file name has one of the listed extensions.
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="allowedExtensions">Array of extensions to consider.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.FileUtilities.ExecutingAssemblyPath">
            <summary>
            Get the currently executing assembly path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFullPath(System.String,System.String)">
            <summary>
            Determines the full path for the given file-spec.
            ASSUMES INPUT IS STILL ESCAPED
            </summary>
            <param name="fileSpec">The file spec to get the full path of.</param>
            <param name="currentDirectory"></param>
            <returns>full path</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)">
            <summary>
            A variation of Path.GetFullPath that will return the input value
            instead of throwing any IO exception.
            Useful to get a better path for an error message, without the risk of throwing
            if the error message was itself caused by the path being invalid!
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ComparePathsNoThrow(System.String,System.String,System.String)">
            <summary>
            Compare if two paths, relative to the given currentDirectory are equal.
            Does not throw IO exceptions. See <see cref="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)"/>
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <param name="currentDirectory"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.NormalizePathForComparisonNoThrow(System.String,System.String)">
             <summary>
             Normalizes a path for path comparison
             Does not throw IO exceptions. See <see cref="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)"/>
            
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteNoThrow(System.String)">
            <summary>
            A variation on File.Delete that will throw ExceptionHandling.NotExpectedException exceptions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteDirectoryNoThrow(System.String,System.Boolean,System.Int32,System.Int32)">
            <summary>
            A variation on Directory.Delete that will throw ExceptionHandling.NotExpectedException exceptions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteWithoutTrailingBackslash(System.String,System.Boolean)">
            <summary>
            Deletes a directory, ensuring that Directory.Delete does not get a path ending in a slash.
            </summary>
            <remarks>
            This is a workaround for https://github.com/dotnet/corefx/issues/3780, which clashed with a common
            pattern in our tests.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFileInfoNoThrow(System.String)">
            <summary>
            Gets a file info object for the specified file path. If the file path
            is invalid, or is a directory, or cannot be accessed, or does not exist,
            it returns null rather than throwing or returning a FileInfo around a non-existent file.
            This allows it to be called where File.Exists() (which never throws, and returns false
            for directories) was called - but with the advantage that a FileInfo object is returned
            that can be queried (e.g., for LastWriteTime) without hitting the disk again.
            </summary>
            <param name="filePath"></param>
            <returns>FileInfo around path if it is an existing /file/, else null</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DirectoryExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Returns if the directory exists
            </summary>
            <param name="fullPath">Full path to the directory in the filesystem</param>
            <param name="fileSystem">The file system</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.FileExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Returns if the directory exists
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <param name="fileSystem">The file system</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.FileOrDirectoryExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            If there is a directory or file at the specified path, returns true.
            Otherwise, returns false.
            Does not throw IO exceptions, to match Directory.Exists and File.Exists.
            Unlike calling each of those in turn it only accesses the disk once, which is faster.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsSolutionFilename(System.String)">
            <summary>
            This method returns true if the specified filename is a solution file (.sln), otherwise
            it returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsVCProjFilename(System.String)">
            <summary>
            Returns true if the specified filename is a VC++ project file, otherwise returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsMetaprojectFilename(System.String)">
            <summary>
            Returns true if the specified filename is a metaproject file (.metaproj), otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.MakeRelative(System.String,System.String)">
            <summary>
            Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
            Throws UriFormatException.
            </summary>
            <param name="basePath">
            The base path we want to be relative to. Must be absolute.
            Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
            </param>
            <param name="path">
            The path we need to make relative to basePath.  The path can be either absolute path or a relative path in which case it is relative to the base path.
            If the path cannot be made relative to the base path (for example, it is on another drive), it is returned verbatim.
            If the basePath is an empty string, returns the path.
            </param>
            <returns>relative path (can be the full path)</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.CreateUriFromPath(System.String)">
            <summary>
            Helper function to create an Uri object from path.
            </summary>
            <param name="path">path string</param>
            <returns>uri object</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.AttemptToShortenPath(System.String)">
            <summary>
            Normalizes the path if and only if it is longer than max path,
            or would be if rooted by the current directory.
            This may make it shorter by removing ".."'s.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsRootedNoThrow(System.String)">
            <summary>
            A variation of Path.IsRooted that not throw any IO exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFolderAbove(System.String,System.Int32)">
            <summary>
            Get the folder N levels above the given. Will stop and return current path when rooted.
            </summary>
            <param name="path">Path to get the folder above.</param>
            <param name="count">Number of levels up to walk.</param>
            <returns>Full path to the folder N levels above the path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.CombinePaths(System.String,System.String[])">
            <summary>
            Combine multiple paths. Should only be used when compiling against .NET 2.0.
            <remarks>
            Only use in .NET 2.0. Otherwise, use System.IO.Path.Combine(...)
            </remarks>
            </summary>
            <param name="root">Root path.</param>
            <param name="paths">Paths to concatenate.</param>
            <returns>Combined path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ToSlash(System.String)">
            <summary>
            Replace all backward slashes to forward slashes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ToPlatformSlash(System.String)">
            <summary>
            Ensure all slashes are the current platform's slash
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectoryNameOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Locate a file in either the directory specified or a location in the
            directory structure above that directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetPathOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Searches for a file based on the specified starting directory.
            </summary>
            <param name="file">The file to search for.</param>
            <param name="startingDirectory">An optional directory to start the search in.  The default location is the directory
                of the file containing the property function.</param>
            <param name="fileSystem">The filesystem</param>
            <returns>The full path of the file if it is found, otherwise an empty string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearFileExistenceCache">
            <summary>
            Clears the file existence cache.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers">
            <summary>
            Encapsulates the definitions of the item-spec modifiers a.k.a. reserved item metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsItemSpecModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for an item-spec modifier.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsDefiningProjectModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for one of the specific subset of itemspec 
            modifiers to do with the defining project of the item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for a derivable item-spec modifier.
            Derivable means it can be computed given a file name.
            </summary>
            <param name="name">Name to check.</param>
            <returns>true, if name of a derivable modifier</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.GetItemSpecModifier(System.String,System.String,System.String,System.String)">
            <summary>
            Performs path manipulations on the given item-spec as directed.
            Does not cache the result.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.GetItemSpecModifier(System.String,System.String,System.String,System.String,System.String@)">
            <summary>
            Performs path manipulations on the given item-spec as directed.
            
            Supported modifiers:
                %(FullPath)         = full path of item
                %(RootDir)          = root directory of item
                %(Filename)         = item filename without extension
                %(Extension)        = item filename extension
                %(RelativeDir)      = item directory as given in item-spec
                %(Directory)        = full path of item directory relative to root
                %(RecursiveDir)     = portion of item path that matched a recursive wildcard
                %(Identity)         = item-spec as given
                %(ModifiedTime)     = last write time of item
                %(CreatedTime)      = creation time of item
                %(AccessedTime)     = last access time of item
            
            NOTES:
            1) This method always returns an empty string for the %(RecursiveDir) modifier because it does not have enough
               information to compute it -- only the BuildItem class can compute this modifier.
            2) All but the file time modifiers could be cached, but it's not worth the space. Only full path is cached, as the others are just string manipulations.
            </summary>
            <remarks>
            Methods of the Path class "normalize" slashes and periods. For example:
            1) successive slashes are combined into 1 slash
            2) trailing periods are discarded
            3) forward slashes are changed to back-slashes
            
            As a result, we cannot rely on any file-spec that has passed through a Path method to remain the same. We will
            therefore not bother preserving slashes and periods when file-specs are transformed.
            
            Never returns null.
            </remarks>
            <param name="currentDirectory">The root directory for relative item-specs. When called on the Engine thread, this is the project directory. When called as part of building a task, it is null, indicating that the current directory should be used.</param>
            <param name="itemSpec">The item-spec to modify.</param>
            <param name="definingProjectEscaped">The path to the project that defined this item (may be null).</param>
            <param name="modifier">The modifier to apply to the item-spec.</param>
            <param name="fullPath">Full path if any was previously computed, to cache.</param>
            <returns>The modified item-spec (can be empty string, but will never be null).</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the item-spec is not a path.</exception>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsRootDirectory(System.String)">
            <summary>
            Indicates whether the given path is a UNC or drive pattern root directory.
            <para>Note: This function mimics the behavior of checking if Path.GetDirectoryName(path) == null.</para>
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.ThrowForUrl(System.String,System.String,System.String)">
            <summary>
            Temporary check for something like http://foo which will end up like c:\foo\bar\http://foo
            We should either have no colon, or exactly one colon.
            UNDONE: This is a minimal safe change for Dev10. The correct fix should be to make GetFullPath/NormalizePath throw for this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryDirectory(System.Boolean)">
            <summary>
            Generates a unique directory name in the temporary folder.  
            Caller must delete when finished. 
            </summary>
            <param name="createDirectory"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName(System.String)">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            File will NOT be created.
            May throw IOException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            If no extension is provided, uses ".tmp".
            File is guaranteed to be unique.
            Caller must delete it when finished.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile(System.String)">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            Caller must delete it when finished.
            May throw IOException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile(System.String,System.String,System.Boolean)">
            <summary>
            Creates a file with unique temporary file name with a given extension in the specified folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            If folder is null, the temporary folder will be used.
            Caller must delete it when finished.
            May throw IOException.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher">
            <summary>
            Functions for matching file names with patterns. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.s_invalidPathChars">
            <summary>
            Cache of the list of invalid path characters, because this method returns a clone (for security reasons)
            which can cause significant transient allocations
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.Default">
            <summary>
            The Default FileMatcher does not cache directory enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.FileSystemEntity">
            <summary>
            The type of entity that GetFileSystemEntries should return.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.GetFileSystemEntries">
            <summary>
            Delegate defines the GetFileSystemEntries signature that GetLongPathName uses
            to enumerate directories on the file system.
            </summary>
            <param name="entityType">Files, Directories, or Files and Directories</param>
            <param name="path">The path to search.</param>
            <param name="pattern">The file pattern.</param>
            <param name="projectDirectory"></param>
            <param name="stripProjectDirectory"></param>
            <returns>An immutable array of filesystem entries.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.HasWildcards(System.String)">
            <summary>
            Determines whether the given path has any wild card characters.
            </summary>
            <param name="filespec"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.HasWildcardsSemicolonItemOrPropertyReferences(System.String)">
            <summary>
            Determines whether the given path has any wild card characters or any semicolons.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFileSystemEntries(Microsoft.Build.Shared.FileSystem.IFileSystem,Microsoft.Build.Shared.FileMatcher.FileSystemEntity,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get the files and\or folders specified by the given path and pattern.
            </summary>
            <param name="entityType">Whether Files, Directories or both.</param>
            <param name="path">The path to search.</param>
            <param name="pattern">The pattern to search.</param>
            <param name="projectDirectory">The directory for the project within which the call is made</param>
            <param name="stripProjectDirectory">If true the project directory should be stripped</param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFilesAndDirectories(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String)">
            <summary>
            Returns an immutable array of file system entries matching the specified search criteria. Inaccessible or non-existent file
            system entries are skipped.
            </summary>
            <param name="path"></param>
            <param name="pattern"></param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>An immutable array of matching file system entries (can be empty).</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.ShouldEnforceMatching(System.String)">
            <summary>
            Determine if the given search pattern will match loosely on Windows
            </summary>
            <param name="searchPattern">The search pattern to check</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFiles(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Same as Directory.EnumerateFiles(...) except that files that
            aren't accessible are skipped instead of throwing an exception.
            
            Other exceptions are passed through.
            </summary>
            <param name="path">The path.</param>
            <param name="filespec">The pattern.</param>
            <param name="projectDirectory">The project directory</param>
            <param name="stripProjectDirectory"></param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>Files that can be accessed.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleDirectories(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String)">
            <summary>
            Same as Directory.EnumerateDirectories(...) except that files that
            aren't accessible are skipped instead of throwing an exception.
            
            Other exceptions are passed through.
            </summary>
            <param name="path">The path.</param>
            <param name="pattern">Pattern to match</param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>Accessible directories.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetLongPathName(System.String)">
            <summary>
            Given a path name, get its long version.
            </summary>
            <param name="path">The short path.</param>
            <returns>The long path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetLongPathName(System.String,Microsoft.Build.Shared.FileMatcher.GetFileSystemEntries)">
            <summary>
            Given a path name, get its long version.
            </summary>
            <param name="path">The short path.</param>
            <param name="getFileSystemEntries">Delegate.</param>
            <returns>The long path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.SplitFileSpec(System.String,System.String@,System.String@,System.String@)">
            <summary>
            Given a filespec, split it into left-most 'fixed' dir part, middle 'wildcard' dir part, and filename part.
            The filename part may have wildcard characters in it.
            </summary>
            <param name="filespec">The filespec to be decomposed.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.PreprocessFileSpecForSplitting(System.String,System.String@,System.String@,System.String@)">
            <summary>
            Do most of the grunt work of splitting the filespec into parts.
            Does not handle post-processing common to the different matching
            paths.
            </summary>
            <param name="filespec">The filespec to be decomposed.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RemoveInitialDotSlash(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Removes the leading ".\" from all of the paths in the array. 
            </summary>
            <param name="paths">Paths to remove .\ from.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsDirectorySeparator(System.Char)">
            <summary>
            Checks if the char is a DirectorySeparatorChar or a AltDirectorySeparatorChar
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RemoveProjectDirectory(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Removes the current directory converting the file back to relative path 
            </summary>
            <param name="paths">Paths to remove current directory from.</param>
            <param name="projectDirectory"></param>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.Filespec">
            <summary>
            The filespec.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.RegexFileMatch">
            <summary>
            Wild-card matching.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.NeedsRecursion">
            <summary>
            If true, then recursion is required.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.BaseDirectory">
            <summary>
            The directory to search in
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.RemainingWildcardDirectory">
            <summary>
            The remaining, wildcard part of the directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.SearchData">
            <summary>
            Data about a search that does not change as the search recursively traverses directories
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFilesRecursive(System.Collections.Concurrent.ConcurrentStack{System.Collections.Generic.List{System.String}},Microsoft.Build.Shared.FileMatcher.RecursionState,System.String,System.Boolean,System.Collections.Generic.IList{Microsoft.Build.Shared.FileMatcher.RecursionState},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.Build.Shared.FileMatcher.RecursionState}},Microsoft.Build.Shared.FileMatcher.TaskOptions)">
            <summary>
            Get all files that match either the file-spec or the regular expression. 
            </summary>
            <param name="listOfFiles">List of files that gets populated.</param>
            <param name="recursionState">Information about the search</param>
            <param name="projectDirectory"></param>
            <param name="stripProjectDirectory"></param>
            <param name="searchesToExclude">Patterns to exclude from the results</param>
            <param name="searchesToExcludeInSubdirs">exclude patterns that might activate farther down the directory tree. Keys assume paths are normalized with forward slashes and no trailing slashes</param>
            <param name="taskOptions">Options for tuning the parallelization of subdirectories</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RegularExpressionFromFileSpec(System.String,System.String,System.String,System.Boolean@)">
            <summary>
            Given a split file spec consisting of a directory without wildcard characters,
            a sub-directory containing wildcard characters,
            and a filename which may contain wildcard characters,
            create a regular expression that will match that file spec.
            
            PERF WARNING: this method is called in performance-critical
            scenarios, so keep it fast and cheap
            </summary>
            <param name="fixedDirectoryPart">The fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
            <param name="isLegalFileSpec">Receives whether this pattern is legal or not.</param>
            <returns>The regular expression string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsLegalFileSpec(System.String,System.String)">
            <summary>
            Determine if the filespec is legal according to the following conditions:
            
            (1) It is not legal for there to be a ".." after a wildcard.
            
            (2) By definition, "**" must appear alone between directory slashes.If there is any remaining "**" then this is not
                a valid filespec.
            </summary>
            <returns>True if both parts meet all conditions for a legal filespec.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromFixedDirectory(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the fixed directory part of a filespec:
            
             (1) The leading \\ in UNC paths, so that the doubled slash isn't reduced in the last step
             
             (2) Common filespec characters
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromWildcardDirectory(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the wildcard directory part of a filespec:
            
             (1) The leading **\ if existing
            
             (2) Each occurrence of recursive wildcard \**\
             
             (3) Common filespec characters
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromFilename(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the filename part of a filespec:
            
             (1) Trailing dots in file names have to be treated specially.
                 We want:
            
                     *. to match foo
            
                 but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful
                 not to match 'foo.txt' by modifying the generated regex for wildcard characters * and ?
             
             (2) Common filespec characters
            
             (3) Ignore the .* portion of any *.* sequence when no trailing dot exists
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromChar(Microsoft.Build.Shared.ReuseableStringBuilder,System.Char)">
            <summary>
            Append the regex equivalents for characters common to all filespec parts.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.LastIndexOfDirectorySequence(System.String,System.Int32)">
             <summary>
             Given an index at a directory separator,
             iteratively skip to the end of two sequences:
            
              (1) \.\ -> \
                 This is an identity, so for example, these two are equivalent,
            
                     dir1\.\dir2 == dir1\dir2
             
                 (2) \\ -> \
                     Double directory separators are treated as a single directory separator,
                     so, for example, this is an identity:
            
                         f:\dir1\\dir2 == f:\dir1\dir2
            
                     The single exemption is for UNC path names, like this:
            
                         \\server\share != \server\share
             
                     This case is handled by isUncPath in
                     a prior step.
            
             </summary>
             <returns>The last index of a directory sequence.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.LastIndexOfDirectoryOrRecursiveSequence(System.String,System.Int32)">
             <summary>
             Given an index at a directory separator or start of a recursive operator,
             iteratively skip to the end of three sequences:
             
             (1), (2) Both sequences handled by IndexOfNextNonCollapsibleChar
             
             (3) \**\**\ -> \**\
                          This is an identity, so for example, these two are equivalent,
            
                             dir1\**\**\ == dir1\**\
             </summary>
             <returns>]
             If starting at a recursive operator, the last index of a recursive sequence.
             Otherwise, the last index of a directory sequence.
             </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFileSpecInfoWithRegexObject(System.String,System.Text.RegularExpressions.Regex@,System.Boolean@,System.Boolean@)">
            <summary>
            Given a filespec, get the information needed for file matching. 
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="regexFileMatch">Receives the regular expression.</param>
            <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
            <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFileSpecInfo(System.String,System.String@,System.String@,System.String@,System.String@,System.Boolean@,System.Boolean@,Microsoft.Build.Shared.FileMatcher.FixupParts)">
            <summary>
            Given a filespec, parse it and construct the regular expression string.
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">Receives the wildcard directory part.</param>
            <param name="filenamePart">Receives the filename part.</param>
            <param name="matchFileExpression">Receives the regular expression.</param>
            <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
            <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
            <param name="fixupParts">hook method to further change the parts</param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.Result">
            <summary>
            The results of a match between a filespec and a file name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.Result.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsMatch(System.String,System.String,System.Boolean)">
            <summary>
            A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
            </summary>
            <param name="input">String which is matched against the pattern.</param>
            <param name="pattern">Pattern against which string is matched.</param>
            <param name="ignoreCase">Determines whether ignoring case when comparing two characters</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.FileMatch(System.String,System.String)">
            <summary>
            Given a pattern (filespec) and a candidate filename (fileToMatch)
            return matching information.
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="fileToMatch">The candidate to match against.</param>
            <returns>The result class.</returns>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.MaxTasks">
            <summary>
            The maximum number of tasks that are allowed to run concurrently
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.AvailableTasks">
            <summary>
            The number of currently available tasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.MaxTasksPerIteration">
            <summary>
            The maximum number of tasks that Parallel.ForEach may use
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFiles(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Given a filespec, find the files that match. 
            Will never throw IO exceptions: if there is no match, returns the input verbatim.
            </summary>
            <param name="projectDirectoryUnescaped">The project directory.</param>
            <param name="filespecUnescaped">Get files that match the given file spec.</param>
            <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
            <returns>The array of files.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.Normalize(System.String)">
            <summary>
            Replace all slashes to the OS slash, collapse multiple slashes into one, trim trailing slashes
            </summary>
            <param name="aString">A string</param>
            <returns>The normalized string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.SkipCharacters(System.String,System.Int32,System.Func{System.Char,System.Boolean})">
            <summary>
            Skips characters that satisfy the condition <param name="jumpOverCharacter"></param>
            </summary>
            <param name="aString">The working string</param>
            <param name="startingIndex">Offset in string to start the search in</param>
            <returns>First index that does not satisfy the condition. Returns the string's length if end of string is reached</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsValidDriveChar(System.Char)">
            <summary>
            Returns true if the given character is a valid drive letter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFilesImplementation(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Given a filespec, find the files that match. 
            Will never throw IO exceptions: if there is no match, returns the input verbatim.
            </summary>
            <param name="projectDirectoryUnescaped">The project directory.</param>
            <param name="filespecUnescaped">Get files that match the given file spec.</param>
            <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
            <returns>The array of files.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilitiesRegex">
            <summary>
            This class contains utility methods for file IO.
            Separate from FileUtilities because some assemblies may only need the patterns.
            PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
            each class get pulled into the resulting assembly.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsDrivePattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsDrivePatternWithSlash(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithDrivePattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithDrivePatternWithSlash(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsUncPattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithUncPattern(System.String)" -->
        <member name="M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithUncPatternMatchLength(System.String)">
            <summary>
            Indicates whether the file-spec begins with a UNC pattern and how long the match is. -1 indicates no match.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilitiesRegex.MeetsUncPatternMinimumRequirements(System.String)">
            <summary>
            Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
            UNC pattern requires a minimum length of 5 and first two characters must be a slash.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Shared.DotNetFrameworkArchitecture">
            <summary>
            Used to specify the targeted bitness of the .NET Framework for some methods of FrameworkLocationHelper
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.DotNetFrameworkArchitecture.Current">
            <summary>
            Indicates the .NET Framework that is currently being run under.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.DotNetFrameworkArchitecture.Bitness32">
            <summary>
            Indicates the 32-bit .NET Framework
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.DotNetFrameworkArchitecture.Bitness64">
            <summary>
            Indicates the 64-bit .NET Framework
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FrameworkLocationHelper">
            <summary>
            FrameworkLocationHelper provides utility methods for locating .NET Framework and .NET Framework SDK directories and files
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.ToolsVersionsRegistryPath">
            <summary>
            Path to the ToolsVersion definitions in the registry
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.programFiles">
            <summary>
            By default when a root path is not specified we would like to use the program files directory \ reference assemblies\framework as the root location
            to generate the reference assembly paths from.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.s_dotNetFrameworkSpecs">
            <summary>
            List the supported .net versions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.s_visualStudioSpecs">
            <summary>
            List the supported visual studio versions.
            </summary>
            <remarks>
            The items must be ordered by the version, because some methods depend on that fact to find the previous visual studio version.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools">
            <summary>
            Define explicit fallback rules for the request to get path of .net framework sdk tools folder.
            The default rule is fallback to previous VS. However, there are some special cases that need
            explicit rules, i.e. v4.5.1 on VS12 fallbacks to v4.5 on VS12.
            </summary>
            <remarks>
            The rules are maintained in a 2-dimensions array. Each row defines a rule. The first column
            defines the trigger condition. The second column defines the fallback .net and VS versions.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.FallbackDotNetFrameworkSdkInstallPath">
             <summary>
             Because there is no longer a strong 1:1 mapping between FX versions and SDK
             versions, if we're unable to locate the desired SDK version, we will try to 
             use whichever SDK version is installed by looking at the key pointing to the
             "latest" version.
            
             This isn't ideal, but it will allow our tasks to function on any of several 
             related SDKs even if they don't have exactly the same versions.
             
             NOTE:  This returns the path to the root of the fallback SDK
             </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.PathToV35ToolsInFallbackDotNetFrameworkSdk">
             <summary>
             Because there is no longer a strong 1:1 mapping between FX versions and SDK
             versions, if we're unable to locate the desired SDK version, we will try to 
             use whichever SDK version is installed by looking at the key pointing to the
             "latest" version.
            
             This isn't ideal, but it will allow our tasks to function on any of several 
             related SDKs even if they don't have exactly the same versions.
             
             NOTE:  This explicitly returns the path to the 3.5 tools (bin) under the fallback
             SDK, to match the data we're pulling from the registry now.  
             </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.PathToV4ToolsInFallbackDotNetFrameworkSdk">
             <summary>
             Because there is no longer a strong 1:1 mapping between FX versions and SDK
             versions, if we're unable to locate the desired SDK version, we will try to 
             use whichever SDK version is installed by looking at the key pointing to the
             "latest" version.
            
             This isn't ideal, but it will allow our tasks to function on any of several 
             related SDKs even if they don't have exactly the same versions.
             
             NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools) 
             under the fallback SDK, to match the data we're pulling from the registry now.  
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.CheckForFrameworkInstallation(System.String,System.String)">
            <summary>
            Check the registry key and value to see if the .net Framework is installed on the machine.
            </summary>
            <param name="registryEntryToCheckInstall">Registry path to look for the value</param>
            <param name="registryValueToCheckInstall">Key to retrieve the value from</param>
            <returns>True if the registry key is 1 false if it is not there. This method also return true if the complus enviornment variables are set.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.FindDotNetFrameworkPath(System.String,System.String,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Shared.GetDirectories,Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Heuristic that first considers the current runtime path and then searches the base of that path for the given
            frameworks version.
            </summary>
            <param name="currentRuntimePath">The path to the runtime that is currently executing.</param>
            <param name="prefix">Should be something like 'v1.2' that indicates the runtime version we want.</param>
            <param name="directoryExists">Function that checks if directory exists.</param>
            <param name="getDirectories">Delegate to method that can return filesystem entries.</param>
            <param name="architecture">.NET framework architecture</param>
            <returns>Will return 'null' if there is no target frameworks on this machine.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateProgramFiles32">
            <summary>
            Determine the 32 bit program files directory, this is used for finding where the reference assemblies live.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateProgramFiles64">
            <summary>
            Determine the 64-bit program files directory, used as the basis for MSBuildExtensionsPath64.
            Returns null if we're not on a 64-bit machine
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateProgramFilesReferenceAssemblyRoot">
            <summary>
            Generate the path to the program files reference assembly location by taking in the program files special folder and then 
            using that path to generate the path to the reference assemblies location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GeneratePathToBuildToolsForToolsVersion(System.String,Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion. 
            </summary>
            <param name="toolsVersion">The ToolsVersion to look up</param>
            <param name="architecture">Target build tools architecture.</param>
            <returns>The path to the build tools folder for that ToolsVersion, if it exists, or 
            null otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateReferenceAssemblyPath(System.String,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Take the parts of the Target framework moniker and formulate the reference assembly path based on the the following pattern:
            For a framework and version:
                $(TargetFrameworkRootPath)\$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)
            For a subtype:
                $(TargetFrameworkRootPath)\$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)\SubType\$(TargetFrameworkSubType)
            e.g.NET Framework v4.0 would locate its reference assemblies in:
                \Program Files\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0
            e.g.Silverlight v2.0 would locate its reference assemblies in:
                \Program Files\Reference Assemblies\Microsoft\Framework\Silverlight\v2.0
            e.g.NET Compact Framework v3.5, subtype PocketPC would locate its reference assemblies in:
                \Program Files\Reference Assemblies\Microsoft\Framework\.NETCompactFramework\v3.5\SubType\PocketPC
            </summary>
            <returns>The path to the reference assembly location</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.RemoveDirectories(System.String,System.Int32)">
            <summary>
            Given a path, subtracts the requested number of directories and returns the result.
            </summary>
            <comments>
            Internal only so that I can have the unit tests use it too, instead of duplicating the same code
            </comments>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GetPathToBuildToolsFromEnvironment(Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GetPathToBuildToolsFromRegistry(System.String,Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateReferenceAssemblyDirectory(System.String)">
            <summary>
            Will return the path to the dot net framework reference assemblies if they exist under the program files\reference assembies\microsoft\framework directory
            or null if the directory does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.FindRegistryValueUnderKey(System.String,System.String,Microsoft.Win32.RegistryView)">
            <summary>
            Look for the given registry value under the given key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.CreateDotNetFrameworkSpecForV4(System.Version,System.Version)">
            <summary>
            Helper method to create an instance of <see cref="T:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec"/> for .net v4.x,
            because most of attributes are the same for v4.x versions.
            </summary>
            <param name="version">.net framework version.</param>
            <param name="visualStudioVersion">Version of Visual Studio</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec._dotNetFrameworkSdkRegistryKey">
            <summary>
            The key in registry to indicate the corresponding .net framework in this visual studio.
            i.e. 'v8.0A' for VS11.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.Version">
            <summary>
            The version of this visual studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.SupportedDotNetFrameworkVersions">
            <summary>
            The list of supported .net framework versions in this visual studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.WindowsSdkRegistryKey">
            <summary>
            The key in registry to indicate the corresponding windows sdk, i.e. "v8.0" for VS11.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.WindowsSdkRegistryInstallationFolderName">
            <summary>
            The name in registry to indicate the sdk installation folder path, i.e. "InstallationFolder" for windows v8.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.GetDotNetFrameworkSdkRegistryKey(System.Version)">
            <summary>
            The key in the registry to indicate the corresponding .net framework in this visual studio.
            i.e. 'v8.0A' for VS11.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._dotNetFrameworkRegistryKey">
            <summary>
            The registry key of this .net framework, i.e. "SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" for .net v4.5.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._dotNetFrameworkSetupRegistryInstalledName">
            <summary>
            The name in registry to indicate that this .net framework is installed, i.e. "Install" for .net v4.5.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._dotNetFrameworkSdkRegistryToolsKey">
            <summary>
            The key in registry to indicate the sdk tools folder, i.e. "WinSDK-NetFx40Tools-x86" for .net v4.5.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._visualStudioVersion">
            <summary>
            The version of visual studio that shipped with this .net framework.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._hasMsBuild">
            <summary>
            Does this .net framework include MSBuild?
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathsToDotNetFramework">
            <summary>
            Cached paths of .net framework on different architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathsToDotNetFrameworkSdkTools">
            <summary>
            Cached paths of .net framework sdk tools folder path on different visual studio version.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathToWindowsSdk">
            <summary>
            Cached path of the corresponding windows sdk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Cached path of .net framework reference assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.Version">
            <summary>
            The version of this .net framework.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.DotNetFrameworkSdkRegistryInstallationFolderName">
            <summary>
            The name in registry to indicate the sdk installation folder path, i.e. "InstallationFolder" for .net v4.5.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.DotNetFrameworkFolderPrefix">
            <summary>
            Folder prefix, i.e. v4.0 for .net v4.5.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.FrameworkName">
            <summary>
            Get the FrameworkName for this version of the .NET Framework.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full registry key of this .net framework Sdk for the given visual studio version.
            i.e. "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx40Tools-x86" for .net v4.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFramework(Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Gets the full path of .net framework for the given architecture.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFrameworkSdkTools(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk tools for the given visual studio version.
            i.e. "C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0A\bin\NETFX 4.0 Tools\" for .net v4.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFrameworkSdk(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk.
            i.e. "C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0A\" for .net v4.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Gets the full path of reference assemblies folder.
            i.e. "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5\" for .net v4.5.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToWindowsSdk">
            <summary>
            Gets the full path of the corresponding windows sdk shipped with this .net framework.
            i.e. "C:\Program Files (x86)\Windows Kits\8.0\" for v8.0 (shipped with .net v4.5 and VS11).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy">
            <summary>
            Specialized implementation for legacy .net framework v1.1 and v2.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full registry key of this .net framework Sdk for the given visual studio version.
            i.e. "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework" for v1.1 and v2.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetPathToDotNetFrameworkSdkTools(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk tools for the given visual studio version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetPathToDotNetFrameworkSdk(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk, which is the full path of .net framework sdk tools for v1.1 and v2.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetPathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Gets the full path of reference assemblies folder, which is the full path of .net framework for v1.1 and v2.0.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecV3">
            <summary>
            Specialized implementation for legacy .net framework v3.0 and v3.5.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecV3.GetPathToDotNetFrameworkSdk(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk.
            i.e. "C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\" for .net v3.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecV3.GetPathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Gets the full path of reference assemblies folder.
            i.e. "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\v3.5\" for v3.5.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.InternalErrorException">
            <summary>
            This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
            exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
            did wrong.
            
            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
            WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
                     Don't throw this exception from one assembly and catch it in another.
            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
                
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor">
            <summary>
            Default constructor.
            SHOULD ONLY BE CALLED BY DESERIALIZER. 
            SUPPLY A MESSAGE INSTEAD.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.String)">
            <summary>
            Creates an instance of this exception using the given message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using the given message and inner exception.
            Adds the inner exception's details to the exception message because most bug reporters don't bother
            to provide the inner exception details which is typically what we care about.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor used for (de)serialization. The constructor is private as this class is sealed
            If we ever add new members to this class, we'll need to update this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.ConsiderDebuggerLaunch(System.String,System.Exception)">
            <summary>
            A fatal internal error due to a bug has occurred. Give the dev a chance to debug it, if possible.
            
            Will in all cases launch the debugger, if the environment variable "MSBUILDLAUNCHDEBUGGER" is set.
            
            In DEBUG build, will always launch the debugger, unless we are in razzle (_NTROOT is set) or in NUnit,
            or MSBUILDDONOTLAUNCHDEBUGGER is set (that could be useful in suite runs).
            We don't launch in retail or LKG so builds don't jam; they get a callstack, and continue or send a mail, etc.
            We don't launch in NUnit as tests often intentionally cause InternalErrorExceptions.
            
            Because we only call this method from this class, just before throwing an InternalErrorException, there is 
            no danger that this suppression will cause a bug to only manifest itself outside NUnit
            (which would be most unfortunate!). Do not make this non-private.
            
            Unfortunately NUnit can't handle unhandled exceptions like InternalErrorException on anything other than
            the main test thread. However, there's still a callstack displayed before it quits.
            
            If it is going to launch the debugger, it first does a Debug.Fail to give information about what needs to
            be debugged -- the exception hasn't been thrown yet. This automatically displays the current callstack.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared">
            <summary>
            Interop methods.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MAX_PATH">
            <summary>
            Default buffer size to use when dealing with the Windows API.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS">
            <summary>
            Flags for CoWaitForMultipleHandles
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_NONE">
            <summary>
            Exit when a handle is signaled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_WAITALL">
            <summary>
            Exit when all handles are signaled AND a message is received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_ALERTABLE">
            <summary>
            Exit when an RPC call is serviced.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitectures">
            <summary>
            Processor architecture values
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SYSTEM_INFO">
            <summary>
            Structure that contain information about the system on which we are running
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SafeProcessHandle">
            <summary>
            Wrap the intptr returned by OpenProcess in a safe handle.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus">
            <summary>
            Contains information about the current state of both physical and virtual memory, including extended memory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus._length">
            <summary>
            Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.MemoryLoad">
            <summary>
            Number between 0 and 100 that specifies the approximate percentage of physical
            memory that is in use (0 indicates no memory use and 100 indicates full memory use).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalPhysical">
            <summary>
            Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailablePhysical">
            <summary>
            Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalPageFile">
            <summary>
            Size of the committed memory limit, in bytes. This is physical memory plus the
            size of the page file, minus a small overhead.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailablePageFile">
            <summary>
            Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalVirtual">
            <summary>
            Total size of the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailableVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the user mode portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailableExtendedVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the extended portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA">
            <summary>
            Contains information about a file or directory; used by GetFileAttributesEx.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SecurityAttributes">
            <summary>
            Contains the security descriptor for an object and specifies whether
            the handle retrieved by specifying this structure is inheritable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ProcessorArchitectureType">
            <summary>
            Architecture as far as the current process is concerned.
            It's x86 in wow64 (native architecture is x64 in that case).
            Otherwise it's the same as the native architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ProcessorArchitectureTypeNative">
            <summary>
            Actual architecture of the system.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ConvertSystemArchitecture(System.UInt16)">
            <summary>
            Convert SYSTEM_INFO architecture values to the internal enum
            </summary>
            <param name="arch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.#ctor">
            <summary>
            Read system info values
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.MaxPath">
            <summary>
            Gets the max path limit of the current OS.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared._maxPath">
            <summary>
            Cached value for MaxPath.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_isUnixLike">
            <summary>
            Cached value for IsUnixLike (this method is called frequently during evaluation).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsUnixLike">
            <summary>
            Gets a flag indicating if we are running under a Unix-like system (Mac, Linux, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsLinux">
            <summary>
            Gets a flag indicating if we are running under Linux
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsBSD">
            <summary>
            Gets a flag indicating if we are running under flavor of BSD (NetBSD, OpenBSD, FreeBSD)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsMono">
            <summary>
            Gets a flag indicating if we are running under MONO
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsWindows">
            <summary>
            Gets a flag indicating if we are running under some version of Windows
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsOSX">
            <summary>
            Gets a flag indicating if we are running under Mac OSX
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.OSName">
            <summary>
            Gets a string for the current OS. This matches the OS env variable
            for Windows (Windows_NT).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetOSNameForExtensionsPath">
            <summary>
            OS name that can be used for the msbuildExtensionsPathSearchPaths element
            for a toolset
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_frameworkBasePath">
            <summary>
            The base directory for all framework paths in Mono
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_frameworkCurrentPath">
            <summary>
            The directory of the current framework
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.FrameworkCurrentPath">
            <summary>
            Gets the currently running framework path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.FrameworkBasePath">
            <summary>
            Gets the base directory of all Mono frameworks
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.SystemInformation">
            <summary>
            System information, initialized when required.
            </summary>
            <remarks>
            Initially implemented as <see cref="T:System.Lazy`1"/>, but
            that's .NET 4+, and this is used in MSBuildTaskHost.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitecture">
            <summary>
            Architecture getter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitectureNative">
            <summary>
            Native architecture getter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.WaitForMultipleObjects(System.UInt32,System.IntPtr[],System.Boolean,System.UInt32)">
            <summary>
            Really truly non pumping wait.
            Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
            single SafeHandles.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLastWriteDirectoryUtcTime(System.String,System.DateTime@)">
            <summary>
            Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
            if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetShortFilePath(System.String)">
            <summary>
            Takes the path and returns the short path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLongFilePath(System.String)">
            <summary>
            Takes the path and returns a full path
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetMemoryStatus">
            <summary>
            Retrieves the current global memory status.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLastWriteFileUtcTime(System.String)">
            <summary>
            Get the last write time of the fullpath to the file.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
            <remarks>
            This method should be accurate for regular files and symlinks, but can report incorrect data
            if the file's content was modified by writing to it through a different link, unless
            MSBUILDALWAYSCHECKCONTENTTIMESTAMP=1.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetContentLastWriteFileUtcTime(System.String)">
            <summary>
            Get the last write time of the content pointed to by a file path.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
            <remarks>
            This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
            See https://github.com/Microsoft/msbuild/issues/2052.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.HResultSucceeded(System.Int32)">
            <summary>
            Did the HRESULT succeed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.HResultFailed(System.Int32)">
            <summary>
            Did the HRESULT Fail
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.ThrowExceptionForErrorCode(System.Int32)">
            <summary>
            Given an error code, converts it to an HRESULT and throws the appropriate exception.
            </summary>
            <param name="errorCode"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.KillTree(System.Int32)">
            <summary>
            Kills the specified process by id and all of its children recursively.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetParentProcessId(System.Int32)">
            <summary>
            Returns the parent process id for the specified process.
            Returns zero if it cannot be gotten for some reason.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetChildProcessIds(System.Int32,System.DateTime)">
            <summary>
            Returns an array of all the immediate child processes by id.
            NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetCurrentDirectory">
            <summary>
            Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.AreStringsEqual(System.Char*,System.Int32,System.String)">
            <summary>
            Compare an unsafe char buffer with a <see cref="T:System.String"/> to see if their contents are identical.
            </summary>
            <param name="buffer">The beginning of the char buffer.</param>
            <param name="len">The length of the buffer.</param>
            <param name="s">The string.</param>
            <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetOEMCP">
            <summary>
            Gets the current OEM code page which is used by console apps
            (as opposed to the Windows/ANSI code page)
            Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
            that needs to be used for instance when writing to batch files
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetModuleFileName(System.Runtime.InteropServices.HandleRef,System.Text.StringBuilder,System.Int32)">
            <summary>
            Gets the fully qualified filename of the currently executing .exe
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.CoWaitForMultipleHandles(Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS,System.Int32,System.Int32,System.IntPtr[],System.Int32@)">
            <summary>
            CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
            VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
            build thread which the main thread (blocked on BuildSubmission.Execute) must service.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle,System.TimeSpan)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle,System.Int32)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyUtilities">
            <summary>
            This class contains common reflection tasks
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.OpenBaseKey">
            <summary>
            Given a registry hive and a request view open the base key for that registry location.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.GetRegistrySubKeyNames">
            <summary>
            Simplified registry access delegate. Given a baseKey and a subKey, get all of the subkey
            names.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subKey">The subkey</param>
            <returns>An enumeration of strings.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue">
            <summary>
            Simplified registry access delegate. Given a baseKey and subKey, get the default value
            of the subKey.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subKey">The subkey</param>
            <returns>A string containing the default value.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.RegistryHelper">
            <summary>
            Helper methods that simplify registry access.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.RegistryHelper.GetSubKeyNames(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Given a baseKey and a subKey, get all of the subkeys names.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subkey">The subkey</param>
            <returns>An enumeration of strings.</returns>        
        </member>
        <member name="M:Microsoft.Build.Shared.RegistryHelper.GetDefaultValue(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Given a baseKey and subKey, get the default value of the subKey.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subkey">The subkey</param>
            <returns>A string containing the default value.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.RegistryHelper.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)">
            <summary>
            Given a hive and a hive view open the base key
                 RegistryKey baseKey = RegistryKey.OpenBaseKey(hive, view);
            </summary>
            <param name="hive">The hive.</param>
            <param name="view">The hive view</param>
            <returns>A registry Key for the given baseKey and view</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.ResourceUtilities">
            <summary>
            This class contains utility methods for dealing with resources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.ExtractMessageCode(System.Boolean,System.String,System.String@)">
            <summary>
            Extracts the message code (if any) prefixed to the given string. 
            <![CDATA[
            MSBuild codes match "^\s*(?<CODE>MSB\d\d\d\d):\s*(?<MESSAGE>.*)$"
            Arbitrary codes match "^\s*(?<CODE>[A-Za-z]+\d+):\s*(?<MESSAGE>.*)$"
            ]]>
            Thread safe.
            </summary>
            <param name="msbuildCodeOnly">Whether to match only MSBuild error codes, or any error code.</param>
            <param name="message">The string to parse.</param>
            <param name="code">[out] The message code, or null if there was no code.</param>
            <returns>The string without its message code prefix, if any.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.GetHelpKeyword(System.String)">
            <summary>
            Retrieves the MSBuild F1-help keyword for the given resource string. Help keywords are used to index help topics in
            host IDEs.
            </summary>
            <param name="resourceName">Resource string to get the MSBuild F1-keyword for.</param>
            <returns>The MSBuild F1-help keyword string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.GetResourceString(System.String)">
            <summary>
            Retrieves the contents of the named resource string.
            </summary>
            <param name="resourceName">Resource string name.</param>
            <returns>Resource string contents.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringStripCodeAndKeyword(System.String@,System.String@,System.String,System.Object[])">
            <summary>
            Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
            message code and help keyword associated with it, they too are returned.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="code">[out] The MSBuild message code, or null.</param>
            <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
            <param name="resourceName">Resource string to load.</param>
            <param name="args">Optional arguments for formatting the resource string.</param>
            <returns>The formatted resource string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringStripCodeAndKeyword(System.String,System.Object[])">
            <summary>
            Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
            message code and help keyword associated with it, they are discarded.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="resourceName">Resource string to load.</param>
            <param name="args">Optional arguments for formatting the resource string.</param>
            <returns>The formatted resource string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(System.String,System.Object[])">
            <summary>
            Formats the resource string with the given arguments.
            Ignores error codes and keywords
            </summary>
            <param name="resourceName"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatString(System.String,System.Object[])">
            <summary>
            Formats the given string using the variable arguments passed in.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            
            Thread safe.
            </summary>
            <param name="unformatted">The string to format.</param>
            <param name="args">Optional arguments for formatting the given string.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.VerifyResourceStringExists(System.String)">
            <summary>
            Verifies that a particular resource string actually exists in the string table. This will only be called in debug
            builds. It helps catch situations where a dev calls VerifyThrowXXX with a new resource string, but forgets to add the
            resource string to the string table, or misspells it!
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="resourceName">Resource string to check.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.ReuseableStringBuilder">
            <summary>
            A StringBuilder lookalike that reuses its internal storage.
            </summary>
            <remarks>
            You can add any properties or methods on the real StringBuilder that are needed.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._borrowedBuilder">
            <summary>
            Captured string builder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._cachedString">
            <summary>
            Profiling showed that the hot code path for large string builder calls first IsOrdinalEqualToStringOfSameLength followed by ExpensiveConvertToString
            when IsOrdinalEqualToStringOfSameLength did return true. We can therefore reduce the costs for large strings by over a factor two. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._capacity">
            <summary>
            Capacity to initialize the builder with.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.#ctor(System.Int32)">
            <summary>
            Create a new builder, under the covers wrapping a reused one.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ReuseableStringBuilder.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.MaxByCharCompareLength">
            <summary>
            The number here is arbitrary. For a StringBuilder we have a chunk length of 8000 characters which corresponds to
            5 StringBuilder chunks which need to be walked before the next character can be fetched (see MaxChunkSize of StringBuilder).
            That should be a good compromise to not allocate to much but still make use of the intern cache. The actual cutoff where it is cheaper
            to allocate a temp string might be well below that limit but that depends on many other factors such as GC Heap size and other allocating threads. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#ReferenceEquals(System.String)">
            <summary>
            Never reference equals to string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ToString">
            <summary>
            Convert to a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.System#IDisposable#Dispose">
            <summary>
            Dispose, indicating you are done with this builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.Char)">
            <summary>
            Append a character.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.String)">
            <summary>
            Append a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.String,System.Int32,System.Int32)">
            <summary>
            Append a substring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a substring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.LazyPrepare">
            <summary>
            Grab a backing builder if necessary.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory">
            <summary>
            A utility class that mediates access to a shared string builder.
            </summary>
            <remarks>
            If this shared builder is highly contended, this class could add
            a second one and try both in turn.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.MaxBuilderSize">
            <summary>
            Made up limit beyond which we won't share the builder
            because we could otherwise hold a huge builder indefinitely.
            This size seems reasonable for MSBuild uses (mostly expression expansion)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.s_sharedBuilder">
            <summary>
            The shared builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.Get(System.Int32)">
            <summary>
            Obtains a string builder which may or may not already
            have been used. 
            Never returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.Release(System.Text.StringBuilder)">
            <summary>
            Returns the shared builder for the next caller to use.
            ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.VersionUtilities">
            <summary>
            Set of methods to deal with versions in the tasks
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.ConvertToVersion(System.String)">
            <summary>
            Convert a version number like 0.0.0.0 to a Version instance.
            The method will return null if the string is not a valid value
            </summary>
            <param name="version">Version string to convert to a version object</param>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.GatherVersionStrings(System.Version,System.Collections.IEnumerable)">
            <summary>
            Go though an enumeration and create a sorted list of strings which can be parsed as versions. Keep around the original 
            string because it may contain a v and this would be required to create the correct path on disk if the string was part of a path.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.ConvertToVersion(System.String,System.Boolean)">
            <summary>
             Convert a version number like 0.0.0.0 to a Version instance.
            </summary>
            <param name="version"></param>
            <param name="throwException">Should we use Parse to TryParse (parse means we throw an exception, tryparse means we will not).</param>
        </member>
        <member name="F:Microsoft.Build.Shared.ReverseStringGenericComparer.Comparer">
            <summary>
            Static accessor for a ReverseVersionGenericComparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReverseStringGenericComparer.System#Collections#Generic#IComparer{System#String}#Compare(System.String,System.String)">
            <summary>
            The Compare implements a reverse comparison
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReverseVersionGenericComparer.Comparer">
            <summary>
            Static accessor for a ReverseVersionGenericComparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReverseVersionGenericComparer.System#Collections#Generic#IComparer{System#Version}#Compare(System.Version,System.Version)">
            <summary>
            The Compare implements a reverse comparison
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioLocationHelper">
            <summary>
            Helper class to wrap the Microsoft.VisualStudio.Setup.Configuration.Interop API to query
            Visual Studio setup for instances installed on the machine.
            Code derived from sample: https://code.msdn.microsoft.com/Visual-Studio-Setup-0cedd331
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VisualStudioLocationHelper.GetInstances">
            <summary>
            Query the Visual Studio setup API to get instances of Visual Studio installed
            on the machine. Will not include anything before Visual Studio "15".
            </summary>
            <returns>Enumerable list of Visual Studio instances</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioInstance">
            <summary>
            Wrapper class to represent an installed instance of Visual Studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Version">
            <summary>
            Version of the Visual Studio Instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Path">
            <summary>
            Path to the Visual Studio installation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Name">
            <summary>
            Full name of the Visual Studio instance with SKU name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig._directoryNames">
            <summary>
            The list of directory names found from the config file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig.#ctor(System.String,System.String,System.Reflection.ProcessorArchitecture)">
            <summary>
            Construct.
            </summary>
            <param name="configFile">The path to the config file.</param>
            <param name="targetRuntimeVersion">The runtime version property from the project file.</param>
            <param name="targetArchitecture">The <see cref="T:System.Reflection.ProcessorArchitecture"/> to target.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig.System#Collections#Generic#IEnumerable{Microsoft#Build#Utilities#AssemblyFoldersFromConfigInfo}#GetEnumerator">
            <summary>
            Get Enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnWriteDictionary`2">
             <summary>
             A dictionary that has copy-on-write semantics.
             KEYS AND VALUES MUST BE IMMUTABLE OR COPY-ON-WRITE FOR THIS TO WORK.
             </summary>
             <typeparam name="K">The key type.</typeparam>
             <typeparam name="V">The value type.</typeparam>
             <remarks>
             This dictionary works by having a backing dictionary which is ref-counted for each
             COWDictionary which references it.  When a write operation is performed on any
             COWDictionary, we check the reference count on the backing dictionary.  If it is 
             greater than 1, it means any changes we make to it would be visible to other readers.
             Therefore, we clone the backing dictionary and decrement the reference count on the
             original.  From there on we use the cloned dictionary, which now has a reference count
             of 1.
            
             Thread safety: for all users, this class is as thread safe as the underlying Dictionary implementation, that is,
             safe for concurrent readers or one writer from EACH user. It achieves this by locking itself and cloning before
             any write, if it is being shared - i.e., stopping sharing before any writes occur.
             </remarks>
             <comment>
             This class must be serializable as it is used for metadata passed to tasks, which may
             be run in a separate appdomain.
             </comment>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.capacity">
            <summary>
            The default capacity.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.backing">
            <summary>
            The backing dictionary.
            Lazily created.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor">
            <summary>
            Constructor. Consider supplying a comparer instead.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Int32)">
            <summary>
            Constructor taking an initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys and an initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor, for crossing appdomain boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1})">
            <summary>
            Cloning constructor. Defers the actual clone.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Keys">
            <summary>
            Returns the collection of keys in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Values">
            <summary>
            Returns the collection of values in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Count">
            <summary>
            Returns the number of items in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.IsReadOnly">
            <summary>
            Returns true if the collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#Count">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Dummy">
            <summary>
            A special single dummy instance that always appears empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.IsDummy">
            <summary>
            Whether this is a dummy instance that always appears empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Comparer">
            <summary>
            Comparer used for keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.ReadOperation">
            <summary>
            Gets the backing dictionary for reading.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.WriteOperation">
            <summary>
            Gets the backing dictionary for writing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Item(`0)">
            <summary>
            Accesses the value for the specified key.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Add(`0,`1)">
            <summary>
            Adds a value to the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if the dictionary contains the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Remove(`0)">
            <summary>
            Removes the entry for the specified key from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to find the value for the specified key in the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item to the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Returns true ff the collection contains the specified item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies all of the elements of the collection to the specified array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Remove an item from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.GetEnumerator">
            <summary>
            Implementation of generic IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Clear">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Clone">
            <summary>
            Clone, with the actual clone deferred
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.HasSameBacking(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1})">
            <summary>
            Returns true if these dictionaries have the same backing.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2">
            <summary>
            A dictionary which is reference counted to allow several references for read operations, but knows when to clone for
            write operations.
            </summary>
            <typeparam name="K1">The key type.</typeparam>
            <typeparam name="V1">The value type.</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.s_readOnlyEmptyDictionary">
            <summary>
            An empty dictionary 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2._refCount">
            <summary>
            The reference count. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`2})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor, for crossing appdomain boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor">
            <summary>
            Empty constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1}.CopyOnWriteBackingDictionary{`2,`3})">
            <summary>
            Cloning constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.ReadOnlyEmptyInstance">
            <summary>
            Returns a read-only empty instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.HasNoClones">
            <summary>
            Returns true if this collection has no clones.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.CloneForWriteIfNecessary">
            <summary>
            Clones backing dictionary if necessary for a write operation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.AddRef">
            <summary>
            Adds a reader-reference to this backing dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization does not call any constructors, not even
            the parameterless constructor. Therefore since we do not serialize
            this field, we must populate it here.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.IConstrainedEqualityComparer`1">
            <summary>
                Defines methods to support the comparison of objects for
                equality over constrained inputs.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.IConstrainedEqualityComparer`1.Equals(`0,`0,System.Int32,System.Int32)">
            <summary>
            Determines whether the specified objects are equal, factoring in the specified bounds when comparing <paramref name="y"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.IConstrainedEqualityComparer`1.GetHashCode(`0,System.Int32,System.Int32)">
            <summary>
            Returns a hash code for the specified object factoring in the specified bounds.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.IKeyed">
            <summary>
            Interface allowing items and metadata and properties to go into keyed collections
            </summary>
            <remarks>
            This can be internal as it is a constraint only on internal collections.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Collections.IKeyed.Key">
            <summary>
            Returns some value useful for a key in a dictionary
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer">
            <summary>
            This is a custom string comparer that has three advantages over the regular
            string comparer:
            1) It can generate hash codes and perform equivalence operations on parts of a string rather than a whole
            2) It uses "unsafe" pointers to maximize performance of those operations
            3) It takes advantage of limitations on MSBuild Property/Item names to cheaply do case insensitive comparison.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.s_runningProcessorArchitecture">
            <summary>
            The processor architecture on which we are running, but default it will be x86
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.#cctor">
            <summary>
            We need a static constructor to retrieve the running ProcessorArchitecture that way we can
            avoid using optimized code that will not run correctly on IA64 due to alignment issues
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.Default">
            <summary>
            The default immutable comparer instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.Equals(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Performs the "Equals" operation on two MSBuild property, item or metadata names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.GetHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Getting a case insensitive hash code for the msbuild property, item or metadata name
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1">
            <summary>
            A read-only wrapper over an empty collection.
            </summary>
            <remarks>
            Thus this is an omission from the BCL.
            </remarks>
            <typeparam name="T">Type of element in the collection</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.s_instance">
            <summary>
            Backing live collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.#ctor">
            <summary>
            Private default constructor as this is a singleton
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Instance">
            <summary>
            Get the instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Count">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.IsReadOnly">
            <summary>
            Returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Whether collection is synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Sync root
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Add(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Contains(`0)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.GetEnumerator">
            <summary>
            Get an enumerator over an empty collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator over an empty collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            ICollection version of CopyTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2">
            <summary>
            A special singleton enumerable that enumerates a read-only empty dictionary
            </summary>
            <typeparam name="K">Key</typeparam>
            <typeparam name="V">Value</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.s_backing">
            <summary>
            The single instance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.s_instance">
            <summary>
            The single instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.#ctor">
            <summary>
            Private default constructor as this is a singleton
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Instance">
            <summary>
            Get the instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Count">
            <summary>
            Empty returns zero
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsReadOnly">
            <summary>
            Returns true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Keys">
            <summary>
            Gets empty collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Values">
            <summary>
            Gets empty collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsFixedSize">
            <summary>
            Is it fixed size
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsSynchronized">
            <summary>
            Not synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.SyncRoot">
            <summary>
            No sync root
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Values
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Item(System.Object)">
            <summary>
            Indexer
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Item(`0)">
            <summary>
            Get returns null as read-only
            Set is prohibited and throws.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(`0,`1)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.ContainsKey(`0)">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Empty does nothing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.GetEnumerator">
            <summary>
            Get empty enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get empty enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(System.Object,System.Object)">
            <summary>
            Add
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Contains(System.Object)">
            <summary>
            Contains
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(System.Object)">
            <summary>
            Remove
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.CopyTo(System.Array,System.Int32)">
            <summary>
            CopyTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern">
             <summary>
             This class is used to selectively intern strings. It should be used at the point of new string creation.
             For example,
            
                 string interned = OpportunisticIntern.Intern(String.Join(",",someStrings));
            
             This class uses heuristics to decide whether it will be efficient to intern a string or not. There is no
             guarantee that a string will intern.
            
             The thresholds and sizes were determined by experimentation to give the best number of bytes saved
             at reasonable elapsed time cost.
             </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_smallMruSize">
            <summary>
            The size of the small mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_largeMruSize">
            <summary>
            The size of the large mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_hugeMruSize">
            <summary>
            The size of the huge mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_smallMruThreshold">
            <summary>
            The smallest size a string can be to be considered small.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_largeMruThreshold">
            <summary>
            The smallest size a string can be to be considered large.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_hugeMruThreshold">
            <summary>
            The smallest size a string can be to be considered huge.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_ginormousThreshold">
            <summary>
            The smallest size a string can be to be ginormous.
            8K for large object heap.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_si">
            <summary>
            Manages the separate MRU lists.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfInfinite">
            <summary>
            What if Mru lists were infinitely long?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfDoubled">
            <summary>
            What if we doubled the size of the Mru lists?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfHalved">
            <summary>
            What if we halved the size of the Mru lists?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfZero">
            <summary>
            What if the size of Mru lists was zero? (We still intern tiny strings in this case)
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.IInternable">
            <summary>
            Define the methods needed to intern something.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.IInternable.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.IInternable.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.ReferenceEquals(System.String)">
            <summary>
            Reference compare target to string. If target is non-string this should return false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.AssignViaEnvironment(System.String,System.Int32)">
            <summary>
            Assign an int from an environment variable. If its not present, use the default.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.EnableStatisticsGathering">
            <summary>
            Turn on statistics gathering.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.InternableToString(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Intern the given internable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderToString(System.Text.StringBuilder)">
            <summary>
            Potentially Intern the given string builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayToString(System.Char[],System.Int32)">
            <summary>
            Potentially Intern the given char array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayToString(System.Char[],System.Int32,System.Int32)">
            <summary>
            Potentially Intern the given char array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.InternStringIfPossible(System.String)">
            <summary>
            Potentially Intern the given string.
            </summary>
            <param name="candidate">The string to intern.</param>
            <returns>The interned string, or the same string if it could not be interned.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.ReportStatistics">
            <summary>
            Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget">
            <summary>
            A wrapper over StringBuilder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget._target">
            <summary>
            The held StringBuilder
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.#ctor(System.Text.StringBuilder)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ReferenceEquals(System.String)">
            <summary>
            Never reference equals to string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ToString">
            <summary>
            Don't use this function. Use ExpensiveConvertToString
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget">
            <summary>
            A wrapper over char[].
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget._startIndex">
            <summary>
            Start index for the string
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget._target">
            <summary>
            The held array
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.#ctor(System.Char[],System.Int32)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ReferenceEquals(System.String)">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ToString">
            <summary>
            Don't use this function. Use ExpensiveConvertToString
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.StringInternTarget">
            <summary>
            Wrapper over a string.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.StringInternTarget._target">
            <summary>
            Stores the wrapped string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.#ctor(System.String)">
            <summary>
            Constructor of the class
            </summary>
            <param name="target">The string to wrap</param>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringInternTarget.Length">
            <summary>
            Gets the length of the target string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringInternTarget.Item(System.Int32)">
            <summary>
            Gets the n character in the target string.
            </summary>
            <param name="index">Index of the character to gather.</param>
            <returns>The character in the position marked by index.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.ExpensiveConvertToString">
            <summary>
            Returns the target which is already a string.
            </summary>
            <returns>The target string.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare if the target string is equal to the given string.
            </summary>
            <param name="other">The string to compare with the target.</param>
            <returns>True if the strings are equal, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.ReferenceEquals(System.String)">
            <summary>
            Verifies if the reference of the target string is the same of the given string.
            </summary>
            <param name="other">The string reference to compare to.</param>
            <returns>True if both references are equal, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList">
            <summary>
            Manages a set of mru lists that hold strings in varying size ranges.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._smallMru">
            <summary>
            The small string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._largeMru">
            <summary>
            The large string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._hugeMru">
            <summary>
            The huge string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormous">
            <summary>
            Three most recently used strings over 8K.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._smallMruThreshold">
            <summary>
            The smallest size a string can be to be considered small.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._largeMruThreshold">
            <summary>
            The smallest size a string can be to be considered large.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._hugeMruThreshold">
            <summary>
            The smallest size a string can be to be considered huge.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousThreshold">
            <summary>
            The smallest size a string can be to be ginormous.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._gatherStatistics">
            <summary>
            Whether or not to gather statistics
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internHits">
            <summary>
            Number of times interning worked.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internMisses">
            <summary>
            Number of times interning didn't work.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internRejects">
            <summary>
            Number of times interning wasn't attempted.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internEliminatedStrings">
            <summary>
            Total number of strings eliminated by interning.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internEliminatedChars">
            <summary>
            Total number of chars eliminated across all strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousHits">
            <summary>
            Number of times the ginourmous string hit.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousMisses">
            <summary>
            Number of times the ginourmous string missed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousCharsSaved">
            <summary>
            Chars interned for ginormous range.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._dontTrack">
            <summary>
            Whether or not to track ginormous strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._stopwatch">
            <summary>
            The time spent interning.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._missedStrings">
            <summary>
            Strings which did not intern
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._rejectedStrings">
            <summary>
            Strings which we didn't attempt to intern
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.GinormousSize">
            <summary>
            Number of ginormous strings to keep
            By observation of Auto7, there are about three variations of the huge solution config blob
            There aren't really any other strings of this size, but make it 10 to be sure. (There will barely be any misses)
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.InterningToString(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Intern the given internable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.ReportStatistics(System.String)">
            <summary>
            Report statistics to the console.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.TryIntern(Microsoft.Build.OpportunisticIntern.IInternable,System.String@)">
            <summary>
            Try to intern the string.
            Return true if an interned value could be returned.
            Return false if it was added to the intern list, but wasn't there already.
            Return null if it didn't meet the length criteria for any of the buckets. Interning was rejected
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.InternWithStatistics(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Version of Intern that gathers statistics
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList">
            <summary>
            A singly linked list of strings where the most recently accessed string is at the top.
            Size expands up to a fixed number of strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList._size">
            <summary>
            Maximum size of the mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList._mru">
            <summary>
            Head of the mru list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.#ctor(System.Int32)">
            <summary>
            Construct an Mru list with a fixed maximum size.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.TryGet(Microsoft.Build.OpportunisticIntern.IInternable,System.String@)">
            <summary>
            Try to get one element from the list. Upon leaving the function 'candidate' will be at the head of the Mru list.
            This function is not thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Statistics">
            <summary>
            Returns the number of strings held and the total number of chars held.
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node">
            <summary>
            Singly linked list node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.#ctor(System.String)">
            <summary>
            Construct a Node
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.Next">
            <summary>
            The next node in the list.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.Value">
            <summary>
            The held string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.Tracing">
            <summary>
            A debug only helper class for tracing
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_counts">
            <summary>
            A dictionary of named counters
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_last">
            <summary>
            Last time logging happened
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_interval">
            <summary>
            How often to log
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_slot">
            <summary>
            A place callers can put something worth logging later
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_currentAssemblyName">
            <summary>
            Short name of the current assembly - to distinguish statics when this type is shared into different assemblies
            </summary> 
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Slot(System.String,System.String)">
            <summary>
            Put something in the slot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Slot``2(System.String,System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Put something in the slot
            </summary>
            <typeparam name="K">The key type.</typeparam>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Record(System.String)">
            <summary>
            Increment the named counter, and dump if it's time to do so
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.List``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Log the provided items
            </summary>
            <typeparam name="T">The item type.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Dump">
            <summary>
            Dump all the named counters, if any
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetConfigurationReaderHelpers">
            <summary>
            Helper class for reading toolsets out of the configuration file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReaderHelpers.ConfigurationFileMayHaveToolsets">
            <summary>
            Creating a ToolsetConfigurationReader, and also reading toolsets from the 
            configuration file, are a little expensive. To try to avoid this cost if it's 
            not necessary, we'll check if the file exists first. If it exists, we'll scan for 
            the string "toolsVersion" to see if it might actually have any tools versions
            defined in it.
            </summary>
            <returns>True if there may be toolset definitions, otherwise false</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement">
            <summary>
            Class representing the Toolset element
            </summary>
            <remarks>
            Internal for unit testing only
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.toolsVersion">
            <summary>
            ToolsVersion attribute of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElements">
            <summary>
            Property element collection 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.AllProjectImportSearchPaths">
            <summary>
            Collection of all the search paths for project imports, per OS
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection">
            <summary>
            Class representing all the per-OS search paths for MSBuildExtensionsPath*
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection._previouslySeenOS">
            <summary>
            We use this dictionary to track whether or not we've seen a given
            searchPaths definition before, since the .NET configuration classes
            won't perform this check without respect for case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.CollectionType">
            <summary>
            Type of the collection
            This has to be public as cannot change access modifier when overriding
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.ThrowOnDuplicate">
            <summary>
            Throw exception if an element with a duplicate key is added to the collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.ElementName">
            <summary>
            Name of the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.GetElement(System.String)">
            <summary>
            Gets an element with the specified name
            </summary>
            <param name="os">OS of the element</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.GetElement(System.Int32)">
            <summary>
            Gets an element based at the specified position
            </summary>
            <param name="index">position</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Returns the key value for the given element
            </summary>
            <param name="element">element whose key is returned</param>
            <returns>key</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.CreateNewElement">
            <summary>
            Creates a new element of the collection
            </summary>
            <returns>Created element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.BaseAdd(System.Int32,System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen elements
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.BaseAdd(System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen elements
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.UpdateOSMap(System.Configuration.ConfigurationElement)">
            <summary>
            Stores the name of the OS in a case-insensitive map
            so we can detect if it is specified more than once but with
            different case
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathElement">
            <summary>
            Class representing searchPaths element for a single OS
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathElement.OS">
            <summary>
            OS attribute of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathElement.PropertyElements">
            <summary>
            Property element collection
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection">
            <summary>
            Class representing collection of property elements
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection._previouslySeenPropertyNames">
            <summary>
            We use this dictionary to track whether or not we've seen a given
            property definition before, since the .NET configuration classes
            won't perform this check without respect for case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.CollectionType">
            <summary>
            Collection type
            This has to be public as cannot change access modifier when overriding  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.ThrowOnDuplicate">
            <summary>
            Throw exception if an element with a duplicate is added
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.ElementName">
            <summary>
            name of the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.GetElement(System.String)">
            <summary>
            Gets an element with the specified name
            </summary>
            <param name="name">name of the element</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.GetElement(System.Int32)">
            <summary>
            Gets an element at the specified position
            </summary>
            <param name="index">position</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.CreateNewElement">
            <summary>
            Creates a new element
            </summary>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.BaseAdd(System.Int32,System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen property names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.BaseAdd(System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen property names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Gets the key for the element
            </summary>
            <param name="element">element</param>
            <returns>key</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.UpdatePropertyNameMap(System.Configuration.ConfigurationElement)">
            <summary>
            Stores the name of the tools version in a case-insensitive map
            so we can detect if it is specified more than once but with
            different case
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.PropertyElement">
            <summary>
            This class represents property element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElement.Name">
            <summary>
            name attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElement.Value">
            <summary>
            value attribute
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElementCollection">
            <summary>
            Class representing the collection of toolset elements
            </summary>
            <remarks>
            Internal for unit testing only
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetElementCollection._previouslySeenToolsVersions">
            <summary>
            We use this dictionary to track whether or not we've seen a given
            toolset definition before, since the .NET configuration classes
            won't perform this check without respect for case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElementCollection.CollectionType">
            <summary>
            Type of the collection
            This has to be public as cannot change access modifier when overriding
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElementCollection.ThrowOnDuplicate">
            <summary>
            Throw exception if an element with a duplicate key is added to the collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElementCollection.ElementName">
            <summary>
            Name of the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.GetElement(System.String)">
            <summary>
            Gets an element with the specified name
            </summary>
            <param name="toolsVersion">toolsVersion of the element</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.GetElement(System.Int32)">
            <summary>
            Gets an element based at the specified position
            </summary>
            <param name="index">position</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Returns the key value for the given element
            </summary>
            <param name="element">element whose key is returned</param>
            <returns>key</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.CreateNewElement">
            <summary>
            Creates a new element of the collection
            </summary>
            <returns>Created element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.BaseAdd(System.Int32,System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen tools versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.BaseAdd(System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen tools versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.UpdateToolsVersionMap(System.Configuration.ConfigurationElement)">
            <summary>
            Stores the name of the tools version in a case-insensitive map
            so we can detect if it is specified more than once but with
            different case
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetConfigurationSection">
            <summary>
            This class is used to programmatically read msbuildToolsets section
            in from the configuration file.  An example of application config file:
            
            &lt;configuration&gt;
                &lt;msbuildToolsets default="2.0"&gt;
                    &lt;toolset toolsVersion="2.0"&gt;
                        &lt;property name="MSBuildBinPath" value="D:\windows\Microsoft.NET\Framework\v2.0.x86ret\"/&gt;
                        &lt;property name="SomeOtherProperty" value="SomeOtherPropertyValue"/&gt;
                    &lt;/toolset&gt;
                    &lt;toolset toolsVersion="3.5"&gt;
                        &lt;property name="MSBuildBinPath" value="D:\windows\Microsoft.NET\Framework\v3.5.x86ret\"/&gt;
                    &lt;/toolset&gt;
                &lt;/msbuildToolsets&gt;
            &lt;/configuration&gt;
            
            </summary>
            <remarks>
            Internal for unit testing only
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.Toolsets">
            <summary>
            toolsVersion element collection 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.Default">
            <summary>
            default attribute on msbuildToolsets element, specifying the default ToolsVersion
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.MSBuildOverrideTasksPath">
            <summary>
            MsBuildOverrideTasksPath attribute on msbuildToolsets element, specifying the path to find msbuildOverrideTasks files
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.DefaultOverrideToolsVersion">
            <summary>
            DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by 
            default to build projects with this version of MSBuild.
            </summary>
        </member>
    </members>
</doc>
