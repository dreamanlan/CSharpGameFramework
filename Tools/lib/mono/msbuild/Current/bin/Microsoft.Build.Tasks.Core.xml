<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Build.Tasks.Core</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Build.Shared.FileSystem.FileSystems">
            <summary>
            Factory for <see cref="T:Microsoft.Build.Shared.FileSystem.IFileSystem"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.IFileSystem">
            <summary>
            Abstracts away some file system operations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of file names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of directory names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of file names and directory names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.DirectoryExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing directory on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.FileExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.DirectoryEntryExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing entry in the directory service.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.ManagedFileSystem">
            <summary>
            Implementation of file system operations directly over the dot net managed layer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem">
            <summary>
            Implementation of file system operations directly over the dot net managed layer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.NativeWin32Exception">
            <summary>
            A possibly-recoverable exception wrapping a failed native call. The <see cref="P:System.ComponentModel.Win32Exception.NativeErrorCode" /> captures the
            associated recent error code (<see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />). The <see cref="P:System.Exception.Message" />
            accounts for the native code as well as a human readable portion.
            </summary>
            <remarks>
            This is much like <see cref="T:System.ComponentModel.Win32Exception"/>, but the message field contains the caller-provided part in addition
            to the system-provided message (rather than replacing the system provided message).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.#ctor(System.Int32,System.String)">
            <summary>
            Creates an exception representing a native failure (with a corresponding Win32 error code).
            The exception's <see cref="P:System.Exception.Message" /> includes the error code, a system-provided message describing it,
            and the provided application-specific message prefix (e.g. "Unable to open log file").
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.#ctor(System.Int32)">
            <summary>
            Creates an exception representing a native failure (with a corresponding Win32 error code).
            The exception's <see cref="P:System.Exception.Message" /> includes the error code and a system-provided message describing it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.GetFormattedMessageForNativeErrorCode(System.Int32,System.String)">
            <summary>
            Returns a human readable error string for a native error code, like <c>Native: Can't access the log file (0x5: Access is denied)</c>.
            The message prefix (e.g. "Can't access the log file") is optional.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.HResultFromWin32(System.Int32)">
            <summary>
            Converts a Win32 error code to HResult
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle">
            <summary>
            Handle for a volume iteration as returned by WindowsNative.FindFirstVolumeW />
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle.#ctor">
            <summary>
            Private constructor for the PInvoke marshaller.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle.ReleaseHandle">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.FileArtifactType">
            <summary>
            The type of file artifact to search for
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.File">
            <nodoc/>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.Directory">
            <nodoc/>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.FileOrDirectory">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsFileSystem">
            <summary>
            Windows-specific implementation of file system operations using Windows native invocations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative">
            <summary>
            Native implementation of file system operations
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.MaxPath">
            <summary>
            Maximum path length.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorSuccess">
            <summary>
            ERROR_SUCCESS
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorFileNotFound">
            <summary>
            ERROR_FILE_NOT_FOUND
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorPathNotFound">
            <summary>
            ERROR_PATH_NOT_FOUND
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorDirectory">
            <summary>
            ERROR_DIRECTORY
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorAccessDenied">
            <summary>
            ERROR_ACCESS_DENIED
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorNoMoreFiles">
            <summary>
            ERROR_NO_MORE_FILES
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags">
            <summary>
            Modifies the search condition of PathMatchSpecEx
            </summary>
            <remarks>
            <see ref="https://msdn.microsoft.com/en-us/library/windows/desktop/bb773728(v=vs.85).aspx"/>
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfNormal">
            <summary>
            The pszSpec parameter points to a single file name pattern to be matched.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfMultiple">
            <summary>
            The pszSpec parameter points to a semicolon-delimited list of file name patterns to be matched.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfDontStripSpaces">
            <summary>
            If PMSF_NORMAL is used, ignore leading spaces in the string pointed to by pszSpec. If PMSF_MULTIPLE is used, 
            ignore leading spaces in each file type contained in the string pointed to by pszSpec. This flag can be combined with PMSF_NORMAL and PMSF_MULTIPLE.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus">
            <summary>
            Status of attempting to enumerate a directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.Success">
            <summary>
            Enumeration of an existent directory succeeded.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound">
            <summary>
            One or more path components did not exist, so the search directory could not be opened.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.CannotEnumerateFile">
            <summary>
            A path component in the search path refers to a file. Only directories can be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.AccessDenied">
            <summary>
            Directory enumeration could not complete due to denied access to the search directory or a file inside.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.UnknownError">
            <summary>
            Directory enumeration failed without a well-known status (see <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.NativeErrorCode"/>).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult">
            <summary>
            Represents the result of attempting to enumerate a directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Directory">
            <summary>
            Enumerated directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Status">
            <summary>
            Overall status indication.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.NativeErrorCode">
            <summary>
            Native error code. Note that an error code other than <c>ERROR_SUCCESS</c> may be present even on success.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.#ctor(System.String,Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus,System.Int32)">
            <nodoc />
        </member>
        <member name="P:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Succeeded">
            <summary>
            Indicates if enumeration succeeded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.ThrowForUnknownError">
            <summary>
            Throws an exception if the native error code could not be canonicalized (a fairly exceptional circumstance).
            This is allowed when <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Status"/> is <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.UnknownError"/>.
            </summary>
            <remarks>
            This is a good <c>default:</c> case when switching on every possible <see cref="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus"/>
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.ThrowForKnownError">
            <summary>
            Throws an exception if the native error code was corresponds to a known <see cref="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus"/>
            (and enumeration was not successful).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.CreateExceptionForError">
            <summary>
            Creates (but does not throw) an exception for this result. The result must not be successful.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData">
            <summary>
            <c>Win32FindData</c>
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwFileAttributes">
            <summary>
            The file attributes of a file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtCreationTime">
            <summary>
            Specified when a file or directory was created
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtLastAccessTime">
            <summary>
            Specifies when the file was last read from, written to, or for executable files, run.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtLastWriteTime">
            <summary>
            For a file, the structure specifies when the file was last written to, truncated, or overwritten.
            For a directory, the structure specifies when the directory is created.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.NFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.NFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.CFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.CAlternate">
            <summary>
            An alternative name for the file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindFirstFileW(System.String,Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData@)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindNextFileW(System.Runtime.InteropServices.SafeHandle,Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData@)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.PathMatchSpecExW(System.String,System.String,System.Int32)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindClose(System.IntPtr)">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.Debugging.PrintLineDebugger">
            <summary>
                A class to help with printline debugging in difficult environments like CI, or when debugging msbuild through other
                tools like VS or CLI.
                See example usages in PrintLineDebugger_Tests
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.Debugging.PrintLineDebuggerWriters">
            <summary>
                A collection of useful writers
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyFoldersEx">
             <summary>
             Implements the rules for finding component directories using the AssemblyFoldersEx scheme.
            
             This is the normal schema:
            
              [HKLM | HKCU]\SOFTWARE\MICROSOFT\.NetFramework\ 
                v1.0.3705 
                  AssemblyFoldersEx 
                      Infragistics.GridControl.1.0:  
                          @Default = c:\program files\infragistics\grid control\1.0\bin 
                          @Description = Infragistics Grid Control for .NET version 1.0 
                          9466 
                              @Default = c:\program files\infragistics\grid control\1.0sp1\bin 
                              @Description = SP1 for Infragistics Grid Control for .NET version 1.0 
            
             
             The root registry path is the following:
            
                 [HKLM | HKCU]\{AssemblyFoldersBase}\{RuntimeVersion}\{AssemblyFoldersSuffix}
            
             Where:
            
                 {AssemblyFoldersBase} = Software\Microsoft\[.NetFramework | .NetCompactFramework]
                 {RuntimeVersion} = the runtime version property from the project file
                 {AssemblyFoldersSuffix} = [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx
            
             </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyFoldersEx._directoryNames">
            <summary>
            The list of directory names found from the registry.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.#ctor(System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,System.Reflection.ProcessorArchitecture,Microsoft.Build.Shared.OpenBaseKey)">
            <summary>
            Construct.
            </summary>
            <param name="registryKeyRoot">Like Software\Microsoft\[.NetFramework | .NetCompactFramework]</param>
            <param name="targetRuntimeVersion">The runtime version property from the project file.</param>
            <param name="registryKeySuffix">Like [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx</param>
            <param name="osVersion">Operating system version</param>
            <param name="platform">Current platform</param>
            <param name="getRegistrySubKeyNames">Used to find registry subkey names.</param>
            <param name="getRegistrySubKeyDefaultValue">Used to find registry key default values.</param>
            <param name="targetProcessorArchitecture">Architecture to seek.</param>
            <param name="openBaseKey">Key object to open.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.FindDirectories(Microsoft.Win32.RegistryView,Microsoft.Win32.RegistryHive,System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,Microsoft.Build.Shared.OpenBaseKey)">
            <summary>
            Finds directories for a specific registry key.
            </summary>
            <param name="view">The registry view to examine.</param>
            <param name="hive">The registry hive to examine.</param>
            <param name="registryKeyRoot">Like Software\Microsoft\[.NetFramework | .NetCompactFramework]</param>
            <param name="targetRuntimeVersion">The runtime version property from the project file.</param>
            <param name="registryKeySuffix">Like [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx</param>
            <param name="osVersion">Operating system version</param>
            <param name="platform">Current platform</param>
            <param name="getRegistrySubKeyNames">Used to find registry subkey names.</param>
            <param name="getRegistrySubKeyDefaultValue">Used to find registry key default values.</param>
            <param name="openBaseKey">Key object to open.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.GatherVersionStrings(System.String,System.Collections.Generic.IEnumerable{System.String})">
             <summary>
              The algorithm for gathering versions from the registry is as follows:
                 1) targetRuntimeVersion is the target framework version you are targeting
                 2) versions is a string list from reading the registry, this list is in what ever order the registry returns 
                    the keys to us in, this is usually alphabetical.
                 
                 We will go through each version string and do the following:
                     1) Check to see if the string is a version
                         If the string is not a version we will check to see if the string starts with the framework we are targeting,
                         if it does we will add it to a list which will be added at the end 
                         of the versions list, if not it gets ignored. We do this to stay compatible to what we have been doing since whidbey.
                         
                         If the string is a version
                             We check to see if the version is a valid target framework version. Meaning.  It has a Maj.Minor version and may have 
                             build, Build is less than or equal to 255 and there is no revision. The reason the build number needs to be less than 255 is because
                             255 is the largest build number for a target framework version that visual studio 2010 supports. The build number is supposed to 
                             represent a service pack on the 4.0 framework.
                             
                             If the string is a valid target framework version we check to see we already have a dictionary entry and if not we 
                             add one. 
                             If the string is not a valid target framework then we will ignore the part of the version which makes it invalid
                             (either the build or the revision, or both) and see where that version would fit in the dictionary as a key and
                             then put the original version string into the list for that entry.
                             
                     Since the dictionary is sorted in reverse order to generate the list to return we do the following:
                     Go through the list of dictionary entries 
                         For each entry sort the list in reverse alphabetical order and add the entries in their internal list to the listToreturn.
            
                     This way we have a reverse sorted list of all of the version keys.
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.AddCandidateVersion(System.Collections.Generic.SortedDictionary{System.Version,System.Collections.Generic.List{System.String}},System.String,System.Version)">
            <summary>
            Given a candidate version we need to add it to the dictionary of targetFrameworkToRegistry versions. This involves determining if we need to add it to
            an existing entry or create a new one.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.System#Collections#Generic#IEnumerable{Microsoft#Build#Utilities#AssemblyFoldersExInfo}#GetEnumerator">
            <summary>
            Get Enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersEx.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderCollection.Load(System.String)">
            <summary>
            Deserialize the file into an AssemblyFolderCollection.
            </summary>
            <param name="filePath">Path to the AssemblyFolder.config file.</param>
            <returns>New deserialized collection instance.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_visualStudioProcess" -->
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_msBuildProcess">
            <summary>
            Name of the MSBuild process(es)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_msBuildExeNames">
            <summary>
            Name of MSBuild executable files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironmentHelper.Instance">
            <summary>
            Gets the cached Build Environment instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.Initialize">
            <summary>
            Find the location of MSBuild.exe based on the current environment.
            </summary>
            <remarks>
            This defines the order and precedence for various methods of discovering MSBuild and associated toolsets.
            At a high level, an install under Visual Studio is preferred as the user may have SDKs installed to a
            specific instance of Visual Studio and build will only succeed if we can discover those. See
            https://github.com/Microsoft/msbuild/issues/1461 for details.
            </remarks>
            <returns>Build environment.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.IsProcessInList(System.String,System.String[])">
            <summary>
            Returns true if processName appears in the processList
            </summary>
            <param name="processName">Name of the process</param>
            <param name="processList">List of processes to check</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(System.Func{System.String},System.Func{System.String},System.Func{System.String},System.Func{System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.VisualStudioInstance}},System.Func{System.String,System.String},System.Func{System.Boolean})">
            <summary>
            Resets the current singleton instance (for testing).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.BuildEnvironmentMode">
            <summary>
            Enum which defines which environment / mode MSBuild is currently running.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.VisualStudio">
            <summary>
            Running from Visual Studio directly or from MSBuild installed under an instance of Visual Studio.
            Toolsets and extensions will be loaded from the Visual Studio instance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.Standalone">
            <summary>
            Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app 
            running and not dependent on Visual Studio. (e.g. dotnet CLI, open source clone of our repo)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.None">
            <summary>
            Running without any defined toolsets. Most functionality limited. Likely will not be able to
            build or evaluate a project. (e.g. reference to Microsoft.*.dll without a toolset definition
            or Visual Studio instance installed).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.BuildEnvironment">
            <summary>
            Defines the current environment for build tools.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.RunningTests">
            <summary>
            Gets the flag that indicates if we are running in a test harness.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.RunningInVisualStudio">
            <summary>
            Returns true when the entry point application is Visual Studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildToolsDirectory32">
            <summary>
            Path to the MSBuild 32-bit tools directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildToolsDirectory64">
            <summary>
            Path to the MSBuild 64-bit (AMD64) tools directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildSDKsPath">
            <summary>
            Path to the Sdks folder for this MSBuild instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildConfigurationFile">
            <summary>
            Full path to the current MSBuild configuration file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildExePath">
            <summary>
            Full path to current MSBuild.exe.
            <remarks>
            This path is likely not the current running process. We may be inside
            Visual Studio or a test harness. In that case this will point to the
            version of MSBuild found to be associated with the current environment.
            </remarks>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildToolsDirectory">
            <summary>
            Full path to the current MSBuild tools directory. This will be 32-bit unless
            we're executing from the 'AMD64' folder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.VisualStudioInstallRootDirectory">
            <summary>
            Path to the root Visual Studio install directory
            (e.g. 'C:\Program Files (x86)\Microsoft Visual Studio\Preview\Enterprise')
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildExtensionsPath">
            <summary>
            MSBuild extensions path. On Standalone this defaults to the MSBuild folder. In
            VisualStudio mode this folder will be %VSINSTALLDIR%\MSBuild.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyNameComparer">
            <summary>
            IKeyComparer implementation that compares AssemblyNames for using in Hashtables.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.Comparer">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.ComparerConsiderRetargetable">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.GenericComparer">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.GenericComparerConsiderRetargetable">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.considerRetargetableFlag">
            <summary>
            Should the comparer consider the retargetable flag when doing comparisons
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.#ctor(System.Boolean)">
            <summary>
            Private construct so there's only one instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare o1 and o2 as AssemblyNames.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.Equals(System.Object,System.Object)">
            <summary>
            Treat o1 and o2 as AssemblyNames. Are they equal?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.GetHashCode(System.Object)">
            <summary>
            Get a hashcode for AssemblyName.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.Equals(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Determine if the assembly name extensions are equal
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.GetHashCode(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Get a hashcode for AssemblyName.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyNameReverseVersionComparer">
            <summary>
            Compare the version numbers only for an AssemblyNameExtension and make sure they are in reverse order. This assumes the names are the same.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameReverseVersionComparer.GenericComparer">
            <summary>
            A static instance of the comparer for use in a sort method
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameReverseVersionComparer.Compare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare x and y by version only.
            
            Change the return value to sort the values in reverse order.
            
            If x is greater than y  return -1 indicating x is less than y. 
            If x is less than y  return 1 indicating x is greater than  y.
            If x and y are equal return 0.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError">
             <summary>
             Functions for dealing with the specially formatted errors returned by
             build tools.
             </summary>
             <remarks>
             Various tools produce and consume CanonicalErrors in various formats.
            
             DEVENV Format When Clicking on Items in the Output Window
             (taken from env\msenv\core\findutil.cpp ParseLocation function)
            
                  v:\dir\file.ext (loc) : msg
                  \\server\share\dir\file.ext(loc):msg
                  url
            
                  loc:
                  (line)
                  (line-line)
                  (line,col)
                  (line,col-col)
                  (line,col,len)
                  (line,col,line,col)
            
             DevDiv Build Process
             (taken from tools\devdiv2.def)
            
                  To echo warnings and errors to the build console, the
                  "description block" must be recognized by build. To do this,
                  add a $(ECHO_COMPILING_COMMAND) or $(ECHO_PROCESSING_COMMAND)
                  to the first line of the description block, e.g.
            
                      $(ECHO_COMPILING_CMD) Resgen_$&lt;
            
                  Errors must have the format:
            
                      &lt;text&gt; : error [num]: &lt;msg&gt;
            
                  Warnings must have the format:
            
                      &lt;text&gt; : warning [num]: &lt;msg&gt;
             </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError.Parts">
            <summary>
            Represents the parts of a decomposed canonical message.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError.Parts.Category">
            <summary>
            Defines the error category\severity level.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.numberNotSpecified">
            <summary>
            Value used for unspecified line and column numbers, which are 1-relative.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.Parts.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Shared.CanonicalError.Parts"/> class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.origin">
            <summary>
            Name of the file or tool (not localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.line">
            <summary>
            The line number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.column">
            <summary>
            The column number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.endLine">
            <summary>
            The ending line number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.endColumn">
            <summary>
            The ending column number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.category">
            <summary>
            The category/severity level
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.subcategory">
            <summary>
            The sub category (localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.code">
            <summary>
            The error code (not localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.text">
            <summary>
            The error message text (localized)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.ConvertToIntWithDefault(System.String)">
            <summary>
            A small custom int conversion method that treats invalid entries as missing (0). This is done to work around tools
            that don't fully conform to the canonical message format - we still want to salvage what we can from the message.
            </summary>
            <param name="value"></param>
            <returns>'value' converted to int or 0 if it can't be parsed or is negative</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.Parse(System.String)">
            <summary>
            Decompose an error or warning message into constituent parts. If the message isn't in the canonical form, return null.
            </summary>
            <remarks>This method is thread-safe, because the Regex class is thread-safe (per MSDN).</remarks>
            <param name="message"></param>
            <returns>Decomposed canonical message, or null.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.ExtensionFoldersRegistryKey">
            <summary>
            Contains information about entries in the AssemblyFoldersEx registry keys.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExtensionFoldersRegistryKey.#ctor(System.String,System.Version)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExtensionFoldersRegistryKey.RegistryKey">
            <summary>
            The registry key to the component
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExtensionFoldersRegistryKey.TargetFrameworkVersion">
            <summary>
            Target framework version for the registry key
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.DirectoryGetFiles">
            <summary>
            delegate for System.IO.Directory.GetFiles, used for testing
            </summary>
            <param name="path">Directory path to start search for files in</param>
            <param name="searchPattern">pattern of files to match</param>
            <returns>string array of files which match search pattern</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.GetDirectories">
            <summary>
            delegate for Directory.GetDirectories.
            </summary>
            <param name="path">The path to get directories for.</param>
            <param name="pattern">The pattern to search for.</param>
            <returns>An array of directories.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.DirectoryExists">
            <summary>
            Delegate for System.IO.Directory.Exists
            </summary>
            <param name="path">Directory path to check if it exists</param>
            <returns>true if directory exists</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileExists">
            <summary>
            File exists delegate
            </summary>
            <param name="path">The path to check for existence.</param>
            <returns>'true' if the file exists.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileCopy">
            <summary>
            File.Copy delegate
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileDelete">
            <summary>
            File.Delete delegate
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileCreate">
            <summary>
            File create delegate
            </summary>
            <param name="path">The path to create.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared">
            <summary>
            Interop methods.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MAX_PATH">
            <summary>
            Default buffer size to use when dealing with the Windows API.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS">
            <summary>
            Flags for CoWaitForMultipleHandles
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_NONE">
            <summary>
            Exit when a handle is signaled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_WAITALL">
            <summary>
            Exit when all handles are signaled AND a message is received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_ALERTABLE">
            <summary>
            Exit when an RPC call is serviced.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitectures">
            <summary>
            Processor architecture values
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SYSTEM_INFO">
            <summary>
            Structure that contain information about the system on which we are running
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SafeProcessHandle">
            <summary>
            Wrap the intptr returned by OpenProcess in a safe handle.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus">
            <summary>
            Contains information about the current state of both physical and virtual memory, including extended memory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus._length">
            <summary>
            Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.MemoryLoad">
            <summary>
            Number between 0 and 100 that specifies the approximate percentage of physical
            memory that is in use (0 indicates no memory use and 100 indicates full memory use).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalPhysical">
            <summary>
            Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailablePhysical">
            <summary>
            Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalPageFile">
            <summary>
            Size of the committed memory limit, in bytes. This is physical memory plus the
            size of the page file, minus a small overhead.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailablePageFile">
            <summary>
            Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalVirtual">
            <summary>
            Total size of the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailableVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the user mode portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailableExtendedVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the extended portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA">
            <summary>
            Contains information about a file or directory; used by GetFileAttributesEx.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SecurityAttributes">
            <summary>
            Contains the security descriptor for an object and specifies whether
            the handle retrieved by specifying this structure is inheritable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ProcessorArchitectureType">
            <summary>
            Architecture as far as the current process is concerned.
            It's x86 in wow64 (native architecture is x64 in that case).
            Otherwise it's the same as the native architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ProcessorArchitectureTypeNative">
            <summary>
            Actual architecture of the system.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ConvertSystemArchitecture(System.UInt16)">
            <summary>
            Convert SYSTEM_INFO architecture values to the internal enum
            </summary>
            <param name="arch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.#ctor">
            <summary>
            Read system info values
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.MaxPath">
            <summary>
            Gets the max path limit of the current OS.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared._maxPath">
            <summary>
            Cached value for MaxPath.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_isUnixLike">
            <summary>
            Cached value for IsUnixLike (this method is called frequently during evaluation).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsUnixLike">
            <summary>
            Gets a flag indicating if we are running under a Unix-like system (Mac, Linux, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsLinux">
            <summary>
            Gets a flag indicating if we are running under Linux
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsBSD">
            <summary>
            Gets a flag indicating if we are running under flavor of BSD (NetBSD, OpenBSD, FreeBSD)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsMono">
            <summary>
            Gets a flag indicating if we are running under MONO
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsWindows">
            <summary>
            Gets a flag indicating if we are running under some version of Windows
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsOSX">
            <summary>
            Gets a flag indicating if we are running under Mac OSX
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.OSName">
            <summary>
            Gets a string for the current OS. This matches the OS env variable
            for Windows (Windows_NT).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetOSNameForExtensionsPath">
            <summary>
            OS name that can be used for the msbuildExtensionsPathSearchPaths element
            for a toolset
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_frameworkBasePath">
            <summary>
            The base directory for all framework paths in Mono
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_frameworkCurrentPath">
            <summary>
            The directory of the current framework
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.FrameworkCurrentPath">
            <summary>
            Gets the currently running framework path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.FrameworkBasePath">
            <summary>
            Gets the base directory of all Mono frameworks
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.SystemInformation">
            <summary>
            System information, initialized when required.
            </summary>
            <remarks>
            Initially implemented as <see cref="T:System.Lazy`1"/>, but
            that's .NET 4+, and this is used in MSBuildTaskHost.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitecture">
            <summary>
            Architecture getter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitectureNative">
            <summary>
            Native architecture getter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.WaitForMultipleObjects(System.UInt32,System.IntPtr[],System.Boolean,System.UInt32)">
            <summary>
            Really truly non pumping wait.
            Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
            single SafeHandles.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLastWriteDirectoryUtcTime(System.String,System.DateTime@)">
            <summary>
            Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
            if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetShortFilePath(System.String)">
            <summary>
            Takes the path and returns the short path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLongFilePath(System.String)">
            <summary>
            Takes the path and returns a full path
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetMemoryStatus">
            <summary>
            Retrieves the current global memory status.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLastWriteFileUtcTime(System.String)">
            <summary>
            Get the last write time of the fullpath to the file.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
            <remarks>
            This method should be accurate for regular files and symlinks, but can report incorrect data
            if the file's content was modified by writing to it through a different link, unless
            MSBUILDALWAYSCHECKCONTENTTIMESTAMP=1.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetContentLastWriteFileUtcTime(System.String)">
            <summary>
            Get the last write time of the content pointed to by a file path.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
            <remarks>
            This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
            See https://github.com/Microsoft/msbuild/issues/2052.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.HResultSucceeded(System.Int32)">
            <summary>
            Did the HRESULT succeed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.HResultFailed(System.Int32)">
            <summary>
            Did the HRESULT Fail
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.ThrowExceptionForErrorCode(System.Int32)">
            <summary>
            Given an error code, converts it to an HRESULT and throws the appropriate exception.
            </summary>
            <param name="errorCode"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.KillTree(System.Int32)">
            <summary>
            Kills the specified process by id and all of its children recursively.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetParentProcessId(System.Int32)">
            <summary>
            Returns the parent process id for the specified process.
            Returns zero if it cannot be gotten for some reason.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetChildProcessIds(System.Int32,System.DateTime)">
            <summary>
            Returns an array of all the immediate child processes by id.
            NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetCurrentDirectory">
            <summary>
            Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.AreStringsEqual(System.Char*,System.Int32,System.String)">
            <summary>
            Compare an unsafe char buffer with a <see cref="T:System.String"/> to see if their contents are identical.
            </summary>
            <param name="buffer">The beginning of the char buffer.</param>
            <param name="len">The length of the buffer.</param>
            <param name="s">The string.</param>
            <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetOEMCP">
            <summary>
            Gets the current OEM code page which is used by console apps
            (as opposed to the Windows/ANSI code page)
            Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
            that needs to be used for instance when writing to batch files
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetModuleFileName(System.Runtime.InteropServices.HandleRef,System.Text.StringBuilder,System.Int32)">
            <summary>
            Gets the fully qualified filename of the currently executing .exe
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.CoWaitForMultipleHandles(Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS,System.Int32,System.Int32,System.IntPtr[],System.Int32@)">
            <summary>
            CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
            VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
            build thread which the main thread (blocked on BuildSubmission.Execute) must service.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle,System.TimeSpan)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle,System.Int32)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyUtilities">
            <summary>
            This class contains common reflection tasks
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NGen`1">
            <summary>
            To avoid CA908 warnings (types that in ngen images that will JIT)
            wrap each problematic value type in the collection in 
            one of these objects.
            </summary>
            <comment>
            This trick is based on advice from 
            http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
            It works because although this is a value type, it is not defined in mscorlib.
            </comment>
            <typeparam name="T">Wrapped type</typeparam>
        </member>
        <member name="F:Microsoft.Build.Shared.NGen`1._value">
            <summary>
            Wrapped value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NGen`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NGen`1.op_Implicit(Microsoft.Build.Shared.NGen{`0})~`0">
            <summary>
            Exposes the value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NGen`1.op_Implicit(`0)~Microsoft.Build.Shared.NGen{`0}">
            <summary>
            Consumes the value
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.OpenBaseKey">
            <summary>
            Given a registry hive and a request view open the base key for that registry location.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.GetRegistrySubKeyNames">
            <summary>
            Simplified registry access delegate. Given a baseKey and a subKey, get all of the subkey
            names.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subKey">The subkey</param>
            <returns>An enumeration of strings.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue">
            <summary>
            Simplified registry access delegate. Given a baseKey and subKey, get the default value
            of the subKey.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subKey">The subkey</param>
            <returns>A string containing the default value.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.RegistryHelper">
            <summary>
            Helper methods that simplify registry access.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.RegistryHelper.GetSubKeyNames(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Given a baseKey and a subKey, get all of the subkeys names.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subkey">The subkey</param>
            <returns>An enumeration of strings.</returns>        
        </member>
        <member name="M:Microsoft.Build.Shared.RegistryHelper.GetDefaultValue(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Given a baseKey and subKey, get the default value of the subKey.
            </summary>
            <param name="baseKey">The base registry key.</param>
            <param name="subkey">The subkey</param>
            <returns>A string containing the default value.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.RegistryHelper.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)">
            <summary>
            Given a hive and a hive view open the base key
                 RegistryKey baseKey = RegistryKey.OpenBaseKey(hive, view);
            </summary>
            <param name="hive">The hive.</param>
            <param name="view">The hive view</param>
            <returns>A registry Key for the given baseKey and view</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.ReuseableStringBuilder">
            <summary>
            A StringBuilder lookalike that reuses its internal storage.
            </summary>
            <remarks>
            You can add any properties or methods on the real StringBuilder that are needed.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._borrowedBuilder">
            <summary>
            Captured string builder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._cachedString">
            <summary>
            Profiling showed that the hot code path for large string builder calls first IsOrdinalEqualToStringOfSameLength followed by ExpensiveConvertToString
            when IsOrdinalEqualToStringOfSameLength did return true. We can therefore reduce the costs for large strings by over a factor two. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._capacity">
            <summary>
            Capacity to initialize the builder with.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.#ctor(System.Int32)">
            <summary>
            Create a new builder, under the covers wrapping a reused one.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ReuseableStringBuilder.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.MaxByCharCompareLength">
            <summary>
            The number here is arbitrary. For a StringBuilder we have a chunk length of 8000 characters which corresponds to
            5 StringBuilder chunks which need to be walked before the next character can be fetched (see MaxChunkSize of StringBuilder).
            That should be a good compromise to not allocate to much but still make use of the intern cache. The actual cutoff where it is cheaper
            to allocate a temp string might be well below that limit but that depends on many other factors such as GC Heap size and other allocating threads. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#ReferenceEquals(System.String)">
            <summary>
            Never reference equals to string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ToString">
            <summary>
            Convert to a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.System#IDisposable#Dispose">
            <summary>
            Dispose, indicating you are done with this builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.Char)">
            <summary>
            Append a character.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.String)">
            <summary>
            Append a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.String,System.Int32,System.Int32)">
            <summary>
            Append a substring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a substring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.LazyPrepare">
            <summary>
            Grab a backing builder if necessary.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory">
            <summary>
            A utility class that mediates access to a shared string builder.
            </summary>
            <remarks>
            If this shared builder is highly contended, this class could add
            a second one and try both in turn.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.MaxBuilderSize">
            <summary>
            Made up limit beyond which we won't share the builder
            because we could otherwise hold a huge builder indefinitely.
            This size seems reasonable for MSBuild uses (mostly expression expansion)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.s_sharedBuilder">
            <summary>
            The shared builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.Get(System.Int32)">
            <summary>
            Obtains a string builder which may or may not already
            have been used. 
            Never returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.Release(System.Text.StringBuilder)">
            <summary>
            Returns the shared builder for the next caller to use.
            ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilities">
            <summary>
            This class contains utility methods for file IO.
            It is in a separate file so that it can be selectively included into an assembly.
            </summary>
            <summary>
            This class contains utility methods for file IO.
            PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
            each class get pulled into the resulting assembly.
            </summary>
            <summary>
            This class contains utility methods for file IO.
            </summary>
            <comment>
            Partial class in order to reduce the amount of sharing into different assemblies
            </comment>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryDirectory(System.Boolean)">
            <summary>
            Generates a unique directory name in the temporary folder.  
            Caller must delete when finished. 
            </summary>
            <param name="createDirectory"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName(System.String)">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            File will NOT be created.
            May throw IOException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            If no extension is provided, uses ".tmp".
            File is guaranteed to be unique.
            Caller must delete it when finished.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile(System.String)">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            Caller must delete it when finished.
            May throw IOException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile(System.String,System.String,System.Boolean)">
            <summary>
            Creates a file with unique temporary file name with a given extension in the specified folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            If folder is null, the temporary folder will be used.
            Caller must delete it when finished.
            May throw IOException.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.cacheDirectory">
            <summary>
            The directory where MSBuild stores cache information used during the build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearCacheDirectoryPath">
            <summary>
            FOR UNIT TESTS ONLY
            Clear out the static variable used for the cache directory so that tests that
            modify it can validate their modifications.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.InvalidPathChars">
            <summary>
            Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
            MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.InvalidFileNameChars">
            <summary>
            Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
            MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetCacheDirectory">
            <summary>
            Retrieves the MSBuild runtime cache directory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetHexHash(System.String)">
            <summary>
            Get the hex hash string for the string
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetPathsHash(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Get the hash for the assemblyPaths
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearCacheDirectory">
            <summary>
            Clears the MSBuild runtime cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureTrailingSlash(System.String)">
            <summary>
            If the given path doesn't have a trailing slash then add one.
            If the path is an empty string, does not modify it.
            </summary>
            <param name="fileSpec">The path to check.</param>
            <returns>A path with a slash.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureNoLeadingSlash(System.String)">
            <summary>
            Ensures the path does not have a leading slash.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureNoTrailingSlash(System.String)">
            <summary>
            Ensures the path does not have a trailing slash.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EndsWithSlash(System.String)">
            <summary>
            Indicates if the given file-spec ends with a slash.
            </summary>
            <param name="fileSpec">The file spec.</param>
            <returns>true, if file-spec has trailing slash</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsSlash(System.Char)">
            <summary>
            Indicates if the given character is a slash.
            </summary>
            <param name="c"></param>
            <returns>true, if slash</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.TrimAndStripAnyQuotes(System.String)">
            <summary>
            Trims the string and removes any double quotes around it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectoryNameOfFullPath(System.String)">
            <summary>
            Get the directory name of a rooted full path
            </summary>
            <param name="fullPath"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.NormalizePath(System.String)">
            <summary>
            Gets the canonicalized full path of the provided path.
            Guidance for use: call this on all paths accepted through public entry
            points that need normalization. After that point, only verify the path
            is rooted, using ErrorUtilities.VerifyThrowPathRooted.
            ASSUMES INPUT IS ALREADY UNESCAPED.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.MaybeAdjustFilePath(System.String,System.String)">
             <summary>
             If on Unix, convert backslashes to slashes for strings that resemble paths.
             The heuristic is if something resembles paths (contains slashes) check if the
             first segment exists and is a directory.
             Use a native shared method to massage file path. If the file is adjusted,
             that qualifies is as a path.
            
             @baseDirectory is just passed to LooksLikeUnixFilePath, to help with the check
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.LooksLikeUnixFilePath(System.String,System.String)">
             <summary>
             If on Unix, check if the string looks like a file path.
             The heuristic is if something resembles paths (contains slashes) check if the
             first segment exists and is a directory.
            
             If @baseDirectory is not null, then look for the first segment exists under
             that
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectory(System.String)">
            <summary>
            Extracts the directory from the given file-spec.
            </summary>
            <param name="fileSpec">The filespec.</param>
            <returns>directory path</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.HasExtension(System.String,System.String[])">
            <summary>
            Determines whether the given assembly file name has one of the listed extensions.
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="allowedExtensions">Array of extensions to consider.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.FileUtilities.ExecutingAssemblyPath">
            <summary>
            Get the currently executing assembly path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFullPath(System.String,System.String)">
            <summary>
            Determines the full path for the given file-spec.
            ASSUMES INPUT IS STILL ESCAPED
            </summary>
            <param name="fileSpec">The file spec to get the full path of.</param>
            <param name="currentDirectory"></param>
            <returns>full path</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)">
            <summary>
            A variation of Path.GetFullPath that will return the input value
            instead of throwing any IO exception.
            Useful to get a better path for an error message, without the risk of throwing
            if the error message was itself caused by the path being invalid!
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ComparePathsNoThrow(System.String,System.String,System.String)">
            <summary>
            Compare if two paths, relative to the given currentDirectory are equal.
            Does not throw IO exceptions. See <see cref="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)"/>
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <param name="currentDirectory"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.NormalizePathForComparisonNoThrow(System.String,System.String)">
             <summary>
             Normalizes a path for path comparison
             Does not throw IO exceptions. See <see cref="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)"/>
            
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteNoThrow(System.String)">
            <summary>
            A variation on File.Delete that will throw ExceptionHandling.NotExpectedException exceptions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteDirectoryNoThrow(System.String,System.Boolean,System.Int32,System.Int32)">
            <summary>
            A variation on Directory.Delete that will throw ExceptionHandling.NotExpectedException exceptions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteWithoutTrailingBackslash(System.String,System.Boolean)">
            <summary>
            Deletes a directory, ensuring that Directory.Delete does not get a path ending in a slash.
            </summary>
            <remarks>
            This is a workaround for https://github.com/dotnet/corefx/issues/3780, which clashed with a common
            pattern in our tests.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFileInfoNoThrow(System.String)">
            <summary>
            Gets a file info object for the specified file path. If the file path
            is invalid, or is a directory, or cannot be accessed, or does not exist,
            it returns null rather than throwing or returning a FileInfo around a non-existent file.
            This allows it to be called where File.Exists() (which never throws, and returns false
            for directories) was called - but with the advantage that a FileInfo object is returned
            that can be queried (e.g., for LastWriteTime) without hitting the disk again.
            </summary>
            <param name="filePath"></param>
            <returns>FileInfo around path if it is an existing /file/, else null</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DirectoryExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Returns if the directory exists
            </summary>
            <param name="fullPath">Full path to the directory in the filesystem</param>
            <param name="fileSystem">The file system</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.FileExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Returns if the directory exists
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <param name="fileSystem">The file system</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.FileOrDirectoryExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            If there is a directory or file at the specified path, returns true.
            Otherwise, returns false.
            Does not throw IO exceptions, to match Directory.Exists and File.Exists.
            Unlike calling each of those in turn it only accesses the disk once, which is faster.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsSolutionFilename(System.String)">
            <summary>
            This method returns true if the specified filename is a solution file (.sln), otherwise
            it returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsVCProjFilename(System.String)">
            <summary>
            Returns true if the specified filename is a VC++ project file, otherwise returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsMetaprojectFilename(System.String)">
            <summary>
            Returns true if the specified filename is a metaproject file (.metaproj), otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.MakeRelative(System.String,System.String)">
            <summary>
            Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
            Throws UriFormatException.
            </summary>
            <param name="basePath">
            The base path we want to be relative to. Must be absolute.
            Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
            </param>
            <param name="path">
            The path we need to make relative to basePath.  The path can be either absolute path or a relative path in which case it is relative to the base path.
            If the path cannot be made relative to the base path (for example, it is on another drive), it is returned verbatim.
            If the basePath is an empty string, returns the path.
            </param>
            <returns>relative path (can be the full path)</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.CreateUriFromPath(System.String)">
            <summary>
            Helper function to create an Uri object from path.
            </summary>
            <param name="path">path string</param>
            <returns>uri object</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.AttemptToShortenPath(System.String)">
            <summary>
            Normalizes the path if and only if it is longer than max path,
            or would be if rooted by the current directory.
            This may make it shorter by removing ".."'s.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsRootedNoThrow(System.String)">
            <summary>
            A variation of Path.IsRooted that not throw any IO exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFolderAbove(System.String,System.Int32)">
            <summary>
            Get the folder N levels above the given. Will stop and return current path when rooted.
            </summary>
            <param name="path">Path to get the folder above.</param>
            <param name="count">Number of levels up to walk.</param>
            <returns>Full path to the folder N levels above the path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.CombinePaths(System.String,System.String[])">
            <summary>
            Combine multiple paths. Should only be used when compiling against .NET 2.0.
            <remarks>
            Only use in .NET 2.0. Otherwise, use System.IO.Path.Combine(...)
            </remarks>
            </summary>
            <param name="root">Root path.</param>
            <param name="paths">Paths to concatenate.</param>
            <returns>Combined path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ToSlash(System.String)">
            <summary>
            Replace all backward slashes to forward slashes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ToPlatformSlash(System.String)">
            <summary>
            Ensure all slashes are the current platform's slash
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectoryNameOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Locate a file in either the directory specified or a location in the
            directory structure above that directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetPathOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Searches for a file based on the specified starting directory.
            </summary>
            <param name="file">The file to search for.</param>
            <param name="startingDirectory">An optional directory to start the search in.  The default location is the directory
                of the file containing the property function.</param>
            <param name="fileSystem">The filesystem</param>
            <returns>The full path of the file if it is found, otherwise an empty string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearFileExistenceCache">
            <summary>
            Clears the file existence cache.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers">
            <summary>
            Encapsulates the definitions of the item-spec modifiers a.k.a. reserved item metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsItemSpecModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for an item-spec modifier.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsDefiningProjectModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for one of the specific subset of itemspec 
            modifiers to do with the defining project of the item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for a derivable item-spec modifier.
            Derivable means it can be computed given a file name.
            </summary>
            <param name="name">Name to check.</param>
            <returns>true, if name of a derivable modifier</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.GetItemSpecModifier(System.String,System.String,System.String,System.String)">
            <summary>
            Performs path manipulations on the given item-spec as directed.
            Does not cache the result.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.GetItemSpecModifier(System.String,System.String,System.String,System.String,System.String@)">
            <summary>
            Performs path manipulations on the given item-spec as directed.
            
            Supported modifiers:
                %(FullPath)         = full path of item
                %(RootDir)          = root directory of item
                %(Filename)         = item filename without extension
                %(Extension)        = item filename extension
                %(RelativeDir)      = item directory as given in item-spec
                %(Directory)        = full path of item directory relative to root
                %(RecursiveDir)     = portion of item path that matched a recursive wildcard
                %(Identity)         = item-spec as given
                %(ModifiedTime)     = last write time of item
                %(CreatedTime)      = creation time of item
                %(AccessedTime)     = last access time of item
            
            NOTES:
            1) This method always returns an empty string for the %(RecursiveDir) modifier because it does not have enough
               information to compute it -- only the BuildItem class can compute this modifier.
            2) All but the file time modifiers could be cached, but it's not worth the space. Only full path is cached, as the others are just string manipulations.
            </summary>
            <remarks>
            Methods of the Path class "normalize" slashes and periods. For example:
            1) successive slashes are combined into 1 slash
            2) trailing periods are discarded
            3) forward slashes are changed to back-slashes
            
            As a result, we cannot rely on any file-spec that has passed through a Path method to remain the same. We will
            therefore not bother preserving slashes and periods when file-specs are transformed.
            
            Never returns null.
            </remarks>
            <param name="currentDirectory">The root directory for relative item-specs. When called on the Engine thread, this is the project directory. When called as part of building a task, it is null, indicating that the current directory should be used.</param>
            <param name="itemSpec">The item-spec to modify.</param>
            <param name="definingProjectEscaped">The path to the project that defined this item (may be null).</param>
            <param name="modifier">The modifier to apply to the item-spec.</param>
            <param name="fullPath">Full path if any was previously computed, to cache.</param>
            <returns>The modified item-spec (can be empty string, but will never be null).</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the item-spec is not a path.</exception>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsRootDirectory(System.String)">
            <summary>
            Indicates whether the given path is a UNC or drive pattern root directory.
            <para>Note: This function mimics the behavior of checking if Path.GetDirectoryName(path) == null.</para>
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.ThrowForUrl(System.String,System.String,System.String)">
            <summary>
            Temporary check for something like http://foo which will end up like c:\foo\bar\http://foo
            We should either have no colon, or exactly one colon.
            UNDONE: This is a minimal safe change for Dev10. The correct fix should be to make GetFullPath/NormalizePath throw for this.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.MetadataConversionUtilities">
            <summary>
            This class contains only static methods, which are useful throughout many
            of the XMake classes and don't really belong in any specific class.   
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.MetadataConversionUtilities.TryConvertItemMetadataToBool(Microsoft.Build.Framework.ITaskItem,System.String,System.Boolean@)">
            <summary>
            Convert a task item metadata to bool. Throw an exception if the string is badly formed and can't
            be converted.
            
            If the metadata is not found, then set metadataFound to false and then return false.
            </summary>
            <param name="item">The item that contains the metadata.</param>
            <param name="itemMetadataName">The name of the metadata.</param>
            <param name="metadataFound">Receives true if the metadata was found, false otherwise.</param>
            <returns>The resulting boolean value.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.MetadataConversionUtilities.TryConvertItemMetadataToBool(Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            Convert a task item metadata to bool. Throw an exception if the string is badly formed and can't
            be converted.
            
            If the attribute is not found, then return false.
            </summary>
            <param name="item">The item that contains the metadata.</param>
            <param name="itemMetadataName">The name of the metadata.</param>
            <returns>The resulting boolean value.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.LanguageParser.StreamMappedString">
            <summary>
            A class with string-like semantics mapped over a Stream.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._binaryStream">
            <summary>
            The raw binary stream that's being read.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._reader">
            <summary>
            The reader on top of binaryStream. This is what interprets the encoding.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._forceANSI">
            <summary>
            When false, try to guess the encoding of binaryStream. When true, force the 
            encoding to ANSI.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._currentPageNumber">
            <summary>
            The page number that 'currentPage' is pointing to.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._finalPageNumber">
            <summary>
            The final page number of the whole stream.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._charactersRead">
            <summary>
            The number of characters read into currentPage.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._priorPage">
            <summary>
            The page before currentPage.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._currentPage">
            <summary>
            The most recently read page.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._pagesAllocated">
            <summary>
            Count of the total number of pages allocated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LanguageParser.StreamMappedString._pageSize">
            <summary>
            Size of pages to use for reading from source file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Construct.
            </summary>
            <param name="binaryStream"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.#ctor(System.IO.Stream,System.Boolean,System.Int32)">
            <summary>
            Construct.
            </summary>
            <param name="binaryStream"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.RestartReader">
            <summary>
            Restart the stream reader at the beginning.
            </summary>
            <param name="binaryStream"></param>
        </member>
        <member name="P:Microsoft.Build.Shared.LanguageParser.StreamMappedString.PagesAllocated">
            <summary>
            Get the total number of pages allocated.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.LanguageParser.StreamMappedString.DefaultPageSize">
            <summary>
            The pagesize in characters that will be used if not specified.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.GetAt(System.Int32)">
            <summary>
            Return a particular character within the file.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.GetPage(System.Int32)">
            <summary>
            Get the page that contains offset. Otherwise, null.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.ReadNextPage">
            <summary>
            Read the next page.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.ReadBlockStripEOF">
            <summary>
            Read characters from the file, and strip out any 1A characters.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.AppendCharacterToStream(System.Char)">
            <summary>
            Add one character to the end of the stream.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.LastCharacterInStream">
            <summary>
            Retrieve the last character in the stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.SwapPages">
            <summary>
            Swap the current page for the last page.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.IsZeroLengthStream">
            <summary>
            True if this stream is zero length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.AbsoluteOffsetToPageOffset(System.Int32)">
            <summary>
            COnvert from absolute offset to relative offset within a particular page.
            </summary>
            <param name="offset"></param>
            <param name="pageNumber"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.PageFromAbsoluteOffset(System.Int32)">
            <summary>
            Convert from offset to page number.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.IsPastEnd(System.Int32)">
            <summary>
            Returns true of the given position is passed the end of the file.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.Substring(System.Int32,System.Int32)">
            <summary>
            Extract a substring.
            </summary>
            <param name="startPosition"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.StreamMappedString.GetCharactersOnPage(System.Int32)">
            <summary>
            Returns the number of characters on the page given by offset.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Shared.LanguageParser.TokenChar">
            <summary>
            Utility functions for classifying characters that might be found in a sources file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsNewLine(System.Char)">
            <summary>
            Determine whether a given character is a newline character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsLetter(System.Char)">
            <summary>
            Determine whether a given character is a letter character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsDecimalDigit(System.Char)">
            <summary>
            Determine whether a given character is a decimal digit character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsConnecting(System.Char)">
            <summary>
            Determine whether a given character is a connecting character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsCombining(System.Char)">
            <summary>
            Determine whether a given character is a combining character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsFormatting(System.Char)">
            <summary>
            Determine whether a given character is a C# formatting character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsHexDigit(System.Char)">
            <summary>
            Determine whether a given character is a hex digit character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenChar.IsOctalDigit(System.Char)">
            <summary>
            Determine whether a given character is an octal digit character
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.TokenCharReader.Sink(System.String,System.Boolean)">
            <summary>
            See if the next characters match the given string. If they do, sink this string.
            </summary>
            <param name="match"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LanguageParser.CSharpTokenizer.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Construct.
            </summary>
            <param name="binaryStream"></param>
            <param name="forceANSI"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.ExceptionHandling">
            <summary>
            Utility methods for classifying and handling exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.GetDebugDumpPath">
            <summary>
            Gets the location of the directory used for diagnostic log files.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.DebugDumpPath">
            <summary>
            The directory used for diagnostic log files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ExceptionHandling.s_dumpFileName">
            <summary>
            The filename that exceptions will be dumped to
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(System.Exception)">
            <summary>
            If the given exception is "ignorable under some circumstances" return false.
            Otherwise it's "really bad", and return true.
            This makes it possible to catch(Exception ex) without catching disasters.
            </summary>
            <param name="e"> The exception to check. </param>
            <returns> True if exception is critical. </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedException(System.Exception)">
            <summary>
            If the given exception is file IO related or expected return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
            <returns>True if exception is not IO related or expected otherwise false.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsIoRelatedException(System.Exception)">
            <summary>
            Determine whether the exception is file-IO related.
            </summary>
            <param name="e">The exception to check.</param>
            <returns>True if exception is IO related.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsXmlException(System.Exception)">
            <summary> Checks if the exception is an XML one. </summary>
            <param name="e"> Exception to check. </param>
            <returns> True if exception is related to XML parsing. </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.GetXmlLineAndColumn(System.Exception)">
            <summary> Extracts line and column numbers from the exception if it is XML-related one. </summary>
            <param name="e"> XML-related exception. </param>
            <returns> Line and column numbers if available, (0,0) if not. </returns>
            <remarks> This function works around the fact that XmlException and XmlSchemaException are not directly related. </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedIoOrXmlException(System.Exception)">
            <summary>
            If the given exception is file IO related or Xml related return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedReflectionException(System.Exception)">
            <summary>
            If the given exception is reflection-related return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedSerializationException(System.Exception)">
            <summary>
            Serialization has been observed to throw TypeLoadException as
            well as SerializationException and IO exceptions. (Obviously
            it has to do reflection but it ought to be wrapping the exceptions.)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedRegistryException(System.Exception)">
            <summary>
            Returns false if this is a known exception thrown by the registry API.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedFunctionException(System.Exception)">
            <summary>
            Returns false if this is a known exception thrown by function evaluation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.UnhandledExceptionHandler(System.Object,System.UnhandledExceptionEventArgs)">
            <summary>
            Dump any unhandled exceptions to a file so they can be diagnosed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.DumpExceptionToFile(System.Exception)">
            <summary>
            Dump the exception information to a file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.ReadAnyExceptionFromFile(System.DateTime)">
            <summary>
            Returns the content of any exception dump files modified
            since the provided time, otherwise returns an empty string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn">
            <summary> Line and column pair. </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn.Line">
            <summary> Gets or sets line number. </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn.Column">
            <summary> Gets or sets column position. </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.EscapingUtilities">
            <summary>
            This class implements static methods to assist with unescaping of %XX codes
            in the MSBuild file format.
            </summary>
            <remarks>
            PERF: since we escape and unescape relatively frequently, it may be worth caching
            the last N strings that were (un)escaped
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.EscapingUtilities.s_unescapedToEscapedStrings">
            <summary>
            Optional cache of escaped strings for use when needing to escape in performance-critical scenarios with significant
            expected string reuse.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.UnescapeAll(System.String)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.UnescapeAll(System.String,System.Boolean@)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <param name="escapingWasNecessary">Whether any replacements were made.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.EscapeWithCaching(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Interns and caches the result.
            </summary>
            <comment>
            NOTE:  Only recommended for use in scenarios where there's expected to be significant
            repetition of the escaped string.  Cache currently grows unbounded.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.Escape(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <returns>escaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.EscapeWithOptionalCaching(System.String,System.Boolean)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Caches if requested.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <param name="cache">
            True if the cache should be checked, and if the resultant string
            should be cached.
            </param>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.ContainsReservedCharacters(System.String)">
            <summary>
            Before trying to actually escape the string, it can be useful to call this method to determine
            if escaping is necessary at all.  This can save lots of calls to copy around item metadata
            that is really the same whether escaped or not.
            </summary>
            <param name="unescapedString"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.ContainsEscapedWildcards(System.String)">
            <summary>
            Determines whether the string contains the escaped form of '*' or '?'.
            </summary>
            <param name="escapedString"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.HexDigitChar(System.Int32)">
            <summary>
            Convert the given integer into its hexadecimal representation.
            </summary>
            <param name="x">The number to convert, which must be non-negative and less than 16</param>
            <returns>The character which is the hexadecimal representation of <paramref name="x"/>.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.AppendEscapedChar(System.Text.StringBuilder,System.Char)">
            <summary>
            Append the escaped version of the given character to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/> to which to append.</param>
            <param name="ch">The character to escape.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.AppendEscapedString(System.Text.StringBuilder,System.String)">
            <summary>
            Append the escaped version of the given string to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/> to which to append.</param>
            <param name="unescapedString">The unescaped string.</param>
        </member>
        <member name="F:Microsoft.Build.Shared.EscapingUtilities.s_charsToEscape">
            <summary>
            Special characters that need escaping.
            It's VERY important that the percent character is the FIRST on the list - since it's both a character
            we escape and use in escape sequences, we can unintentionally escape other escape sequences if we
            don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits
            (that would require rewriting the algorithm) but since it seems unlikely that we ever do, this should
            be good enough to avoid complicating the algorithm at this point.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher">
            <summary>
            Functions for matching file names with patterns. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.s_invalidPathChars">
            <summary>
            Cache of the list of invalid path characters, because this method returns a clone (for security reasons)
            which can cause significant transient allocations
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.Default">
            <summary>
            The Default FileMatcher does not cache directory enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.FileSystemEntity">
            <summary>
            The type of entity that GetFileSystemEntries should return.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.GetFileSystemEntries">
            <summary>
            Delegate defines the GetFileSystemEntries signature that GetLongPathName uses
            to enumerate directories on the file system.
            </summary>
            <param name="entityType">Files, Directories, or Files and Directories</param>
            <param name="path">The path to search.</param>
            <param name="pattern">The file pattern.</param>
            <param name="projectDirectory"></param>
            <param name="stripProjectDirectory"></param>
            <returns>An immutable array of filesystem entries.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.HasWildcards(System.String)">
            <summary>
            Determines whether the given path has any wild card characters.
            </summary>
            <param name="filespec"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.HasWildcardsSemicolonItemOrPropertyReferences(System.String)">
            <summary>
            Determines whether the given path has any wild card characters or any semicolons.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFileSystemEntries(Microsoft.Build.Shared.FileSystem.IFileSystem,Microsoft.Build.Shared.FileMatcher.FileSystemEntity,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get the files and\or folders specified by the given path and pattern.
            </summary>
            <param name="entityType">Whether Files, Directories or both.</param>
            <param name="path">The path to search.</param>
            <param name="pattern">The pattern to search.</param>
            <param name="projectDirectory">The directory for the project within which the call is made</param>
            <param name="stripProjectDirectory">If true the project directory should be stripped</param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFilesAndDirectories(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String)">
            <summary>
            Returns an immutable array of file system entries matching the specified search criteria. Inaccessible or non-existent file
            system entries are skipped.
            </summary>
            <param name="path"></param>
            <param name="pattern"></param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>An immutable array of matching file system entries (can be empty).</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.ShouldEnforceMatching(System.String)">
            <summary>
            Determine if the given search pattern will match loosely on Windows
            </summary>
            <param name="searchPattern">The search pattern to check</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFiles(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Same as Directory.EnumerateFiles(...) except that files that
            aren't accessible are skipped instead of throwing an exception.
            
            Other exceptions are passed through.
            </summary>
            <param name="path">The path.</param>
            <param name="filespec">The pattern.</param>
            <param name="projectDirectory">The project directory</param>
            <param name="stripProjectDirectory"></param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>Files that can be accessed.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleDirectories(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String)">
            <summary>
            Same as Directory.EnumerateDirectories(...) except that files that
            aren't accessible are skipped instead of throwing an exception.
            
            Other exceptions are passed through.
            </summary>
            <param name="path">The path.</param>
            <param name="pattern">Pattern to match</param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>Accessible directories.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetLongPathName(System.String)">
            <summary>
            Given a path name, get its long version.
            </summary>
            <param name="path">The short path.</param>
            <returns>The long path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetLongPathName(System.String,Microsoft.Build.Shared.FileMatcher.GetFileSystemEntries)">
            <summary>
            Given a path name, get its long version.
            </summary>
            <param name="path">The short path.</param>
            <param name="getFileSystemEntries">Delegate.</param>
            <returns>The long path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.SplitFileSpec(System.String,System.String@,System.String@,System.String@)">
            <summary>
            Given a filespec, split it into left-most 'fixed' dir part, middle 'wildcard' dir part, and filename part.
            The filename part may have wildcard characters in it.
            </summary>
            <param name="filespec">The filespec to be decomposed.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.PreprocessFileSpecForSplitting(System.String,System.String@,System.String@,System.String@)">
            <summary>
            Do most of the grunt work of splitting the filespec into parts.
            Does not handle post-processing common to the different matching
            paths.
            </summary>
            <param name="filespec">The filespec to be decomposed.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RemoveInitialDotSlash(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Removes the leading ".\" from all of the paths in the array. 
            </summary>
            <param name="paths">Paths to remove .\ from.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsDirectorySeparator(System.Char)">
            <summary>
            Checks if the char is a DirectorySeparatorChar or a AltDirectorySeparatorChar
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RemoveProjectDirectory(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Removes the current directory converting the file back to relative path 
            </summary>
            <param name="paths">Paths to remove current directory from.</param>
            <param name="projectDirectory"></param>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.Filespec">
            <summary>
            The filespec.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.RegexFileMatch">
            <summary>
            Wild-card matching.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.NeedsRecursion">
            <summary>
            If true, then recursion is required.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.BaseDirectory">
            <summary>
            The directory to search in
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.RemainingWildcardDirectory">
            <summary>
            The remaining, wildcard part of the directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.SearchData">
            <summary>
            Data about a search that does not change as the search recursively traverses directories
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFilesRecursive(System.Collections.Concurrent.ConcurrentStack{System.Collections.Generic.List{System.String}},Microsoft.Build.Shared.FileMatcher.RecursionState,System.String,System.Boolean,System.Collections.Generic.IList{Microsoft.Build.Shared.FileMatcher.RecursionState},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.Build.Shared.FileMatcher.RecursionState}},Microsoft.Build.Shared.FileMatcher.TaskOptions)">
            <summary>
            Get all files that match either the file-spec or the regular expression. 
            </summary>
            <param name="listOfFiles">List of files that gets populated.</param>
            <param name="recursionState">Information about the search</param>
            <param name="projectDirectory"></param>
            <param name="stripProjectDirectory"></param>
            <param name="searchesToExclude">Patterns to exclude from the results</param>
            <param name="searchesToExcludeInSubdirs">exclude patterns that might activate farther down the directory tree. Keys assume paths are normalized with forward slashes and no trailing slashes</param>
            <param name="taskOptions">Options for tuning the parallelization of subdirectories</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RegularExpressionFromFileSpec(System.String,System.String,System.String,System.Boolean@)">
            <summary>
            Given a split file spec consisting of a directory without wildcard characters,
            a sub-directory containing wildcard characters,
            and a filename which may contain wildcard characters,
            create a regular expression that will match that file spec.
            
            PERF WARNING: this method is called in performance-critical
            scenarios, so keep it fast and cheap
            </summary>
            <param name="fixedDirectoryPart">The fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
            <param name="isLegalFileSpec">Receives whether this pattern is legal or not.</param>
            <returns>The regular expression string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsLegalFileSpec(System.String,System.String)">
            <summary>
            Determine if the filespec is legal according to the following conditions:
            
            (1) It is not legal for there to be a ".." after a wildcard.
            
            (2) By definition, "**" must appear alone between directory slashes.If there is any remaining "**" then this is not
                a valid filespec.
            </summary>
            <returns>True if both parts meet all conditions for a legal filespec.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromFixedDirectory(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the fixed directory part of a filespec:
            
             (1) The leading \\ in UNC paths, so that the doubled slash isn't reduced in the last step
             
             (2) Common filespec characters
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromWildcardDirectory(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the wildcard directory part of a filespec:
            
             (1) The leading **\ if existing
            
             (2) Each occurrence of recursive wildcard \**\
             
             (3) Common filespec characters
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromFilename(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the filename part of a filespec:
            
             (1) Trailing dots in file names have to be treated specially.
                 We want:
            
                     *. to match foo
            
                 but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful
                 not to match 'foo.txt' by modifying the generated regex for wildcard characters * and ?
             
             (2) Common filespec characters
            
             (3) Ignore the .* portion of any *.* sequence when no trailing dot exists
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromChar(Microsoft.Build.Shared.ReuseableStringBuilder,System.Char)">
            <summary>
            Append the regex equivalents for characters common to all filespec parts.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.LastIndexOfDirectorySequence(System.String,System.Int32)">
             <summary>
             Given an index at a directory separator,
             iteratively skip to the end of two sequences:
            
              (1) \.\ -> \
                 This is an identity, so for example, these two are equivalent,
            
                     dir1\.\dir2 == dir1\dir2
             
                 (2) \\ -> \
                     Double directory separators are treated as a single directory separator,
                     so, for example, this is an identity:
            
                         f:\dir1\\dir2 == f:\dir1\dir2
            
                     The single exemption is for UNC path names, like this:
            
                         \\server\share != \server\share
             
                     This case is handled by isUncPath in
                     a prior step.
            
             </summary>
             <returns>The last index of a directory sequence.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.LastIndexOfDirectoryOrRecursiveSequence(System.String,System.Int32)">
             <summary>
             Given an index at a directory separator or start of a recursive operator,
             iteratively skip to the end of three sequences:
             
             (1), (2) Both sequences handled by IndexOfNextNonCollapsibleChar
             
             (3) \**\**\ -> \**\
                          This is an identity, so for example, these two are equivalent,
            
                             dir1\**\**\ == dir1\**\
             </summary>
             <returns>]
             If starting at a recursive operator, the last index of a recursive sequence.
             Otherwise, the last index of a directory sequence.
             </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFileSpecInfoWithRegexObject(System.String,System.Text.RegularExpressions.Regex@,System.Boolean@,System.Boolean@)">
            <summary>
            Given a filespec, get the information needed for file matching. 
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="regexFileMatch">Receives the regular expression.</param>
            <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
            <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFileSpecInfo(System.String,System.String@,System.String@,System.String@,System.String@,System.Boolean@,System.Boolean@,Microsoft.Build.Shared.FileMatcher.FixupParts)">
            <summary>
            Given a filespec, parse it and construct the regular expression string.
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">Receives the wildcard directory part.</param>
            <param name="filenamePart">Receives the filename part.</param>
            <param name="matchFileExpression">Receives the regular expression.</param>
            <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
            <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
            <param name="fixupParts">hook method to further change the parts</param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.Result">
            <summary>
            The results of a match between a filespec and a file name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.Result.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsMatch(System.String,System.String,System.Boolean)">
            <summary>
            A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
            </summary>
            <param name="input">String which is matched against the pattern.</param>
            <param name="pattern">Pattern against which string is matched.</param>
            <param name="ignoreCase">Determines whether ignoring case when comparing two characters</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.FileMatch(System.String,System.String)">
            <summary>
            Given a pattern (filespec) and a candidate filename (fileToMatch)
            return matching information.
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="fileToMatch">The candidate to match against.</param>
            <returns>The result class.</returns>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.MaxTasks">
            <summary>
            The maximum number of tasks that are allowed to run concurrently
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.AvailableTasks">
            <summary>
            The number of currently available tasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.MaxTasksPerIteration">
            <summary>
            The maximum number of tasks that Parallel.ForEach may use
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFiles(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Given a filespec, find the files that match. 
            Will never throw IO exceptions: if there is no match, returns the input verbatim.
            </summary>
            <param name="projectDirectoryUnescaped">The project directory.</param>
            <param name="filespecUnescaped">Get files that match the given file spec.</param>
            <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
            <returns>The array of files.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.Normalize(System.String)">
            <summary>
            Replace all slashes to the OS slash, collapse multiple slashes into one, trim trailing slashes
            </summary>
            <param name="aString">A string</param>
            <returns>The normalized string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.SkipCharacters(System.String,System.Int32,System.Func{System.Char,System.Boolean})">
            <summary>
            Skips characters that satisfy the condition <param name="jumpOverCharacter"></param>
            </summary>
            <param name="aString">The working string</param>
            <param name="startingIndex">Offset in string to start the search in</param>
            <returns>First index that does not satisfy the condition. Returns the string's length if end of string is reached</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsValidDriveChar(System.Char)">
            <summary>
            Returns true if the given character is a valid drive letter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFilesImplementation(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Given a filespec, find the files that match. 
            Will never throw IO exceptions: if there is no match, returns the input verbatim.
            </summary>
            <param name="projectDirectoryUnescaped">The project directory.</param>
            <param name="filespecUnescaped">Get files that match the given file spec.</param>
            <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
            <returns>The array of files.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.VersionUtilities">
            <summary>
            Set of methods to deal with versions in the tasks
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.ConvertToVersion(System.String)">
            <summary>
            Convert a version number like 0.0.0.0 to a Version instance.
            The method will return null if the string is not a valid value
            </summary>
            <param name="version">Version string to convert to a version object</param>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.GatherVersionStrings(System.Version,System.Collections.IEnumerable)">
            <summary>
            Go though an enumeration and create a sorted list of strings which can be parsed as versions. Keep around the original 
            string because it may contain a v and this would be required to create the correct path on disk if the string was part of a path.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.ConvertToVersion(System.String,System.Boolean)">
            <summary>
             Convert a version number like 0.0.0.0 to a Version instance.
            </summary>
            <param name="version"></param>
            <param name="throwException">Should we use Parse to TryParse (parse means we throw an exception, tryparse means we will not).</param>
        </member>
        <member name="F:Microsoft.Build.Shared.ReverseStringGenericComparer.Comparer">
            <summary>
            Static accessor for a ReverseVersionGenericComparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReverseStringGenericComparer.System#Collections#Generic#IComparer{System#String}#Compare(System.String,System.String)">
            <summary>
            The Compare implements a reverse comparison
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReverseVersionGenericComparer.Comparer">
            <summary>
            Static accessor for a ReverseVersionGenericComparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReverseVersionGenericComparer.System#Collections#Generic#IComparer{System#Version}#Compare(System.Version,System.Version)">
            <summary>
            The Compare implements a reverse comparison
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioConstants">
            <summary>
            Shared Visual Studio related constants
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.VisualStudioConstants.CurrentVisualStudioSolutionFileVersion">
            <summary>
            This is the version number of the most recent solution file format
            we will read. It will be the version number used in solution files
            by the latest version of Visual Studio.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.VisualStudioConstants.CurrentVisualStudioVersion">
            <summary>
            This is the version number of the latest version of Visual Studio.
            </summary>
            <remarks>
            We use it for the version of the VC PIA we try to load and to find
            Visual Studio registry hive that we use to find where vcbuild.exe might be.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioLocationHelper">
            <summary>
            Helper class to wrap the Microsoft.VisualStudio.Setup.Configuration.Interop API to query
            Visual Studio setup for instances installed on the machine.
            Code derived from sample: https://code.msdn.microsoft.com/Visual-Studio-Setup-0cedd331
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VisualStudioLocationHelper.GetInstances">
            <summary>
            Query the Visual Studio setup API to get instances of Visual Studio installed
            on the machine. Will not include anything before Visual Studio "15".
            </summary>
            <returns>Enumerable list of Visual Studio instances</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioInstance">
            <summary>
            Wrapper class to represent an installed instance of Visual Studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Version">
            <summary>
            Version of the Visual Studio Instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Path">
            <summary>
            Path to the Visual Studio installation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Name">
            <summary>
            Full name of the Visual Studio instance with SKU name
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.PartialComparisonFlags">
            <summary>
            Specifies the parts of the assembly name to partially match
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.SimpleName">
            <summary>
            Compare SimpleName  A.PartialCompare(B,SimpleName)  match the simple name on A and B if the simple name on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.Version">
            <summary>
            Compare Version A.PartialCompare(B, Version)  match the Version on A and B if the Version on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.Culture">
            <summary>
            Compare Culture A.PartialCompare(B, Culture)  match the Culture on A and B if the Culture on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.PublicKeyToken">
            <summary>
            Compare PublicKeyToken A.PartialCompare(B, PublicKeyToken)  match the PublicKeyToken on A and B if the PublicKeyToken on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.Default">
            <summary>
            When doing a comparison   A.PartialCompare(B, Default) compare all fields of A which are not null with B.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyNameExtension">
            <summary>
            A replacement for AssemblyName that optimizes calls to FullName which is expensive.
            The assembly name is represented internally by an AssemblyName and a string, conversion
            between the two is done lazily on demand.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameExtension.remappedFrom">
            <summary>
            Set of assemblyNameExtensions that THIS assemblyname was remapped from.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor">
            <summary>
            Construct an unnamed assembly.
            Private because we want only one of these.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.Reflection.AssemblyName)">
            <summary>
            Construct with AssemblyName.
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.String)">
            <summary>
            Construct with string.
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.String,System.Boolean)">
            <summary>
            Construct from a string, but immediately construct a real AssemblyName.
            This will cause an exception to be thrown up front if the assembly name 
            isn't well formed.
            </summary>
            <param name="assemblyName">
            The string version of the assembly name.
            </param>
            <param name="validate">
            Used when the assembly name comes from a user-controlled source like a project file or config file.
            Does extra checking on the assembly name and will throw exceptions if something is invalid.
            </param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Ctor for deserializing from state file (binary serialization).
            <remarks>This is required because AssemblyName is not Serializable on .NET Core.</remarks>
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetAssemblyNameEx(System.String)">
            <summary>
            To be used as a delegate. Gets the AssemblyName of the given file.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.SetRemappedFromDefaultAfterSerialization(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Run after the object has been deserialized
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.InitializeRemappedFrom">
            <summary>
            Initialize the remapped from structure.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CreateAssemblyName">
            <summary>
            Assume there is a string version, create the AssemblyName version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CreateFullName">
            <summary>
            Assume there is a string version, create the AssemblyName version.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Name">
            <summary>
            The base name of the assembly.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.ProcessorArchitecture">
            <summary>
            Gets the backing AssemblyName, this can be None.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Version">
            <summary>
            The assembly's version number.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.IsSimpleName">
            <summary>
            Is the assembly a complex name or a simple name. A simple name is where only the name is set 
            a complex name is where the version, culture or publickeytoken is also set
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.HasProcessorArchitectureInFusionName">
            <summary>
            Does the fullName have the processor architecture defined
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ReplaceVersion(System.Version)">
            <summary>
            Replace the current version with a new version.
            </summary>
            <param name="version"></param>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.CultureInfo">
            <summary>
            The assembly's Culture
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Retargetable">
            <summary>
            The assembly's retargetable bit
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.RemappedFromEnumerator">
            <summary>
            The full name of the original extension we were before being remapped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.AddRemappedAssemblyName(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Add an assemblyNameExtension which represents an assembly name which was mapped to THIS assemblyName.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.AssemblyName">
            <summary>
            As an AssemblyName
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.FullName">
            <summary>
            The assembly's full name.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetPublicKeyToken">
            <summary>
            Get the assembly's public key token.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.UnnamedAssembly">
            <summary>
            A special "unnamed" instance of AssemblyNameExtension.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareTo(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare one assembly name to another.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareTo(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean)">
            <summary>
            Compare one assembly name to another.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetHashCode">
            <summary>
            Get a hash code for this assembly name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareBaseNameTo(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare two base names as quickly as possible.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareBaseNameToImpl(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            An implementation of compare that compares two base 
            names as quickly as possible.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareBaseNamesStringWise(System.String,System.String)">
            <summary>
            Compare two basenames.
            </summary>
            <param name="asString1"></param>
            <param name="asString2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.Clone">
            <summary>
            Clone this assemblyNameExtension
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CloneImmutable">
            <summary>
            Clone the object but mark and mark the cloned object as immutable
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Immutable">
            <summary>
            Is this object immutable
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.MarkImmutable">
            <summary>
            Mark this object as immutable
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.Equals(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare two assembly names for equality.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.System#IEquatable{Microsoft#Build#Shared#AssemblyNameExtension}#Equals(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Interface method for IEquatable&lt;AssemblyNameExtension&gt;
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.EqualsIgnoreVersion(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare two assembly names for equality ignoring version.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.Equals(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean)">
            <summary>
            Compare two assembly names and consider the retargetable flag during the comparison
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.EqualsImpl(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean,System.Boolean)">
            <summary>
            Compare two assembly names for equality.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareCultures(System.Reflection.AssemblyName,System.Reflection.AssemblyName)">
            <summary>
            Allows the comparison of the culture.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ComparePublicKeyToken(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
             Allows the comparison of just the PublicKeyToken
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ComparePublicKeyTokens(System.Byte[],System.Byte[])">
            <summary>
            Compare two public key tokens.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.IsUnnamedAssembly">
            <summary>
            Only the unnamed assembly has both null assemblyname and null string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetAssemblyNameFromDisplayName(System.String)">
            <summary>
            Given a display name, construct an assembly name.
            </summary>
            <param name="displayName">The display name.</param>
            <returns>The assembly name.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.EscapeDisplayNameCharacters(System.String)">
            <summary>
            Return a string that has AssemblyName special characters escaped. 
            Those characters are Equals(=), Comma(,), Quote("), Apostrophe('), Backslash(\).
            </summary>
            <remarks>
            WARNING! This method is not meant as a general purpose escaping method for assembly names.
            Use only if you really know that this does what you need.
            </remarks>
            <param name="displayName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ToString">
            <summary>
            Convert to a string for display.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare the fields of this with that if they are not null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean)">
            <summary>
            Compare the fields of this with that if they are not null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.PartialComparisonFlags)">
            <summary>
            Do a partial comparison between two assembly name extensions.
            Compare the fields of A and B on the following conditions:
            1) A.Field has a non null value 
            2) The field has been selected in the comparison flags or the default comparison flags are passed in.
            
            If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.PartialComparisonFlags,System.Boolean)">
            <summary>
            Do a partial comparison between two assembly name extensions.
            Compare the fields of A and B on the following conditions:
            1) A.Field has a non null value 
            2) The field has been selected in the comparison flags or the default comparison flags are passed in.
            
            If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.EncodingUtilities">
            <summary>
            This class contains utility methods for dealing with encoding.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.EncodingUtilities.CurrentSystemOemEncoding">
            <summary>
            Get the current system locale code page, OEM version. OEM code pages are used for console-based input/output
            for historical reasons.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.SimilarToEncoding(System.Text.Encoding,System.Text.Encoding)">
            <summary>
            Checks two encoding types to determine if they are similar to each other (equal or if
            the Encoding Name is the same).
            </summary>
            <param name="encoding1"></param>
            <param name="encoding2"></param>
            <returns>True if the two Encoding objects are equal or similar.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.IsUtf8Encoding(System.Text.Encoding)">
            <summary>
            Check if an encoding type is UTF8 (with or without BOM).
            </summary>
            <param name="encoding"></param>
            <returns>True if the encoding is UTF8.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.StartsWithPreamble(System.IO.Stream)">
            <summary>
            Check the first 3 bytes of a stream to determine if it matches the UTF8 preamble.
            </summary>
            <param name="stream">Steam to check.</param>
            <returns>True when the first 3 bytes of the Stream are equal to the UTF8 preamble (BOM).</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.StartsWithPreamble(System.IO.Stream,System.Byte[])">
            <summary>
            Check the first 3 bytes of a stream to determine if it matches the given preamble.
            </summary>
            <param name="stream">Steam to check.</param>
            <param name="preamble">Preamble to look for.</param>
            <returns>True when the first 3 bytes of the Stream are equal to the preamble.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.FileStartsWithPreamble(System.String)">
            <summary>
            Check the first 3 bytes of a file to determine if it matches the 3-byte UTF8 preamble (BOM).
            </summary>
            <param name="file">Path to file to check.</param>
            <returns>True when the first 3 bytes of the file are equal to the UTF8 BOM.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.CanEncodeString(System.Int32,System.String)">
            <summary>
            Checks to see if a string can be encoded in a specified code page.
            </summary>
            <remarks>Internal for testing purposes.</remarks>
            <param name="codePage">Code page for encoding.</param>
            <param name="stringToEncode">String to encode.</param>
            <returns>True if the string can be encoded in the specified code page.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.BatchFileEncoding(System.String,System.String)">
             <summary>
             Find the encoding for the batch file.
             </summary>
             <remarks>
             The "best" encoding is the current OEM encoding, unless it's not capable of representing
             the characters we plan to put in the file. If it isn't, we can fall back to UTF-8.
            
             Why not always UTF-8? Because tools don't always handle it well. See
             https://github.com/Microsoft/msbuild/issues/397
             </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.ErrorUtilities">
            <summary>
            This class contains methods that are useful for error checking and validation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ErrorUtilities.s_throwExceptions">
            <summary>
            Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
            and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
            then we can give them this undocumented environment variable as an immediate workaround.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Object[])">
            <summary>
            Throws InternalErrorException. 
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Exception,System.Object[])">
            <summary>
            Throws InternalErrorException. 
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalErrorUnreachable">
            <summary>
            Throws InternalErrorException. 
            Indicates the code path followed should not have been possible.
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowIfTypeDoesNotImplementToString(System.Object)">
            <summary>
            Throws InternalErrorException. 
            Indicates the code path followed should not have been possible.
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalNull(System.Object,System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is null.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="parameter">The value of the argument.</param>
            <param name="parameterName">Parameter that should not be null</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalLockHeld(System.Object)">
            <summary>
            Helper to throw an InternalErrorException when a lock on the specified object is not already held.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="locker">The object that should already have been used as a lock.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalLength(System.String,System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is null or zero length.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="parameterValue">The value of the argument.</param>
            <param name="parameterName">Parameter that should not be null or zero length</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalRooted(System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is not a rooted path.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="value">Parameter that should be a rooted path</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String)">
            <summary>
            This method should be used in places where one would normally put
            an "assert". It should be used to validate that our assumptions are
            true, where false would indicate that there must be a bug in our
            code somewhere. This should not be used to throw errors based on bad
            user input or anything that the user did wrong.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInvalidOperation(System.String,System.Object[])">
            <summary>
            Throws an InvalidOperationException with the specified resource string
            </summary>
            <param name="resourceName">Resource to use in the exception</param>
            <param name="args">Formatting args.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String)">
            <summary>
            Throws an InvalidOperationException if the given condition is false.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgument(System.String,System.Object[])">
            <summary>
            Throws an ArgumentException that can include an inner exception.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgument(System.Exception,System.String,System.Object[])">
            <summary>
            Throws an ArgumentException that can include an inner exception.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>
            This method is thread-safe.
            </remarks>
            <param name="innerException">Can be null.</param>
            <param name="resourceName"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String)">
            <summary>
            Throws an ArgumentException if the given condition is false.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String)">
            <summary>
            Throws an ArgumentException that includes an inner exception, if
            the given condition is false.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException">Can be null.</param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgumentOutOfRange(System.String)">
            <summary>
            Throws an argument out of range exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentOutOfRange(System.Boolean,System.String)">
            <summary>
            Throws an ArgumentOutOfRangeException using the given parameter name
            if the condition is false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentLength(System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given string parameter is null
            and ArgumentException if it has zero length.
            </summary>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentInvalidPath(System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given string parameter is null
            and ArgumentException if it has zero length.
            </summary>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(System.String,System.String)">
            <summary>
            Throws an ArgumentException if the string has zero length, unless it is 
            null, in which case no exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentNull(System.Object,System.String)">
            <summary>
            Throws an ArgumentNullException if the given parameter is null.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentNull(System.Object,System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given parameter is null.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentArraysSameLength(System.Array,System.Array,System.String,System.String)">
            <summary>
            Verifies the given arrays are not null and have the same length
            </summary>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="parameter1Name"></param>
            <param name="parameter2Name"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.ConversionUtilities">
            <summary>
            This class contains only static methods, which are useful throughout many
            of the MSBuild classes and don't really belong in any specific class.   
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertStringToBool(System.String)">
            <summary>
            Converts a string to a bool.  We consider "true/false", "on/off", and 
            "yes/no" to be valid boolean representations in the XML.
            </summary>
            <param name="parameterValue">The string to convert.</param>
            <returns>Boolean true or false, corresponding to the string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertByteArrayToHex(System.Byte[])">
            <summary>
            Returns a hex representation of a byte array.
            </summary>
            <param name="bytes">The bytes to convert</param>
            <returns>A string byte types formated as X2.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.CanConvertStringToBool(System.String)">
            <summary>
            Returns true if the string can be successfully converted to a bool,
            such as "on" or "yes"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidBooleanTrue(System.String)">
            <summary>
            Returns true if the string represents a valid MSBuild boolean true value,
            such as "on", "!false", "yes"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidBooleanFalse(System.String)">
            <summary>
            Returns true if the string represents a valid MSBuild boolean false value,
            such as "!on" "off" "no" "!true"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertDecimalToDouble(System.String)">
            <summary>
            Converts a string like "123.456" into a double. Leading sign is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertHexToDouble(System.String)">
            <summary>
            Converts a hex string like "0xABC" into a double.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertDecimalOrHexToDouble(System.String)">
            <summary>
            Converts a string like "123.456" or "0xABC" into a double.
            Tries decimal conversion first.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidHexNumber(System.String)">
            <summary>
            Returns true if the string is a valid hex number, like "0xABC"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidDecimalNumber(System.String)">
            <summary>
            Returns true if the string is a valid decimal number, like "-123.456"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidDecimalOrHexNumber(System.String)">
            <summary>
            Returns true if the string is a valid decimal or hex number
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilitiesRegex">
            <summary>
            This class contains utility methods for file IO.
            Separate from FileUtilities because some assemblies may only need the patterns.
            PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
            each class get pulled into the resulting assembly.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsDrivePattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsDrivePatternWithSlash(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithDrivePattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithDrivePatternWithSlash(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsUncPattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithUncPattern(System.String)" -->
        <member name="M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithUncPatternMatchLength(System.String)">
            <summary>
            Indicates whether the file-spec begins with a UNC pattern and how long the match is. -1 indicates no match.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilitiesRegex.MeetsUncPatternMinimumRequirements(System.String)">
            <summary>
            Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
            UNC pattern requires a minimum length of 5 and first two characters must be a slash.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Shared.InternalErrorException">
            <summary>
            This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
            exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
            did wrong.
            
            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
            WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
                     Don't throw this exception from one assembly and catch it in another.
            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
                
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor">
            <summary>
            Default constructor.
            SHOULD ONLY BE CALLED BY DESERIALIZER. 
            SUPPLY A MESSAGE INSTEAD.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.String)">
            <summary>
            Creates an instance of this exception using the given message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using the given message and inner exception.
            Adds the inner exception's details to the exception message because most bug reporters don't bother
            to provide the inner exception details which is typically what we care about.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor used for (de)serialization. The constructor is private as this class is sealed
            If we ever add new members to this class, we'll need to update this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.ConsiderDebuggerLaunch(System.String,System.Exception)">
            <summary>
            A fatal internal error due to a bug has occurred. Give the dev a chance to debug it, if possible.
            
            Will in all cases launch the debugger, if the environment variable "MSBUILDLAUNCHDEBUGGER" is set.
            
            In DEBUG build, will always launch the debugger, unless we are in razzle (_NTROOT is set) or in NUnit,
            or MSBUILDDONOTLAUNCHDEBUGGER is set (that could be useful in suite runs).
            We don't launch in retail or LKG so builds don't jam; they get a callstack, and continue or send a mail, etc.
            We don't launch in NUnit as tests often intentionally cause InternalErrorExceptions.
            
            Because we only call this method from this class, just before throwing an InternalErrorException, there is 
            no danger that this suppression will cause a bug to only manifest itself outside NUnit
            (which would be most unfortunate!). Do not make this non-private.
            
            Unfortunately NUnit can't handle unhandled exceptions like InternalErrorException on anything other than
            the main test thread. However, there's still a callstack displayed before it quits.
            
            If it is going to launch the debugger, it first does a Debug.Fail to give information about what needs to
            be debugged -- the exception hasn't been thrown yet. This automatically displays the current callstack.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ResourceUtilities">
            <summary>
            This class contains utility methods for dealing with resources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.ExtractMessageCode(System.Boolean,System.String,System.String@)">
            <summary>
            Extracts the message code (if any) prefixed to the given string. 
            <![CDATA[
            MSBuild codes match "^\s*(?<CODE>MSB\d\d\d\d):\s*(?<MESSAGE>.*)$"
            Arbitrary codes match "^\s*(?<CODE>[A-Za-z]+\d+):\s*(?<MESSAGE>.*)$"
            ]]>
            Thread safe.
            </summary>
            <param name="msbuildCodeOnly">Whether to match only MSBuild error codes, or any error code.</param>
            <param name="message">The string to parse.</param>
            <param name="code">[out] The message code, or null if there was no code.</param>
            <returns>The string without its message code prefix, if any.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.GetHelpKeyword(System.String)">
            <summary>
            Retrieves the MSBuild F1-help keyword for the given resource string. Help keywords are used to index help topics in
            host IDEs.
            </summary>
            <param name="resourceName">Resource string to get the MSBuild F1-keyword for.</param>
            <returns>The MSBuild F1-help keyword string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.GetResourceString(System.String)">
            <summary>
            Retrieves the contents of the named resource string.
            </summary>
            <param name="resourceName">Resource string name.</param>
            <returns>Resource string contents.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringStripCodeAndKeyword(System.String@,System.String@,System.String,System.Object[])">
            <summary>
            Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
            message code and help keyword associated with it, they too are returned.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="code">[out] The MSBuild message code, or null.</param>
            <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
            <param name="resourceName">Resource string to load.</param>
            <param name="args">Optional arguments for formatting the resource string.</param>
            <returns>The formatted resource string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringStripCodeAndKeyword(System.String,System.Object[])">
            <summary>
            Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
            message code and help keyword associated with it, they are discarded.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="resourceName">Resource string to load.</param>
            <param name="args">Optional arguments for formatting the resource string.</param>
            <returns>The formatted resource string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(System.String,System.Object[])">
            <summary>
            Formats the resource string with the given arguments.
            Ignores error codes and keywords
            </summary>
            <param name="resourceName"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatString(System.String,System.Object[])">
            <summary>
            Formats the given string using the variable arguments passed in.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            
            Thread safe.
            </summary>
            <param name="unformatted">The string to format.</param>
            <param name="args">Optional arguments for formatting the given string.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.VerifyResourceStringExists(System.String)">
            <summary>
            Verifies that a particular resource string actually exists in the string table. This will only be called in debug
            builds. It helps catch situations where a dev calls VerifyThrowXXX with a new resource string, but forgets to add the
            resource string to the string table, or misspells it!
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="resourceName">Resource string to check.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyResources">
            <summary>
            This class provides access to the assembly's resources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.GetString(System.String)">
            <summary>
            Loads the specified resource string, either from the assembly's primary resources, or its shared resources.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <returns>The resource string, or null if not found.</returns>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyResources.PrimaryResources">
            <summary>
            Gets the assembly's primary resources i.e. the resources exclusively owned by this assembly.
            </summary>
            <remarks>This property is thread-safe.</remarks>
            <value>ResourceManager for primary resources.</value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyResources.SharedResources">
            <summary>
            Gets the assembly's shared resources i.e. the resources this assembly shares with other assemblies.
            </summary>
            <remarks>This property is thread-safe.</remarks>
            <value>ResourceManager for shared resources.</value>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig._directoryNames">
            <summary>
            The list of directory names found from the config file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig.#ctor(System.String,System.String,System.Reflection.ProcessorArchitecture)">
            <summary>
            Construct.
            </summary>
            <param name="configFile">The path to the config file.</param>
            <param name="targetRuntimeVersion">The runtime version property from the project file.</param>
            <param name="targetArchitecture">The <see cref="T:System.Reflection.ProcessorArchitecture"/> to target.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig.System#Collections#Generic#IEnumerable{Microsoft#Build#Utilities#AssemblyFoldersFromConfigInfo}#GetEnumerator">
            <summary>
            Get Enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache">
            <summary>
            Contains information about entries in the AssemblyFoldersEx registry keys.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache._filesInDirectories">
            <summary>
            Set of files in ALL AssemblyFolderFromConfig directories
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache._fileExists">
            <summary>
            File exists delegate we are replacing
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache._useOriginalFileExists">
            <summary>
            Should we use the original on or use our own
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache.#ctor(Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig,Microsoft.Build.Shared.FileExists)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache.AssemblyFoldersFromConfig">
            <summary>
            AssemblyfoldersEx object which contains the set of directories in assmblyfoldersFromConfig
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache.FileExists(System.String)">
            <summary>
             Fast file exists for AssemblyFoldersFromConfig.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver">
            <summary>
            Resolve search path type {AssemblyFolderFromConfig: *}
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver.s_crackAssemblyFoldersFromConfigSentinel">
            <summary>
                Regex for breaking up the search path pieces.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver._wasMatch">
            <summary>
            Whether or not the search path could be cracked.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver._targetRuntimeVersion">
            <summary>
            From the search path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver._isInitialized">
            <summary>
            Whether regex initialization has happened.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver._assemblyFoldersCache">
            <summary>
            List of assembly folders to search for keys in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver._buildEngine">
            <summary>
            BuildEngine
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver._taskLogger">
            <summary>
            Task log context.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver._assemblyFolderConfigFile">
            <summary>
            Path to the assembly folder config file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver.AssemblyFoldersExLocations">
            <summary>
            If it is not initialized then just return the null object, that would mean the resolver was not called.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver.#ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,System.Reflection.ProcessorArchitecture,System.Boolean,Microsoft.Build.Framework.IBuildEngine,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver.LazyInitialize">
            <summary>
            Initialize this class if it hasn't been initialized yet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="sdkName">Not used by this type.</param>
            <param name="rawFileNameCandidate">Not used by this type.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">Not used by this type.</param>
            <param name="assemblyFolderKey">Not used by this type.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyDependency.AssemblyMetadata">
            <summary>
            Information about a managed assembly.
            </summary>
            <remarks>
            After initial construction, this object is readonly and data-only,
            allowing it to be safely cached.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Tasks.ConvertToAbsolutePath">
            <summary>
            Task to call Path.GetFullPath
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths">
            <summary>
            The list of paths to convert to absolute paths.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths">
            <summary>
            This is the output of the task, a list of absolute paths for the items passed in
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ConvertToAbsolutePath.Execute">
            <summary>
            Calls Path.GetFullPath for each of the inputs.  Preserves metadata.
            </summary>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.PropertyParser.GetTable(Microsoft.Build.Utilities.TaskLoggingHelper,System.String,System.String[],System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
            a hash table containing the property names as keys and the property values as values.  
            </summary>
            <returns>true on success, false on failure.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.PropertyParser.GetTableWithEscaping(Microsoft.Build.Utilities.TaskLoggingHelper,System.String,System.String,System.String[],System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
            a hash table containing the property names as keys and the property values as values.  
            This method escapes any special characters found in the property values, in case they 
            are going to be passed to a method (such as that expects the appropriate escaping to have happened
            already.
            </summary>
            <returns>true on success, false on failure.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.PropertyParser.PropertyNameValuePair">
            <summary>
            A very simple class that holds two strings, a property name and property value.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.PropertyParser.PropertyNameValuePair.Name">
            <summary>
            Property name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.PropertyParser.PropertyNameValuePair.Value">
            <summary>
            Property value
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.TaskLoggingHelperExtension">
            <summary>
            Helper logging class for tasks, used for dealing with two resource streams.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.TaskLoggingHelperExtension.#ctor(Microsoft.Build.Framework.ITask,System.Resources.ResourceManager,System.Resources.ResourceManager,System.String)">
            <summary>
            public constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources">
            <summary>
            Used to load culture-specific resources. Derived classes should register their resources either during construction, or
            via this property, if they have localized strings.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.TaskLoggingHelperExtension.FormatResourceString(System.String,System.Object[])">
            <summary>
            Loads the specified resource string and optionally formats it using the given arguments. The current thread's culture
            is used for formatting.
            </summary>
            <remarks>
            1) This method requires the owner task to have registered its resources either via the Task (or TaskMarshalByRef) base
               class constructor, or the "Task.TaskResources" (or "AppDomainIsolatedTask.TaskResources") property.
            2) This method is thread-safe.
            </remarks>
            <param name="resourceName">The name of the string resource to load.</param>
            <param name="args">Optional arguments for formatting the loaded string.</param>
            <returns>The formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>resourceName</c> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the string resource indicated by <c>resourceName</c> does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
        </member>
        <member name="T:Microsoft.Build.Tasks.AppConfig">
            <summary>
            Read information from application .config files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AppConfig.Load(System.String)">
            <summary>
            Read the .config from a file.
            </summary>
            <param name="appConfigFile"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AppConfig.Read(System.Xml.XmlReader)">
            <summary>
            Read the .config from an XmlReader
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:Microsoft.Build.Tasks.AppConfig.Runtime">
            <summary>
            Access the Runtime section of the application .config file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AppConfig.StringEquals(System.String,System.String)">
            <summary>
            App.config files seem to come with mixed casing for element and attribute names.
            If the fusion loader can handle this then this code should too.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.AppConfigException">
            <summary>
            An exception thrown while parsing through an app.config.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AppConfigException.fileName">
            <summary>
            The name of the app.config file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AppConfigException.line">
            <summary>
            The line number with the error. Is initialized to zero
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AppConfigException.column">
            <summary>
            The column with the error. Is initialized to zero
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AppConfigException.#ctor(System.String,System.String,System.Int32,System.Int32,System.Exception)">
            <summary>
            Construct the exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AppConfigException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Construct the exception.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.BindingRedirect">
            <summary>
            Represents a single &lt;bindingRedirect&gt; from the app.config file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.BindingRedirect.OldVersionLow">
            <summary>
            The low end of the old version range.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.BindingRedirect.OldVersionHigh">
            <summary>
            The high end of the old version range.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.BindingRedirect.NewVersion">
            <summary>
            The new version number.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.BindingRedirect.Read(System.Xml.XmlReader)">
            <summary>
            The reader is positioned on a &lt;bindingRedirect&gt; element--read it.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.DependentAssembly">
            <summary>
            Represents a single &lt;dependentassembly&gt; from the app.config file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DependentAssembly.PartialAssemblyName">
            <summary>
            The partial <see cref="T:System.Reflection.AssemblyName"/>, there should be no version.
            Setter and Getter clone the incoming / outgoing assembly
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DependentAssembly.AssemblyNameReadOnly">
            <summary>
            The full <see cref="T:System.Reflection.AssemblyName"/>. It is not cloned. Callers should not mutate this object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.DependentAssembly.Read(System.Xml.XmlReader)">
            <summary>
            The reader is positioned on a &lt;dependentassembly&gt; element--read it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DependentAssembly.BindingRedirects">
            <summary>
            The binding redirects.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.RuntimeSection">
            <summary>
            Wraps the &lt;runtime&gt; section of the .config file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RuntimeSection.Read(System.Xml.XmlReader)">
            <summary>
            The reader is positioned on a &lt;runtime&gt; element--read it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RuntimeSection.DependentAssemblies">
            <summary>
            Return the collection of dependent assemblies for this runtime element.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyFoldersExResolver">
            <summary>
            Resolve searchpath type {Registry: *}
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver.s_crackAssemblyFoldersExSentinel">
            <summary>
            Regex for breaking up the searchpath pieces.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._getRegistrySubKeyNames">
            <summary>
            Delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._getRegistrySubKeyDefaultValue">
            <summary>
            Delegate
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._openBaseKey">
            <summary>
            Open the base registry key given a hive and a view
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._wasMatch">
            <summary>
            Whether or not the search path could be cracked.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._registryKeyRoot">
            <summary>
            From the search path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._targetRuntimeVersion">
            <summary>
            From the search path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._registryKeySuffix">
            <summary>
            From the search path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._osVersion">
            <summary>
            From the search path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._platform">
            <summary>
            From the search path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._isInitialized">
            <summary>
            Whether regex initialization has happened.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._assemblyFoldersCache">
            <summary>
            List of assembly folders to search for keys in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExResolver._buildEngine">
            <summary>
            BuildEngine
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyFoldersExResolver.AssemblyFoldersExLocations">
            <summary>
            If it is not initialized then just return the null object, that would mean the resolver was not called.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersExResolver.#ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,Microsoft.Build.Shared.OpenBaseKey,System.Version,System.Reflection.ProcessorArchitecture,System.Boolean,Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersExResolver.LazyInitialize">
            <summary>
            Initialize this class if it hasn't been initialized yet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersExResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyFoldersExCache">
            <summary>
            Contains information about entries in the AssemblyFoldersEx registry keys.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExCache._filesInDirectories">
            <summary>
            Set of files in ALL assemblyfoldersEx directories
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExCache._fileExists">
            <summary>
            File exists delegate we are replacing
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFoldersExCache._useOriginalFileExists">
            <summary>
            Should we use the original on or use our own
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersExCache.#ctor(Microsoft.Build.Shared.AssemblyFoldersEx,Microsoft.Build.Shared.FileExists)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyFoldersExCache.AssemblyFoldersEx">
            <summary>
            AssemblyfoldersEx object which contains the set of directories in assmblyfoldersex
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersExCache.FileExists(System.String)">
            <summary>
             Fast file exists for assemblyfoldersex.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyFoldersResolver">
            <summary>
            Resolve searchpath type {AssemblyFolders}
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersResolver.#ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Construct.
            </summary>
            <param name="searchPathElement"></param>
            <param name="getAssemblyName"></param>
            <param name="fileExists"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFoldersResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyInformation">
            <summary>
            Collection of methods used to discover assembly metadata.
            Primarily stolen from manifestutility.cs AssemblyMetaDataImport class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.#ctor(System.String)">
            <summary>
            Construct an instance for a source file.
            </summary>
            <param name="sourceFile">The assembly.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyInformation.Dependencies">
            <summary>
            Get the dependencies.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyInformation.Files">
            <summary>
            Get the scatter files from the assembly metadata. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyInformation.FrameworkNameAttribute">
            <summary>
            What was the framework name that the assembly was built against.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.GetAssemblyMetadata(System.String,System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Build.Tasks.AssemblyDependency.AssemblyMetadata},Microsoft.Build.Shared.AssemblyNameExtension[]@,System.String[]@,System.Runtime.Versioning.FrameworkName@)">
            <summary>
            Given an assembly name, crack it open and retrieve the list of dependent 
            assemblies and  the list of scatter files.
            </summary>
            <param name="path">Path to the assembly.</param>
            <param name="assemblyMetadataCache">Cache of pre-extracted assembly metadata.</param>
            <param name="dependencies">Receives the list of dependencies.</param>
            <param name="scatterFiles">Receives the list of associated scatter files.</param>
            <param name="frameworkName">Gets the assembly name.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.GetTargetFrameworkAttribute(System.String)">
            <summary>
            Given an assembly name, crack it open and retrieve the TargetFrameworkAttribute
            assemblies and  the list of scatter files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.IsWinMDFile(System.String,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,Microsoft.Build.Shared.FileExists,System.String@,System.Boolean@)">
            <summary>
            Determine if an file is a winmd file or not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.GetFrameworkName">
            <summary>
            Get the framework name from the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.CorePopulateMetadata">
            <summary>
            Read everything from the assembly in a single stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.GetFixedStringArguments(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.CustomAttribute)">
            <summary>
            Gets the fixed (required) string arguments of a custom attribute.
            Only attributes that have only fixed string arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.DisposeUnmanagedResources">
            <summary>
            Release interface pointers on Dispose(). 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.GetRuntimeVersion(System.String)">
            <summary>
            Given a path get the CLR runtime version of the file
            </summary>
            <param name="path">path to the file</param>
            <returns>The CLR runtime version or empty if the path does not exist.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.ImportAssemblyDependencies">
            <summary>
            Import assembly dependencies.
            </summary>
            <returns>The array of assembly dependencies.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.ImportFiles">
            <summary>
            Import extra files. These are usually consituent members of a scatter assembly.
            </summary>
            <returns>The extra files of assembly dependencies.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.AllocAsmMeta">
            <summary>
            Allocate assembly metadata structure buffer.
            </summary>
            <returns>Pointer to structure</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.ConstructAssemblyName(System.IntPtr,System.Char[],System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Construct assembly name. 
            </summary>
            <param name="asmMetaPtr">Assembly metadata structure</param>
            <param name="asmNameBuf">Buffer containing the name</param>
            <param name="asmNameLength">Length of that buffer</param>
            <param name="pubKeyPtr">Pointer to public key</param>
            <param name="pubKeyBytes">Count of bytes in public key.</param>
            <param name="flags">Extra flags</param>
            <returns>The assembly name.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyInformation.FreeAsmMeta(System.IntPtr)">
            <summary>
            Free the assembly metadata structure.
            </summary>
            <param name="asmMetaPtr">The pointer.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.ManagedRuntimeVersionReader">
            <summary>
            Managed implementation of a reader for getting the runtime version of an assembly
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ManagedRuntimeVersionReader.GetRuntimeVersion(System.String)">
            <summary>
            Given a path get the CLR runtime version of the file
            </summary>
            <param name="path">path to the file</param>
            <returns>The CLR runtime version or empty if the path does not exist or the file is not an assembly.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyNameReference">
            <summary>
            An assembly name coupled with reference information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNameReference.ToString">
            <summary>
            Display as string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNameReference.CompareTo(Microsoft.Build.Tasks.AssemblyNameReference)">
            <summary>
            Compare by assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNameReference.Create(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            Construct a new AssemblyNameReference.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyNameReferenceAscendingVersionComparer">
            <summary>
            Compare the two AssemblyNameReferences by version number.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNameReferenceAscendingVersionComparer.#ctor">
            <summary>
            Private construct so there's only one instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNameReferenceAscendingVersionComparer.Compare(Microsoft.Build.Tasks.AssemblyNameReference,Microsoft.Build.Tasks.AssemblyNameReference)">
            <summary>
            Compare the two AssemblyNameReferences by version number.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyResolution">
             <summary>
             Utility class encapsulates steps to resolve assembly references.
             For example, this class has the code that will take:
            
                  System.Xml
            
             and turn it into:
            
                 [path-to-frameworks]\System.Xml.dll
            
             
             </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyResolution.ResolveReference(System.Collections.Generic.IEnumerable{Microsoft.Build.Tasks.Resolver[]},Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Implementation guts for ResolveReference.
            </summary>
            <param name="jaggedResolvers">The array of resolvers to search with.</param>
            <param name="assemblyName">The assembly name to look up.</param>
            <param name="sdkName"></param>
            <param name="rawFileNameCandidate">The file name to match if {RawFileName} is seen. (May be null).</param>
            <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
            <param name="wantSpecificVersion"></param>
            <param name="executableExtensions">The filename extension of the assembly. Must be this or its no match.</param>
            <param name="hintPath">This reference's hintpath</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="resolvedSearchPath">Receives the searchPath that the reference was resolved at. Empty if not resolved.</param>
            <param name="userRequestedSpecificFile"> This will be true if the user requested a specific file.</param>
            <returns>The resolved path</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyResolution.CompileSearchPaths(Microsoft.Build.Framework.IBuildEngine,System.String[],System.String[],System.Reflection.ProcessorArchitecture,System.String[],Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,Microsoft.Build.Shared.OpenBaseKey,Microsoft.Build.Tasks.InstalledAssemblies,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,Microsoft.Build.Tasks.GetAssemblyPathInGac,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Compile search paths into an array of resolvers.
            </summary>
            <param name="buildEngine"></param>
            <param name="searchPaths"></param>
            <param name="candidateAssemblyFiles">Paths to assembly files mentioned in the project.</param>
            <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
            <param name="frameworkPaths">Paths to FX folders.</param>
            <param name="fileExists"></param>
            <param name="getAssemblyName"></param>
            <param name="getRegistrySubKeyNames"></param>
            <param name="getRegistrySubKeyDefaultValue"></param>
            <param name="openBaseKey"></param>
            <param name="installedAssemblies"></param>
            <param name="getRuntimeVersion"></param>
            <param name="targetedRuntimeVersion"></param>
            <param name="getAssemblyPathInGac"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyResolution.CompileDirectories(System.Collections.Generic.List{System.String},Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Build a resolver array from a set of directories to resolve directly from.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyResolutionConstants">
            <summary>
            Constants used for assembly resolution.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.hintPathSentinel">
            <summary>
            Special hintpath indicator. May be passed in where SearchPaths are taken. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.assemblyFoldersSentinel">
            <summary>
            Special AssemblyFolders indicator. May be passed in where SearchPaths are taken. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.candidateAssemblyFilesSentinel">
            <summary>
            Special CandidateAssemblyFiles indicator. May be passed in where SearchPaths are taken. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.gacSentinel">
            <summary>
            Special GAC indicator. May be passed in where SearchPaths are taken. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.frameworkPathSentinel">
            <summary>
            Special Framework directory indicator. May be passed in where SearchPaths are taken. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.rawFileNameSentinel">
            <summary>
            Special SearchPath indicator that means: match against the assembly item's Include as
            if it were a file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.assemblyFoldersExSentinel">
            <summary>
            Special AssemblyFoldersEx indicator.  May be passed in where SearchPaths are taken. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyResolutionConstants.assemblyFoldersFromConfigSentinel">
            <summary>
            Special AssemblyFoldersFromConfig indicator.  May be passed in where SearchPaths are taken. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.BadImageReferenceException">
            <summary>
            The reference points to a bad image.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.BadImageReferenceException.#ctor(System.String,System.Exception)">
            <summary>
            Construct
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.BadImageReferenceException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Construct
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CandidateAssemblyFilesResolver">
            <summary>
            Resolve searchpath type {CandidateAssemblyFiles}
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CandidateAssemblyFilesResolver._candidateAssemblyFiles">
            <summary>
            The candidate assembly files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CandidateAssemblyFilesResolver.#ctor(System.String[],System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Construct.
            </summary>
            <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
            <param name="searchPathElement"></param>
            <param name="getAssemblyName"></param>
            <param name="fileExists"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.CandidateAssemblyFilesResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="sdkName"></param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.ConflictLossReason">
            <summary>
            If this reference lost in a conflict with another reference, this reason explains 
            why.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ConflictLossReason.DidntLose">
            <summary>
            This reference didn't lose a conflict.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ConflictLossReason.HadLowerVersion">
            <summary>
            This reference matched another assembly that had a higher version number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ConflictLossReason.InsolubleConflict">
            <summary>
            The two assemblies cannot be reconciled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ConflictLossReason.WasNotPrimary">
            <summary>
            In this case, this reference was a dependency and the other reference was 
            primary (specified in the project file). 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ConflictLossReason.FusionEquivalentWithSameVersion">
            <summary>
            The two references were equivalent according to fusion and also have the same version.
            Its hard to see how this could happen, but handle it.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CopyLocalState">
            <summary>
            The value of the copyLocal flag and why it was set that way.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.Undecided">
            <summary>
            The copy local state is undecided right now.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.YesBecauseOfHeuristic">
            <summary>
            The Reference should be CopyLocal='true' because it wasn't 'no' for any reason.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.YesBecauseReferenceItemHadMetadata">
            <summary>
            The Reference should be CopyLocal='true' because its source item has Private='true'
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseFrameworkFile">
            <summary>
            The Reference should be CopyLocal='false' because it is a framework file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecausePrerequisite">
            <summary>
            The Reference should be CopyLocal='false' because it is a prerequisite file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseReferenceItemHadMetadata">
            <summary>
            The Reference should be CopyLocal='false' because the the Private attribute is set to 'false' in the project. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseReferenceResolvedFromGAC">
            <summary>
            The Reference should be CopyLocal='false' because it was resolved from the GAC.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseReferenceFoundInGAC">
            <summary>
            Legacy behavior, CopyLocal='false' when the assembly is found in the GAC (even when it was resolved elsewhere).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseConflictVictim">
            <summary>
            The Reference should be CopyLocal='false' because it lost a conflict between an same-named assembly file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseUnresolved">
            <summary>
            The reference was unresolved. It can't be copied to the bin directory because it wasn't found.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseEmbedded">
            <summary>
            The reference was embedded. It shouldn't be copied to the bin directory because it won't be loaded at runtime.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CopyLocalState.NoBecauseParentReferencesFoundInGAC">
            <summary>
            The property copyLocalDependenciesWhenParentReferenceInGac is set to false and all the parent source items were found in the GAC.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CopyLocalStateUtility">
            <remarks>
            Helper methods for dealing with CopyLocalState enumeration.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.CopyLocalStateUtility.IsCopyLocal(Microsoft.Build.Tasks.CopyLocalState)">
            <summary>
            Returns the true or false from a CopyLocalState.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.DependencyResolutionException">
            <summary>
            Exception indicates a problem finding dependencies of a reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.DependencyResolutionException.#ctor(System.String,System.Exception)">
            <summary>
            Construct
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.DependencyResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Construct
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.DirectoryResolver">
            <summary>
            Resolve when the searchpath type is a simple directory name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.DirectoryResolver.#ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.DirectoryResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="sdkName"></param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.FrameworkPathResolver">
            <summary>
            Resolve searchpath type {TargetFrameworkDirectory}
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FrameworkPathResolver.#ctor(System.String[],Microsoft.Build.Tasks.InstalledAssemblies,System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FrameworkPathResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="sdkName"></param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.FrameworkPathResolver.GetHighestVersionInRedist(Microsoft.Build.Tasks.InstalledAssemblies,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            If the version is not set for an assembly reference, go through the redist list and find the highest version for that assembly.
            Make sure when matching the assembly in the redist that we take into account the publicKeyToken and the Culture.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateBindingRedirects">
            <summary>
            Take suggested redirects (from the ResolveAssemblyReference and GenerateOutOfBandAssemblyTables tasks)
            and add them to an intermediate copy of the App.config file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects">
            <summary>
            Sugested redirects as output from the ResolveAssemblyReference task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile">
            <summary>
            Path to the app.config source file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName">
            <summary>
            Name of the output application config file: $(TargetFileName).config
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile">
            <summary>
            Path to an intermediate file where we can write the input app.config plus the generated binding redirects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateBindingRedirects.Execute">
            <summary>
            Execute the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateBindingRedirects.IsMatch(System.Reflection.AssemblyName,System.String,System.String,System.String)">
            <summary>
            Determins whether the name, culture, and public key token of the given assembly name "suggestedRedirect"
            matches the name, culture, and publicKeyToken strings.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateBindingRedirects.ByteArrayMatchesString(System.Byte[],System.String)">
            <summary>
            Determines whether string "s" is the hexdecimal representation of the byte array "a".
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateBindingRedirects.UpdateExistingBindingRedirects(System.Xml.Linq.XElement,System.Collections.Generic.IDictionary{System.Reflection.AssemblyName,System.String})">
            <summary>
            Going through all the binding redirects in the runtime node, if anyone overlaps with a RAR suggested redirect,
            we update the existing redirect and output warning.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateBindingRedirects.LoadAppConfig(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Load or create App.Config
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateBindingRedirects.ParseSuggestedRedirects">
            <summary>
            Parse the suggested redirects from RAR and return a dictionary containing all those suggested redirects
            in the form of AssemblyName-MaxVersion pairs.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.HintPathResolver">
            <summary>
            Resolve searchpath type {HintPathFromItem}
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.HintPathResolver.#ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.HintPathResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="sdkName"></param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.InstalledAssemblies">
            <summary>
            Utility methods that encapsulate well-known assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledAssemblies.#ctor(Microsoft.Build.Tasks.RedistList)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledAssemblies.GetInfo(Microsoft.Build.Shared.AssemblyNameExtension,System.Version@,System.Boolean@,System.Nullable{System.Boolean}@,System.String@)">
            <summary>
            Unify an assembly name according to the fx retarget rules.
            </summary>
            <param name="assemblyName">The unify-from assembly name.</param>
            <param name="unifiedVersion">The new version number.</param>
            <param name="isPrerequisite">Whether this assembly will be available on target machines.</param>
            <param name="isRedistRoot">May be true, false or null. Null means there was no IsRedistRoot in the redist list.</param>
            <param name="redistName">Name of the corresponding Resist specified in the redist list.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledAssemblies.RemapAssemblyExtension(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            We need to check to see if an assembly name is in our remapping list, if it is we should return a new assemblyNameExtension which has been remapped.
            Remapping is usually used for portable libraries where we need to turn one assemblyName that is retargetable to another assemblyname.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledAssemblies.FindHighestVersionInRedistList(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Find the highest version of the assemblyName in the redist list for framework assemblies taking into account the simplename, culture and public key.
            </summary>
            <param name="assemblyName">The name of the assembly we would like to find the highest version for</param>
            <returns>Key value pair, K: Assembly entry of highest value in the redist list. V: AssemblyNameExtension with the version information or null if the name could not be found</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledAssemblies.FrameworkAssemblyEntryInRedist(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Given an assemblyNameExtension, is that assembly name in the redist list and does that redist name start with Microsoft-Windows-CLRCoreComp which indicates
            the redist entry is a framework redist list rather than a 3rd part redist list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledAssemblies.FindAssemblyNameFromSimpleName(System.String)">
            <summary>
            Find every assembly full name in the redist list that matches the given simple name.
            </summary>
            <returns>The array of assembly names.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.InvalidReferenceAssemblyNameException">
            <summary>
            There reference is not a well-formed fusion name *and* its not a file 
            that exists on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InvalidReferenceAssemblyNameException.#ctor(System.String)">
            <summary>
            Construct
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InvalidReferenceAssemblyNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Construct
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.InvalidReferenceAssemblyNameException.SourceItemSpec">
            <summary>
            The item spec of the item that is the source fo the problem.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.NoMatchReason">
            <summary>
            Reasons why a resolution might fail.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NoMatchReason.Unknown">
            <summary>
            The default state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NoMatchReason.FileNotFound">
            <summary>
            There was no file found.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NoMatchReason.FusionNamesDidNotMatch">
            <summary>
            The file was found, but its fusion name didn't match.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NoMatchReason.TargetHadNoFusionName">
            <summary>
            The file was found, but it didn't have a fusion name. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NoMatchReason.NotInGac">
            <summary>
            The file is not in the GAC.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NoMatchReason.NotAFileNameOnDisk">
            <summary>
            If treated as a filename, the file doesn't exist on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NoMatchReason.ProcessorArchitectureDoesNotMatch">
            <summary>
            The processor architecture does not match the targeted processor architecture.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.RawFilenameResolver">
            <summary>
            Resolve searchpath type {RawFileName}
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RawFilenameResolver.#ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RawFilenameResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="sdkName"></param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Reference">
            <summary>
            A reference to an assembly along with information about resolution.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._sourceItems">
            <summary>
            dictionary where ITaskItem.ItemSpec (a string) is the key and ITaskItem is the value.
            A hash table is used to remove duplicates.
            All source items that inspired this reference (possibly indirectly through a dependency chain).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._dependees">
            <summary>
            A list of unique dependencies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._dependencies">
            <summary>
            Hashset of Reference which depend on this reference
            A list of unique dependencies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._scatterFiles">
            <summary>
            Scatter files associated with this reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._errors">
            <summary>
            Any errors that occurred while resolving or finding dependencies on this item.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._relatedFileExtensions">
            <summary>
            Contains any file extension that are related to this file. Pdbs and xmls are related.
            This is an extension string starting with "."
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._satelliteFiles">
            <summary>
            Contains satellite files for this reference.
            This file path is relative to the location of the reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._serializationAssemblyFiles">
            <summary>
            Contains serialization assembly files for this reference.
            This file path is relative to the location of the reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._conflictVictims">
            <summary>
            AssemblyNames of references that lost collision conflicts with this reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._preUnificationVersions">
            <summary>
            These are the versions (type UnificationVersion) that were unified from.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._primarySourceItem">
            <summary>
            The original source item, as passed into the task that is directly associated
            with this reference.  This only applies to "primary" references.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._fullPath">
            <summary>
            The full path to the assembly. If this is "", then that means that this reference
            has not been resolved.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._directoryName">
            <summary>
            The directory that this reference lives in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._fileNameWithoutExtension">
            <summary>
            The reference's filename without extension.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._fullPathWithoutExtension">
            <summary>
            The full path to the file name but without the extension.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._expectedExtensions">
            <summary>
            The list of expected extensions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._isManagedWinMDFile">
            <summary>
             Is the file a managed winmd file. That means it has both windows runtime and CLR in the imageruntime string.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._imageRuntimeVersion">
            <summary>
            The imageruntime version for this reference. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._remappedAssemblyNames">
            <summary>
            Set containing the names the reference was remapped from
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._isWinMDFile">
            <summary>
            Delegate to determine if the file is a winmd file or not
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._fileExists">
            <summary>
            Delegate to check to see if the file exists on disk
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Reference._getRuntimeVersion">
            <summary>
            Delegate to get the imageruntime version from a file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddSourceItem(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Add items that caused (possibly indirectly through a dependency chain) this Reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddSourceItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Add items that caused (possibly indirectly through a dependency chain) this Reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.PropagateSourceItems(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            We have had our source item list updated, we need to propagate this change to any of our dependencies so they have the new information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetSourceItems">
            <summary>
            Get the source items for this reference.
             This is collection of ITaskItems.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddDependency(Microsoft.Build.Tasks.Reference)">
            <summary>
            Add a reference which this reference depends on
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddDependee(Microsoft.Build.Tasks.Reference)">
            <summary>
            Add a reference that caused (possibly indirectly through a dependency chain) this Reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.RemoveDependee(Microsoft.Build.Tasks.Reference)">
            <summary>
            A dependee may be removed because it or its dependee's are in the black list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.RemoveDependency(Microsoft.Build.Tasks.Reference)">
            <summary>
            A dependency may be removed because it may not be referenced any more due this reference being in the black list or being removed due to it depending on something in the black list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetDependees">
            <summary>
            Get the dependee references for this reference.
             This is collection of References.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AttachScatterFiles(System.String[])">
            <summary>
            Scatter files associated with this assembly.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetScatterFiles">
            <summary>
            Scatter files associated with this assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.SetExecutableExtension(System.String)">
            <summary>
            Set one expected extension for this reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetExecutableExtensions(System.String[])">
            <summary>
            Get the list of expected extensions.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.WantSpecificVersion">
            <summary>
            Whether the name needs to match exactly or just the simple name part needs to match.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.EmbedInteropTypes">
            <summary>
            Whether types need to be embedded into the target assembly
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.UserRequestedSpecificFile">
            <summary>
            This will be true if the user requested a specific file. We know this when the file was resolved
            by hintpath or if it was resolve as a raw file name for example.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ReferenceVersion">
            <summary>
            The version number of this reference
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.FoundInGac">
            <summary>
            True if the assembly was found to be in the GAC.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ResolvedFromGac">
            <summary>
            True if the assembly was resolved through the GAC. Otherwise, false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ExclusionListLoggingProperties">
            <summary>
            Set of properties for this reference used to log why this reference could not be resolved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.CheckForSpecificVersionMetadataOnParentsReference(System.Boolean)">
            <summary>
            Determines if a given reference or its parent primary references have specific version metadata set to true.
            If anyParentHasMetadata is set to true then we will return true if any parent primary reference has the specific version metadata set to true, 
            if the value is false we will return true ONLY if all parent primary references have the metadata set to true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddError(System.Exception)">
            <summary>
            Add a dependency or resolution error to this reference's list of errors.
            </summary>
            <param name="e">The error.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetErrors">
            <summary>
            Return the list of dependency or resolution errors for this item.
            </summary>
            <returns>The collection of resolution errors.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddRelatedFileExtension(System.String)">
            <summary>
            Add a new related file to this reference.
            Related files always live in the same directory as the reference.
            Examples include, MyAssembly.pdb and MyAssembly.xml
            </summary>
            <param name="filenameExtension">This is the filename extension.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetRelatedFileExtensions">
            <summary>
            Return the list of related files for this item.
            </summary>
            <returns>The collection of related file extensions.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddSatelliteFile(System.String)">
            <summary>
            Add a new satellite file
            </summary>
            <param name="filename">This is the filename relative the this reference.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddSerializationAssemblyFile(System.String)">
            <summary>
            Add a new serialization assembly file.
            </summary>
            <param name="filename">This is the filename relative the this reference.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetSatelliteFiles">
            <summary>
            Return the list of satellite files for this item.
            </summary>
            <returns>The collection of satellit files.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetSerializationAssemblyFiles">
            <summary>
            Return the list of serialization assembly files for this item.
            </summary>
            <returns>The collection of serialization assembly files.</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.FullPath">
            <summary>
            The full path to the assembly. If this is "", then that means that this reference
            has not been resolved.
            </summary>
            <value>The full path to this assembly.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.DirectoryName">
            <summary>
            The directory that this assembly lives in.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.FileNameWithoutExtension">
            <summary>
            The file name without extension.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.FullPathWithoutExtension">
            <summary>
            The full path to the assembly but without an extension on the file namee
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.HintPath">
            <summary>
            This is the HintPath from the source item. This is used to resolve the assembly.
            </summary>
            <value>The hint path to this assembly.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.AssemblyFolderKey">
            <summary>
            This is the key that was passed in to the reference through the &lt;AssemblyFolderKey&gt; metadata.
            </summary>
            <value>The &lt;AssemblyFolderKey&gt; value.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsPrimary">
            <summary>
            Whether this assembly came from the project. If 'false' then this reference was deduced 
            through the reference resolution process.
            </summary>
            <value>'true' if this reference is a primary assembly.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsPrerequisite">
            <summary>
            Whether or not this reference will be installed on the target machine.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsRedistRoot">
            <summary>
            Whether or not this reference is a redist root.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.RedistName">
            <summary>
            The redist name for this reference (if any)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.PrimarySourceItem">
            <summary>
            The original source item, as passed into the task that is directly associated
            with this reference.  This only applies to "primary" references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsBadImage">
            <summary>
            If 'true' then the path that this item points to is known to be a bad image.
            This item shouldn't be passed to compilers and so forth. 
            </summary>
            <value>'true' if this reference points to a bad image.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsConflictVictim">
            <summary>
             If true, then this item conflicted with another item and lost.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddConflictVictim(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Add a conflict victim to this reference
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetConflictVictims">
            <summary>
            Return the list of conflict victims.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ConflictVictorName">
            <summary>
             The name of the assembly that won over this reference.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ConflictLossExplanation">
            <summary>
             The reason why this reference lost to another reference.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsWinMDFile">
            <summary>
            Is the file a WinMDFile.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsManagedWinMDFile">
            <summary>
            Is the file a Managed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ImplementationAssembly">
            <summary>
            For winmd files there may be an implementation file sitting beside the winmd called the assemblyName.dll
            We need to attach a piece of metadata to if this is the case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ImageRuntime">
            <summary>
            ImageRuntime Information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.GetPreUnificationVersions">
            <summary>
            Return the list of versions that this reference is unified from.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.RemappedAssemblyNames">
            <summary>
            Return the list of versions that this reference is unified from.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddPreUnificationVersion(System.String,System.Version,Microsoft.Build.Tasks.UnificationReason)">
            <summary>
            Add a new version number for a version of this reference 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddRemapping(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Add the AssemblyNames name we were remapped from
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsUnified">
            <summary>
             Whether or not this reference is unified from a different version or versions.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.CopyLocal">
            <summary>
            Whether this reference should be copied to the local 'bin' dir or not and the reason this flag
            was set that way.
            </summary>
            <value>The current copy-local state.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsCopyLocal">
            <summary>
            Whether the reference should be CopyLocal. For the reason, see CopyLocalState.
            </summary>
            <value>'true' if this reference should be copied.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsResolved">
            <summary>
            Whether this reference has already been resolved.
            Resolved means that the actual filename of the assembly has been found.
            </summary>
            <value>'true' if this reference has been resolved.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.IsUnresolvable">
            <summary>
            Whether this reference can't be resolve.
            References are usually unresolvable because they weren't found anywhere in the defined search paths.
            </summary>
            <value>'true' if this reference is unresolvable.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.DependenciesFound">
            <summary>
            Whether or not we still need to find dependencies for this reference.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.SDKName">
            <summary>
            If the reference has an SDK name metadata this will contain that string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.AddAssembliesConsideredAndRejected(System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation})">
            <summary>
            Add some records to the table of assemblies that were considered and then rejected.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.AssembliesConsideredAndRejected">
            <summary>
            Returns a collection of strings. Each string is the full path to an assembly that was 
            considered for resolution but then rejected because it wasn't a complete match.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ResolvedSearchPath">
            <summary>
            The searchpath location that the reference was found at.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.FrameworkNameAttribute">
            <summary>
            FrameworkName attribute on this reference
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ExternallyResolved">
            <summary>
            Indicates that the reference is primary and has ExternallyResolved=true metadata to denote that 
            it was resolved by an external system (commonly from nuget). Such a system has already provided a
            resolved closure as primary references and therefore we can skip the expensive closure walk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.MakeDependentAssemblyReference(Microsoft.Build.Tasks.Reference)">
             <summary>
             Make this reference an assembly that is a dependency of 'sourceReference'
            
             For example, if 'sourceReference' is MyAssembly.dll then a dependent assembly file
             might be en\MyAssembly.resources.dll
             
             Assembly references do not have their own dependencies, therefore they are
             </summary>
             <param name="sourceReference">The source reference that this reference will be dependent on</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.MakePrimaryAssemblyReference(Microsoft.Build.Framework.ITaskItem,System.Boolean,System.String)">
            <summary>
            Make this reference a primary assembly reference. 
            This is a refrence that is an assembly and is primary.
            </summary>
            <param name="sourceItem">The source item.</param>
            <param name="wantSpecificVersionValue">Whether the version needs to match exactly or loosely.</param>
            <param name="executableExtension">The filename extension that the resulting assembly must have.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.IsFrameworkFile(System.String,System.String[])">
            <summary>
            Determine whether the given assembly is an FX assembly.
            </summary>
            <param name="fullPath">The full path to the assembly.</param>
            <param name="frameworkPaths">The path to the frameworks.</param>
            <returns>True if this is a frameworks assembly.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.SetFinalCopyLocalState(Microsoft.Build.Shared.AssemblyNameExtension,System.String[],System.Reflection.ProcessorArchitecture,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyPathInGac,System.Boolean,System.Boolean,Microsoft.Build.Tasks.ReferenceTable)">
            <summary>
            Figure out the what the CopyLocal state of given assembly should be.
            </summary>
            <param name="assemblyName">The name of the assembly.</param>
            <param name="frameworkPaths">The framework paths.</param>
            <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
            <param name="getRuntimeVersion">Delegate to get runtime version.</param>
            <param name="targetedRuntimeVersion">The targeted runtime version.</param>
            <param name="fileExists">Delegate to check if a file exists.</param>
            <param name="getAssemblyPathInGac">Delegate to get the path to an assembly in the system GAC.</param>
            <param name="copyLocalDependenciesWhenParentReferenceInGac">if set to true, copy local dependencies when only parent reference in gac.</param>
            <param name="doNotCopyLocalIfInGac">If set to true, do not copy local a reference that exists in the GAC (legacy behavior).</param>
            <param name="referenceTable">The reference table.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Reference.ToString">
            <summary>
            Produce a string representation.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Reference.ExclusionListProperties">
            <summary>
            There are a number of properties which are set when we generate exclusion lists and it is useful to have this information on the references so that 
            the correct reasons can be logged for these references being in the black list.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ExclusionListProperties.IsInExclusionList">
            <summary>
            Is this reference in an exclusion list
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ExclusionListProperties.HighestVersionInRedist">
            <summary>
            What is the highest version of this assembly in the current redist list
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ExclusionListProperties.HighestRedistListMonkier">
            <summary>
            What is the highest versioned redist list on the machine
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Reference.ExclusionListProperties.ExclusionReasonLogDelegate">
            <summary>
            Delegate which logs the reason for not resolving a reference
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ReferenceResolutionException">
            <summary>
            There was a problem resolving this reference into a full file name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceResolutionException.#ctor(System.String,System.Exception)">
            <summary>
            Construct
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implement required constructors for serialization
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ReferenceTable">
            <summary>
            A table of references.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable.s_targetFrameworkVersion_40">
            <summary>version 4.0</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable.s_monikerToHighestRedistList">
            <summary>
            A mapping of a framework identifier to the most current redist list on the system based on the target framework identifier on the moniker.
            This is used to determine if an assembly is in a redist list for the framework targeted by the moniker.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._externallyResolvedPrimaryReferences">
            <summary>
            Reference simple names that were resolved by an external entity to RAR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._remappedAssemblies">
            <summary>The table of remapped assemblies. Used for Unification.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._findDependencies">
            <summary>If true, then search for dependencies.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._ignoreVersionForFrameworkReferences">
            <summary>
             Should version be ignored for framework primary references
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._findSatellites">
            <summary>If true, then search for satellite files.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._findSerializationAssemblies">
            <summary>If true, then search for serialization assembly files.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._findRelatedFiles">
            <summary>If true, then search for related files.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._checkAssemblyVersionAgainstTargetFrameworkVersion">
            <summary>
            If true, then force framework assembly version check against the target framework version
            If false, the default behavior is to disable version checks for target framework versions 4.5 and above.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._frameworkPaths">
            <summary>Path to the FX.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._allowedAssemblyExtensions">
            <summary>The allowed assembly extensions.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._relatedFileExtensions">
            <summary>These are companion files that typically travel with assemblies</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._resolvedSDKReferences">
            <summary>
            Locations where sdks are installed. K:SDKName v: Resolved Reference item
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._installedAssemblies">
            <summary>Path to installed assembly XML tables.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._targetProcessorArchitecture">
            <summary>Like x86 or IA64\AMD64, the processor architecture being targetted.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._fileExists">
            <summary>Delegate used for checking for the existence of a file.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._directoryExists">
            <summary>Delegate used for checking for the existence of a directory.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._getDirectories">
            <summary>Delegate used for getting directories.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._getAssemblyName">
            <summary>Delegate used for getting assembly names.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._getAssemblyMetadata">
            <summary>Delegate used for finding dependencies of a file.</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._getRuntimeVersion">
            <summary>Delegate used to get the image runtime version of a file</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._openBaseKey">
            <summary> Delegate to get the base registry key for AssemblyFoldersEx</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._targetedRuntimeVersion">
            <summary>Version of the runtime we are targeting</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._readMachineTypeFromPEHeader">
            <summary>
            Delegate used to get the machineType from the PE header of the dll.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._isWinMDFile">
            <summary>
            Is the file a winMD file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._projectTargetFramework">
            <summary>version of the framework targeted by this project</summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._targetFrameworkMoniker">
            <summary>
            Target framework moniker we are targeting.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._log">
            <summary>
            Logging helper to allow the logging of meessages from the Reference Table
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._latestTargetFrameworkDirectories">
            <summary>
            List of framework directories which are the highest on the machine
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._copyLocalDependenciesWhenParentReferenceInGac">
            <summary>
            Should dependencies be set to copy local if the parent reference is in the GAC
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._ignoreFrameworkAttributeVersionMismatch">
            <summary>
             Shoould the framework attribute version mismatch be ignored.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._getAssemblyPathInGac">
            <summary>
            Delegate to determine if an assembly name is in the GAC.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ReferenceTable._warnOrErrorOnTargetArchitectureMismatch">
            <summary>
            Should a warning or error be emitted on architecture mismatch
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ReferenceTable.LogExclusionReason">
            <summary>
            When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is. 
            There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message 
            depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we 
            discover an assembly in the black list we can log the correct message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.#ctor(Microsoft.Build.Framework.IBuildEngine,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String[],System.String[],System.String[],System.String[],Microsoft.Build.Framework.ITaskItem[],System.String[],Microsoft.Build.Tasks.InstalledAssemblies,System.Reflection.ProcessorArchitecture,Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Tasks.GetDirectories,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyMetadata,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,Microsoft.Build.Shared.OpenBaseKey,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,System.Version,System.Runtime.Versioning.FrameworkName,Microsoft.Build.Utilities.TaskLoggingHelper,System.String[],System.Boolean,System.Boolean,Microsoft.Build.Tasks.GetAssemblyPathInGac,Microsoft.Build.Tasks.IsWinMDFile,System.Boolean,Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader,Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior,System.Boolean,System.Boolean,System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Build.Tasks.AssemblyDependency.AssemblyMetadata})">
            <summary>
            Construct.
            </summary>
            <param name="buildEngine"></param>
            <param name="findDependencies">If true, then search for dependencies.</param>
            <param name="findSatellites">If true, then search for satellite files.</param>
            <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
            <param name="findRelatedFiles">If true, then search for related files.</param>
            <param name="searchPaths">Paths to search for dependent assemblies on.</param>
            <param name="relatedFileExtensions"></param>
            <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
            <param name="resolvedSDKItems">Resolved sdk items</param>
            <param name="frameworkPaths">Path to the FX.</param>
            <param name="installedAssemblies">Installed assembly XML tables.</param>
            <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
            <param name="fileExists">Delegate used for checking for the existence of a file.</param>
            <param name="directoryExists">Delegate used for files.</param>
            <param name="getDirectories">Delegate used for getting directories.</param>
            <param name="getAssemblyName">Delegate used for getting assembly names.</param>
            <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
            <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
            <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
            <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
            <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
            <param name="allowedAssemblyExtensions"></param>
            <param name="openBaseKey"></param>
            <param name="getRuntimeVersion"></param>
            <param name="targetedRuntimeVersion"></param>
            <param name="projectTargetFramework"></param>
            <param name="targetFrameworkMoniker"></param>
            <param name="log"></param>
            <param name="latestTargetFrameworkDirectories"></param>
            <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
            <param name="doNotCopyLocalIfInGac"></param>
            <param name="getAssemblyPathInGac"></param>
            <param name="isWinMDFile"></param>
            <param name="ignoreVersionForFrameworkReferences"></param>
            <param name="readMachineTypeFromPEHeader"></param>
            <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
            <param name="ignoreFrameworkAttributeVersionMismatch"></param>
        </member>
        <member name="P:Microsoft.Build.Tasks.ReferenceTable.Resolvers">
            <summary>
            Set of resolvers the reference table uses.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ReferenceTable.References">
            <summary>
            Get a table of all vertices.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ReferenceTable.ListOfExcludedAssemblies">
            <summary>
            If assemblies have been marked for exclusion this contains the list of their full names
            This may be null
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ReferenceTable.SkippedFindingExternallyResolvedDependencies">
            <summary>
            Indicates that at least one reference was <see cref="P:Microsoft.Build.Tasks.Reference.ExternallyResolved"/> and
            we skipped finding its dependencies as a result.
            </summary>
            <remarks>
            This is currently used to perform a shallow search for System.Runtime/netstandard usage
            within the externally resolved graph.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.ReferenceTable.FindDependenciesOfExternallyResolvedReferences">
            <summary>
            Force dependencies to be walked even when a reference is marked with ExternallyResolved=true
            metadata.
            </summary>
            <remarks>
            This is currently used to ensure that we suggest appropriate binding redirects for
            assembly version conflicts within an externally resolved graph.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.AddReference(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            Adds a reference to the table.
            </summary>
            <param name="assemblyName">The assembly name to be used as a key.</param>
            <param name="reference">The reference to add.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.GetReference(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Find the reference that corresponds to the given path.
            </summary>
            <param name="assemblyName">The assembly name  to find the reference for.</param>
            <returns>'null' if no reference existed.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.NameAssemblyFileReference(Microsoft.Build.Tasks.Reference,System.String)">
            <summary>
            Give an assembly file name, adjust a Reference to match it.
            </summary>
            <param name="reference">The reference to work on</param>
            <param name="assemblyFileName">The path to the assembly file.</param>
            <returns>The AssemblyName of assemblyFileName</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.SetPrimaryItems(Microsoft.Build.Framework.ITaskItem[],Microsoft.Build.Framework.ITaskItem[],System.Collections.Generic.List{System.Exception})">
            <summary>
            Given a list of task items, add them all to this table and make them the only primary items.
            </summary>
            <param name="referenceAssemblyFiles">The task items which contain file names to add.</param>
            <param name="referenceAssemblyNames">The task items which contain fusion names to add.</param>
            <param name="exceptions">Exceptions encountered while setting primary items. Exceptions are logged, but it doesn't stop the resolution process.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.SetPrimaryAssemblyReferenceItem(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Given an item that refers to a assembly name, make it a primary reference.
            </summary>
            <param name="referenceAssemblyName">The task item which contain fusion names to add.</param>
            <returns>Resulting exception containing resolution failure details, if any: too costly to throw it.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.TryConvertToAssemblyName(System.String,System.String,Microsoft.Build.Shared.AssemblyNameExtension@)">
            <summary>
            Attempts to convert an itemSpec and fusionName into an assembly name.
            AssemblyName is left unchanged if conversion wasn't possible.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.TryGatherAssemblyNameEssentials(System.String,Microsoft.Build.Shared.AssemblyNameExtension@)">
            <summary>
            Given a string that may be a fusion name, try to gather the four essential properties:
                Name
                Version
                PublicKeyToken
                Culture
            </summary>
            <param name="fusionName"></param>
            <param name="assemblyName"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.TryGetAssemblyNameComponent(System.String,System.String,System.String@)">
            <summary>
            Attempt to get one field out of an assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.SetPrimaryFileItem(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Given an item that refers to a file name, make it a primary reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.FindRelatedFiles(Microsoft.Build.Tasks.Reference)">
            <summary>
            Find related files like .pdbs and .xmls
            </summary>
            <param name="reference">The reference to the parent assembly.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.FindSatellites(Microsoft.Build.Tasks.Reference)">
            <summary>
            Find satellite assemblies.
            </summary>
            <param name="reference">The reference to the parent assembly.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.FindSerializationAssemblies(Microsoft.Build.Tasks.Reference)">
            <summary>
            Find serialization assemblies.
            </summary>
            <param name="reference">The reference to the parent assembly.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.GetUnifiedAssemblyMetadata(Microsoft.Build.Tasks.Reference,System.Collections.Generic.IEnumerable{Microsoft.Build.Tasks.UnifiedAssemblyName}@,System.String[]@)">
            <summary>
            Get unified dependencies and scatter files for a reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.GetUnifiedAssemblyNames(System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.AssemblyNameExtension})">
            <summary>
            Given an enumerator of pre-unified assembly names, return an enumerator of unified 
            assembly names.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.FindDependenciesAndScatterFiles(Microsoft.Build.Tasks.Reference,System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference}})">
            <summary>
            Find references and scatter files defined for the given assembly.
            </summary>
            <param name="reference">The reference to the parent assembly.</param>
            <param name="newEntries">New references are added to this list.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.IsPseudoAssembly(System.String)">
            <summary>
            Mscorlib is not a real managed assembly. It is seen both with and without metadata.
            We assume that the correct mscorlib is on the target platform.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.CalculateParentAssemblyDirectories(System.Collections.Generic.List{System.String},Microsoft.Build.Tasks.Reference)">
            <summary>
            Based on the set of parent assemblies we want to add their directories to the list of resolvers so that 
            if the dependency is sitting beside the assembly which requires it then we will resolve the assembly from that location first.
            
            The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly 
            to be found using those resolvers so that our GAC and AssemblyFolders checks later on will work on those assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ResolveReference(Microsoft.Build.Shared.AssemblyNameExtension,System.String,Microsoft.Build.Tasks.Reference)">
            <summary>
            Given an unresolved reference (one that we don't know the full name for yet), figure out the 
            full name. Should only be called on references that haven't been resolved yet--otherwise, its
            a perf problem.
            </summary>
            <param name="assemblyName">The fusion name for this reference.</param>
            <param name="rawFileNameCandidate">The file name to match if {RawFileName} is seen. (May be null).</param>
            <param name="reference">The reference object.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.RemoveReferencesMarkedForExclusion(System.Boolean,System.String)">
            <summary>
            This method will remove references from the reference table which are contained in the blacklist.
            References which are primary references but are in the black list will be placed in the invalidResolvedFiles list.
            References which are dependency references but are in the black list will be placed in the invalidResolvedDependencyFiles list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.AddToDependencyGraph(System.Collections.Generic.Dictionary{Microsoft.Build.Tasks.Reference,System.Collections.Generic.List{Microsoft.Build.Tasks.ReferenceTable.ReferenceAssemblyExtensionPair}},Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            References usually only contains who they depend on, they do not know who depends on them. Given a reference
            A we cannot inspect A to find out that B,C,D depend on it. This method will traverse the references and build up this other direction of the graph, 
            therefore we will be able to know given reference A, that B,C,D depend on it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.RemoveDependencyMarkedForExclusion(Microsoft.Build.Tasks.ReferenceTable.LogExclusionReason,System.Boolean,System.String,System.Collections.Generic.Dictionary{Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference},System.Collections.Generic.List{Microsoft.Build.Tasks.Reference},Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            We have determined the given assembly reference is in the black list, we now need to find the primary references which caused it and make sure those are removed from the list of references.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.RemovePrimaryReferenceMarkedForExclusion(Microsoft.Build.Tasks.ReferenceTable.LogExclusionReason,System.Boolean,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.Reference},Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            A primary references has been determined to be in the black list, it needs to be removed from the list of references by not being added to the list of good references
            and added to the list of removed references.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.GetReferenceFromItemSpec(System.String)">
            <summary>
            Get the primary reference based on the Itemspec
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.RemoveDependencies(Microsoft.Build.Tasks.Reference,System.Collections.Generic.Dictionary{Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference},System.Collections.Generic.Dictionary{Microsoft.Build.Tasks.Reference,System.Collections.Generic.List{Microsoft.Build.Tasks.ReferenceTable.ReferenceAssemblyExtensionPair}})">
            <summary>
            Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other 
            assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the black list.
            </summary>
            <param name="removedReference">Reference to remove dependencies for</param>
            <param name="referenceList">Reference list which contains reference to be used in unification and returned as resolved items</param>
            <param name="dependencyList"> A dictionary (Key: Reference Value: List of dependencies and their assembly name)</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ComputeClosure(System.Collections.Generic.IEnumerable{Microsoft.Build.Tasks.DependentAssembly},Microsoft.Build.Framework.ITaskItem[],Microsoft.Build.Framework.ITaskItem[],System.Collections.Generic.List{System.Exception})">
             <summary>
             Searches the table for references that haven't been resolved to their full file names and
             for dependencies that haven't yet been found.
            
             If any are found, they're resolved and then dependencies are found. Then the process is repeated 
             until nothing is left unresolved.
             </summary>
             <param name="remappedAssembliesValue">The table of remapped assemblies.</param>
             <param name="referenceAssemblyFiles">The task items which contain file names to add.</param>
             <param name="referenceAssemblyNames">The task items which contain fusion names to add.</param>
             <param name="exceptions">Errors encountered while computing closure.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ComputeClosure">
            <summary>
            Implementation of ComputeClosure.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.FindAssociatedFiles">
            <summary>
            Find associates for references that we haven't found associates for before.
            Returns true if new dependent assemblies were found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ResolveAssemblyFilenames">
            <summary>
            Resolve all references that have not been resolved yet to real files on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ResolveConflictsBetweenReferences(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyNameReference}})">
            <summary>
            This methods looks for conflicts between assemblies and attempts to 
            resolve them.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ResolveConflicts(System.Collections.Generic.List{Microsoft.Build.Tasks.DependentAssembly}@,System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyNameReference}@)">
            <summary>
            Based on the closure, get a table of ideal remappings needed to 
            produce zero conflicts.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.MarkReferencesExcludedDueToOtherFramework(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            If a reference is a higher version than what exists in the redist list of the target framework then 
            this reference needs to be marked as excluded so that it is not not allowed to be referenced. 
            
            If the user needs this reference then they need to set specific version to true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.InLatestRedistList(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Is the assembly in the latest framework redist list as either passed into RAR on the lastestFrameworkDirectories property or determined by inspecting the file system.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.GetHighestVersionFullFrameworkForTFM(System.Runtime.Versioning.FrameworkName)">
            <summary>
            Get the redist list which corresponds to the highest target framework for a given target framework moniker.
            
            This is done in two ways:
             First, if the latestTargetFrameworkDirectories parameter is passed into RAR those directories will be used to get the redist list
             regardless of the target framework moniker. 
             
            Second, if latest Target Framework Directories is not passed in then we ask the ToollocationHelper for the highest target framework which has 
            a TargetFrameworkIdentifier which matches the passed in TargetFrameworkMoniker.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.GetHighestVersionReferenceAssemblyDirectories(System.Runtime.Versioning.FrameworkName,System.Runtime.Versioning.FrameworkName@)">
            <summary>
            Based on a target framework moniker, get the set of reference assembly directories which 
            correspond to the highest version of the target framework identifier property on the target framework moniker.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.MarkReferenceWithHighestVersionInCurrentRedistList(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            Is the assemblyName in the current redist list and does it have a version number which is higher than what is in the current redist list.
            This may happen if someone passes in a p2p reference whcih is a framework assembly which is a higher version than what is in the redist list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.MarkReferenceForExclusionDueToHigherThanCurrentFramework(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            Is the assemblyName in the current redist list and does it have a version number which is higher than what is in the current redist list.
            This may happen if someone passes in a p2p reference whcih is a framework assembly which is a higher version than what is in the redist list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference)">
            <summary>
            Does the assembly have a targetFrameworkAttribute which has a higher framework version than what the project is currently targeting.
            This may happen for example if a p2p is done between two projects with built against different target frameworks.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.BuildSimpleNameTable">
            <summary>
            Build a table of simple names mapped to assemblyname+reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ResolveAssemblyNameConflict(Microsoft.Build.Tasks.AssemblyNameReference,Microsoft.Build.Tasks.AssemblyNameReference)">
            <summary>
            Given two references along with their fusion names, resolve the filename conflict that they
            would have if both assemblies need to be copied to the same directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.IsAssemblyRemovedFromDotNetFramework(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String[],Microsoft.Build.Tasks.InstalledAssemblies)">
            <summary>
            Returns true if an assembly has been removed from the .NET framework
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.UnifyAssemblyNameVersions(Microsoft.Build.Shared.AssemblyNameExtension,System.Version@,Microsoft.Build.Tasks.UnificationReason@,System.Boolean@,System.Nullable{System.Boolean}@,System.String@)">
            <summary>
            Get unification information for the given assembly name. 
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <param name="unifiedVersion">The new version of the assembly to use.</param>
            <param name="unificationReason">The reason this reference was unified.</param>
            <param name="isPrerequisite">True if this is a prereq assembly.</param>
            <returns>True if there was a unification.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.CompareAssembliesIgnoringVersion(System.Reflection.AssemblyName,System.Reflection.AssemblyName)">
            <summary>
            Used to avoid extra allocations from cloning AssemblyNameExtension and AssemblyName
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.GetReferenceItems(Microsoft.Build.Framework.ITaskItem[]@,Microsoft.Build.Framework.ITaskItem[]@,Microsoft.Build.Framework.ITaskItem[]@,Microsoft.Build.Framework.ITaskItem[]@,Microsoft.Build.Framework.ITaskItem[]@,Microsoft.Build.Framework.ITaskItem[]@,Microsoft.Build.Framework.ITaskItem[]@)">
            <summary>
            Return the resulting reference items, dependencies and other files.
            </summary>
            <param name="primaryFiles">Primary references fully resolved.</param>
            <param name="dependencyFiles">Dependent references fully resolved.</param>
            <param name="relatedFiles">Related files like .xmls and .pdbs.</param>
            <param name="satelliteFiles">Satellite files.</param>
            <param name="copyLocalFiles">All copy-local files out of primaryFiles+dependencyFiles+relatedFiles+satelliteFiles.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.SetItemMetadata(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.String,Microsoft.Build.Tasks.Reference,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Set metadata on the items which will be output from RAR.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.VerifyArchitectureOfImplementationDll(System.String,System.String)">
            <summary>
            Verify that the implementation dll has a matching architecture to what the project is targeting.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.ReadMachineTypeFromPEHeader(System.String)">
            <summary>
            Read the PE header to get the machine type
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.RemoveNonForwardableMetadata(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Some metadata should not be forwarded between the parent and child items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.FindCopyLocalItems(Microsoft.Build.Framework.ITaskItem[],System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Given a list of items, find all that have CopyLocal==true and add it to the list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.LogHigherVersionUnresolve(System.Boolean,Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            The reference was determined to have a version which is higher than what is in the currently targeted redist list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.LogHigherVersionUnresolveDueToAttribute(System.Boolean,Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            The reference was determined to have a version which is higher than what is in the currently targeted using the framework attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.LogAnotherFrameworkUnResolve(System.Boolean,Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            The reference was determined to not be in the current redist list but in fact are from another framework.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.LogProfileExclusionUnresolve(System.Boolean,Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            The reference was found to be resolved from a full framework while we are actually targeting a profile.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ReferenceTable.ReferenceAssemblyExtensionPair">
            <summary>
             Provide a class which has a key value pair for references and their assemblyNameExtensions.
             This is used to prevent JIT'ing when using a generic list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReferenceTable.MarkReferencesForExclusion(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Rather than have exclusion lists float around, we may as well just mark the reference themselves. This allows us to attach to a reference
            whether or not it is excluded and why.  This method will do a number of checks in a specific order and mark the reference as being excluded or not.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolutionSearchLocation">
            <summary>
            A place the resolver tried to look for an assembly along with some information
            that can be used to provide a good error message.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolutionSearchLocation.FileNameAttempted">
            <summary>
            The name of the file that was attempted to match.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolutionSearchLocation.SearchPath">
            <summary>
            The literal searchpath element that was used to discover this location.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolutionSearchLocation.AssemblyName">
            <summary>
            The name of the assembly found at that location. Will be null if there was no assembly there.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolutionSearchLocation.Reason">
            <summary>
            The reason there was no macth.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Resolver">
            <summary>
            Base class for all resolver types.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Resolver.searchPathElement">
            <summary>
            The corresponding element from the search path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Resolver.getAssemblyName">
            <summary>
            Delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Resolver.fileExists">
            <summary>
            Delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Resolver.getRuntimeVersion">
            <summary>
            Delegate
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Resolver.targetedRuntimeVersion">
            <summary>
            Runtime we are targeting
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Resolver.targetProcessorArchitecture">
            <summary>
            Processor architecture we are targeting.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Resolver.compareProcessorArchitecture">
            <summary>
            Should the processor architecture we are targeting match the assembly we resolve from disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Resolver.#ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,System.Reflection.ProcessorArchitecture,System.Boolean)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Resolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve a reference to a specific file name.
            </summary>
            <param name="assemblyName">The assemblyname of the reference.</param>
            <param name="sdkName">The name of the sdk to resolve.</param>
            <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
            <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
            <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
            <param name="executableExtensions">Allowed executable extensions.</param>
            <param name="hintPath">The item's hintpath value.</param>
            <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <param name="foundPath">The path where the file was found.</param>
            <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
            <returns>True if the file was resolved.</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Resolver.SearchPath">
            <summary>
            The search path element that this resolver is based on.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Resolver.ResolveAsFile(System.String,Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation})">
            <summary>
            Resolve a single file.
            </summary>
            <returns>True if the file was a match, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Resolver.FileMatchesAssemblyName(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean,System.Boolean,System.Boolean,System.String,Microsoft.Build.Tasks.ResolutionSearchLocation)">
            <summary>
            Determines whether an assembly name matches the assembly pointed to by pathToCandidateAssembly
            </summary>
            <param name="assemblyName">The assembly name to look up.</param>
            <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
            <param name="wantSpecificVersion">Whether the version needs to match exactly or loosely.</param>
            <param name="pathToCandidateAssembly">Path to a possible file.</param>
            <param name="searchLocation">Information about why the candidate file didn't match</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Resolver.ResolveFromDirectory(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean,System.Boolean,System.String[],System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation})">
            <summary>
            Given a strong name, which may optionally have Name, Version and Public Key,
            return a fully qualified directory name.
            </summary>
            <param name="assemblyName">The assembly name to look up.</param>
            <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
            <param name="executableExtensions">The possible filename extensions of the assembly. Must be one of these or its no match.</param>
            <param name="directory">the directory to look in</param>
            <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
            <returns>'null' if the assembly wasn't found.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveAssemblyReference">
            <summary>
            Given a list of assemblyFiles, determine the closure of all assemblyFiles that
            depend on those assemblyFiles including second and nth-order dependencies too.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveAssemblyReference.SystemRuntimeAssemblyName">
            <summary>
            key assembly used to trigger inclusion of facade references. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveAssemblyReference.NETStandardAssemblyName">
            <summary>
            additional key assembly used to trigger inclusion of facade references. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveAssemblyReference.GetListPath">
            <summary>
            Delegate to a method that takes a targetFrameworkDirectory and returns an array of redist or subset list paths
            </summary>
            <param name="targetFrameworkDirectory">TargetFramework directory to search for redist or subset list</param>
            <returns>String array of redist or subset lists</returns>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveAssemblyReference._cache">
            <summary>
            Cache of system state information, used to optimize performance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.#ctor">
            <summary>
            Construct
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks">
            <summary>
            If set to true, it forces to unresolve framework assemblies with versions higher or equal the version of the target framework, regardless of the target framework
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch">
            <summary>
            If there is a mismatch between the targetprocessor architecture and the architecture of a primary reference.
            
            When this is error,  an error will be logged. 
            
            When this is warn, if there is a mismatch between the targetprocessor architecture and the architecture of a primary reference a warning will be logged.
            
            When this is none, no error or warning will be logged.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles">
             <summary>
             A list of fully qualified paths-to-assemblyFiles to find dependencies for.
            
             Optional attributes are:
                 bool Private [default=true] -- means 'CopyLocal'
                 string FusionName -- the simple or strong fusion name for this item. If this 
                     attribute is present it can save time since the assembly file won't need
                     to be opened to get the fusion name.
                 bool ExternallyResolved [default=false] -- indicates that the reference and its
                    dependencies are resolved by an external system (commonly from nuget assets) and
                    so several steps can be skipped as an optimization: finding dependencies, 
                    satellite assemblies, etc.
             </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories">
            <summary>
            The list of directories which contain the redist lists for the most current 
            framework which can be targeted on the machine. If this is not set
            Then we will looks for the highest framework installed on the machine 
            for a given target framework identifier and use that.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch">
            <summary>
            Should the framework attribute be ignored when checking to see if an assembly is compatible with the targeted framework.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences">
            <summary>
            Force dependencies to be walked even when a reference is marked with ExternallyResolved=true
            metadata.
            </summary>
            <remarks>
            This is used to ensure that we suggest appropriate binding redirects for assembly version
            conflicts within an externally resolved graph.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets">
            <summary>
            List of target framework subset names which will be searched for in the target framework directories
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies">
             <summary>
             These can either be simple fusion names like:
            
                  System
            
             or strong names like
            
                 System, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
            
             These names will be resolved into full paths and all dependencies will be found.
            
             Optional attributes are:
                 bool Private [default=true] -- means 'CopyLocal'
                 string HintPath [default=''] -- location of file name to consider as a reference, 
                     used when {HintPathFromItem} is one of the paths in SearchPaths.
                 bool SpecificVersion [default=absent] -- 
                     when true, the exact fusionname in the Include must be matched. 
                     when false, any assembly with the same simple name will be a match.
                     when absent, then look at the value in Include. 
                       If its a simple name then behave as if specific version=false.
                       If its a strong name name then behave as if specific version=true.
                 string ExecutableExtension [default=absent] -- 
                     when present, the resolved assembly must have this extension.
                     when absent, .dll is considered and then .exe for each directory looked at.
                 string SubType -- only items with empty SubTypes will be considered. Items 
                     with non-empty subtypes will be ignored.
                 string AssemblyFolderKey [default=absent] -- supported for legacy AssemblyFolder 
                     resolution. This key can have a value like 'hklm\vendor folder'. When set, only
                     this particular assembly folder key will be used.
                        This is to support the scenario in VSWhidey#357946 in which there are multiple
                        side-by-side libraries installed and the user wants to pick an exact version.
                 bool EmbedInteropTyeps [default=absent] -- 
                     when true, we should treat this assembly as if it has no dependencies and should 
                     be completely embedded into the target assembly.
             </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles">
             <summary>
             A list of assembly files that can be part of the search and resolution process.
             These must be absolute filenames, or project-relative filenames.
            
             Assembly files in this list will be considered when SearchPaths contains
             {CandidateAssemblyFiles} as one of the paths to consider.
             </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences">
            <summary>
            A list of resolved SDK references which contain the sdk name, sdk location and the targeted configuration.
            These locations will only be searched if the reference has the SDKName metadata attached to it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories">
            <summary>
            Path to the target frameworks directory. Required to figure out CopyLocal status 
            for resulting items.
            If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity 
            have a Private='true' attribute on their source item.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables">
            <summary>
            A list of XML files that contain assemblies that are expected to be installed on the target machine.
            
            Format of the file is like:
            
                <FileList Redist="Microsoft-Windows-CLRCoreComp" >
                    <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
                    etc.
                </FileList>
            
            When present, assemblies from this list will be candidates to automatically "unify" from prior versions up to
            the version listed in the XML. Also, assemblies with InGAC='true' will be considered prerequisites and will be CopyLocal='false'
            unless explicitly overridden.
            Items in this list may optionally specify the "FrameworkDirectory" metadata to associate an InstalledAssemblyTable
            with a particular framework directory.  However, this setting will be ignored unless the Redist name begins with
            "Microsoft-Windows-CLRCoreComp".
            If there is only a single TargetFrameworkDirectories element, then any items in this list missing the
            "FrameworkDirectory" metadata will be treated as though this metadata is set to the lone (unique) value passed
            to TargetFrameworkDirectories.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables">
            <summary>
            A list of XML files that contain assemblies that are expected to be in the target subset
            
            Format of the file is like:
            
                <FileList Redist="ClientSubset" >
                    <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
                    etc.
                </FileList>
            
            Items in this list may optionally specify the "FrameworkDirectory" metadata to associate an InstalledAssemblySubsetTable
            with a particular framework directory. 
            If there is only a single TargetFrameworkDirectories element, then any items in this list missing the
            "FrameworkDirectory" metadata will be treated as though this metadata is set to the lone (unique) value passed
            to TargetFrameworkDirectories.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables">
            <summary>
            A list of XML files that contain the full framework for the profile.
            
            Normally nothing is passed in here, this is for the cases where the location of the xml file for the full framework 
            is not under a RedistList folder.
            
            Format of the file is like:
            
                <FileList Redist="MatchingRedistListName" >
                    <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
                    etc.
                </FileList>
            
            Items in this list must specify the "FrameworkDirectory" metadata to associate an redist list
            with a particular framework directory. If the association is not made an error will be logged. The reason is, 
            The logic in rar assumes if a FrameworkDirectory is not set it will use the target framework directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables">
            <summary>
            [default=false]
            Boolean property to control whether or not the task should look for and use additional installed 
            assembly tables (a.k.a Redist Lists) found in the RedistList directory underneath the provided
            TargetFrameworkDirectories.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables">
            <summary>
            [default=false]
            Boolean property to control whether or not the task should look for and use additional installed 
            assembly subset tables (a.k.a Subset Lists) found in the SubsetList directory underneath the provided
            TargetFrameworkDirectories.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences">
            <summary>
            If the primary reference is a framework assembly ignore its version information and actually resolve the framework assembly from the currently targeted framework.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture">
            <summary>
            The preferred target processor architecture. Used for resolving {GAC} references. 
            Should be like x86, IA64 or AMD64.
            
            This is the order of preference:
            (1) Assemblies in the GAC that match the supplied ProcessorArchitecture.
            (2) Assemblies in the GAC that have ProcessorArchitecture=MSIL
            (3) Assemblies in the GAC that have no ProcessorArchitecture.
            
            If absent, then only consider assemblies in the GAC that have ProcessorArchitecture==MSIL or
            no ProcessorArchitecture (these are pre-Whidbey assemblies).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion">
            <summary>
            What is the runtime we are targeting, is it 2.0.57027 or anotherone, It can have a v or not prefixed onto it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths">
             <summary>
             List of locations to search for assemblyFiles when resolving dependencies.
             The following types of things can be passed in here:
             (1) A plain old directory path.
             (2) {HintPathFromItem} -- Look at the HintPath attribute from the base item.
                 This attribute must be a file name *not* a directory name.
             (3) {CandidateAssemblyFiles} -- Look at the files passed in through the CandidateAssemblyFiles
                 parameter.
             (4) {Registry:_AssemblyFoldersBase_,_RuntimeVersion_,_AssemblyFoldersSuffix_}
                  Where:
            
                     _AssemblyFoldersBase_ = Software\Microsoft\[.NetFramework | .NetCompactFramework]
                     _RuntimeVersion_ = the runtime version property from the project file
                     _AssemblyFoldersSuffix_ = [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx
            
                  Then look in the registry for keys with the following schema:
            
                     [HKLM | HKCU]\SOFTWARE\MICROSOFT\.NetFramework\
                       v1.0.3705
                         AssemblyFoldersEx
                             ControlVendor.GridControl.1.0:
                                 @Default = c:\program files\ControlVendor\grid control\1.0\bin
                                 @Description = Grid Control for .NET version 1.0
                                 9466
                                     @Default = c:\program files\ControlVendor\grid control\1.0sp1\bin
                                     @Description = SP1 for Grid Control for .NET version 1.0
            
                  The based registry key is composed as:
            
                      [HKLM | HKCU]\_AssemblyFoldersBase_\_RuntimeVersion_\_AssemblyFoldersSuffix_
            
             (5) {AssemblyFolders} -- Use the VisualStudion 2003 .NET finding-assemblies-from-registry scheme.
             (6) {GAC} -- Look in the GAC.
             (7) {RawFileName} -- Consider the Include value to be an exact path and file name.
            
            
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions">
            <summary>
            [default=.exe;.dll]
            These are the assembly extensions that will be considered during references resolution.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions">
            <summary>
            [default=.pdb;.xml]
            These are the extensions that will be considered when looking for related files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile">
             <summary>
             If this file name is passed in, then we parse it as an app.config file and extract bindingRedirect mappings. These mappings are used in the dependency
             calculation process to remap versions of assemblies.
            
             If this parameter is passed in, then AutoUnify must be false, otherwise error.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration">
            <summary>
            This is true if the project type supports "AutoGenerateBindingRedirects" (currently only for EXE projects).
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify">
             <summary>
             [default=false]
             This parameter is used for building assemblies, such as DLLs, which cannot have a normal
             App.Config file.
            
             When true, the resulting dependency graph is automatically treated as if there were an
             App.Config file passed in to the AppConfigFile parameter. This virtual
             App.Config file has a bindingRedirect entry for each conflicting set of assemblies such
             that the highest version assembly is chosen. A consequence of this is that there will never
             be a warning about conflicting assemblies because every conflict will have been resolved.
            
             When true, each distinct remapping will result in a high priority comment indicating the
             old and new versions and the fact that this was done automatically because AutoUnify was true.
            
             When true, the AppConfigFile parameter should be empty. Otherwise, it's an
             error.
            
             When false, no assembly version remapping will occur automatically. When two versions of an
             assembly are present, there will be a warning.
            
             When false, each distinct conflict between different versions of the same assembly will
             result in a high priority comment. After all of these comments are displayed, there will be
             a single warning with a unique error code and text that reads "Found conflicts between
             different versions of reference and dependent assemblies".
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac">
            <summary>
             When determining if a dependency should be copied locally one of the checks done is to see if the 
             parent reference in the project file has the Private metadata set or not. If that metadata is set then 
             We will use that for the dependency as well. 
             
            However, if the metadata is not set then the dependency will go through the same checks as the parent reference. 
            One of these checks is to see if the reference is in the GAC. If a reference is in the GAC then we will not copy it locally
            as it is assumed it will be in the gac on the target machine as well. However this only applies to that specific reference and not its dependencies.
            
            This means a reference in the project file may be copy local false due to it being in the GAC but the dependencies may still be copied locally because they are not in the GAC.
            This is the default behavior for RAR and causes the default value for this property to be true.
            
            When this property is false we will still check project file references to see if they are in the GAC and set their copy local state as appropriate. 
            However for dependencies we will not only check to see if they are in the GAC but we will also check to see if the parent reference from the project file is in the GAC. 
            If the parent reference from the project file is in the GAC then we will not copy the dependency locally.
            
            NOTE: If there are multiple parent reference and ANY of them does not come from the GAC then we will set copy local to true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac">
            <summary>
            [default=false]
            Enables legacy mode for CopyLocal determination. If true, referenced assemblies will not be copied locally if they
            are found in the GAC. If false, assemblies will be copied locally unless they were found only in the GAC.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile">
            <summary>
            An optional file name that indicates where to save intermediate build state
            for this task. If not specified, then no inter-build caching will occur.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies">
             <summary>
             If set, then dependencies will be found. Otherwise, only Primary references will be
             resolved.
            
             Default is true.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites">
             <summary>
             If set, then satellites will be found.
            
             Default is true.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies">
             <summary>
             If set, then serialization assemblies will be found.
            
             Default is true.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles">
             <summary>
             If set, then related files (.pdbs and .xmls) will be found.
            
             Default is true.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.Silent">
             <summary>
             If set, then don't log any messages to the screen.
            
             Default is false.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion">
             <summary>
             The project target framework version.
            
             Default is empty. which means there will be no filtering for the reference based on their target framework.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker">
             <summary>
             The target framework moniker we are targeting if any. This is used for logging purposes.
            
             Default is empty.
             </summary>
             <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName">
            <summary>
            The display name of the target framework moniker, if any. This is only for logging.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames">
            <summary>
            Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring 
            of TargetFrameworkSubsets.
            
            Full, Complete
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName">
            <summary>
            Name of the target framework profile we are targeting.
            Eg. Client, Web, or Network
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders">
            <summary>
            Set of folders which containd a RedistList directory which represent the full framework for a given client profile.
            An example would be 
            %programfiles%\reference assemblies\microsoft\framework\v4.0
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles">
            <summary>
            This is a list of all primary references resolved to full paths.
                bool CopyLocal - whether the given reference should be copied to the output directory.
                string FusionName - the fusion name for this dependency.
                string ResolvedFrom - the literal search path that this file was resolved from.
                bool IsRedistRoot - Whether or not this assembly is the representative for an entire redist.
                    'true' means the assembly is representative of an entire redist and should be indicated as
                    an application dependency in an application manifest.
                    'false' means the assembly is internal to a redist and should not be part of the
                    application manifest.
                string Redist - The name (if any) of the redist that contains this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles">
            <summary>
            A list of all n-th order paths-to-dependencies with the following attributes:
                bool CopyLocal - whether the given reference should be copied to the output directory.
                string FusionName - the fusion name for this dependency.
                string ResolvedFrom - the literal search path that this file was resolved from.
                bool IsRedistRoot - Whether or not this assembly is the representative for an entire redist.
                    'true' means the assembly is representative of an entire redist and should be indicated as 
                    an application dependency in an application manifest.
                    'false' means the assembly is internal to a redist and should not be part of the 
                    application manifest.
                string Redist - The name (if any) of the redist that contains this assembly.
            Does not include first order primary references--this list is in ResolvedFiles.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles">
            <summary>
            Related files are files like intellidoc (.XML) and symbols (.PDB) that have the same base
            name as a reference.
                bool Primary [always false] - true if this assembly was passed in with Assemblies.
                bool CopyLocal - whether the given reference should be copied to the output directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles">
            <summary>
            Any satellite files found. These will be CopyLocal=true iff the reference or dependency 
            that caused this item to exist is CopyLocal=true.
                bool CopyLocal - whether the given reference should be copied to the output directory.
                string DestinationSubDirectory - the relative destination directory that this file 
                  should be copied to. This is mainly for satellites.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles">
            <summary>
            Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency 
            that caused this item to exist is CopyLocal=true.
                bool CopyLocal - whether the given reference should be copied to the output directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles">
            <summary>
            Scatter files associated with one of the given assemblies.
                bool CopyLocal - whether the given reference should be copied to the output directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles">
            <summary>
            Returns every file in ResolvedFiles+ResolvedDependencyFiles+RelatedFiles+SatelliteFiles+ScatterFiles+SatelliteAssemblyFiles
            that have CopyLocal flags set to 'true'.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects">
             <summary>
             Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly 
             identity--including culture and PKT--that was found that did not have a suitable bindingRedirect 
             entry in the ApplicationConfigurationFile. 
            
             Each returned ITaskItem will have the following values:
              ItemSpec - the full fusion name of the assembly family with empty version=0.0.0.0
              MaxVersion - the maximum version number.
             </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveAssemblyReference._filesWritten">
            <summary>
            Storage for names of all files writen to disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten">
            <summary>
            The names of all files written to disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnSystemRuntime">
            <summary>
            Whether the assembly or any of its primary references depends on system.runtime. (Aka needs Facade references to resolve duplicate types)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnNETStandard">
            <summary>
            Whether the assembly or any of its primary references depends on netstandard
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogResults(Microsoft.Build.Tasks.ReferenceTable,System.Collections.Generic.List{Microsoft.Build.Tasks.DependentAssembly},System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyNameReference},System.Collections.Generic.List{System.Exception})">
            <summary>
            Log the results.
            </summary>
            <param name="dependencyTable">Reference table.</param>
            <param name="idealAssemblyRemappings">Array of ideal assembly remappings.</param>
            <param name="idealAssemblyRemappingsIdentities">Array of identities of ideal assembly remappings.</param>
            <param name="generalResolutionExceptions">List of exceptions that were not attributable to a particular fusion name.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.ByteArrayToString(System.Byte[])">
            <summary>
            Used to generate the string representation of a public key token.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogReferenceDependenciesAndSourceItems(System.String,Microsoft.Build.Tasks.Reference)">
            <summary>
            Log the source items and dependencies which lead to a given item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogDependeeReference(Microsoft.Build.Tasks.Reference)">
            <summary>
            Log the dependee and the item specs which caused the dependee reference to be resolved.
            </summary>
            <param name="dependeeReference"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogReference(Microsoft.Build.Tasks.Reference,System.String)">
            <summary>
            Display the information about how a reference was resolved.
            </summary>
            <param name="reference">The reference information</param>
            <param name="fusionName">The fusion name of the reference.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.ChooseReferenceLoggingImportance(Microsoft.Build.Tasks.Reference)">
            <summary>
            Choose an importance level for reporting information about this reference.
            </summary>
            <param name="reference">The reference.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogInputs">
            <summary>
            Log all task inputs.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogAttribute(Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            Log a specific item metadata.
            </summary>
            <param name="item"></param>
            <param name="attribute"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogPrimaryOrDependency(Microsoft.Build.Tasks.Reference,System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Describes whether this reference is primary or not
            </summary>
            <param name="reference">The reference.</param>
            <param name="fusionName">The fusion name for this reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogReferenceErrors(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Log any errors for a reference.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogFullName(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Show the full name of a reference.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogAssembliesConsideredAndRejected(Microsoft.Build.Tasks.Reference,System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            If there is a list of assemblyFiles that was considered but then rejected,
            show information about them.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogDependees(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Show the files that made this dependency necessary.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogRelatedFiles(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Log related files.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogSatellites(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Log the satellite files.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogScatterFiles(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Log the satellite files.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogCopyLocalState(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Log a message about the CopyLocal state of the reference.
            </summary>
            <param name="reference">The reference.</param>
            <param name="importance">The importance of the message.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogImageRuntime(Microsoft.Build.Tasks.Reference,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Log a message about the imageruntime information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.LogConflict(Microsoft.Build.Tasks.Reference,System.String)">
            <summary>
            Log a conflict.
            </summary>
            <param name="reference">The reference.</param>
            <param name="fusionName">The fusion name of the reference.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.ReadStateFile">
            <summary>
            Reads the state file (if present) into the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.WriteStateFile">
            <summary>
            Write out the state file if a state name was supplied and the cache is dirty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.GetAssemblyRemappingsFromAppConfig">
            <summary>
            Read the app.config and get any assembly remappings from it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.Execute(Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Tasks.GetDirectories,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyMetadata,Microsoft.Build.Shared.GetRegistrySubKeyNames,Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue,Microsoft.Build.Tasks.GetLastWriteTime,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,Microsoft.Build.Shared.OpenBaseKey,Microsoft.Build.Tasks.GetAssemblyPathInGac,Microsoft.Build.Tasks.IsWinMDFile,Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader)">
            <summary>
            Execute the task.
            </summary>
            <param name="fileExists">Delegate used for checking for the existence of a file.</param>
            <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
            <param name="getDirectories">Delegate used for finding directories.</param>
            <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
            <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
            <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
            <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
            <param name="getLastWriteTime">Delegate used to get the last write time.</param>
            <returns>True if there was success.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.GetDependencies(Microsoft.Build.Tasks.Reference,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyMetadata,System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Build.Tasks.AssemblyDependency.AssemblyMetadata})">
            <summary>
            Returns the raw list of direct dependent assemblies from assembly's metadata.
            </summary>
            <param name="resolvedReference">reference we are interested</param>
            <param name="fileExists">the delegate to check for the existence of a file.</param>
            <param name="getAssemblyMetadata">the delegate to access assembly metadata</param>
            <param name="assemblyMetadataCache">Cache of pre-extracted assembly metadata.</param>
            <returns>list of dependencies</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.CombineRemappedAssemblies(System.Collections.Generic.IReadOnlyCollection{Microsoft.Build.Tasks.DependentAssembly},System.Collections.Generic.IReadOnlyCollection{Microsoft.Build.Tasks.DependentAssembly})">
            <summary>
            Combines two DependentAssembly arrays into one.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.SetTargetedRuntimeVersion(System.String)">
            <summary>
            If a targeted runtime is passed in use that, if none is passed in then we need to use v2.0.50727
            since the common way this would be empty is if we were using RAR as an override task.
            </summary>
            <returns>The targered runtime</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.HandleProfile(Microsoft.Build.Tasks.AssemblyTableInfo[],Microsoft.Build.Tasks.AssemblyTableInfo[]@,System.Collections.Generic.Dictionary{System.String,System.String}@,Microsoft.Build.Tasks.RedistList@)">
            <summary>
            For a given profile generate the exclusion list and return the list of redist list files read in so they can be logged at the end of the task execution.
            </summary>
            <param name="installedAssemblyTableInfo">Installed assembly info of the profile redist lists</param>
            <param name="fullRedistAssemblyTableInfo">Installed assemblyInfo for the full framework redist lists</param>
            <param name="blackList">Generated exclusion list</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.GenerateSubSetName(System.String[],Microsoft.Build.Framework.ITaskItem[])">
            <summary>
            Given the names of the targetFrameworkSubset lists passed in generate a single name which can be used for logging.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.VerifyInputConditions">
            <summary>
            Make sure certain combinations of properties are validated before continuing with the execution of rar.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.DumpTargetProfileLists(Microsoft.Build.Tasks.AssemblyTableInfo[],Microsoft.Build.Tasks.AssemblyTableInfo[],Microsoft.Build.Tasks.ReferenceTable)">
            <summary>
            Log the target framework subset information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.ShouldUseSubsetBlackList">
            <summary>
            Determine if a black list should be used or not
            
            The black list should only be used if there are TargetFrameworkSubsets to use or TargetFrameworkProfiles.
            
            1) If we find a Full or equivalent marker in the list of subsets passed in we do not want to generate a black list even if installedAssemblySubsets are passed in
            2) If we are ignoring the default installed subset tables and we have not passed in any additional subset tables, we do not want to generate a black list
            3) If no targetframework subsets were passed in and no additional subset tables were passed in, we do not want to generate a blacklist
            </summary>
            <returns>True if we should generate a black list, false if a blacklist should not be generated</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.PopulateSuggestedRedirects(System.Collections.Generic.List{Microsoft.Build.Tasks.DependentAssembly},System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyNameReference})">
            <summary>
            Populates the suggested redirects output parameter.
            </summary>
            <param name="idealAssemblyRemappings">The list of ideal remappings.</param>
            <param name="idealAssemblyRemappedReferences">The list of of references to ideal assembly remappings.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.GetInstalledAssemblyTableInfo(System.Boolean,Microsoft.Build.Framework.ITaskItem[],Microsoft.Build.Tasks.ResolveAssemblyReference.GetListPath,System.String[])">
            <summary>
            Process TargetFrameworkDirectories and an array of InstalledAssemblyTables.
            The goal is this:  for each installed assembly table (whether found on disk
            or given as an input), we wish to determine the target framework directory
            it is associated with.
            </summary>
            <returns>Array of AssemblyTableInfo objects (Describe the path and framework directory of a redist or subset list xml file) </returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.FrameworkVersionFromString(System.String)">
            <summary>
            Converts the string target framework value to a number.
            Accepts both "v" prefixed and no "v" prefixed formats
            if format is bad will log a message and return 0.
            </summary>
            <returns>Target framework version value</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.IsAvailableForTargetFramework(System.String)">
            <summary>
            Check if the assembly is available for on project's target framework.
            - Assuming the russian doll model. It will be available if the projects target framework is higher or equal than the assembly target framework
            </summary>
            <returns>True if the assembly is available for the project's target framework.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.FilterBySubtypeAndTargetFramework">
            <summary>
            Validate and filter the Assemblies that were passed in.
            - Check for assemblies that look like file names.
            - Check for assemblies where subtype!=''. These are removed.
            - Check for assemblies that have target framework higher than the project. These are removed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.ProcessorArchitectureToString(System.Reflection.ProcessorArchitecture)">
            <summary>
            Take a processor architecure and get the string representation back.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.GetAssemblyPathInGac(Microsoft.Build.Shared.AssemblyNameExtension,System.Reflection.ProcessorArchitecture,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,Microsoft.Build.Shared.FileExists,System.Boolean,System.Boolean)">
            <summary>
             Checks to see if the assemblyName passed in is in the GAC.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveAssemblyReference.Execute">
            <summary>
            Execute the task.
            </summary>
            <returns>True if there was success.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.TaskItemSpecFilenameComparer">
            <summary>
            Compare two ITaskItems by the file name in their ItemSpec.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.TaskItemSpecFilenameComparer.#ctor">
            <summary>
            Private construct so there's only one instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.TaskItemSpecFilenameComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare the two AssemblyNameReferences by file name, and if that is equal, by item spec.
            </summary>
            <remarks>
            Sorting by item spec allows these to be ordered consistently:
            c:\Regress315619\A\MyAssembly.dll
            c:\Regress315619\B\MyAssembly.dll
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Tasks.UnificationReason">
            <summary>
            The reason that a unification happened
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.UnificationReason.DidntUnify">
            <summary>
            This reference was not unified.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.UnificationReason.FrameworkRetarget">
            <summary>
            Unified because this was a framework assembly and it the current fusion
            loader rules would unify to a different version.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.UnificationReason.BecauseOfBindingRedirect">
            <summary>
            Unified because of a binding redirect coming from either an explicit
            app.config file or implicitly because AutoUnify was true.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.UnificationVersion">
            <summary>
            A version number coupled with a reason why this version number
            was chosen.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.UnifiedAssemblyName">
            <summary>
            A unified assembly name.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior">
            <summary>
            Enum describing the behavior when a a primary reference has an architecture different from the project
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior.Error">
            <summary>
            Print an error
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning">
            <summary>
            Print a warning
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior.None">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyFolder">
            <summary>
            Contains utility functions for dealing with assembly folders found in the registry.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFolder.s_assemblyFolders">
            <summary>
            Key -- Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project
            Value -- Directory
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyFolder.s_syncLock">
            <summary>
            Synchronize the creation of assemblyFolders
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFolder.AddFoldersFromRegistryKey(Microsoft.Win32.RegistryKey,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Given a registry key, find all of the registered assembly folders and add them to the list.
            </summary>
            <param name="hive">Like 'hklm' or 'hkcu'</param>
            <param name="key">The registry key to examine</param>
            <param name="directories">The object to populate</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFolder.AddFoldersFromRegistryKey(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            For the given key name, look for registered assembly folders in HKCU then HKLM.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFolder.CreateAssemblyFolders">
            <summary>
            Populates the internal tables.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyFolder.GetAssemblyFolders(System.String)">
            <summary>
            Returns the list of assembly folders that we're interested in.
            </summary>
            <param name="regKeyAlias">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyRemapping">
            <summary>
            Describes a remapping entry pair
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyRemapping.#ctor(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyRemapping.From">
            <summary>
            The assemblyName we mapped from
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyRemapping.To">
            <summary>
            The assemblyName we mapped to
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyRemapping.Equals(System.Object)">
            <summary>
            Compare two Assembly remapping objects
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyRemapping.GetHashCode">
            <summary>
            Get the hash code
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyRemapping.Equals(Microsoft.Build.Tasks.AssemblyRemapping)">
            <summary>
            We only compare the from because in terms of what is in the redist list unique from's are expected
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssignLinkMetadata">
            <summary>
            Task to assign a reasonable "Link" metadata to the provided items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignLinkMetadata.Items">
            <summary>
            The set of items to assign metadata to
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems">
            <summary>
            The set of items to which the Link metadata has been set
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignLinkMetadata.Execute">
            <summary>
            Sets "Link" metadata on any item where the project file in which they 
            were defined is different from the parent project file to a sane default: 
            the relative directory compared to the defining file.  
            
            Does NOT overwrite Link metadata if it's already defined. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents">
            <summary>
            A special XML string containing a project configuration for each project - we need to simply 
            match the projects and assign the appropriate configuration names to them
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies">
            <summary>
            Whether to use the solution dependency information passed in the solution blob
            to add synthetic project references for the purposes of build ordering
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping">
            <summary>
            String containing a semicolon-delimited list of mappings from the platform names used
            by most VS types to those used by .vcxprojs.  
            </summary>
            <remarks>
            E.g.  "AnyCPU=Win32"
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping">
            <summary>
            String containing a semicolon-delimited list of mappings from .vcxproj platform names
            to the platform names use by most other VS project types.  
            </summary>
            <remarks>
            E.g.  "Win32=AnyCPU"
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject">
            <summary>
            The current project's full path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration">
            <summary>
            The current project's platform.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform">
            <summary>
            The current project's platform.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration">
            <summary>
            Should we build references even if they were disabled in the project configuration
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform">
            <summary>
            Whether to set the GlobalPropertiesToRemove metadata on the project reference such that
            on an MSBuild call, the Configuration and Platform metadata will be unset, allowing the 
            child project to build in its default configuration / platform. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType">
            <summary>
            The output type for the project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings">
            <summary>
            True if we should use the default mappings to resolve the configuration/platform
            of the passed in project references, false otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects">
            <summary>
            The list of resolved reference paths (preserving the original project reference attributes)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects">
            <summary>
            The list of project reference items that could not be resolved using the pre-resolved list of outputs.
            Since VS only pre-resolves non-MSBuild projects, this means that project references in this list
            are in the MSBuild format.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignProjectConfiguration.Execute">
            <summary>
            Main task method
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveProject(Microsoft.Build.Framework.ITaskItem,Microsoft.Build.Framework.ITaskItem@)">
            <summary>
            Given a project reference task item and an XML document containing project configurations, 
            find the configuration for that task item.
            </summary>
            <returns>true if resolved successfully</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignProjectConfiguration.SetBuildInProjectAndReferenceOutputAssemblyMetadata(System.Boolean,Microsoft.Build.Framework.ITaskItem,System.Xml.XmlElement)">
            <summary>
            Given the project configuration blob and the project reference item, set the BuildInProject metadata and the ReferenceOutputAssembly metadata
            based on the contents of the blob.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignProjectConfiguration.SetupDefaultPlatformMappings">
            <summary>
            Given the contents of VcxToDefaultPlatformMapping and DefaultToVcxPlatformMapping properties, 
            fill out the maps that will be used to translate between the two.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignProjectConfiguration.PopulateMappingDictionary(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Given a dictionary to populate and a string of the format "a=b;c=d", populate the 
            dictionary with the given pairs.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssignTargetPath">
            <summary>
            Create a new list of items that have &lt;TargetPath&gt; attributes if none was present in
            the input.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignTargetPath.RootFolder">
            <summary>
            The folder to make the links relative to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignTargetPath.Files">
            <summary>
            The incoming list of files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles">
            <summary>
            The resulting list of files.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignTargetPath.Execute">
            <summary>
            Execute the task.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.CallTarget">
            <remarks>
            This class implements the "CallTarget" task, which invokes other targets within the same
            project file.  Marked RunInMTA because we do not want this task to ever be invoked explicitly
            on the STA if the RequestBuilder is running on another thread, as this will cause thread
            id validation checks to fail.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.CallTarget.Targets">
            <summary>
            The targets to build.
            </summary>
            <value>Array of target names.</value>
            <remarks>
            This is a required parameter. If you want to build the 
            default targets, use the &lt;MSBuild&gt; task and pass in Projects=$(MSBuildProjectFile).
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.CallTarget.TargetOutputs">
            <summary>
            Outputs of the targets built in each project.
            </summary>
            <value>Array of output items.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately">
            <summary>
            When this is true, instead of calling the engine once to build all the targets (for each project),
            we would call the engine once per target (for each project).  The benefit of this is that
            if one target fails, you can still continue with the remaining targets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CallTarget.UseResultsCache">
            <summary>
            Deprecated. Does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CallTarget.Execute">
            <summary>
            Instructs the MSBuild engine to build one or more targets in the current project.
            </summary>
            <returns>true if all targets built successfully; false if any target fails</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.CombinePath">
            <summary>
            Task to call Path.Combine.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CombinePath.BasePath">
            <summary>
            The base path, the first parameter into Path.Combine.  Can be a relative path,
            absolute path, or (blank).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CombinePath.Paths">
            <summary>
            The list of paths to combine with the base path.  These can be relative paths
            or absolute paths.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CombinePath.CombinedPaths">
            <summary>
            This is the output of the task, a list of paths produced by combining the base
            path with each of the paths passed in.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CombinePath.Execute">
            <summary>
            Calls Path.Combine for each of the inputs.  Preserves metadata.
            </summary>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.CommandLineBuilderExtension">
            <summary>
            CommandLineBuilder derived class for specialized logic specific to MSBuild tasks
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.#ctor">
            <summary>
            Initializes a new instance of the CommandLineBuilderExtension class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the CommandLineBuilderExtension class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendWhenTrue(System.String,System.Collections.Hashtable,System.String)">
            <summary>
            Set a boolean switch iff its value exists and its value is 'true'.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendPlusOrMinusSwitch(System.String,System.Collections.Hashtable,System.String)">
            <summary>
            Set a boolean switch only if its value exists.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendPlusOrMinusSwitch(System.String,System.Nullable{System.Boolean})">
            <summary>
            Set a boolean switch only if its value exists.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendByChoiceSwitch(System.String,System.Collections.Hashtable,System.String,System.String,System.String)">
            <summary>
            Set a switch if its value exists by choosing from the input choices
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendSwitchWithInteger(System.String,System.Collections.Hashtable,System.String)">
            <summary>
            Set an integer switch only if its value exists.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendSwitchAliased(System.String,System.String,System.String)">
            <summary>
            Adds an aliased switch, used for ResGen:
                 /reference:Foo=System.Xml.dll
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendNestedSwitch(System.String,System.String,System.String)">
            <summary>
            Adds a nested switch, used by SGen.exe.  For example:
                /compiler:"/keyfile:\"c:\some folder\myfile.snk\""
            </summary>
            <param name="outerSwitchName"></param>
            <param name="innerSwitchName"></param>
            <param name="parameter"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.GetQuotedText(System.String)">
            <summary>
            Returns a quoted string appropriate for appending to a command line.
            </summary>
            <remarks>
            Escapes any double quotes in the string.
            </remarks>
            <param name="unquotedText"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendSwitchIfNotNull(System.String,Microsoft.Build.Framework.ITaskItem[],System.String[])">
            <summary>
            Appends a command-line switch that takes a compound string parameter. The parameter is built up from the item-spec and
            the specified attributes. The switch is appended as many times as there are parameters given.
            </summary>
            <param name="switchName"></param>
            <param name="parameters"></param>
            <param name="attributes"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendSwitchWithSplitting(System.String,System.String,System.String,System.Char[])">
            <summary>
            Append a switch if 'parameter' is not null.
            Split on the characters provided.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.IsParameterEmpty(System.String,System.Char[])">
            <summary>
            Returns true if the parameter is empty in spirits, 
            even if it contains the separators and white space only
            Split on the characters provided.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendSwitchIfNotNull(System.String,Microsoft.Build.Framework.ITaskItem[],System.String[],System.Boolean[])">
             <summary>
             Designed to handle the /link and /embed swithes:
            
                  /embed[resource]:&lt;filename&gt;[,&lt;name&gt;[,Private]]
                  /link[resource]:&lt;filename&gt;[,&lt;name&gt;[,Private]]
            
             Where the last flag--Private--is either present or not present
             depending on whether the ITaskItem has a Private="True" attribue.
             </summary>
             <param name="switchName"></param>
             <param name="parameters"></param>
             <param name="metadataNames"></param>
             <param name="treatAsFlags"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.CommandLineBuilderExtension.AppendSwitchIfTrue(System.String,System.Nullable{System.Boolean})">
            <summary>
            Appends a switch if the specified value is <code>true</code>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResourceHandling.BinaryFormatterByteArrayResource.TypeAssemblyQualifiedName">
            <summary>
            BinaryFormatter byte arrays contain the type name, but it is not directly accessible from the resx.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResourceHandling.BinaryFormatterByteArrayResource.TypeFullName">
            <summary>
            BinaryFormatter byte arrays contain the type name, but it is not directly accessible from the resx.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResourceHandling.FileStreamResource.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Construct a new linked resource.
            </summary>
            <param name="name">The resource's name</param>
            <param name="assemblyQualifiedTypeName">The assembly-qualified type name of the resource (at runtime).</param>
            <param name="fileName">The absolute path of the file to be embedded as a resource.</param>
            <param name="originatingFile">The absolute path of the file that defined the ResXFileRef to this resource.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResourceHandling.IResource.Name">
            <summary>
            Name of the resource, as specified in the source.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResourceHandling.IResource.TypeAssemblyQualifiedName">
            <summary>
            The resource's type's assembly-qualified name. May be null when the type is not knowable from the source.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResourceHandling.IResource.TypeFullName">
            <summary>
            The resource's type's full name. May be null when the type is not knowable from the source.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResourceHandling.IResource.AddTo(System.Resources.IResourceWriter)">
            <summary>
            Adds the resource represented by this object to the specified writer.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResourceHandling.LiveObjectResource">
            <summary>
            Name value resource pair to go in resources list
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Tasks.ResourceHandling.MSBuildResXReader.IsByteArray(System.String)" -->
        <member name="M:Microsoft.Build.Tasks.ResourceHandling.MSBuildResXReader.GetResourcesFromFile(System.String,System.Boolean)">
            <summary>
            Extract <see cref="T:Microsoft.Build.Tasks.ResourceHandling.IResource"/>s from a given file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResourceHandling.NameUtilities.FullNameFromAssemblyQualifiedName(System.String)">
            <summary>
            Extract the full name of a type from an assembly-qualified name string.
            </summary>
            <param name="assemblyQualifiedName"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.TypeLibNames">
            <summary>
            COM references specified by guid/version/lcid
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.TypeLibFiles">
            <summary>
            COM references specified by type library file path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.EnvironmentVariables">
            <summary>
            Array of equals-separated pairs of environment
            variables that should be passed to the spawned tlbimp.exe and aximp.exe,
            in addition to (or selectively overriding) the regular environment block.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.WrapperOutputDirectory">
            <summary>
            the directory wrapper files get generated into
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.IncludeVersionInInteropName">
            <summary>
            When set to true, the typelib version will be included in the wrapper name.  Default is false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.ResolvedAssemblyReferences">
            <summary>
            source of resolved .NET assemblies - we need this for ActiveX wrappers, since we can't resolve .NET assembly
            references ourselves
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.KeyContainer">
            <summary>
            container name for public/private keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.KeyFile">
            <summary>
            file containing public/private keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.DelaySign">
            <summary>
            delay sign wrappers?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.NoClassMembers">
            <summary>
            Passes the TypeLibImporterFlags.PreventClassMembers flag to tlb wrapper generation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.Silent">
            <summary>
            If true, do not log messages or warnings.  Default is false. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.TargetProcessorArchitecture">
            <summary>
            The preferred target processor architecture. Passed to tlbimp.exe /machine flag after translation. 
            Should be a member of Microsoft.Build.Utilities.ProcessorArchitecture.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.ExecuteAsTool">
            <summary>
            Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe
            from the appropriate target framework will be run out-of-proc to generate
            the necessary wrapper assemblies. Aximp is always run out of proc.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.ResolvedFiles">
            <summary>
            paths to found/generated reference wrappers
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.ResolvedModules">
            <summary>
            paths to found modules (needed for isolation)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.SdkToolsPath">
            <summary>
            If ExecuteAsTool is true, this must be set to the SDK
            tools path for the framework version being targeted.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.StateFile">
            <summary>
            Cache file for COM component timestamps. If not present, every run will regenerate all the wrappers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.IResolveComReferenceTaskContract.TargetFrameworkVersion">
             <summary>
             The project target framework version.
            
             Default is empty. which means there will be no filtering for the reference based on their target framework.
             </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveComReference">
            <summary>
            Main class for the COM reference resolution task
            </summary>
            <summary>
            Main class for the COM reference resolution task
            </summary>
            <summary>
            Main class for the COM reference resolution task
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveComReference.s_targetFrameworkVersion_40">
            <summary>version 4.0</summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.Execute">
            <summary>
            Task entry point.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.SetFrameworkVersionFromString(System.String)">
            <summary>
            Converts the string target framework value to a number.
            Accepts both "v" prefixed and no "v" prefixed formats
            if format is bad will log a message and return 0.
            </summary>
            <returns>Target framework version value</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.ComputePathToTlbImp">
            <summary>
            Computes the path to TlbImp.exe for use in logging and for passing to the 
            nested TlbImp task.
            </summary>
            <returns>True if the path is found (or it doesn't matter because we're executing in memory), false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.ComputePathToAxImp">
            <summary>
            Computes the path to AxImp.exe for use in logging and for passing to the 
            nested AxImp task.
            </summary>
            <returns>True if the path is found, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.GetPathToSDKFileWithCurrentlyTargetedArchitecture(System.String,Microsoft.Build.Utilities.TargetDotNetFrameworkVersion,Microsoft.Build.Utilities.VisualStudioVersion)">
            <summary>
            Try to get the path to the tool in the Windows SDK with the given .NET Framework version and 
            of the same architecture as we were currently given for TargetProcessorArchitecture.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.Cleanup">
            <summary>
            Clean various caches and other state that should not be preserved between subsequent runs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.AddMissingTlbReferences">
            <summary>
            Every ActiveX reference (aximp) requires a corresponding tlbimp reference. If the tlbimp reference is
            missing from the project file we pretend it's there to save the user some useless typing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.ResolveReferenceAndAddToList(Microsoft.Build.Tasks.ComDependencyWalker,Microsoft.Build.Tasks.ComReferenceInfo,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Resolves the COM reference, and adds it to the appropriate item list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.ResolveComReferencePia(Microsoft.Build.Tasks.ComReferenceInfo,System.String,Microsoft.Build.Tasks.ComReferenceWrapperInfo@)">
            <summary>
            Helper function - resolves a PIA COM classic reference given the type library attributes.
            </summary>
            <param name="referenceInfo">Information about the reference to be resolved</param>
            <param name="refName">Name of reference</param>
            <param name="wrapperInfo">Information about wrapper locations</param>
            <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.GetResolvedAssemblyReferenceItemSpecs">
            <summary>
            Return the set of item specs for the resolved assembly references. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.ResolveComReferenceTlb(Microsoft.Build.Tasks.ComReferenceInfo,System.String,System.String,System.Boolean,System.Collections.Generic.List{System.String},Microsoft.Build.Tasks.ComReferenceWrapperInfo@)">
            <summary>
            Helper function - resolves a regular tlb COM classic reference given the type library attributes.
            </summary>
            <param name="referenceInfo">Information about the reference to be resolved</param>
            <param name="outputDirectory">Directory the interop DLL should be written to</param>
            <param name="refName">Name of reference</param>
            <param name="topLevelRef">True if this is a top-level reference</param>
            <param name="wrapperInfo">Information about wrapper locations</param>
            <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.ResolveComReferenceAx(Microsoft.Build.Tasks.ComReferenceInfo,System.String,System.String,Microsoft.Build.Tasks.ComReferenceWrapperInfo@)">
            <summary>
            Helper function - resolves an ActiveX reference given the type library attributes.
            </summary>
            <param name="referenceInfo">Information about the reference to be resolved</param>
            <param name="outputDirectory">Directory the interop DLL should be written to</param>
            <param name="refName">Name of reference</param>
            <param name="wrapperInfo">Information about wrapper locations</param>
            <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.SetCopyLocalToFalseOnGacOrNoPIAAssemblies(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.String)">
            <summary>
            Set the CopyLocal metadata to false on all assemblies that are located in the GAC.
            </summary>
            <param name="outputTaskItems">List of ITaskItems that will be outputted from the task</param>
            <param name="gacPath">The GAC root path</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.ScanAndResolveAllDependencies(Microsoft.Build.Tasks.ComDependencyWalker,Microsoft.Build.Tasks.ComReferenceInfo)">
            <summary>
            Scan all the dependencies of the main project references and preresolve them
            so that when we get asked about a previously unknown dependency in the form of a .NET assembly 
            we know what to do with it.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveComReference.AxImp">
            <summary>
            Defines the "AxImp" MSBuild task, which enables using AxImp.exe 
            to generate Windows Forms wrappers for ActiveX controls.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.ActiveXControlName">
            <summary>
            .ocx File the ActiveX controls being wrapped are defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.GenerateSource">
            <summary>
            If true, will generate C# source code for the Windows Forms wrapper.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.NoLogo">
            <summary>
            If true, suppresses displaying the logo
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.OutputAssembly">
            <summary>
            File name of assembly to be produced.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.RuntimeCallableWrapperAssembly">
            <summary>
            Name of assembly to use as a RuntimeCallableWrapper instead of generating one.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.Silent">
            <summary>
            If true, prevents AxImp from displaying success message.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.Verbose">
            <summary>
            If true, AxImp prints more information.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.AxImp.ToolName">
            <summary>
            Returns the name of the tool to execute
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.AxImp.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Fills the provided CommandLineBuilderExtension with all the command line options used when
            executing this tool
            </summary>
            <param name="commandLine">Gets filled with command line commands</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.AxImp.ValidateParameters">
            <summary>
            Validates the parameters passed to the task
            </summary>
            <returns>True if parameters are valid</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveComReference.TlbImpTransformFlags">
            <summary>
            Passed to the "Transform" property on the TlbImp task to indicate
            what transforms, if any, to apply to the type library during 
            assembly generation
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveComReference.TlbImpTransformFlags.None">
            <summary>
            No transforms should be applied.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveComReference.TlbImpTransformFlags.TransformDispRetVals">
            <summary>
            Transforms [out, retval] parameters of methods on dispatch-only
            interfaces into return values.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveComReference.TlbImpTransformFlags.SerializableValueClasses">
            <summary>
            Mark all value classes as serializable.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveComReference.TlbImp">
            <summary>
            Defines the "TlbImp" MSBuild task, which enables using TlbImp.exe 
            to generate assemblies from type libraries.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.TypeLibName">
            <summary>
            Type library being imported to an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.AssemblyNamespace">
            <summary>
            Namespace of the generated assembly
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.AssemblyVersion">
            <summary>
            Version of the generated assembly
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.Machine">
            <summary>
            Create an assembly for the specified machine type
            Supported machine types:
             X86
             X64
             Itanium
             Agnostic
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.NoLogo">
            <summary>
            If true, suppresses displaying the logo
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.OutputAssembly">
            <summary>
            File name of assembly to be produced.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.PreventClassMembers">
            <summary>
            If true, prevents TlbImp from adding members to classes
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.SafeArrayAsSystemArray">
            <summary>
            If true, import the SAFEARRAY type as System.Arrays
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.Silent">
            <summary>
            If true, prevents AxImp from displaying success message.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.Transform">
            <summary>
            Transformation to be applied to the resulting assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.Verbose">
            <summary>
            If true, AxImp prints more information.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.ReferenceFiles">
            <summary>
            References to dependency assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReference.TlbImp.ToolName">
            <summary>
            Returns the name of the tool to execute
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.TlbImp.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Fills the provided CommandLineBuilderExtension with all the command line options used when
            executing this tool
            </summary>
            <param name="commandLine">Gets filled with command line commands</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.TlbImp.ValidateParameters">
            <summary>
            Validates the parameters passed to the task
            </summary>
            <returns>True if parameters are valid</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.TlbImp.GetTlbImpTransformFlagsParameterWithDefault(System.String,Microsoft.Build.Tasks.ResolveComReference.TlbImpTransformFlags)">
            <summary>
            Returns the TlbImpTransformFlags value stored in the hashtable under the provided
            parameter, or the default value passed if the value in the hashtable is null
            </summary>
            <param name="parameterName">The parameter used to retrieve the value from the hashtable</param>
            <param name="defaultValue">The default value to return if the hashtable value is null</param>
            <returns>The value contained in the hashtable, or if that's null, the default value passed to the method</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.TlbImp.ValidateTransformFlags">
            <summary>
            Verifies that an allowed combination of TlbImpTransformFlags has been 
            passed to the Transform property.
            </summary>
            <returns>True if Transform is valid and false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReference.TlbImp.ConvertTransformFlagsToCommandLineCommand(Microsoft.Build.Tasks.ResolveComReference.TlbImpTransformFlags)">
            <summary>
            Converts a given flag to the equivalent parameter passed to the /transform: 
            option of tlbimp.exe
            </summary>
            <param name="flags">The TlbImpTransformFlags being converted</param>
            <returns>A string that can be passed to /transform: on the command line</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.BuildCacheDisposeWrapper">
            <summary>
            Create a wrapper so that when dispose is called we execute the delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.BuildCacheDisposeWrapper._disposed">
            <summary>
            Has this been disposed
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.BuildCacheDisposeWrapper._callDuringDispose">
            <summary>
            Delegate to call when we are in dispose
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.BuildCacheDisposeWrapper.#ctor(Microsoft.Build.Tasks.BuildCacheDisposeWrapper.CallDuringDispose)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.BuildCacheDisposeWrapper.CallDuringDispose">
            <summary>
            Delegate to call when we are in dispose
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.BuildCacheDisposeWrapper.Dispose">
            <summary>
            IDisposable
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.BuildCacheDisposeWrapper.Dispose(System.Boolean)">
            <summary>
            Clear the caches
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.DownloadFile">
            <summary>
            Represents a task that can download a file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.DestinationFileName">
            <summary>
            Gets or sets an optional filename for the destination file.  By default, the filename is derived from the <see cref="P:Microsoft.Build.Tasks.DownloadFile.SourceUrl"/> if possible.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.DestinationFolder">
            <summary>
            Gets or sets a <see cref="T:Microsoft.Build.Framework.ITaskItem"/> that specifies the destination folder to download the file to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.DownloadedFile">
            <summary>
            Gets or sets a <see cref="T:Microsoft.Build.Framework.ITaskItem"/> that contains details about the downloaded file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.Retries">
            <summary>
            Gets or sets an optional number of times to retry if possible.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds">
            <summary>
            Gets or sets the number of milliseconds to wait before retrying.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles">
            <summary>
            Gets or sets an optional value indicating whether or not the download should be skipped if the file is up-to-date.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.SourceUrl">
            <summary>
            Gets or sets the URL to download.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DownloadFile.HttpMessageHandler">
            <summary>
            Gets or sets a <see cref="P:Microsoft.Build.Tasks.DownloadFile.HttpMessageHandler"/> to use.  This is used by unit tests to mock a connection to a remote server.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.DownloadFile.Cancel">
            <inheritdoc cref="M:Microsoft.Build.Framework.ICancelableTask.Cancel"/>
        </member>
        <member name="M:Microsoft.Build.Tasks.DownloadFile.DownloadAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Attempts to download the file.
            </summary>
            <param name="uri">The parsed <see cref="T:System.Uri"/> of the request.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.DownloadFile.IsRetriable(System.Exception,System.Exception@)">
            <summary>
            Determines if the specified exception is considered retriable.
            </summary>
            <param name="exception">The originally thrown exception.</param>
            <param name="actualException">The actual exception to be used for logging errors.</param>
            <returns><code>true</code> if the exception is retriable, otherwise <code>false</code>.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.DownloadFile.TryGetFileName(System.Net.Http.HttpResponseMessage,System.String@)">
            <summary>
            Attempts to get the file name to use when downloading the file.
            </summary>
            <param name="response">The <see cref="T:System.Net.Http.HttpResponseMessage"/> with information about the response.</param>
            <param name="filename">Receives the name of the file.</param>
            <returns><code>true</code> if a file name could be determined, otherwise <code>false</code>.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.DownloadFile.CustomHttpRequestException">
            <summary>
            Represents a wrapper around the <see cref="T:System.Net.Http.HttpRequestException"/> that also contains the <see cref="T:System.Net.HttpStatusCode"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetFileHash">
            <summary>
            Computes the checksum for a single file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFileHash.Files">
            <summary>
            The files to be hashed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFileHash.Algorithm">
            <summary>
            The algorithm. Allowed values: SHA256, SHA384, SHA512. Default = SHA256.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFileHash.MetadataName">
            <summary>
            The metadata name where the hash is stored in each item. Defaults to "FileHash".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFileHash.HashEncoding">
            <summary>
            The encoding to use for generated hashs. Defaults to "hex". Allowed values = "hex", "base64".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFileHash.Hash">
            <summary>
            The hash of the file. This is only set if there was one item group passed in.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFileHash.Items">
            <summary>
            The input files with additional metadata set to include the file hash.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.VerifyFileHash">
            <summary>
            Verifies that a file matches the expected file hash.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.VerifyFileHash.File">
            <summary>
            The file path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.VerifyFileHash.Hash">
            <summary>
            The expected hash of the file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.VerifyFileHash.HashEncoding">
            <summary>
            The encoding format of <see cref="P:Microsoft.Build.Tasks.VerifyFileHash.Hash"/>. Defaults to "hex".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.VerifyFileHash.Algorithm">
            <summary>
            The hashing algorithm to use. Allowed values: SHA256, SHA384, SHA512. Default = SHA256.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CopyFileWithState">
            <summary>
            CopyFile delegate
            
            returns  Success = true, Failure = false; Retry = null
            </summary>
            <param name="source">Source file</param>
            <param name="destination">Destination file</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.FileState">
            <summary>
            Short-term cache saves the result of IO operations on a filename. Should only be
            used in cases where it is know there will be no exogenous changes to the filesystem
            for this file.
            </summary>
            <remarks>
            Uses PInvoke rather than FileInfo because the latter does all kinds of expensive checks.
            
            Deficiency: some of the properties eat some or all exceptions. If they are called first, they will
            trigger the population and eat. Subsequent calls will then not throw, but instead eg return zero.
            This could be fixed by storing the exception from the population, and throwing no matter who does
            the population and whether it's been done before.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState.FileDirInfo._filename">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState.FileDirInfo.Exists">
            <summary>
            Set to true if file or directory exists
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState.FileDirInfo.IsDirectory">
            <summary>
            Set to true if the path referred to a directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState.FileDirInfo.Length">
            <summary>
            File length
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState.FileDirInfo.LastWriteTimeUtc">
            <summary>
            Last time the file was updated
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState.FileDirInfo.IsReadOnly">
            <summary>
            True if the file is readonly
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState.FileDirInfo._exceptionThrown">
            <summary>
            Exception thrown on creation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FileState.FileDirInfo.#ctor(System.String)">
            <summary>
            Constructor gets the data for the filename.
            On Win32 it uses native means. Otherwise,
            uses standard .NET FileInfo/DirInfo
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FileState.FileDirInfo.ThrowFileInfoException(System.Boolean)">
            <summary>
            Throw exception as if the FileInfo did it. We
            know that getting the length of a file would
            throw exception if there are IO problems
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FileState.FileDirInfo.ThrowNonIoExceptionIfPending">
            <summary>
            Throw non-IO-related exception if occurred during creation.
            Return true if exception did occur, but was IO-related
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FileState.FileDirInfo.ThrowException">
            <summary>
            Throw any exception collected during construction
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState._filename">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FileState._data">
            <summary>
            Actual file or directory information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FileState.#ctor(System.String)">
            <summary>
            Constructor.
            Only stores file name: does not grab the file state until first request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.IsReadOnly">
            <summary>
            Whether the file is readonly.
            Returns false for directories.
            Throws if file does not exist.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.FileExists">
            <summary>
            Whether the file exists.
            Returns false if it is a directory, even if it exists.
            Returns false instead of IO related exceptions.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.DirectoryExists">
            <summary>
            Whether the directory exists.
            Returns false for files.
            Returns false instead of IO related exceptions.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.LastWriteTime">
            <summary>
            Last time the file was written.
            Works for directories.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.LastWriteTimeUtcFast">
            <summary>
            Last time the file was written, in UTC. Avoids translation for daylight savings, time zone etc which isn't needed for just comparisons.
            If file does not exist, returns 12 midnight 1/1/1601.
            Works for directories.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.Length">
            <summary>
            Length of the file in bytes.
            Throws if it is a directory.
            Throws if it does not exist.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.Name">
            <summary>
            Name of the file as it was passed in.
            Not normalized.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FileState.IsDirectory">
            <summary>
            Whether this is a directory.
            Throws if it does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FileState.Reset">
            <summary>
            Use in case the state is known to have changed exogenously.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Copy">
            <summary>
            A task that copies files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Copy.s_alwaysRetryCopy">
            <summary>
            Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since 
            normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually 
            succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Copy.s_forceSymlinks">
            <summary>
            Global flag to force on UseSymboliclinksIfPossible since Microsoft.Common.targets doesn't expose the functionality.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Copy.RetryDelayMillisecondsDefault">
            <summary>
            Default milliseconds to wait between necessary retries
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Copy.Retries">
            <summary>
            How many times to attempt to copy, if all previous
            attempts failed. Defaults to zero.
            Warning: using retries may mask a synchronization problem in your
            build process.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds">
            <summary>
            Delay between any necessary retries.
            Defaults to <see cref="F:Microsoft.Build.Tasks.Copy.RetryDelayMillisecondsDefault">RetryDelayMillisecondsDefault</see>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible">
            <summary>
            Create Hard Links for the copied files rather than copy the files if possible to do so
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible">
            <summary>
            Create Symbolic Links for the copied files rather than copy the files if possible to do so
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Copy.ErrorIfLinkFails">
            <summary>
            Fail if unable to create a symbolic or hard link instead of falling back to copy
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Copy.CopiedFiles">
            <summary>
            The subset of files that were successfully copied.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles">
            <summary>
            Whether to overwrite files in the destination
            that have the read-only attribute set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.Cancel">
            <summary>
            Stop and return (in an undefined state) as soon as possible.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.IsMatchingSizeAndTimeStamp(Microsoft.Build.Tasks.FileState,Microsoft.Build.Tasks.FileState)">
            <summary>
            Method compares two files and returns true if their size and timestamp are identical.
            </summary>
            <param name="sourceFile">The source file</param>
            <param name="destinationFile">The destination file</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.RefreshInternalEnvironmentValues">
            <summary>
            INTERNAL FOR UNIT-TESTING ONLY
            
            We've got several environment variables that we read into statics since we don't expect them to ever
            reasonably change, but we need some way of refreshing their values so that we can modify them for
            unit testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.LogDiagnostic(System.String,System.Object[])">
            <summary>
            If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as 
            a warning, so it's easily visible. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.CopyFileWithLogging(Microsoft.Build.Tasks.FileState,Microsoft.Build.Tasks.FileState)">
            <summary>
            Copy one file from source to destination. Create the target directory if necessary and 
            leave the file read-write.
            </summary>
            <returns>Return true to indicate success, return false to indicate failure and NO retry, return NULL to indicate retry.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.MakeFileWriteable(Microsoft.Build.Tasks.FileState,System.Boolean)">
            <summary>
            Ensure the read-only attribute on the specified file is off, so
            the file is writeable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.Execute(Microsoft.Build.Tasks.CopyFileWithState,System.Int32)">
            <summary>
            Copy the files.
            </summary>
            <param name="copyFile">Delegate used to copy the files.</param>
            <param name="parallelism">
            Thread parallelism allowed during copies. 1 uses the original algorithm, >1 uses newer algorithm.
            </param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.CopySingleThreaded(Microsoft.Build.Tasks.CopyFileWithState,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem}@)">
            <summary>
            Original copy code that performs single-threaded copies.
            Used for single-file copies and when parallelism is 1.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.CopyParallel(Microsoft.Build.Tasks.CopyFileWithState,System.Int32,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem}@)">
            <summary>
            Parallelize I/O with the same semantics as the single-threaded copy method above.
            ResolveAssemblyReferences tends to generate longer and longer lists of files to send
            to CopyTask as we get further and further down the dependency graph.
            The OS can handle a lot of parallel I/O so let's minimize wall clock time to get
            it all done.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.ValidateInputs">
            <summary>
            Verify that the inputs are correct.
            </summary>
            <returns>False on an error, implying that the overall copy operation should be aborted.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.InitializeDestinationFiles">
            <summary>
            Set up our list of destination files.
            </summary>
            <returns>False if an error occurred, implying aborting the overall copy operation.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.DoCopyIfNecessary(Microsoft.Build.Tasks.FileState,Microsoft.Build.Tasks.FileState,Microsoft.Build.Tasks.CopyFileWithState)">
            <summary>
            Copy source to destination, unless SkipUnchangedFiles is true and they are equivalent.
            </summary>
            <returns>True if the file was copied or, on SkipUnchangedFiles, the file was equivalent.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.DoCopyWithRetries(Microsoft.Build.Tasks.FileState,Microsoft.Build.Tasks.FileState,Microsoft.Build.Tasks.CopyFileWithState)">
            <summary>
            Copy one file with the appropriate number of retries if it fails.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.GetLockedFileMessage(System.String)">
            <summary>
            Try to get a message to inform the user which processes have a lock on a given file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.Execute">
            <summary>
            Standard entry point.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Copy.PathsAreIdentical(System.String,System.String)">
            <summary>
            Compares two paths to see if they refer to the same file. We can't solve the general
            canonicalization problem, so we just compare strings on the full paths.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CreateCSharpManifestResourceName">
            <summary>
            Base class for task that determines the appropriate manifest resource name to 
            assign to a given resx or other resource.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(System.String,System.String,System.String,System.String,System.IO.Stream)">
            <summary>
            Utility function for creating a C#-style manifest name from 
            a resource name. 
            </summary>
            <param name="fileName">The file name of the dependent (usually a .resx)</param>
            <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
            <param name="rootNamespace">The root namespace (usually from the project file). May be null</param>
            <param name="dependentUponFileName">The file name of the parent of this dependency (usually a .cs file). May be null</param>
            <param name="binaryStream">File contents binary stream, may be null</param>
            <returns>Returns the manifest name</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestNameImpl(System.String,System.String,System.Boolean,System.String,System.String,System.String,System.IO.Stream,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Utility function for creating a C#-style manifest name from 
            a resource name. Note that this function attempts to emulate the
            Everret implementation of this code which can be found by searching for
            ComputeNonWFCResourceName() or ComputeWFCResourceName() in
            \vsproject\langproj\langbldmgrsite.cpp
            </summary>
            <param name="fileName">The file name of the dependent (usually a .resx)</param>
            <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
            <param name="rootNamespace">The root namespace (usually from the project file). May be null</param>
            <param name="prependCultureAsDirectory">should the culture name be prepended to the manifest name as a path</param>
            <param name="dependentUponFileName">The file name of the parent of this dependency (usually a .cs file). May be null</param>
            <param name="culture">The override culture of this resource, if any</param>
            <param name="binaryStream">File contents binary stream, may be null</param>
            <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
            <returns>Returns the manifest name</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateCSharpManifestResourceName.IsSourceFile(System.String)">
            <summary>
            Return 'true' if this is a C# source file.
            </summary>
            <param name="fileName">Name of the candidate source file.</param>
            <returns>True, if this is a validate source file.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName">
            <summary>
            Base class for task that determines the appropriate manifest resource name to 
            assign to a given resx or other resource.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(System.String,System.String,System.String,System.String,System.IO.Stream)">
            <summary>
            Utility function for creating a VB-style manifest name from 
            a resource name. 
            </summary>
            <param name="fileName">The file name of the dependent (usually a .resx)</param>
            <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
            <param name="rootNamespace">The root namespace (usually from the project file). May be null</param>
            <param name="dependentUponFileName">The file name of the parent of this dependency (usually a .vb file). May be null</param>
            <param name="binaryStream">File contents binary stream, may be null</param>
            <returns>Returns the manifest name</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestNameImpl(System.String,System.String,System.Boolean,System.String,System.String,System.String,System.IO.Stream,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Utility function for creating a VB-style manifest name from 
            a resource name. Note that this function attempts to emulate the
            Everret implementation of this code which can be found by searching for
            ComputeNonWFCResourceName() or ComputeWFCResourceName() in
            \vsproject\langproj\langbldmgrsite.cpp
            </summary>
            <param name="fileName">The file name of the dependent (usually a .resx)</param>
            <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
            <param name="prependCultureAsDirectory">should the culture name be prepended to the manifest name as a path</param>
            <param name="rootNamespace">The root namespace (usually from the project file). May be null</param>
            <param name="dependentUponFileName">The file name of the parent of this dependency (usually a .vb file). May be null</param>
            <param name="culture">The override culture of this resource, if any</param>
            <param name="binaryStream">File contents binary stream, may be null</param>
            <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
            <returns>Returns the manifest name</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.IsSourceFile(System.String)">
            <summary>
            Return 'true' if this is a VB source file.
            </summary>
            <param name="fileName">Name of the candidate source file.</param>
            <returns>True, if this is a validate source file.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.CreateItem">
            <summary>
            Forward a list of items from input to output. This allows dynamic item lists.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata">
            <summary>
            Only apply the additional metadata is none already exists
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateItem.AdditionalMetadata">
            <summary>
            A list of metadata name/value pairs to apply to the output items.  
            A typical input: "metadataname1=metadatavalue1", "metadataname2=metadatavalue2", ...
            </summary>
            <remarks>
            The fact that this is a string[] makes the following illegal:
                <CreateItem
                    AdditionalMetadata="TargetPath=@(OutputPathItem)" />
            The engine fails on this because it doesn't like item lists being concatenated with string
            constants when the data is being passed into an array parameter.  So the workaround is to 
            write this in the project file:
                <CreateItem
                    AdditionalMetadata="@(OutputPathItem->'TargetPath=%(Identity)')" />
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateItem.Execute">
            <summary>
            Execute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateItem.CreateOutputItems(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Create the list of output items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateItem.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[])">
            <summary>
            Expand wildcards in the item list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateItem.GetUniqueItems(Microsoft.Build.Framework.ITaskItem[])">
            <summary>
            Create a table of unique items
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CreateManifestResourceName">
            <summary>
            Base class for task that determines the appropriate manifest resource name to 
            assign to a given resx or other resource.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory">
            <summary>
            Should the culture name be prepended to the manifest resource name as a directory?
            This is true by default.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles">
            <summary>
            The possibly dependent resource files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace">
            <summary>
            Rootnamespace to use for naming.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames">
            <summary>
            The resulting manifest names.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames">
            <summary>
            The initial list of resource names, with additional metadata for manifest resource names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestName(System.String,System.String,System.String,System.String,System.IO.Stream)">
            <summary>
            Method in the derived class that composes the manifest name.
            </summary>
            <param name="fileName">The file name of the dependent (usually a .resx)</param>
            <param name="linkFileName">The name of the file specified by the Link attribute.</param>
            <param name="rootNamespaceName">The root namespace (usually from the project file). May be null</param>
            <param name="dependentUponFileName">The file name of the parent of this dependency. May be null</param>
            <param name="binaryStream">File contents binary stream, may be null</param>
            <returns>Returns the manifest name</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.IsSourceFile(System.String)">
            <summary>
            The derived class chooses whether this is a valid source file to work against.
            Usually, this is just a matter of looking at the file's extension.
            </summary>
            <param name="fileName">Name of the candidate source file.</param>
            <returns>True, if this is a validate source file.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.CreateFileStreamOverNewFileStream(System.String,System.IO.FileMode,System.IO.FileAccess)">
            <summary>
            Given a file path, return a stream on top of that path.
            </summary>
            <param name="path">Path to the file</param>
            <param name="mode">File mode</param>
            <param name="access">Access type</param>
            <returns>The FileStream</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.Execute(Microsoft.Build.Tasks.CreateFileStream)">
            <summary>
            Execute the task with delegate handlers.
            </summary>
            <param name="createFileStream">CreateFileStream delegate</param>
            <returns>True if task succeeded.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.Execute">
            <summary>
            Do the task's work.
            </summary>
            <returns>True if succeeded.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.IsValidEverettIdFirstChar(System.Char)">
            <summary>
            Is the character a valid first Everett identifier character?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.IsValidEverettIdChar(System.Char)">
            <summary>
            Is the character a valid Everett identifier character?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettSubFolderIdentifier(System.String)">
            <summary>
            Make a folder subname into an Everett-compatible identifier 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettFolderIdentifier(System.String)">
            <summary>
            Make a folder name into an Everett-compatible identifier
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettIdentifier(System.String)">
            <summary>
            This method is provided for compatibility with Everett which used to convert parts of resource names into
            valid identifiers
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CreateProperty">
            <summary>
            Just a straight pass-through of the inputs through to the outputs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateProperty.Value">
            <summary>
            The in/out property value.
            </summary>
            <remarks>
            So ... why is this a string[] instead of a string?
            Basically if the project author passed in:
            
                    CreateProperty Value="Clean;Build"
                        Output TaskParameter="Value" PropertyName="MyTargetsToBuild"
                    /CreateProperty
            
            We need to respect the semicolon that he put in the value, and need to treat
            this exactly as if he had done:
            
                    PropertyGroup
                        MyTargetsToBuild="Clean;Build"
                    /PropertyGroup
            
            If we make this parameter a "string", then the engine will escape the 
            value on the way out from the task back to the engine, creating a property
            that is set to "Clean%3BBuild", which is not what the user wanted.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.CreateProperty.ValueSetByTask">
            <summary>
            This is to fool MSBuild into not doing its little TLDA trick whereby even if 
            a target is up-to-date, it will still set the properties that were meant to
            be set using the CreateProperty task.  This is because MSBuild is smart enough
            to figure out the value of the output property without running the task.
            But if the input parameter is differently named than the output parameter,
            MSBuild can't be smart enough to do that.  This is an important scenario
            for people who want to know whether a particular target was up-to-date or not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CreateProperty.Execute">
            <summary>
            Create the property. Since the input property is the same as the
            output property, this is rather easy.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.CSharpParserUtilities">
            <summary>
            Specific-purpose utility functions for parsing C#.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CSharpParserUtilities.GetFirstClassNameFullyQualified(System.IO.Stream)">
            <summary>
            Parse a C# file and get the first class name, fully qualified with namespace.
            </summary>
            <param name="binaryStream"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CSharpParserUtilities.Extract(Microsoft.Build.Shared.LanguageParser.CSharpTokenizer)">
            <summary>
            Extract the class name.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetAttributes">
            <summary>
            File.GetAttributes delegate
            </summary>
            <param name="path">The path get attributes for.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.SetAttributes">
            <summary>
            File SetAttributes delegate
            </summary>
            <param name="path">The path to set attributes for.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.SetLastAccessTime">
            <summary>
            File SetLastAccessTime delegate.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.SetLastWriteTime">
            <summary>
            File SetLastWriteTime delegate.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetDirectories">
            <summary>
            GetDirectories delegate
            </summary>
            <param name="path">The path to get directories for.</param>
            <param name="pattern">The pattern to search for.</param>
            <returns>An array of directories.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.CopyFile">
            <summary>
            CopyFile delegate
            </summary>
            <param name="source">Source file</param>
            <param name="destination">Destination file</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetAssemblyName">
            <summary>
            GetAssemblyName delegate
            </summary>
            <param name="path">The path to the file</param>
            <returns>The assembly name.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetAssemblyRuntimeVersion">
            <summary>
            GetAssemblyRuntimeVersion delegate to get the clr runtime version of a file.
            </summary>
            <param name="path">The path to the file</param>
            <returns>The clr runtime version for the file</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetGacEnumerator">
            <summary>
            GetGacEnumerator delegate to get the enumerator which will enumerate over the GAC
            </summary>
            <param name="strongName">StrongName to get an enumerator for</param>
            <returns>The enumerator for the gac</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetPathFromFusionName">
            <summary>
            GetPathFromFusionName delegate to get path to a file based on the fusion name
            </summary>
            <param name="strongName">StrongName to get a path for</param>
            <returns>The path to the assembly</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetAssemblyMetadata">
            <summary>
            Delegate. Given an assembly name, crack it open and retrieve the list of dependent 
            assemblies and  the list of scatter files.
            </summary>
            <param name="path">Path to the assembly.</param>
            <param name="dependencies">Receives the list of dependencies.</param>
            <param name="scatterFiles">Receives the list of associated scatter files.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader">
            <summary>
            Delegate to take in a dll path and read the machine type from the PEHeader
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetAssemblyPathInGac">
            <summary>
            Delegate to get the path to an assembly in the GAC.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.IsWinMDFile">
            <summary>
            Determines if a assembly is an winmd file 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CreateFileStream">
            <summary>
            CreateFileString delegate. Creates a stream on top of a file.
            </summary>
            <param name="path">Path to the file</param>
            <param name="mode">File mode</param>
            <param name="access">Access type</param>
            <returns>The Stream</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetLastWriteTime">
            <summary>
            Delegate for System.IO.File.GetLastWriteTime
            </summary>
            <param name="path">The file name</param>
            <returns>The last write time.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Delete">
            <summary>
            Delete files from disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings">
            <summary>
            When true, errors will be logged as warnings.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Delete.Cancel">
            <summary>
            Stop and return (in an undefined state) as soon as possible.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Delete.Execute">
            <summary>
            Delete the files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Delete.LogError(Microsoft.Build.Framework.ITaskItem,System.Exception)">
            <summary>
            Log an error.
            </summary>
            <param name="file">The file that wasn't deleted.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.Error">
            <summary>
            Task that simply emits an error. Engine will add project file path and line/column
            information.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Error.Text">
            <summary>
            Error message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Error.Code">
            <summary>
            Error code
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Error.File">
            <summary>
            Relevant file if any.
            If none is provided, the file containing the Error 
            task will be used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Error.HelpKeyword">
            <summary>
            Error help keyword
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Error.Execute">
            <summary>
            Main task method
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Exec">
            <summary>
            This class defines an "Exec" MSBuild task, which simply invokes the specified process with the specified arguments, waits
            for it to complete, and then returns True if the process completed successfully, and False if an error occurred.
            </summary>
            <comments>
            UNDONE: ToolTask has a "UseCommandProcessor" flag that duplicates much of the code in this class. Remove the duplication.
            </comments>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.ConsoleToMSBuild">
            <summary>
            Enable the pipe of the standard out to an item (StandardOutput).
            </summary>
            <Remarks>
            Even thought this is called a pipe, it is in fact a Tee.  Use StandardOutputImportance to adjust the visibility of the stdout.
            </Remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression">
            <summary>
            Users can supply a regular expression that we should
            use to spot error lines in the tool output. This is
            useful for tools that produce unusually formatted output
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression">
            <summary>
            Users can supply a regular expression that we should
            use to spot warning lines in the tool output. This is
            useful for tools that produce unusually formatted output
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat">
            <summary>
            Whether to use pick out lines in the output that match
            the standard error/warning format, and log them as errors/warnings.
            Defaults to false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.StandardOutputEncoding">
            <summary>
            Property specifying the encoding of the captured task standard output stream
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.StandardErrorEncoding">
            <summary>
            Property specifying the encoding of the captured task standard error stream
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.UseUtf8Encoding">
            <summary>
            Whether or not to use UTF8 encoding for the cmd file and console window.
            Values: Always, Never, Detect
            If set to Detect, the current code page will be used unless it cannot represent 
            the Command string. In that case, UTF-8 is used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.StdOutEncoding">
            <summary>
            Project visible property specifying the encoding of the captured task standard output stream
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.StdErrEncoding">
            <summary>
            Project visible property specifying the encoding of the captured task standard error stream
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.ConsoleOutput">
            <summary>
            Returns the output as an Item.  Whitespace are trimmed.
            ConsoleOutput is enabled when ConsoleToMSBuild is true.  This avoids holding lines in memory
            if they aren't used.  ConsoleOutput is a combination of stdout and stderr.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.CreateTemporaryBatchFile">
            <summary>
            Write out a temporary batch file with the user-specified command in it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.ExecuteTool(System.String,System.String,System.String)">
            <summary>
            Executes cmd.exe and waits for it to complete
            </summary>
            <remarks>
            Overridden to clean up the batch file afterwards.
            </remarks>
            <returns>Upon completion of the process, returns True if successful, False if not.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.HandleTaskExecutionErrors">
            <summary>
            Allows tool to handle the return code.
            This method will only be called with non-zero exitCode set to true.
            </summary>
            <remarks>
            Overridden to make sure we display the command we put in the batch file, not the cmd.exe command
            used to run the batch file.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.LogPathToTool(System.String,System.String)">
            <summary>
            Logs the tool name and the path from where it is being run.
            </summary>
            <remarks>
            Overridden to avoid logging the path to "cmd.exe", which is not interesting.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.LogToolCommand(System.String)">
            <summary>
            Logs the command to be executed.
            </summary>
            <remarks>
            Overridden to log the batch file command instead of the cmd.exe command.
            </remarks>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.LogEventsFromTextOutput(System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Calls a method on the TaskLoggingHelper to parse a single line of text to
            see if there are any errors or warnings in canonical format.
            </summary>
            <remarks>
            Overridden to handle any custom regular expressions supplied.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.OutputMatchesRegex(System.String,System.String@)">
            <summary>
            Returns true if the string is matched by the regular expression.
            If the regular expression is invalid, logs an error, then clears it out to
            prevent more errors.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.ValidateParameters">
            <summary>
            Validate the task arguments, log any warnings/errors
            </summary>
            <returns>true if arguments are corrent enough to continue processing, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.ValidateParametersAccessor">
            <summary>
            Accessor for ValidateParameters purely for unit-test use
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.GenerateFullPathToTool">
            <summary>
            Determining the path to cmd.exe
            </summary>
            <returns>path to cmd.exe</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.GetWorkingDirectory">
            <summary>
            Gets the working directory to use for the process. Should return null if ToolTask should use the
            current directory.
            May throw an IOException if the directory to be used is somehow invalid.
            </summary>
            <returns>working directory</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.GetWorkingDirectoryAccessor">
            <summary>
            Accessor for GetWorkingDirectory purely for unit-test use
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Exec.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Adds the arguments for cmd.exe
            </summary>
            <param name="commandLine">command line builder class to add arguments to</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.ToolName">
            <summary>
            The name of the tool to execute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.StandardErrorLoggingImportance">
            <summary>
            Importance with which to log ordinary messages in the
            standard error stream.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Exec.StandardOutputLoggingImportance">
            <summary>
            Importance with which to log ordinary messages in the
            standard out stream.
            </summary>
            <remarks>
            Overridden to increase from the default "Low" up to "High".
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Tasks.FindAppConfigFile">
            <summary>
            Finds the app.config file, if any, in the provided lists.
            For compat reasons, it has to follow a particular arbitrary algorithm.
            It also adds the TargetPath metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList">
            <summary>
            The primary list to search through
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList">
            <summary>
            The secondary list to search through
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindAppConfigFile.TargetPath">
            <summary>
            The value to add as TargetPath metadata
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile">
            <summary>
            The first matching item found in the list, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FindAppConfigFile.Execute">
            <summary>
            Find the app config
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FindAppConfigFile.IsMatchingItem(Microsoft.Build.Framework.ITaskItem,System.Boolean)">
            <summary>
            Examines the item to see if it matches what we are looking for.
            If it does, returns true.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetFrameworkPath">
            <summary>
            Returns the paths to the various frameworks versions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetFrameworkPath.Execute">
            <summary>
            Does nothing: getters do all the work
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.Path">
            <summary>
            Path to the latest framework, whatever version it happens to be
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion11Path">
            <summary>
            Path to the v1.1 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion20Path">
            <summary>
            Path to the v2.0 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion30Path">
            <summary>
            Path to the v3.0 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion35Path">
            <summary>
            Path to the v3.5 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion40Path">
            <summary>
            Path to the v4.0 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion45Path">
            <summary>
            Path to the v4.5 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion451Path">
            <summary>
            Path to the v4.5.1 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion452Path">
            <summary>
            Path to the v4.5.2 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion46Path">
            <summary>
            Path to the v4.6 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path">
            <summary>
            Path to the v4.6.1 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion462Path">
            <summary>
            Path to the v4.6.2 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path">
            <summary>
            Path to the v4.7 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion471Path">
            <summary>
            Path to the v4.7.1 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion472Path">
            <summary>
            Path to the v4.7.2 framework, if available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path">
            <summary>
            Path to the v4.8 framework, if available
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetReferenceAssemblyPaths">
            <summary>
            Returns the reference assembly paths to the various frameworks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.NET35SP1SentinelAssemblyName">
            <summary>
            This is the sentinel assembly for .NET FX 3.5 SP1
            Used to determine if SP1 of 3.5 is installed
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.s_net35SP1SentinelAssemblyFound">
            <summary>
            Cache in a static whether or not we have found the 35sp1sentinel assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetReferenceAssemblyPaths._tfmPaths">
            <summary>
            Hold the reference assembly paths based on the passed in targetframeworkmoniker.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetReferenceAssemblyPaths._tfmPathsNoProfile">
            <summary>
            Hold the reference assembly paths based on the passed in targetframeworkmoniker without considering any profile passed in.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.ReferenceAssemblyPaths">
            <summary>
            Returns the path based on the passed in TargetFrameworkMoniker. If the TargetFrameworkMoniker is null or empty
            this path will be empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.FullFrameworkReferenceAssemblyPaths">
            <summary>
            Returns the path based on the passed in TargetFrameworkMoniker without considering the profile part of the moniker. If the TargetFrameworkMoniker is null or empty
            this path will be empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker">
            <summary>
            The target framework moniker to get the reference assembly paths for
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath">
            <summary>
            The root path to use to generate the reference assembly path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks">
            <summary>
            By default GetReferenceAssemblyPaths performs simple checks
            to ensure that certain runtime frameworks are installed depending on the
            target framework.
            set BypassFrameworkInstallChecks to true in order to bypass those checks.
            </summary>        
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError">
            <summary>
            If set to true, the task will not generate an error (or a warning) if the reference assemblies cannot be found.
            This allows the task to be used to check whether reference assemblies for a framework are available.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName">
            <summary>
            Gets the display name for the targetframeworkmoniker
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths">
            <summary>
            Target frameworks are looked up in @RootPath. If it cannot be found
            there, then paths in @TargetFrameworkFallbackSearchPaths
            are used for the lookup, in order. This can have multiple paths, separated
            by ';'
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute">
            <summary>
            If the target framework moniker is set, generate the correct Paths.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetReferenceAssemblyPaths.GetPaths(System.String,System.String,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Generate the set of chained reference assembly paths
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hash">
            <summary>
            Generates a hash of a given ItemGroup items. Metadata is not considered in the hash.
            <remarks>
            Currently uses SHA1. Implementation subject to change between MSBuild versions. Not
            intended as a cryptographic security measure, only uniqueness between build executions.
            </remarks>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Hash.ItemsToHash">
            <summary>
            Items from which to generate a hash.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Hash.IgnoreCase">
            <summary>
            When true, will generate a case-insensitive hash.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Hash.HashResult">
            <summary>
            Hash of the ItemsToHash ItemSpec.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Hash.Execute">
            <summary>
            Execute the task.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.InstalledSDKResolver">
             <summary>
            There is no search path element because the only way to get this resolver is by having the SDKName metadata on the reference.
             </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.InstalledSDKResolver._resolvedSDKs">
            <summary>
             Resolved SDKs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledSDKResolver.#ctor(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Framework.ITaskItem},System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InstalledSDKResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)">
            <summary>
            Resolve references which are found in a specific SDK
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ErrorFromResources">
            <summary>
            Task that emits an error given a resource string. Engine will add project file path and line/column
            information.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ErrorFromResources.Resource">
            <summary>
            Resource from which error message is extracted
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ErrorFromResources.Arguments">
            <summary>
            Optional arguments to use when formatting the error message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ErrorFromResources.Code">
            <summary>
            Error code
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ErrorFromResources.File">
            <summary>
            Relevant file if any.
            If none is provided, the file containing the Error 
            task will be used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword">
            <summary>
            Error help keyword
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ErrorFromResources.Execute">
            <summary>
            Log the requested error message.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ExtractedClassName">
            <summary>
            Extracted class name from the source file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock">
            <summary>
            Whether or not we found the name inside a block of conditionally compiled code
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ExtractedClassName.Name">
            <summary>
            Extracted class name
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ReadLinesFromFile">
            <summary>
            Read a list of items from a file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ReadLinesFromFile.File">
            <summary>
            File to read lines from.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ReadLinesFromFile.Lines">
            <summary>
            Receives lines from file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ReadLinesFromFile.Execute">
            <summary>
            Execute the task.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.WriteLinesToFile">
            <summary>
            Appends a list of items to a file. One item per line with carriage returns in-between.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteLinesToFile.File">
            <summary>
            File to write lines to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteLinesToFile.Lines">
            <summary>
            Write each item as a line in the file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteLinesToFile.Overwrite">
            <summary>
            If true, overwrite any existing file contents.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteLinesToFile.Encoding">
            <summary>
            Encoding to be used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent">
            <summary>
            If true, the target file specified, if it exists, will be read first to compare against
            what the task would have written. If identical, the file is not written to disk and the
            timestamp will be preserved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.WriteLinesToFile.Execute">
            <summary>
            Execute the task.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.FindInList">
            <summary>
            A task that finds an item with the specified itemspec, if present,
            in the provided list.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInList.List">
            <summary>
            The list to search through
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInList.MatchFileNameOnly">
            <summary>
            Whether to match against just the file part of the itemspec,
            or the whole itemspec (the default)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInList.ItemFound">
            <summary>
            The first matching item found in the list, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInList.ItemSpecToFind">
            <summary>
            The itemspec to try to find
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInList.CaseSensitive">
            <summary>
            Whether or not to match case sensitively
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInList.FindLastMatch">
            <summary>
            Whether or not to return the last match, instead of 
            the first one
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FindInList.Execute">
            <summary>
            Entry point
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FindInList.IsMatchingItem(System.StringComparison,Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Examines the item to see if it matches what we are looking for.
            If it does, returns true.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.FormatVersion">
            <summary>
            Formats a version by combining version and revision.
            </summary>
            <comment>
             Case #1: Input: Version=&lt;undefined&gt;  Revision=&lt;don't care&gt;   Output: OutputVersion="1.0.0.0"
             Case #2: Input: Version="1.0.0.*"    Revision="5"            Output: OutputVersion="1.0.0.5"
             Case #3: Input: Version="1.0.0.0"    Revision=&lt;don't care&gt;   Output: OutputVersion="1.0.0.0"
            </comment>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateResource">
            <summary>
            This class defines the "GenerateResource" MSBuild task, which enables using resource APIs
            to transform resource files.
            </summary>
            <summary>
            This class defines the "GenerateResource" MSBuild task, which enables using resource APIs
            to transform resource files.
            </summary>
            <comment>See GenerateResource.cs for the source code to the GenerateResource task; this file
            just contains the nested internal ResGen task</comment>
        </member>
        <member name="F:Microsoft.Build.Tasks.GenerateResource._aliases">
            <summary>
            Table of aliases for types defined in resx / resw files
            Ordinal comparer matches ResXResourceReader's use of a HashTable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GenerateResource._remotedTaskItems">
            <summary>
            The task items that we remoted across the appdomain boundary
            we use this list to disconnect the task items once we're done.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GenerateResource._satelliteInputs">
            <summary>
            Satellite input assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.Sources">
            <summary>
            The names of the items to be converted. The extension must be one of the
            following: .txt, .resx or .resources.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.UseSourcePath">
            <summary>
            Indicates whether the resource reader should use the source file's directory to
            resolve relative file paths.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.References">
            <summary>
            Resolves types in ResX files (XML resources) for Strongly Typed Resources
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources">
            <summary>
            Indicates whether resources should be passed through in their current serialization
            format. .NET Core-targeted assemblies should use this; it's the only way to support
            non-string resources with MSBuild running on .NET Core.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.AdditionalInputs">
            <summary>
            Additional inputs to the dependency checking done by this task. For example,
            the project and targets files typically should be inputs, so that if they are updated,
            all resources are regenerated.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.StateFile">
            <summary>
            This is the path/name of the file containing the dependency cache
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.OutputResources">
            <summary>
            The name(s) of the resource file to create. If the user does not specify this
            attribute, the task will append a .resources extension to each input filename
            argument and write the file to the directory that contains the input file.
            Includes any output files that were already up to date, but not any output files
            that failed to be written due to an error.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.FilesWritten">
            <summary>
            Storage for names of *all files* written to disk.  This is part of the implementation
            for Clean, and contains the OutputResources items and the StateFile item.
            Includes any output files that were already up to date, but not any output files
            that failed to be written due to an error.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage">
            <summary>
            The language to use when generating the class source for the strongly typed resource.
            This parameter must match exactly one of the languages used by the CodeDomProvider.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace">
            <summary>
            Specifies the namespace to use for the generated class source for the
            strongly typed resource. If left blank, no namespace is used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix">
            <summary>
            Specifies the resource namespace or manifest prefix to use in the generated
            class source for the strongly typed resource.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName">
            <summary>
            Specifies the class name for the strongly typed resource class.  If left blank, the base
            name of the resource file is used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName">
            <summary>
            Specifies the filename for the source file.  If left blank, the name of the class is
            used as the base filename, with the extension dependent on the language.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.PublicClass">
            <summary>
            Specifies whether the strongly typed class should be created public (with public methods)
            instead of the default internal. Analogous to resgen.exe's /publicClass switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles">
            <summary>
            Whether this rule is generating .resources files or extracting .ResW files from assemblies.
            Requires some additional input filtering.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies">
            <summary>
            (default = false)
            When true, a new AppDomain is always created to evaluate the .resx files.
            When false, a new AppDomain is created only when it looks like a user's
             assembly is referenced by the .resx.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.SdkToolsPath">
            <summary>
            Even though the generate resource task will do the processing in process, a logging message is still generated. This logging message
            will include the path to the windows SDK. Since the targets now will pass in the Windows SDK path we should use this for logging.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool">
            <summary>
            Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe and
            aximp.exe from the appropriate target framework will be run out-of-proc to generate
            the necessary wrapper assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables">
            <summary>
            Array of equals-separated pairs of environment
            variables that should be passed to the spawned resgen.exe,
            in addition to (or selectively overriding) the regular environment block.
            These aren't currently used when resgen is run in-process.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths">
            <summary>
            That set of paths from which tracked inputs will be ignored during
            Up to date checking
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking">
            <summary>
            Property used to set whether tracked incremental build will be used. If true,
            incremental build is turned on; otherwise, a rebuild will be forced.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.TrackFileAccess">
            <summary>
            True if we should be tracking file access patterns - necessary for incremental
            build support.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.TLogReadFiles">
            <summary>
            Names of the read tracking logs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.TLogWriteFiles">
            <summary>
            Names of the write tracking logs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory">
            <summary>
            Intermediate directory into which the tracking logs from running this task will be placed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ToolArchitecture">
            <summary>
            Microsoft.Build.Utilities.ExecutableType of ResGen.exe.  Used to determine whether or not
            Tracker.exe needs to be used to spawn ResGen.exe.  If empty, uses a heuristic to determine
            a default architecture.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath">
            <summary>
            Path to the appropriate .NET Framework location that contains FileTracker.dll.  If set, the user
            takes responsibility for making sure that the bitness of the FileTracker.dll that they pass matches
            the bitness of the ResGen.exe that they intend to use. If not set, the task decides the appropriate
            location based on the current .NET Framework version.
            </summary>
            <comments>
            Should only need to be used in partial or full checked in toolset scenarios.
            </comments>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath">
            <summary>
            Path to the appropriate Windows SDK location that contains Tracker.exe.  If set, the user takes
            responsibility for making sure that the bitness of the Tracker.exe that they pass matches the
            bitness of the ResGen.exe that they intend to use. If not set, the task decides the appropriate
            location based on the current Windows SDK.
            </summary>
            <comments>
            Should only need to be used in partial or full checked in toolset scenarios.
            </comments>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.OutputDirectory">
            <summary>
            Where to extract ResW files.  (Could be the intermediate directory.)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.#ctor">
            <summary>
            Simple public constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.#cctor">
            <summary>
            Static constructor checks the registry opt-out for mark-of-the-web rejection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.LogResgenCommandLine(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Logs a Resgen.exe command line that indicates what parameters were
            passed to this task. Since this task is replacing Resgen, and we used
            to log the Resgen.exe command line, we need to continue logging an
            equivalent command line.
            </summary>
            <param name="inputFiles"></param>
            <param name="outputFiles"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.GenerateResGenCommandLineWithoutResources(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Generate the parts of the resgen command line that are don't involve resgen.exe itself or the
            resources to be generated.
            </summary>
            <comments>
            Expects resGenCommand to be non-null -- otherwise, it doesn't get passed back to the caller, so it's
            useless anyway.
            </comments>
            <param name="resGenCommand"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.Execute">
            <summary>
            This is the main entry point for the GenerateResource task.
            </summary>
            <returns>true, if task executes successfully</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.CloneValuesInThisAppDomain(System.Collections.Generic.IList{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            For setting OutputResources and ensuring it can be read after the second AppDomain has been unloaded.
            </summary>
            <param name="remoteValues">ITaskItems in another AppDomain</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.RecordItemsForDisconnectIfNecessary(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Remember this TaskItem so that we can disconnect it when this Task has finished executing
            Only if we're passing TaskItems to another AppDomain is this necessary. This call
            Will make that determination for you.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ComputePathToResGen">
            <summary>
            Computes the path to ResGen.exe for use in logging and for passing to the
            nested ResGen task.
            </summary>
            <returns>True if the path is found (or it doesn't matter because we're executing in memory), false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.GenerateResourcesUsingResGen(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Wrapper around the call to the ResGen task that handles setting up the
            task to run properly.
            </summary>
            <param name="inputsToProcess">Array of names of inputs to be processed</param>
            <param name="outputsToProcess">Array of output names corresponding to the inputs</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.TransformResourceFilesUsingResGen(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Given an instance of the ResGen task with everything but the strongly typed
            resource-related parameters filled out, execute the task and return the result
            </summary>
            <param name="resGen">The task to execute.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.CalculateResourceBatchSize(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.String,System.Int32)">
            <summary>
            Given the list of inputs and outputs, returns the number of resources (starting at the provided initial index)
            that can fit onto the commandline without exceeding MaximumCommandLength.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.GenerateStronglyTypedResourceUsingResGen(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Given an instance of the ResGen task with everything but the strongly typed
            resource-related parameters filled out, execute the task and return the result
            </summary>
            <param name="resGen">The task to execute.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.CreateResGenTaskWithDefaultParameters">
            <summary>
            Factoring out the setting of the default parameters to the
            ResGen task.
            </summary>
            <param name="resGen"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ValidateParameters">
            <summary>
            Check for parameter errors.
            </summary>
            <returns>true if parameters are valid</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.GetResourcesToProcess(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem}@,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem}@,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem}@)">
            <summary>
            Returns true if everything is up to date and we don't need to do any work.
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Tasks.GenerateResource.AppendCachedOutputTaskItems(Microsoft.Build.Tasks.ResGenDependencies.PortableLibraryFile,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem})" -->
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ContainsDuplicates(System.Collections.Generic.IList{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Checks if this list contain any duplicates.  Do this so we don't have any races where we have two
            threads trying to write to the same file simultaneously.
            </summary>
            <param name="originalList">A list that may have duplicates</param>
            <returns>Were there duplicates?</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ShouldRebuildResgenOutputFile(System.String,System.String)">
            <summary>
            Determines if the given output file is up to date with respect to the
            the given input file by comparing timestamps of the two files as well as
            (if the source is a .resx) the linked files inside the .resx file itself
            </summary>
            <param name="sourceFilePath"></param>
            <param name="outputFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.NeedToRebuildSourceFile(System.String,System.DateTime,System.String,System.DateTime)">
            <summary>
            Returns true if the output does not exist, if the provided source is newer than the output,
            or if any of the set of additional inputs is newer than the output.  Otherwise, returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.GetStronglyTypedResourceToProcess(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem}@,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem}@)">
            <summary>
            Add the strongly typed resource to the set of resources to process if it is out of date.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.UpdateNewestUncorrelatedInputWriteTime">
            <summary>
            Returns the newest last write time among the references and additional inputs.
            If any do not exist, returns DateTime.MaxValue so that resource generation produces a nice error.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.NeedSeparateAppDomain">
            <summary>
            Make the decision about whether a separate AppDomain is needed.
            If this algorithm is unsure about whether a separate AppDomain is
            needed, it should always err on the side of returning 'true'. This
            is because a separate AppDomain, while slow to create, is always safe.
            </summary>
            <param name="sources">The list of .resx files.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.NeedSeparateAppDomainBasedOnSerializedType(System.Xml.XmlReader)">
            <summary>
            Finds the "value" element expected to be the next element read from the supplied reader.
            Deserializes the data content in order to figure out whether it implies a new app domain
            should be used to process resources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.DetermineWhetherSerializedObjectLoads(System.String)">
            <summary>
            Deserializes a base64 block from a resx in order to figure out if its type is in the GAC.
            Because we're not providing any assembly resolution callback, deserialization
            will attempt to load the object's type using fusion rules, which essentially means
            the GAC. So, if the object is null, it's definitely not in the GAC.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GenerateResource.s_specialChars">
            <summary>
            Chars that should be ignored in the nicely justified block of base64
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ByteArrayFromBase64WrappedString(System.String)">
            <summary>
            Turns the nicely justified block of base64 found in a resx into a byte array.
            Copied from fx\src\winforms\managed\system\winforms\control.cs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.CreateOutputResourcesNames">
            <summary>
            Make sure that OutputResources has 1 file name for each name in Sources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.RemoveUnsuccessfullyCreatedResourcesFromOutputResources">
            <summary>
            Remove any output resources that we didn't successfully create (due to error) from the
            OutputResources list. Keeps the ordering of OutputResources the same.
            </summary>
            <remarks>
            Q: Why didn't we keep a "successfully created" list instead, like in the Copy task does, which
            would save us doing the removal algorithm below?
            A: Because we want the ordering of OutputResources to be the same as the ordering passed in.
            Some items (the up to date ones) would be added to the successful output list first, and the other items
            are added during processing, so the ordering would change. We could fix that up, but it's better to do
            the fix up only in the rarer error case. If there were no errors, the algorithm below skips.</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.RecordFilesWritten">
            <summary>
            Record the list of file that will be written to disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ReadStateFile">
            <summary>
            Read the state file if able.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.WriteStateFile">
            <summary>
            Write the state file if there is one to be written.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateResource.ResGen">
            <summary>
            Defines the "ResGen" MSBuild task, which enables using ResGen.exe 
            to generate strongly-typed resource classes and convert resource
            files from one format to another.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.InputFiles">
            <summary>
            Files being passed to ResGen.exe to be converted to a different resource format.  
            If a strongly typed resource class is being created, only one file may be 
            passed to InputFiles at a time. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.OutputFiles">
            <summary>
            Should be the same length as InputFiles or null.  If null, the files output
            by ResGen.exe will be named "inputFiles[i].resources".  Otherwise, the 
            extensions on the output filesnames indicate which format the corresponding
            input file will be translated to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.PublicClass">
            <summary>
            Specifies whether the strongly typed class should be created public (with public methods)
            instead of the default internal. Analogous to resgen.exe's /publicClass switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.References">
            <summary>
            Resolves types in ResX files (XML resources) for Strongly Typed Resources
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.SdkToolsPath">
            <summary>
            Path to the SDK directory where ResGen.exe can be found
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.StronglyTypedLanguage">
            <summary>
            The language to use when generating the class source for the strongly typed resource.
            This parameter must match exactly one of the languages used by the CodeDomProvider.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.StronglyTypedNamespace">
            <summary>
            Specifies the namespace to use for the generated class source for the
            strongly typed resource. If left blank, no namespace is used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.StronglyTypedClassName">
            <summary>
            Specifies the class name for the strongly typed resource class.  If left blank, the base
            name of the resource file is used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.StronglyTypedFileName">
            <summary>
            Specifies the filename for the source file.  If left blank, the name of the class is
            used as the base filename, with the extension dependent on the language.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.UseSourcePath">
            <summary>
            Indicates whether the resource reader should use the source file's directory to
            resolve relative file paths.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.ToolName">
            <summary>
            Returns the name of the tool to execute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GenerateResource.ResGen.ResponseFileEncoding">
            <summary>
            Tracker.exe wants Unicode response files, and ResGen.exe doesn't care, 
            so make them Unicode across the board. 
            </summary>
            <comment>
            We no longer use Tracker.exe in ResGen, but given that as ResGen doesn't care, 
            there doesn't really seem to be a particular reason to change it back, either...
            </comment>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.Execute">
            <summary>
            Invokes the ToolTask with the given parameters
            </summary>
            <returns>True if the task succeeded, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Fills the provided CommandLineBuilderExtension with all the command line options used when
            executing this tool that can go into a response file.  
            </summary>
            <comments>
            ResGen 3.5 and earlier doesn't support response files, but ResGen 4.0 and later does.
            </comments>
            <param name="commandLine">Gets filled with command line options</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Fills the provided CommandLineBuilderExtension with all the command line options used when
            executing this tool that must go on the command line
            </summary>
            <comments>
            Has to be command line commands because ResGen 3.5 and earlier don't know about
            response files. 
            </comments>
            <param name="commandLine">Gets filled with command line options</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.GenerateFullPathToTool">
            <summary>
            Generates the full path to the tool being executed by this ToolTask
            </summary>
            <returns>A string containing the full path of this tool, or null if the tool was not found</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.ValidateParameters">
            <summary>
            Validates the parameters passed to the task
            </summary>
            <returns>True if parameters are valid</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.IsNullOrEmpty(Microsoft.Build.Framework.ITaskItem[])">
            <summary>
            Checks a string array for null or length zero.  Does not check if 
            individual members are null
            </summary>
            <param name="value">The string array to check</param>
            <returns>True if the array is null or has length zero</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.GenerateOutputFileNames">
            <summary>
            If OutputFiles is null, we need to generate default output names
            to pass to resgen.exe (which would generate the names on its own, but
            then we wouldn't have access to them)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.GenerateResGenFullPath">
            <summary>
            Generates the full path to ResGen.exe.  
            </summary>
            <returns>The path to ResGen.exe, or null.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateResource.ResGen.GenerateResGenCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension,System.Boolean)">
            <summary>
            Generate the command line to be passed to resgen.exe, sans the path to the tool. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ProcessResourceFiles">
            <summary>
            This class handles the processing of source resource files into compiled resource files.
            Its designed to be called from a separate AppDomain so that any files locked by ResXResourceReader
            can be released.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._readers">
            <summary>
            List of readers used for input.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._logger">
            <summary>
            Logger for any messages or errors
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._stronglyTypedLanguage">
            <summary>
            Language for the strongly typed resources.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ProcessResourceFiles.StronglyTypedFilename">
            <summary>
            Filename for the strongly typed resources.
            Getter provided since the processor may choose a default.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._stronglyTypedNamespace">
            <summary>
            Namespace for the strongly typed resources.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._stronglyTypedResourcesNamespace">
            <summary>
            ResourceNamespace for the strongly typed resources.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ProcessResourceFiles.StronglyTypedClassName">
            <summary>
            Class name for the strongly typed resources.
            Getter provided since the processor may choose a default.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._stronglyTypedClassIsPublic">
            <summary>
            Whether the fields in the STR class should be public, rather than internal
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._typeResolver">
            <summary>
            Class that gets called by the ResxResourceReader to resolve references
            to assemblies within the .RESX.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._eventHandler">
            <summary>
            Handles assembly resolution events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._assemblyFiles">
            <summary>
            The referenced assemblies
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._assemblyNames">
            <summary>
            The AssemblyNameExtensions for each of the referenced assemblies in "assemblyFiles".
            This is populated lazily.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._inFiles">
            <summary>
            List of input files to process.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._satelliteInFiles">
            <summary>
            List of satellite input files to process.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._outFiles">
            <summary>
            List of output files to process.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._extractResWFiles">
            <summary>
            Whether we are extracting ResW files from an assembly, instead of creating .resources files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._resWOutputDirectory">
            <summary>
            Where to write extracted ResW files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ProcessResourceFiles.PortableLibraryCacheInfo">
            <summary>
            Record all the information about outputs here to avoid future incremental builds.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ProcessResourceFiles.UnsuccessfullyCreatedOutFiles">
            <summary>
            List of output files that we failed to create due to an error.
            See note in RemoveUnsuccessfullyCreatedResourcesFromOutputResources()
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ProcessResourceFiles.StronglyTypedResourceSuccessfullyCreated">
            <summary>
            Whether we successfully created the STR class
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ProcessResourceFiles._useSourcePath">
            <summary>
            Indicates whether the resource reader should use the source file's
            directory to resolve relative file paths.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.Run(Microsoft.Build.Utilities.TaskLoggingHelper,Microsoft.Build.Framework.ITaskItem[],System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Boolean,System.Boolean,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.String)">
            <summary>
            Process all files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.ResolveAssembly(System.Object,System.ResolveEventArgs)">
            <summary>
            Callback to resolve assembly names to assemblies.
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.ProcessFile(System.String,System.String)">
            <summary>
            Read all resources from a file and write to a new file in the chosen format
            </summary>
            <remarks>Uses the input and output file extensions to determine their format</remarks>
            <param name="inFile">Input resources file</param>
            <param name="outFile">Output resources file</param>
            <returns>True if conversion was successful, otherwise false</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.EnsurePathIsShortEnough(System.String,System.String,System.String,System.String)">
            <summary>
            For very long resource names, the directory structure we generate may be too deep.
            If so, assume that the name is so long it will already uniquely distinguish itself.
            However for shorter names we'd still prefer to use the assembly simple name
            in the path to avoid conflicts.
            </summary>
            <param name="currentOutputFile">The current path name</param>
            <param name="currentOutputFileNoPath">The current file name without a path.</param>
            <param name="outputDirectory">Output directory path</param>
            <param name="cultureName">culture for this resource</param>
            <returns>The current path or a shorter one.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.RemoveCorruptedFile(System.String)">
            <summary>
            Remove a corrupted file, with error handling and a warning if we fail.
            </summary>
            <param name="filename">Full path to file to delete</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.GetFormat(System.String)">
            <summary>
            Figure out the format of an input resources file from the extension
            </summary>
            <param name="filename">Input resources file</param>
            <returns>Resources format</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.ProcessResourceFiles.Format">
            <summary>
            Text files are just name/value pairs.  ResText is the same format
            with a unique extension to work around some ambiguities with MSBuild
            ResX is our existing XML format from V1.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.ReadResources(System.String,System.Boolean,System.String)">
            <summary>
            Reads the resources out of the specified file and populates the
            resources hashtable.
            </summary>
            <param name="filename">Filename to load</param>
            <param name="shouldUseSourcePath">Whether to resolve paths in the
            resources file relative to the resources file location</param>
            <param name="outFileOrDir"> Output file or directory. </param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.AddResourcesUsingMinimalCoreResxParsing(System.String,Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo)">
            <summary>
            Legacy Core implementation of string-only ResX handling
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.ReadAssemblyResources(System.String,System.String)">
            <summary>
            Reads resources from an assembly.
            </summary>
            <param name="name"></param>
            <param name="outFileOrDir"> Output file or directory. </param>
            <remarks> This should not run for Framework assemblies. </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.CheckAssemblyCultureInfo(System.String,System.Reflection.AssemblyName,System.Globalization.CultureInfo,System.Reflection.Assembly,System.Boolean)">
            <summary>
            Checks the consistency of the CultureInfo and NeutralResourcesLanguageAttribute settings.
            </summary>
            <param name="name">Assembly's file name</param>
            <param name="assemblyName">AssemblyName of this assembly</param>
            <param name="culture">Assembly's CultureInfo</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.WriteResources(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.String)">
            <summary>
            Write resources from the resources ArrayList to the specified output file
            </summary>
            <param name="filename">Output resources file</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.CreateStronglyTypedResources(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.String,System.String,System.String@)">
            <summary>
            Create a strongly typed resource class
            </summary>
            <param name="outFile">Output resource filename, for defaulting the class filename</param>
            <param name="inputFileName">Input resource filename, for error messages</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(System.CodeDom.Compiler.CodeDomProvider,System.String)">
            <summary>
            If no strongly typed resource class filename was specified, we come up with a default based on the
            input file name and the default language extension.
            </summary>
            <comments>
            Broken out here so it can be called from GenerateResource class.
            </comments>
            <param name="provider">A CodeDomProvider for the language</param>
            <param name="outputResourcesFile">Name of the output resources file</param>
            <returns>Filename for strongly typed resource class</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.TryCreateCodeDomProvider(Microsoft.Build.Utilities.TaskLoggingHelper,System.String,System.CodeDom.Compiler.CodeDomProvider@)">
            <summary>
            Tries to create a CodeDom provider for the specified strongly typed language.  If successful, returns true,
            otherwise returns false.
            </summary>
            <comments>
            Broken out here so it can be called from GenerateResource class.
            Not a true "TryXXX" method, as it still throws if it encounters an exception it doesn't expect.
            </comments>
            <param name="stronglyTypedLanguage">The language to create a provider for.</param>
            <param name="provider">The provider in question, if one is successfully created.</param>
            <returns>True if the provider was successfully created, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.ReadResources(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.Resources.IResourceReader,System.String)">
            <summary>
            Read resources from an XML or binary format file
            </summary>
            <param name="reader">Appropriate IResourceReader</param>
            <param name="fileName">Filename, for error messages</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.ReadTextResources(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.String)">
            <summary>
            Read resources from a text format file
            </summary>
            <param name="fileName">Input resources filename</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.WriteResources(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.Resources.IResourceWriter)">
            <summary>
            Write resources to an XML or binary format resources file.
            </summary>
            <remarks>Closes writer automatically</remarks>
            <param name="writer">Appropriate IResourceWriter</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.WriteTextResources(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.String)">
            <summary>
            Write resources to a text format resources file
            </summary>
            <param name="fileName">Output resources file</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.AddResource(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.String,System.Object,System.String,System.Int32,System.Int32)">
            <summary>
            Add a resource from a text file to the internal data structures
            </summary>
            <param name="name">Resource name</param>
            <param name="value">Resource value</param>
            <param name="inputFileName">Input file for messages</param>
            <param name="lineNumber">Line number for messages</param>
            <param name="linePosition">Column number for messages</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.AddResource(Microsoft.Build.Tasks.ProcessResourceFiles.ReaderInfo,System.String,System.Object,System.String)">
            <summary>
            Add a resource from an XML or binary format file to the internal data structures
            </summary>
            <param name="name">Resource name</param>
            <param name="value">Resource value</param>
            <param name="inputFileName">Input file for messages</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.ProcessResourceFiles.LineNumberStreamReader">
            <summary>
            Custom StreamReader that provides detailed position information,
            used when reading text format resources
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.Build.Tasks.ProcessResourceFiles.TextFileException" -->
        <member name="M:Microsoft.Build.Tasks.ProcessResourceFiles.TextFileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Fxcop want to have the correct basic exception constructors implemented
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService">
            <summary>
            This implemention of ITypeResolutionService is passed into the ResxResourceReader
            class, which calls back into the methods on this class in order to resolve types
            and assemblies that are referenced inside of the .RESX.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.#ctor(Microsoft.Build.Framework.ITaskItem[])">
            <summary>
            Constructor, initialized with the set of resolved reference paths passed
            into the GenerateResource task.
            </summary>
            <param name="referencePaths"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetAssembly(System.Reflection.AssemblyName)">
            <summary>
            Not implemented.  Not called by the ResxResourceReader.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetAssembly(System.Reflection.AssemblyName,System.Boolean)">
            <summary>
            Not implemented.  Not called by the ResxResourceReader.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetAssemblyByPath(System.String,System.Boolean)">
            <summary>
            Given a path to an assembly, load the assembly if it's not already loaded.
            </summary>
            <param name="pathToAssembly"></param>
            <param name="throwOnError"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetPathOfAssembly(System.Reflection.AssemblyName)">
            <summary>
            Not implemented.  Not called by the ResxResourceReader.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetType(System.String)">
            <summary>
            Returns the type with the specified name.  Searches for the type in all
            of the assemblies passed into the References parameter of the GenerateResource
            task.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetType(System.String,System.Boolean)">
            <summary>
            Returns the type with the specified name.  Searches for the type in all
            of the assemblies passed into the References parameter of the GenerateResource
            task.
            </summary>
            <param name="name"></param>
            <param name="throwOnError"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns the type with the specified name.  Searches for the type in all
            of the assemblies passed into the References parameter of the GenerateResource
            task.
            </summary>
            <param name="name"></param>
            <param name="throwOnError"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.ReferenceAssembly(System.Reflection.AssemblyName)">
            <summary>
            Not implemented.  Not called by the ResxResourceReader.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetAssemblyIdentity">
            <summary>
            Sniffs input files for their assembly identities, and outputs a set of items with the identity information.
            </summary>
            <comment>
             Input:  Assembly Include="foo.exe"
             Output: Identity Include="Foo, Version=1.0.0.0", Name="Foo, Version="1.0.0.0"
            </comment>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject">
            <summary>
            Defines an interface for the Vbc/Csc tasks to communicate information about
            analyzers and rulesets to the IDE.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.ICscHostObject">
            <summary>
            Defines an interface for the Csc task to communicate with the IDE.  In particular,
            the Csc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.ICscHostObject2">
            <summary>
            Defines an interface for the Csc task to communicate with the IDE.  In particular,
            the Csc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.ICscHostObject3">
            <summary>
            Defines an interface for the Csc task to communicate with the IDE.  In particular,
            the Csc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.ICscHostObject4">
            <summary>
            Defines an interface for the Csc task to communicate with the IDE.  In particular,
            the Csc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.IVbcHostObject">
            <summary>
            Defines an interface for the Vbc task to communicate with the IDE.  In particular,
            the Vbc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.IVbcHostObject2">
            <summary>
            Defines an interface for the Vbc task to communicate with the IDE.  In particular,
            the Vbc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.IVbcHostObject3">
            <summary>
            Defines an interface for the Vbc task to communicate with the IDE.  In particular,
            the Vbc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.IVbcHostObject4">
            <summary>
            Defines an interface for the Vbc task to communicate with the IDE.  In particular,
            the Vbc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.IVbcHostObject5">
            <summary>
            Defines an interface that proffers a free threaded host object that
            allows for background threads to call directly (avoids marshalling
            to the UI thread.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded">
            <summary>
            Defines a free threaded interface for the Vbc task to communicate with the IDE.  In particular,
            the Vbc task will delegate the actual compilation to the IDE, rather than shelling
            out to the command-line compilers. 
            This particular version of Compile (unlike the IVbcHostObject::Compile) is not marshalled back to the UI
            thread. The implementor of the interface is responsible for any marshalling.
            This was added to allow some of the implementors code to run on the BG thread from which VBC Task is being 
            called from.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.InvalidParameterValueException">
            <summary>
            A parameter passed to the task was invalid.
            Currently used by the RAR task.
            ArgumentException was not used because it does not have a property for ActualValue.
            ArgumentOutOfRangeException does, but it appends its own message to yours.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InvalidParameterValueException.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InvalidParameterValueException.#ctor(System.String,System.String,System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InvalidParameterValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.InvalidParameterValueException.ParamName">
            <summary>
            The name of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.InvalidParameterValueException.ActualValue">
            <summary>
            The value supplied, that was bad.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.FindUnderPath">
            <summary>
            Given a list of items, determine which are in the cone of the folder passed in and which aren't.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindUnderPath.Path">
            <summary>
            Filter based on whether items fall under this path or not.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindUnderPath.Files">
            <summary>
            Files to consider.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths">
            <summary>
            Set to true if the paths of the output items should be updated to be absolute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindUnderPath.InPath">
            <summary>
            Files that were inside of Path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindUnderPath.OutOfPath">
            <summary>
            Files that were outside of Path.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FindUnderPath.Execute">
            <summary>
            Execute the task.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.RemoveDuplicates">
            <summary>
            Given a list of items, remove duplicate items. Attributes are not considered. Case insensitive.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RemoveDuplicates.Inputs">
            <summary>
            The left-hand set of items to be RemoveDuplicatesed from.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RemoveDuplicates.Filtered">
            <summary>
            List of unique items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates">
            <summary>
            True if any duplicate items were found. False otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RemoveDuplicates.Execute">
            <summary>
            Execute the task.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.MakeDir">
            <summary>
            A task that creates a directory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.MakeDir.Execute">
            <summary>
            Executes the MakeDir task. Create the directory.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Message">
            <summary>
            Task that simply emits a message. Importance defaults to high if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Message.Text">
            <summary>
            Text to log.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Message.Importance">
            <summary>
            Importance: high, normal, low (default normal)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Message.Code">
            <summary>
            Message code
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Message.File">
            <summary>
            Relevant file if any.
            If none is provided and this is a critical message, the file containing the Message
            task will be used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Message.HelpKeyword">
            <summary>
            Message help keyword
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Message.IsCritical">
            <summary>
            Indicates if this is a critical message
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Move">
            <summary>
            Task to move one or more files.
            </summary>
            <remarks>
            This does not support moving directories (ie, xcopy)
            but this could restriction could be lifted as MoveFileEx,
            which is used here, supports it.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Tasks.Move.Flags">
            <summary>
            Flags for MoveFileEx.
            
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Move._canceling">
            <summary>
            Whether we should cancel.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Move.SourceFiles">
            <summary>
            List of files to move.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Move.DestinationFolder">
            <summary>
            Destination folder for all the source files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles">
            <summary>
            Whether to overwrite files in the destination
            that have the read-only attribute set.
            Default is to not overwrite.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Move.DestinationFiles">
            <summary>
            Destination files matching each of the source files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Move.MovedFiles">
            <summary>
            Subset that were successfully moved 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Move.Cancel">
            <summary>
            Stop and return (in an undefined state) as soon as possible.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Move.Execute">
            <summary>
            Main entry point.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Move.MakeWriteableIfReadOnly(System.String)">
            <summary>
            Makes the provided file writeable if necessary
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Move.MoveFileWithLogging(System.String,System.String)">
            <summary>
            Move one file from source to destination. Create the target directory if necessary.
            </summary>
            <throws>IO related exceptions</throws>
        </member>
        <member name="T:Microsoft.Build.Tasks.MSBuild">
            <remarks>
            This class implements the "MSBuild" task, which hands off child project files to the MSBuild engine to be built.
            Marked RunInMTA because there is no reason MSBuild tasks should run on a thread other than that of the 
            RequestBuilder which spawned them.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjectsBehavior">
            <summary>
            Enum describing the behavior when a project doesn't exist on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjectsBehavior.Skip">
            <summary>
            Skip the project if there is no file on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjectsBehavior.Error">
            <summary>
            Error if the project does not exist on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjectsBehavior.Build">
            <summary>
            Build even if the project does not exist on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.Properties">
            <summary>
            A list of property name/value pairs to apply as global properties to 
            the child project.  
            A typical input: "propname1=propvalue1", "propname2=propvalue2", "propname3=propvalue3".
            </summary>
            <remarks>
            The fact that this is a string[] makes the following illegal:
                <MSBuild
                    Properties="TargetPath=@(OutputPathItem)" />
            The engine fails on this because it doesn't like item lists being concatenated with string
            constants when the data is being passed into an array parameter.  So the workaround is to 
            write this in the project file:
                <MSBuild
                    Properties="@(OutputPathItem->'TargetPath=%(Identity)')" />
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.RemoveProperties">
            <summary>
            Gets or sets the set of global properties to remove.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.Targets">
            <summary>
            The targets to build in each project specified by the <see cref="P:Microsoft.Build.Tasks.MSBuild.Projects"/> property.
            </summary>
            <value>Array of target names.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.Projects">
            <summary>
            The projects to build.
            </summary>
            <value>Array of project items.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.TargetOutputs">
            <summary>
            Outputs of the targets built in each project.
            </summary>
            <value>Array of output items.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.RebaseOutputs">
            <summary>
            Indicates if the paths of target output items should be rebased relative to the calling project.
            </summary>
            <value>true, if target output item paths should be rebased</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure">
            <summary>
            Forces the task to stop building the remaining projects as soon as any of
            them fail.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately">
            <summary>
            When this is true, instead of calling the engine once to build all the targets (for each project),
            we would call the engine once per target (for each project).  The benefit of this is that
            if one target fails, you can still continue with the remaining targets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.ToolsVersion">
            <summary>
            Value of ToolsVersion to use when building projects passed to this task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.BuildInParallel">
            <summary>
            When this is true we call the engine with all the projects at once instead of 
            calling the engine once per project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion">
            <summary>
            If true the project will be unloaded once the operation is completed
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.UseResultsCache">
            <summary>
            Deprecated. Does nothing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects">
            <summary>
            When this is true, project files that do not exist on the disk will be skipped. By default,
            such projects will cause an error.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators">
            <summary>
            Unescape Targets, Properties (including Properties and AdditionalProperties as Project item metadata)
            will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will 
            be treated as if it were an un-escaped ';'
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.MSBuild.Execute">
            <summary>
            Instructs the MSBuild engine to build one or more project files whose locations are specified by the
            <see cref="P:Microsoft.Build.Tasks.MSBuild.Projects"/> property.
            </summary>
            <returns>true if all projects build successfully; false if any project fails</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.MSBuild.BuildProjectsInParallel(System.Collections.Generic.Dictionary{System.String,System.String},System.String[],System.Collections.Generic.List{System.String[]},System.Boolean,System.Boolean[])">
            <summary>
            Build projects which have not been skipped. This will be done in parallel
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.MSBuild.ExpandAllTargetsAndProperties">
            <summary>
            Expand and re-construct arrays of all targets and properties
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.MSBuild.ExecuteTargets(System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Collections.Generic.Dictionary{System.String,System.String},System.String[],System.Collections.Generic.List{System.String[]},System.Boolean,System.Boolean,Microsoft.Build.Framework.IBuildEngine3,Microsoft.Build.Utilities.TaskLoggingHelper,System.Collections.Generic.List{Microsoft.Build.Framework.ITaskItem},System.Boolean,System.String)">
            <returns>True if the operation was successful</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.IFixedTypeInfo">
            <summary>
            The original ITypeInfo interface in the CLR has incorrect definitions for GetRefTypeOfImplType and GetRefTypeInfo.
            It uses ints for marshalling handles which will result in a crash on 64 bit systems. This is a temporary interface
            for use until the one in the CLR is fixed. When it is we can go back to using ITypeInfo.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.NativeMethods">
            <summary>
            Interop methods.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.NativeMethods.MoveFileEx(System.String,System.String,Microsoft.Build.Tasks.NativeMethods.MoveFileFlags)">
            <summary>
            Add implementation of this function when not running on windows. The implementation is
            not complete, of course, but should work for most common cases.
            </summary>
            <param name="existingFileName"></param>
            <param name="newFileName"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.NativeMethods.GetCachePath(Microsoft.Build.Tasks.AssemblyCacheFlags,System.Text.StringBuilder,System.Int32@)">
            <summary>
            GetCachePath from fusion.dll.
            Using StringBuilder here is a way to pass a preallocated buffer of characters to (native) functions that require it.
            A common design pattern in unmanaged C++ is calling a function twice, once to determine the length of the string
            and then again to pass the client-allocated character buffer. StringBuilder is the most straightforward way
            to allocate a mutable buffer of characters and pass it around.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.NativeMethods.GetFileVersion(System.String,System.Text.StringBuilder,System.Int32,System.UInt32@)">
            <summary>
            Get the runtime version for a given file
            </summary>
            <param name="szFullPath">The path of the file to be examined</param>
            <param name="szBuffer">The buffer allocated for the version information that is returned.</param>
            <param name="cchBuffer">The size, in wide characters, of szBuffer</param>
            <param name="dwLength">The size, in bytes, of the returned szBuffer.</param>
            <returns>HResult</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.NativeMethods.TryReadMetadataString(System.String,System.IntPtr,System.UInt32,System.String@)">
            <summary>
            Given a pointer to a metadata blob, read the string parameter from it.  Returns true if 
            a valid string was constructed and false otherwise.  
            
            Adapted from bizapps\server\designers\models\packagemodel\nativemethods.cs (TryReadStringArgument) and 
            the original ARD implementation in vsproject\compsvcspkg\enumcomplus.cpp (GetStringCustomAttribute)
            This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.NativeMethods.CorSigUncompressData(System.IntPtr,System.Int32@)">
            <summary>
            Returns the number of bytes that compressed data -- the length of the uncompressed 
            data -- takes up, and has an out value of the length of the string.  
            
            Decompression algorithm stolen from ndp\clr\src\toolbox\mdbg\corapi\metadata\cormetadata.cs, which 
            was translated from the base implementation in ndp\clr\src\inc\cor.h
            This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
            </summary>
            <param name="data">Pointer to the beginning of the data block</param>
            <param name="uncompressedDataLength">Length of the uncompressed data block</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum">
            <summary>
            This class is a wrapper over the native GAC enumeration API.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum.s_gacPath">
            <summary>
            Path to the gac
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum.s_assemblyVersionRegex">
            <summary>
            Regex for directory version parsing
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum._assemblyEnum">
            <summary>
            The IAssemblyEnum interface which allows us to ask for the next assembly from the GAC enumeration.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum._assemblyNameVersion">
            <summary>
            For non-Windows implementation, we need assembly name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum._gacDirectories">
            <summary>
            For non-Windows implementation, we need assembly name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum._done">
            <summary>
            Are we done going through the enumeration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum.InitializeEnum(System.String)">
            <summary>
            Initialize the GAC Enum
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="T:Microsoft.Build.Tasks.ParseState">
            <summary>
            State used by the c# and vb parsers. Maintains information about
            what's being parsed and what has been seen so far.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ParseState.ResolvingNamespace">
            <summary>
            Are we resolving a namespace?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ParseState.ResolvingClass">
            <summary>
            Are we resolving a class?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ParseState.InsideConditionalDirective">
            <summary>
            Are we inside a conditional directive?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ParseState.Namespace">
            <summary>
            The current namespace name as its being resolved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ParseState.Reset">
            <summary>
            Reset the state, but don't throw away namespace stack information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ParseState.OpenConditionalDirective">
            <summary>
            Note that we've entered a conditional directive
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ParseState.CloseConditionalDirective">
            <summary>
            Note that we've exited a conditional directive
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ParseState.PushNamespacePart(System.String)">
            <summary>
            Push a namespace element onto the stack. May be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ParseState.PopNamespacePart">
            <summary>
            Pop a namespace element from the stack. May be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ParseState.ComposeQualifiedClassName(System.String)">
            <summary>
            Build a fully qualified (i.e. with the namespace) class name based on the contents of the stack.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.RedistList">
            <summary>
            Defines list of redistributable assemblies for use in dependency analysis.
            The input is a set of XML files in a well known format consisting of
            File elements. Each File element defines the assembly name of an assembly
            that is part of a redistributable unit, such as the .NET Framework
            (i.e. dotnetfx.exe) or the J# Framework. For the .NET Framework, these
            data files are specified in a sub-folder of the .NET Framework named
            "RedistList". This list is used by the build system to unify previous
            Framework version dependencies to the current Framework version.
            This list is also used by the deployment system to exclude Framework
            dependencies from customer deployment packages.
            </summary>    
        </member>
        <member name="F:Microsoft.Build.Tasks.RedistList._assemblyNameInRedist">
            <summary>
            When we check to see if an assembly is in this redist list we want to cache it so that if we ask again we do not
            have to re-scan bits of the redist list and do the assemblynameExtension comparisons.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RedistList._assemblyNameToUnifiedAssemblyName">
            <summary>
            AssemblyName to unified assemblyName. We make this kind of call a lot and also will ask for the same name multiple times.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RedistList._assemblyNameToAssemblyNameExtension">
            <summary>
            AssemblyName to AssemblyNameExtension object. We make this kind of call a lot and also will ask for the same name multiple times.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RedistList._remappingCache">
            <summary>
            When we check to see if an assembly is remapped we should cache the result because we may get asked the same question a number of times.
            Since the remapping list does not change between builds neither would the results of the remapping for a given fusion name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RedistList.Errors">
            <summary>
            Returns any exceptions encountered while reading\parsing the XML.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RedistList.ErrorFileNames">
            <summary>
            Returns any exceptions encountered while reading\parsing the XML.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RedistList.Count">
            <summary>
            Returns the number of entries in the redist list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.IsFrameworkAssembly(System.String)">
            <summary>
            Determines whether or not the specified assembly is part of the Framework.
            Assemblies from a previous version of the Framework will be
            correctly identified.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.IsPrerequisiteAssembly(System.String)">
            <summary>
            Determines whether or not the specified assembly is a Prerequisite assembly.
            A prerequisite assembly is any assembly that is flagged as being installed in the GAC
            in a redist data file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.RemapAssembly(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            If there was a remapping entry in the redist list list then remap the passed in assemblynameextension 
            if not just return the original one. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.IsRedistRoot(System.String)">
            <summary>
            Determines whether or not the specified assembly is a redist root.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GetFrameworkList20">
            <summary>
            Returns an instance of RedistList initialized from the framework folder for v2.0
            This function returns a statically cached object, so all calls will return the
            same instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GetFrameworkList30">
            <summary>
            Returns an instance of RedistList initialized from the framework folder for v3.0
            This function returns a statically cached object, so all calls will return the
            same instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GetFrameworkList35">
            <summary>
            Returns an instance of RedistList initialized from the framework folder for v3.5
            This function returns a statically cached object, so all calls will return the
            same instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GetRedistListFromPath(System.String)">
            <summary>
            This is owned by chris mann
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GetRedistListPathsFromDisk(System.String)">
            <summary>
            Given a framework directory path, this static method will find matching
            redist list files underneath that path.  A process-wide cache is used to
            avoid hitting the disk multiple times for the same framework directory.
            </summary>
            <returns>Array of paths to redist lists under given framework directory.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.RedistName(System.String)">
            <summary>
            The name of this redist.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GetRedistList(Microsoft.Build.Tasks.AssemblyTableInfo[])">
            <summary>
            Returns an instance of RedistList initialized from the specified set of files.
            This function returns a statically cached object, so subsequent calls with the same set
            of files will return the same instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.FrameworkAssemblyEntryInRedist(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Given an assemblyNameExtension, is that assembly name in the redist list or not. This will use partial matching and match as much of the fusion name as exists in the assemblyName passed in.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GetUnifiedAssemblyName(System.String)">
            <summary>
            Returns the unified version of the specified assembly.
            Assemblies from a previous version of the Framework will be
            returned with the current runtime version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.FindAssemblyNameFromSimpleName(System.String)">
            <summary>
            Find every assembly full name that matches the given simple name.
            </summary>
            <returns>The list of assembly names.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.GenerateBlackList(Microsoft.Build.Tasks.AssemblyTableInfo[],System.Collections.Generic.List{System.Exception},System.Collections.Generic.List{System.String})">
             <summary>
             This method will take a list of AssemblyTableInfo and generate a black list by subtracting the 
             assemblies listed in the WhiteList from the RedistList. 
             
             1) If there are assemblies in the redist list and one or more client subset files are read in with matching names then
                the subtraction will take place. If there were no matching redist lists read in the black list will be empty.
                
             2) If the subset has a matching name but there are no files inside of it then the black list will contain ALL files in the redist list.
             
             3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for black list generation.
            
             When generating the blacklist, we will first see if the black list is in the appdomain wide cache
             so that we do not regenerate one for multiple calls using the same whiteListAssemblyTableInfo.
             
             </summary>
             <param name="whiteListAssemblyTableInfo">List of paths to white list xml files</param>
             <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value. 
                      If there is no assemblies in the redist list null is returned.
             </returns> 
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.ReadFile(Microsoft.Build.Tasks.AssemblyTableInfo,System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyEntry},System.Collections.Generic.List{System.Exception},System.Collections.Generic.List{System.String},System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyRemapping})">
            <summary>
            Read the redist list from disk.
            XML formatting issues will recorded in the 'errors' collection.
            </summary>
            <param name="assemblyTableInfo">Information about the redistlist file.</param>
            <returns>Redist name of the redist list just read in</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.ParseRemapSection(Microsoft.Build.Tasks.AssemblyTableInfo,System.String,System.String,System.Xml.XmlReader,System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyRemapping})">
            <summary>
            Parse the remapping xml element in the redist list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.ParseFileListSection(Microsoft.Build.Tasks.AssemblyTableInfo,System.String,System.String,System.Xml.XmlReader,System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Tasks.AssemblyEntry},System.Collections.Generic.List{Microsoft.Build.Tasks.AssemblyRemapping})">
            <summary>
            Parse the FileList section in the redist list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RedistList.ReadFileListEntry(Microsoft.Build.Tasks.AssemblyTableInfo,System.String,System.String,System.Xml.XmlReader,System.Boolean)">
            <summary>
            Parse an individual FileListEntry in the redist list
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.RedistList.SortByVersionDescending">
            <summary>
            The redist list is a collection of AssemblyEntry. We would like to have the redist list sorted on two keys.
            The first key is simple name, the simple names should be sorted alphabetically in ascending order (a,b,c,d,e).
            When the simple names are the same the sorting shouldbe done by version number rather than the alphabetical representation of the version.
            A numerical comparison is required because the alphabetical sort does not place the versions in numerical order. For example 1, 10, 2, 3, 4
            This sort should be done descending ( 10,9,8,7,6,5) so that if the resdist list is read from top to bottom the newest version is seen first.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyTableInfo">
            <summary>
            Internal class representing a redist list or whitelist and its corresponding framework directory.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.SubsetListFinder">
            <summary>
            Provide a mechanism to determine where the subset white lists are located by searching the target framework folders 
            for a list of provided subset list names.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SubsetListFinder._subsetToSearchFor">
            <summary>
            The subset names to search for.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SubsetListFinder.#ctor(System.String[])">
            <summary>
            This class takes in a list of subset names to look for and provides a method to search the target framework directories to see if those
            files exist.
            </summary>
            <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be 
            found in the target framework directories. This can happen if the the subsets are instead passed in as InstalledDefaultSubsetTables</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.SubsetListFinder.SubsetListFolder">
            <summary>
             Folder to look for the subset lists under the target framework directories
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SubsetListFinder.GetSubsetListPathsFromDisk(System.String)">
            <summary>
            Given a framework directory path, this method will find matching
            subset list files underneath that path.  An appdomain-wide cache is used to
            avoid hitting the disk multiple times for the same framework directory and set of requested subset names.
            </summary>
            <param name="frameworkDirectory">Framework directory to look for set of subset files under</param>
            <returns>Array of paths locations to subset lists under the given framework directory.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyEntry">
            <summary>
            Describes an assembly entry found in an installed assembly table.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.RemoveDir">
            <summary>
            Remove the specified directories.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResGenDependencies">
            <remarks>
            This class is a caching mechanism for the resgen task to keep track of linked
            files within processed .resx files.
            
            This is an on-disk serialization format, don't change field names or types or use readonly.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResGenDependencies.resXFiles">
            <summary>
            The list of resx files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResGenDependencies.portableLibraries">
            <summary>
            A list of portable libraries and the ResW files they can produce.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResGenDependencies._isDirty">
            <summary>
            A newly-created ResGenDependencies is not dirty.
            What would be the point in saving the default?
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResGenDependencies.baseLinkedFileDirectory">
            <summary>
             This is the directory that will be used for resolution of files linked within a .resx.
             If this is NULL then we use the directory in which the .resx is in (that should always
             be the default!)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResGenDependencies.SerializeCache(System.String,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Writes the contents of this object out to the specified file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResGenDependencies.DeserializeCache(System.String,System.Boolean,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Reads the .cache file from disk into a ResGenDependencies object.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResGenDependencies.ResXFile">
            <remarks>
            Represents a single .resx file in the dependency cache.
            
            This is an on-disk serialization format, don't change field names or types or use readonly.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResGenDependencies.ResXFile.GetLinkedFiles(System.String,System.String,System.Boolean)">
            <summary>
            Given a .RESX file, returns all the linked files that are referenced within that .RESX.
            </summary>
            <exception cref="T:System.ArgumentException">May be thrown if Resx is invalid. May contain XmlException.</exception>
            <exception cref="T:System.Xml.XmlException">May be thrown if Resx is invalid</exception>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResGenDependencies.PortableLibraryFile">
            <remarks>
            Represents a single assembly in the dependency cache, which may produce 
            0 to many ResW files.
            
            This is an on-disk serialization format, don't change field names or types or use readonly.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResGenDependencies.IsDirty">
            <summary>
            Whether this cache is dirty or not.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet">
            <summary>
            Determines which file, if any, to be used as the code analysis rule set based
            on the supplied code analysis properties.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet">
            <summary>
            The desired code analysis rule set file. May be a simple name, relative
            path, or full path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories">
            <summary>
            The set of additional directories to search for code analysis rule set files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory">
            <summary>
            The location of the project currently being built.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolvedCodeAnalysisRuleSet">
            <summary>
            The location of the resolved rule set file. May be null if the file
            does not exist on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.Execute">
            <summary>
            Runs the task.
            </summary>
            <returns>True if the task succeeds without errors; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.GetResolvedRuleSetPath">
             <summary>
             Computes the resolved rule set path.
             
             There are four cases: null, file name, relative path, and full path.
            
             If we were given no value for the ruleset, simply return null.
            
             For full path we return the string as it is.
            
             A simple file name can refer to either a file in the MSBuild project directory
             or a file in the rule set search paths. In the former case we return the string as-is.
             In the latter case, we create a full path by prepending the first rule set search path
             where the file is found.
            
             For relative paths we return the string as-is.
            
             In all cases, we return null if the file does not actual exist.
             </summary>
             <returns>The full or relative path to the rule set, or null if the file does not exist.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveKeySource">
            <summary>
            Determine the strong name key source
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput" -->
        <member name="M:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.#ctor">
            <summary>
            default public constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs">
            <summary>
            A special XML string containing resolved project outputs - we need to simply match the projects and
            return the appropriate paths
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths">
            <summary>
            The list of resolved reference paths (preserving the original project reference attributes)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences">
            <summary>
            The list of project reference items that could not be resolved using the pre-resolved list of outputs.
            Since VS only pre-resolves non-MSBuild projects, this means that project references in this list
            are in the MSBuild format.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.GetAssemblyNameDelegate">
            <summary>
            A delegate with a signature that matches AssemblyName.GetAssemblyName.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.GetAssemblyName">
            <summary>
            A dependency-injection way of getting an assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute">
            <summary>
            Main task method
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolveProject(Microsoft.Build.Framework.ITaskItem,Microsoft.Build.Framework.ITaskItem@)">
            <summary>
            Given a project reference task item and an XML document containing pre-resolved output paths, 
            find the output path for that task item.
            </summary>
            <param name="resolvedPath">resulting ITaskItem containing the resolved path</param>
            <returns>true if resolved successfully</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveProjectBase">
            <summary>
            Base class for ResolveNonMSBuildProjectOutput and AssignProjectConfiguration, since they have
            similar architecture
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences">
            <summary>
            The list of project references
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveProjectBase.VerifyReferenceAttributes(Microsoft.Build.Framework.ITaskItem,System.String@)">
            <summary>
            Checks if a project reference task item contains all the required attributes.
            Currently, the only required attribute is project GUID for inside the IDE mode.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveProjectBase.VerifyProjectReferenceItems(Microsoft.Build.Framework.ITaskItem[],System.Boolean)">
            <summary>
            Checks all project reference task items for required attributes
            Internal for unit testing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveProjectBase.CacheProjectElementsFromXml(System.String)">
            <summary>
            Pre-cache individual project elements from the XML string in a hashtable for quicker access.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Helper method for retrieving whatever was stored in the XML string for the given project
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveProjectBase.GetProjectElement(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Helper method for retrieving the XML element for the given project
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveProjectBase.AddSyntheticProjectReferences(System.String)">
            <summary>
            Helper method for retrieving the extra "project references" passed in the solution blob.
            These came from dependencies expressed in the solution file itself.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory.DefaultNamespaces">
            <summary>
            A set of default namespaces to add so that user does not have to include them.  Make sure that these are covered
            by the list of <see cref="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory.DefaultReferences"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory.DefaultReferences">
            <summary>
            A set of default references to add so that the user does not have to include them.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory.ReferenceAssemblyDirectoryName">
            <summary>
            The name of a subdirectory that contains reference assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory.MonoLibDirs">
            <summary>
            Array of mono lib directories used to resolve references
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory.CompiledAssemblyCache">
            <summary>
            A cache of <see cref="T:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo"/> objects and their corresponding compiled assembly.  This cache ensures that two of the exact same code task
            declarations are not compiled multiple times.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory.ThisAssemblyDirectoryLazy">
            <summary>
            Stores the path to the directory that this assembly is located in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory._log">
            <summary>
            Stores an instance of a <see cref="T:Microsoft.Build.Utilities.TaskLoggingHelper"/> for logging messages.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory._parameters">
            <summary>
            Stores the parameters parsed in the &lt;UsingTask /&gt;.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactory._taskName">
            <summary>
            Stores the task name parsed in the &lt;UsingTask /&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactory.FactoryName">
            <inheritdoc cref="P:Microsoft.Build.Framework.ITaskFactory.FactoryName"/>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactory.TaskType">
            <inheritdoc />
            <summary>
            Gets the <see cref="T:System.Type" /> of the compiled task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask)">
            <inheritdoc cref="M:Microsoft.Build.Framework.ITaskFactory.CleanupTask(Microsoft.Build.Framework.ITask)"/>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine)">
            <inheritdoc cref="M:Microsoft.Build.Framework.ITaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine)"/>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetTaskParameters">
            <inheritdoc cref="M:Microsoft.Build.Framework.ITaskFactory.GetTaskParameters"/>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.Initialize(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,Microsoft.Build.Framework.IBuildEngine)">
            <inheritdoc cref="M:Microsoft.Build.Framework.ITaskFactory.Initialize(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,Microsoft.Build.Framework.IBuildEngine)"/>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetSourceCode(Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo,System.Collections.Generic.ICollection{Microsoft.Build.Framework.TaskPropertyInfo})">
            <summary>
            Gets the full source code by applying an appropriate template based on the current <see cref="T:Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.TryLoadTaskBody(Microsoft.Build.Utilities.TaskLoggingHelper,System.String,System.String,System.Collections.Generic.ICollection{Microsoft.Build.Framework.TaskPropertyInfo},Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo@)">
              <summary>
              Parses and validates the body of the &lt;UsingTask /&gt;.
              </summary>
              <param name="log">A <see cref="T:Microsoft.Build.Utilities.TaskLoggingHelper"/> used to log events during parsing.</param>
              <param name="taskName">The name of the task.</param>
              <param name="taskBody">The raw inner XML string of the &lt;UsingTask />&gt; to parse and validate.</param>
             <param name="parameters">An <see cref="T:System.Collections.Generic.ICollection`1"/> containing parameters for the task.</param>
             <param name="taskInfo">A <see cref="T:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo"/> object that receives the details of the parsed task.</param>
             <returns><code>true</code> if the task body was successfully parsed, otherwise <code>false</code>.</returns>
              <remarks>
              The <paramref name="taskBody"/> will look like this:
              <![CDATA[
            
                <Using Namespace="Namespace" />
                <Reference Include="AssemblyName|AssemblyPath" />
                <Code Type="Fragment|Method|Class" Language="cs|vb" Source="Path">
                  // Source code
                </Code>
            
              ]]>
              </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.TryResolveAssemblyReferences(Microsoft.Build.Utilities.TaskLoggingHelper,Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo,Microsoft.Build.Framework.ITaskItem[]@)">
            <summary>
            Attempts to resolve assembly references that were specified by the user.
            </summary>
            <param name="log">A <see cref="T:Microsoft.Build.Utilities.TaskLoggingHelper"/> used for logging.</param>
            <param name="taskInfo">A <see cref="T:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo"/> object containing details about the task.</param>
            <param name="items">Receives the list of full paths to resolved assemblies.</param>
            <returns><code>true</code> if all assemblies could be resolved, otherwise <code>false</code>.</returns>
            <remarks>The user can specify a short name like My.Assembly or My.Assembly.dll.  In this case we'll
            attempt to look it up in the directory containing our reference assemblies.  They can also specify a
            full path and we'll do no resolution.  At this time, these are the only two resolution mechanisms.
            Perhaps in the future this could be more powerful by using NuGet to resolve assemblies but we think
            that is too complicated for a simple in-line task.  If users have more complex requirements, they
            can compile their own task library.</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactory.TryCompileInMemoryAssembly(Microsoft.Build.Framework.IBuildEngine,Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo,System.Reflection.Assembly@)">
            <summary>
            Attempts to compile the current source code and load the assembly into memory.
            </summary>
            <param name="buildEngine">An <see cref="T:Microsoft.Build.Framework.IBuildEngine"/> to use give to the compiler task so that messages can be logged.</param>
            <param name="taskInfo">A <see cref="T:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo"/> object containing details about the task.</param>
            <param name="assembly">The <see cref="T:System.Reflection.Assembly"/> if the source code be compiled and loaded, otherwise <code>null</code>.</param>
            <returns><code>true</code> if the source code could be compiled and loaded, otherwise <code>null</code>.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType">
            <summary>
            Represents the kind of code contained in the code task definition.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType.Fragment">
            <summary>
            The code is a fragment and should be included within a method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType.Method">
            <summary>
            The code is a method and should be included within a class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType.Class">
            <summary>
            The code is a whole class and no modifications should be made to it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo.CodeLanguage">
            <summary>
            Gets or sets the code language of the task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo.CodeType">
            <summary>
            Gets or sets the <see cref="T:Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType"/> of the task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo.Name">
            <summary>
            Gets or sets the name of the task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo.Namespaces">
            <summary>
            Gets a <see cref="T:System.Collections.Generic.ISet`1"/> of namespaces to use.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo.References">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ISet`1"/> of assembly references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo.SourceCode">
            <summary>
            Gets or sets the source code of the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo.Equals(Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="T:Microsoft.Build.Tasks.ISGenTaskContract">
            <summary>
            An interface containing public SGen task properties to make sure that all versions of the task have the same public surface.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ISGenTaskContract.Platform">
            <summary>
            Gets or Sets the Compiler Platform used by SGen to generate the output assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ISGenTaskContract.Types">
            <summary>
            Gets or Sets a list of specific Types to generate serialization code for, SGen will generate serialization code only for those types.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.SGen">
            <summary>
            Genererates a serialization assembly containing XML serializers for the input assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.SGen.Platform">
            <summary>
            Gets or Sets the Compiler Platform used by SGen to generate the output assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.SGen.Types">
            <summary>
            Gets or Sets a list of specific Types to generate serialization code for, SGen will generate serialization code only for those types.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.SGen.ToolName">
            <summary>
            The name of the tool to execute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SGen.GenerateFullPathToTool">
            <summary>
            The full path of the tool to execute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SGen.ValidateParameters">
            <summary>
            Validate parameters, log errors and warnings and return true if Execute should proceed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SGen.SkipTaskExecution">
            <summary>
            Returns true if task execution is not necessary. Executed after ValidateParameters
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SGen.GenerateCommandLineCommands">
            <summary>
            Returns a string with those switches and other information that can't go into a response file and
            must go directly onto the command line.
            Called after ValidateParameters and SkipTaskExecution
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SRDescriptionAttribute.#ctor(System.String)">
            <summary>
                Constructs a new sys description.
            </summary>
            <param name='description'>
                description text.
            </param>
        </member>
        <member name="P:Microsoft.Build.Tasks.SRDescriptionAttribute.Description">
            <summary>
                Retrieves the description text.
            </summary>
            <returns>
                description
            </returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.SR">
             <summary>
                AutoGenerated resource class. Usage:
            
                    string s = SR.GetString(SR.MyIdenfitier);
             </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.SR.MainAssemblyFallbackResourceManager">
            <summary>
            The containing assembly is set to lookup resources for the neutral language in satellite assemblies, not in the main assembly.
            System.Design resources are not meant to be translated, so the ResourceManager should not look for satellite assemblies.
            This ResourceManager forces resource lookup to be constrained to the current assembly and not look for satellites.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.TaskExtension">
            <summary>
            A small intermediate class for MSBuild tasks, see also TaskLoadInSeparateAppDomainExtension
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.TaskExtension.Log">
            <summary>
            Gets an instance of a TaskLoggingHelperExtension class containing task logging methods.
            </summary>
            <value>The logging helper object.</value>
        </member>
        <member name="T:Microsoft.Build.Tasks.Telemetry">
            <summary>
            Task that logs telemetry.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Telemetry.EventData">
            <summary>
            Gets or sets a semi-colon delimited list of equal-sign separated key/value pairs.  An example would be &quot;Property1=Value1;Property2=Value2&quot;.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Telemetry.EventName">
            <summary>
            Gets or sets the event name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Telemetry.Execute">
            <summary>
            Main task method
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ToolTaskExtension">
            <summary>
            A small intermediate class between ToolTask and classes using it in XMakeTasks, implementing functionality
            that we didn't want to expose in Utilities
            </summary>
            <remarks>
            This class has to be public because the tasks that derive from it are public.
            Ideally we would like this class to be internal, but C# does not allow a base class
            to be less accessible than its derived classes.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.ToolTaskExtension.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ToolTaskExtension.Log">
            <summary>
            Gets an instance of a TaskLoggingHelperExtension class containing task logging methods.
            </summary>
            <value>The logging helper object.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ToolTaskExtension.HasLoggedErrors">
            <summary>
            Whether this ToolTaskExtension has logged any errors
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ToolTaskExtension.Bag">
            <summary>
            Gets the collection of parameters used by the derived task class.
            </summary>
            <value>Parameter bag.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.ToolTaskExtension.UseNewLineSeparatorInResponseFile">
            <summary>
            When set to true, the response file will use new lines instead of spaces to separate arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ToolTaskExtension.GetBoolParameterWithDefault(System.String,System.Boolean)">
            <summary>
            Get a bool parameter and return a default if its not present
            in the hash table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ToolTaskExtension.GetIntParameterWithDefault(System.String,System.Int32)">
            <summary>
            Get an int parameter and return a default if its not present
            in the hash table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ToolTaskExtension.GenerateResponseFileCommands">
            <summary>
            Returns the command line switch used by the tool executable to specify the response file
            Will only be called if the task returned a non empty string from GetResponseFileCommands
            Called after ValidateParameters, SkipTaskExecution and GetResponseFileCommands
            </summary>
            <param name="responseFilePath">full path to the temporarily created response file</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ToolTaskExtension.GenerateCommandLineCommands">
            <summary>
            Returns a string with those switches and other information that can't go into a response file and
            must go directly onto the command line.
            Called after ValidateParameters and SkipTaskExecution
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ToolTaskExtension.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Fills the provided CommandLineBuilderExtension with those switches and other information that can go into a response file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ToolTaskExtension.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Fills the provided CommandLineBuilderExtension with those switches and other information that can't go into a response file and
            must go directly onto the command line.
            </summary>
            <returns>true, if successful</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Touch">
            <summary>
            This class defines the touch task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Touch.ForceTouch">
            <summary>
            Forces a touch even if the file to be touched is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Touch.AlwaysCreate">
            <summary>
            Creates the file if it doesn't exist.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Touch.Time">
            <summary>
            Specifies a specific time other than current.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Touch.Files">
            <summary>
            File(s) to touch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Touch.TouchedFiles">
            <summary>
            Output of this task - which files were touched.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Touch.ExecuteImpl(Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.FileCreate,Microsoft.Build.Tasks.GetAttributes,Microsoft.Build.Tasks.SetAttributes,Microsoft.Build.Tasks.SetLastAccessTime,Microsoft.Build.Tasks.SetLastWriteTime)">
            <summary>
            Implementation of the execute method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Touch.Execute">
            <summary>
            Run the task
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Touch.CreateFile(System.String,Microsoft.Build.Shared.FileCreate)">
            <summary>
            Helper method creates a file.
            </summary>
            <param name="file"></param>
            <param name="fileCreate"></param>
            <returns>"true" if the file was created.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Touch.TouchFile(System.String,System.DateTime,Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.FileCreate,Microsoft.Build.Tasks.GetAttributes,Microsoft.Build.Tasks.SetAttributes,Microsoft.Build.Tasks.SetLastAccessTime,Microsoft.Build.Tasks.SetLastWriteTime)">
            <summary>
            Helper method touches a file.
            </summary>
            <returns>"True" if the file was touched.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Unzip">
            <summary>
            Represents a task that can extract a .zip archive.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Unzip._cancellationToken">
            <summary>
            Stores a <see cref="T:System.Threading.CancellationTokenSource"/> used for cancellation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Unzip.DestinationFolder">
            <summary>
            Gets or sets a <see cref="T:Microsoft.Build.Framework.ITaskItem"/> with a destination folder path to unzip the files to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles">
            <summary>
            Gets or sets a value indicating whether read-only files should be overwritten.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles">
            <summary>
            Gets or sets a value indicating whether files should be skipped if the destination is unchanged.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Unzip.SourceFiles">
            <summary>
            Gets or sets an array of <see cref="T:Microsoft.Build.Framework.ITaskItem"/> objects containing the paths to .zip archive files to unzip.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Unzip.Cancel">
            <inheritdoc cref="M:Microsoft.Build.Framework.ICancelableTask.Cancel"/>
        </member>
        <member name="M:Microsoft.Build.Tasks.Unzip.Execute">
            <inheritdoc cref="M:Microsoft.Build.Utilities.Task.Execute"/>
        </member>
        <member name="M:Microsoft.Build.Tasks.Unzip.Extract(System.IO.Compression.ZipArchive,System.IO.DirectoryInfo)">
            <summary>
            Extracts all files to the specified directory.
            </summary>
            <param name="sourceArchive">The <see cref="T:System.IO.Compression.ZipArchive"/> containing the files to extract.</param>
            <param name="destinationDirectory">The <see cref="T:System.IO.DirectoryInfo"/> to extract files to.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Unzip.ShouldSkipEntry(System.IO.Compression.ZipArchiveEntry,System.IO.FileInfo)">
            <summary>
            Determines whether or not a file should be skipped when unzipping.
            </summary>
            <param name="zipArchiveEntry">The <see cref="T:System.IO.Compression.ZipArchiveEntry"/> object containing information about the file in the zip archive.</param>
            <param name="fileInfo">A <see cref="T:System.IO.FileInfo"/> object containing information about the destination file.</param>
            <returns><code>true</code> if the file should be skipped, otherwise <code>false</code>.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.VisualBasicParserUtilities">
            <summary>
            Specific-purpose utility functions for parsing VB.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.VisualBasicParserUtilities.GetFirstClassNameFullyQualified(System.IO.Stream)">
            <summary>
            Parse a VB file and get the first class name, fully qualified with namespace.
            </summary>
            <param name="binaryStream"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.VisualBasicParserUtilities.Extract(Microsoft.Build.Shared.LanguageParser.VisualBasicTokenizer)">
            <summary>
            Extract the class name.
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Warning">
            <summary>
            Task that simply emits a warning. Engine will add the project path because
            we do not specify a filename.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Warning.Text">
            <summary>
            Error message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Warning.Code">
            <summary>
            Warning code
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Warning.File">
            <summary>
            Relevant file if any.
            If none is provided, the file containing the Warning 
            task will be used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Warning.HelpKeyword">
            <summary>
            Warning help keyword
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Warning.Execute">
            <summary>
            Main task method
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.XslTransformation">
            <summary>
            A task that transforms a XML input with an XSLT or Compiled XSLT
            and outputs to screen or specified file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation._outputPaths">
            <summary>
            The output files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.XmlInputPaths">
            <summary>
            The XML input as file path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.XmlContent">
            <summary>
            The XML input as string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.XslInputPath">
            <summary>
            The XSLT input as file path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.XslContent">
            <summary>
            The XSLT input as string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath">
            <summary>
            The XSLT input as compiled dll.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.OutputPaths">
            <summary>
            The output file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.Parameters">
            <summary>
            The parameters to XSLT Input document.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings">
            <summary>
            Determines whether or not to use trusted settings. Default is false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.Execute">
            <summary>
            Executes the XslTransform task.
            </summary>
            <returns>true if transformation succeeds.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.ProcessXsltArguments(System.String)">
            <summary>
            Takes the raw XML and loads XsltArgumentList
            </summary>
            <param name="xsltParametersXml">The raw XML that holds each parameter as <Parameter Name="" Value="" Namespace="" /> </param>
            <returns>XsltArgumentList</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.XslTransformation.XmlInput">
            <summary>
            This class prepares XML input from XmlFile and Xml parameters
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XmlInput._data">
            <summary>
            This either contains the raw Xml or the path to Xml file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.XmlInput.#ctor(Microsoft.Build.Framework.ITaskItem[],System.String)">
            <summary>
            Constructor.
            Only one parameter should be non null or will throw ArgumentException.
            </summary>
            <param name="xmlFile">The path to XML file or null.</param>
            <param name="xml">The raw XML.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.XslTransformation.XmlInput.XmlModes">
            <summary>
            Possible accepted types of XML input.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XmlInput.XmlModes.XmlFile">
            <summary>
            If the mode is a XML file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XmlInput.XmlModes.Xml">
            <summary>
            If the mode is a raw XML.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.XmlInput.Count">
            <summary>
            Returns the count of Xml Inputs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XslTransformation.XmlInput.XmlMode">
            <summary>
            Returns the current mode of the XmlInput
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.XmlInput.CreateReader(System.Int32)">
            <summary>
            Creates correct reader based on the input type.
            </summary>
            <returns>The XmlReader object</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.XslTransformation.XsltInput">
            <summary>
            This class prepares XSLT input from XsltFile, Xslt and XsltCompiledDll parameters
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XsltInput._xslMode">
            <summary>
            What XSLT input type are we at.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XsltInput._data">
            <summary>
            Contains the raw XSLT 
            or the path to XSLT file
            or the path to compiled XSLT dll.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XsltInput._log">
            <summary>
            Tool for logging build messages, warnings, and errors
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.XsltInput.#ctor(Microsoft.Build.Framework.ITaskItem,System.String,Microsoft.Build.Framework.ITaskItem,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Constructer.
            Only one parameter should be non null or will throw ArgumentException.
            </summary>
            <param name="xsltFile">The path to XSLT file or null.</param>
            <param name="xslt">The raw to XSLT or null.</param>
            <param name="xsltCompiledDll">The path to compiled XSLT file or null.</param>
            <param name="logTool">Log helper.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.XslTransformation.XsltInput.XslModes">
            <summary>
            Possible accepted types of XSLT input.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XsltInput.XslModes.XsltFile">
            <summary>
            If the mode is a XSLT file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XsltInput.XslModes.Xslt">
            <summary>
            If the mode is a raw XSLT.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XslTransformation.XsltInput.XslModes.XsltCompiledDll">
            <summary>
            If the mode is a compiled Xslt dll.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.XsltInput.LoadXslt">
            <summary>
            Loads the XSLT to XslCompiledTransform. By default uses Default settings instead of trusted settings.
            </summary>
            <returns>A XslCompiledTransform object.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.XsltInput.LoadXslt(System.Boolean)">
            <summary>
            Loads the XSLT to XslCompiledTransform. By default uses Default settings instead of trusted settings.
            </summary>
            <param name="useTrustedSettings">Determines whether or not to use trusted settings.</param>
            <returns>A XslCompiledTransform object.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.XslTransformation.XsltInput.FindType(System.String,System.String)">
            <summary>
            Find the type from an assembly and loads it.
            </summary>
            <param name="assemblyPath">The path to assembly.</param>
            <param name="typeName">The type name.</param>
            <returns>Found type.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssignCulture">
            <summary>
            Class: AssignCulture
            
            This task takes a list of resource file names and sets an attribute that
            contains the culture name embedded in the file name:
            
                 MyResources.fr.resx     ==> Culture='fr'
            
            The task can also return a list of "Culture-neutral" file names, like:
            
                 MyGlyph.fr.bmp          ==> MyGlyph.bmp [Culture='fr']
            
            This is because embedded resources are referred to this way.
            
            There are plenty of corner cases with this task. See the unit test for
            more details.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignCulture.Files">
            <summary>
            The incoming list of files to assign a culture to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignCulture.AssignedFiles">
            <summary>
            This outgoing list of files is exactly the same as the incoming Files
            list except that an attribute name "Culture" will have been added if 
            the particular file name is in the form:
            
                 MyResource.&lt;any-valid-culture-id&gt;.resx
            
            The value of Culture will be "&lt;any-valid-culture-id&gt;".
            
            If the incoming item from Files already has a Culture attribute then
            that original attribute is used instead.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture">
            <summary>
            This is a subset of AssignedFiles that has all of the items that
            ended up have a Culture assigned to them. This includes items that
            already had a Culture in the incoming Files list as well as items
            that were assigned a Culture because they had a valid culture ID
            embedded in their file name.
            
            The following is always true:
            
                 AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture">
            <summary>
            This is a subset of AssignedFiles that has all of the items that
            ended up with no Culture assigned to them. 
            
            The following is always true:
            
                 AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles">
            <summary>
            This list has the same number of items as the Files list or the
            AssignedFiles list.
            
            Items in this list have the file name from Files or AssignedFiles
            but with the culture stripped if it was embedded in the file name.
            
            So for example, if the incoming item in Files was:
            
                 MyBitmap.fr.bmp
            
            then the corresponding file in CultureNeutralAssignedFiles will be:
            
                 MyBitmap.bmp
            
            The culture will only be stripped if it is a valid culture identifier.
            So for example,
            
                 MyCrazyFile.XX.txt
            
            will result in exactly the same file name:
            
                 MyCrazyFile.XX.txt
            
            because 'XX' is not a valid culture identifier.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssignCulture.Execute">
            <summary>
            Execute.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Culture">
            <summary>
            Utility functions for dealing with Culture information.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Culture.ItemCultureInfo">
            <summary>
            Culture information about an item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Culture.GetItemCultureInfo(System.String,System.String)">
            <summary>
            Given an item's filename, return information about the item including the culture and the culture-neutral filename.
            </summary>
            <remarks>
            We've decided to ignore explicit Culture attributes on items.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Tasks.CultureInfoCache">
            <summary>
            Provides read-only cached instances of <see cref="T:System.Globalization.CultureInfo"/>.
            <remarks>
            Original source:
            https://raw.githubusercontent.com/aspnet/Localization/dev/src/Microsoft.Framework.Globalization.CultureInfoCache/CultureInfoCache.cs
            </remarks>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CultureInfoCache.IsValidCultureString(System.String)">
            <summary>
            Determine if a culture string represents a valid <see cref="T:System.Globalization.CultureInfo"/> instance.
            </summary>
            <param name="name">The culture name.</param>
            <returns>True if the culture is determined to be valid.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.WriteCodeFragment">
            <summary>
            Generates a temporary code file with the specified generated code fragment.
            Does not delete the file.
            </summary>
            <comment>
            Currently only supports writing .NET attributes.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteCodeFragment.Language">
            <summary>
            Language of code to generate.
            Language name can be any language for which a CodeDom provider is
            available. For example, "C#", "VisualBasic".
            Emitted file will have the default extension for that language.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes">
            <summary>
            Description of attributes to write.
            Item include is the full type name of the attribute.
            For example, "System.AssemblyVersionAttribute".
            Each piece of metadata is the name-value pair of a parameter, which must be of type System.String.
            Some attributes only allow positional constructor arguments, or the user may just prefer them.
            To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
            If a parameter index is skipped, it's an error.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory">
            <summary>
            Destination folder for the generated code.
            Typically the intermediate folder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WriteCodeFragment.OutputFile">
            <summary>
            The path to the file that was generated.
            If this is set, and a file name, the destination folder will be prepended.
            If this is set, and is rooted, the destination folder will be ignored.
            If this is not set, the destination folder will be used, an arbitrary file name will be used, and 
            the default extension for the language selected.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.WriteCodeFragment.Execute">
            <summary>
            Main entry point.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.WriteCodeFragment.GenerateCode(System.String@)">
            <summary>
            Generates the code into a string.
            If it fails, logs an error and returns null.
            If no meaningful code is generated, returns empty string.
            Returns the default language extension as an out parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.XmlPeek">
            <summary>
            A task that returns values as specified by XPath Query
            from an XML file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPeek._query">
            <summary>
            The XPath Query.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPeek.XmlInputPath">
            <summary>
            The XML input as a file path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPeek.XmlContent">
            <summary>
            The XML input as a string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPeek.Query">
            <summary>
            The XPath Query.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPeek.Result">
            <summary>
            The results returned by this task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPeek.Namespaces">
            <summary>
            The namespaces for XPath query's prefixes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPeek.ProhibitDtd">
            <summary>
            Set to true to prohibit loading XML with embedded DTD and produce error MSB3733
            if DTD is present. This was a pre-v15 behavior. By default, a DTD clause if any is ignored.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XmlPeek.Execute">
            <summary>
            Executes the XMLPeek task.
            </summary>
            <returns>true if transformation succeeds.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.XmlPeek.LoadNamespaces(System.Xml.XmlNamespaceManager@,System.String)">
            <summary>
            Loads the namespaces specified at Namespaces parameter to XmlNSManager.
            </summary>
            <param name="namespaceManager">The namespace manager to load namespaces to.</param>
            <param name="namepaces">The namespaces as XML snippet.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.XmlPeek.XmlInput">
            <summary>
            This class prepares XML input from XMLInputPath and XMLContent parameters
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPeek.XmlInput._data">
            <summary>
            This either contains the raw Xml or the path to Xml file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPeek.XmlInput._fs">
            <summary>
            Filestream used to read XML.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XmlPeek.XmlInput.#ctor(Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            Constructor.
            Only one parameter should be non null or will throw ArgumentException.
            </summary>
            <param name="xmlInputPath">The path to XML file or null.</param>
            <param name="xmlContent">The raw XML.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.XmlPeek.XmlInput.XmlModes">
            <summary>
            Possible accepted types of XML input.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPeek.XmlInput.XmlModes.XmlFile">
            <summary>
            If the mode is a XML file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPeek.XmlInput.XmlModes.Xml">
            <summary>
            If the mode is a raw XML.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPeek.XmlInput.XmlMode">
            <summary>
            Returns the current mode of the XmlInput
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XmlPeek.XmlInput.CreateReader(System.Boolean)">
            <summary>
            Creates correct reader based on the input type.
            </summary>
            <returns>The XmlReader object</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.XmlPeek.XmlInput.CloseReader">
            <summary>
            Closes the reader.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.XmlPoke">
            <summary>
            A task that sets values as specified by XPath Query
            into a XML file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPoke._xmlInputPath">
            <summary>
            The XML input as file paths.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPoke._query">
            <summary>
            The XPath Query.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XmlPoke._value">
            <summary>
            The property that this task will set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPoke.XmlInputPath">
            <summary>
            The XML input as file path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPoke.Query">
            <summary>
            The XPath Query.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPoke.Value">
            <summary>
            The value to be inserted into the specified location.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XmlPoke.Namespaces">
            <summary>
            The namespaces for XPath query's prefixes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XmlPoke.Execute">
            <summary>
            Executes the XMLPoke task.
            </summary>
            <returns>true if transformation succeeds.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.XmlPoke.LoadNamespaces(System.Xml.XmlNamespaceManager@,System.String)">
            <summary>
            Loads the namespaces specified at Namespaces parameter to XmlNSManager.
            </summary>
            <param name="namespaceManager">The namespace manager to load namespaces to.</param>
            <param name="namepaces">The namespaces as XML snippet.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.CodeTaskFactory">
            <summary>
            A task factory which can take code dom supported languages and create a task out of it
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory.s_knownReferenceAssemblies">
            <summary>
            This dictionary keeps track of custom references to compiled assemblies.  The in-memory assembly is loaded from a byte
            stream and as such its dependencies cannot be found unless they are in the MSBuild.exe directory or the GAC.  They
            cannot be found even if they are already loaded in the AppDomain.  This dictionary knows the FullName of the assembly
            and a reference to the assembly itself.  In the <see cref="M:Microsoft.Build.Tasks.CodeTaskFactory.CurrentDomainOnAssemblyResolve(System.Object,System.ResolveEventArgs)"/> handler, the dictionary 
            is used to return the loaded assemblies as a way to allow custom references that are not in the normal assembly Load
            context.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CurrentDomainOnAssemblyResolve(System.Object,System.ResolveEventArgs)">
            <summary>
            Handles the <see cref="E:System.AppDomain.AssemblyResolve"/> event to return assemblies loaded from custom references.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory.s_defaultReferencedFrameworkAssemblyNames">
            <summary>
            Default assemblies names to reference during inline code compilation - from the .NET Framework
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._defaultUsingNamespaces">
            <summary>
             Default using's for the code
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory.s_compiledTaskCache">
            <summary>
            A collection of task assemblies which have been instantiated by any CodeTaskFactory.  Used to prevent us from creating
            duplicate assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory.s_defaultReferencedAssemblies">
            <summary>
            The default assemblies to reference when compiling inline code. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._referencedAssemblies">
            <summary>
            Merged set of assembly reference paths (default + specified)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._usingNamespaces">
            <summary>
            Merged set of namespaces (default + specified) 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._type">
            <summary>
            Type of code fragment, ie   Fragment, Class, Method
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._typeIsFragment">
            <summary>
            Is the type a fragment or not
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._typeIsMethod">
            <summary>
            Is the type a method or not
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._language">
            <summary>
            By default the language supported is C#, but anything that supports code dom will work
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._sourceCode">
            <summary>
            The source that will be compiled
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._nameOfTask">
            <summary>
            The name of the task for which this is the factory
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._sourcePath">
            <summary>
            Path to source that is outside the project file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._taskNode">
            <summary>
            The using task node from the project file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._compiledAssembly">
            <summary>
            The inline source compiled into an in memory assembly
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._log">
            <summary>
            Helper to assist in logging messages
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory._taskParameterTypeInfo">
            <summary>
            Task parameter type information
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CodeTaskFactory.FactoryName">
            <summary>
            MSBuild engine uses this for logging where the task comes from
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CodeTaskFactory.TaskType">
            <summary>
            Gets the type of the generated task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.CodeTaskFactory.DefaultReferencedAssemblies">
            <summary>
            The assemblies that the codetaskfactory should reference by default. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.GetTaskParameters">
            <summary>
            Get the type information for all task parameters
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.Initialize(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Initialze the task factory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Create a taskfactory instance which contains the data that needs to be refreshed between task invocations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask)">
            <summary>
            Cleans up any context or state that may have been built up for a given task.
            </summary>
            <param name="task">The task to clean up.</param>
            <remarks>
            For many factories, this method is a no-op.  But some factories may have built up
            an AppDomain as part of an individual task instance, and this is their opportunity
            to shutdown the AppDomain.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CreateProperty(System.CodeDom.CodeTypeDeclaration,System.String,System.Type,System.Object)">
            <summary>
            Create a property (with the corresponding private field) from the given type information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CreateExecuteMethodFromFragment(System.CodeDom.CodeTypeDeclaration,System.String)">
            <summary>
            Create the Execute() method for the task from the fragment of code from the <Task /> element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CreateTaskBody(System.CodeDom.CodeTypeDeclaration,System.String)">
            <summary>
            Create the body of the task's code by simply using the taskCode as a snippet for the CodeDom
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CreateProperty(System.CodeDom.CodeTypeDeclaration,Microsoft.Build.Framework.TaskPropertyInfo,System.Object)">
            <summary>
            Create a property (with the corresponding private field) from the given type information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.ExtractReferencedAssemblies">
            <summary>
            Extract the <Reference /> elements from the <UsingTask />
            </summary>
            <returns>string[] of reference paths</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.ExtractUsingNamespaces">
            <summary>
            Extract the <Using /> elements from the <UsingTask />
            </summary>
            <returns>string[] of using's</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.ExtractTaskContent(System.String)">
            <summary>
            Extract the <Task /> node from the UsingTask node
            </summary>
            <param name="taskElementContents">textual content of the <Task /> node</param>
            <returns>XmlNode <Task /></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.ValidateTaskNode">
            <summary>
            Make sure the task node only contains Code, Reference, Usings
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.HasInvalidChildNodes(System.Xml.XmlNode,System.Xml.XmlNodeType[])">
            <summary>
            If a parent node has a child node and it is not supposed to, log an error indicating it has an invalid element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.AddReferenceAssemblyToReferenceList(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Add a reference assembly to the list of references passed to the compiler. We will try and load the assembly to make sure it is found 
            before sending it to the compiler. The reason we load here is that we will be using it in this appdomin anyways as soon as we are going to compile, which should be right away.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CompileInMemoryAssembly">
            <summary>
            Compile the assembly in memory and get a reference to the assembly itself.
            If compilation fails, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CombineReferencedAssemblies(System.Collections.Generic.List{System.String})">
            <summary>
            Combine our default referenced assemblies with those explicitly specified
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CombineUsingNamespaces">
            <summary>
            Combine our default imported namespaces with those explicitly specified
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CreateTaskProperties(System.CodeDom.CodeTypeDeclaration)">
            <summary>
            Create the task properties
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.CreateTaskClass">
            <summary>
            Create the task class
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification">
            <summary>
            Class used as a key for the compiled assembly cache
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification._referenceAssemblies">
            <summary>
            The set of assemblies referenced by this task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification._fullCode">
            <summary>
            The complete source code for the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification.#ctor(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification.GetHashCode">
            <summary>
            Override of GetHashCode
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification.Equals(System.Object)">
            <summary>
            Override of Equals
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification.System#IEquatable{Microsoft#Build#Tasks#CodeTaskFactory#FullTaskSpecification}#Equals(Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification)">
            <summary>
            Implementation of Equals.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification.System#IComparable{Microsoft#Build#Tasks#CodeTaskFactory#FullTaskSpecification}#CompareTo(Microsoft.Build.Tasks.CodeTaskFactory.FullTaskSpecification)">
            <summary>
            Implementation of CompareTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.XamlTaskFactory">
            <summary>
            The task factory provider for XAML tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XamlTaskFactory.XamlTaskNamespace">
            <summary>
            The namespace we put the task in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XamlTaskFactory._taskAssembly">
            <summary>
            The compiled task assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.XamlTaskFactory._taskType">
            <summary>
            The task type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XamlTaskFactory.TaskName">
            <summary>
            The name of the task pulled from the XAML.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XamlTaskFactory.TaskNamespace">
            <summary>
            The namespace of the task pulled from the XAML.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XamlTaskFactory.TaskElementContents">
            <summary>
            The contents of the UsingTask body.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XamlTaskFactory.FactoryName">
            <summary>
            The name of this factory. This factory name will be used in error messages. For example
            Task "Mytask" failed to load from "FactoryName".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.XamlTaskFactory.TaskType">
            <summary>
            The task type object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XamlTaskFactory.Initialize(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the factory can be asked
             whether or not task names can be created by the factory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.XamlTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Create an instance of the task to be used.
            </summary>
            <param name="taskFactoryLoggingHost">The task factory logging host will log messages in the context of the task.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.XamlTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask)">
            <summary>
            Cleans up any context or state that may have been built up for a given task.
            </summary>
            <param name="task">The task to clean up.</param>
            <remarks>
            For many factories, this method is a no-op.  But some factories may have built up
            an AppDomain as part of an individual task instance, and this is their opportunity
            to shutdown the AppDomain.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.XamlTaskFactory.GetTaskParameters">
            <summary>
            Get a list of parameters for the task.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.StateFileBase">
            <remarks>
            Base class for task state files.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.StateFileBase.SerializeCache(System.String,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Writes the contents of this object out to the specified file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.StateFileBase.DeserializeCache(System.String,Microsoft.Build.Utilities.TaskLoggingHelper,System.Type)">
            <summary>
            Reads the specified file from disk into a StateFileBase derived object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.StateFileBase.DeleteFile(System.String,Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            Deletes the state file from disk
            </summary>
            <param name="stateFile"></param>
            <param name="log"></param>
        </member>
        <member name="T:Microsoft.Build.Tasks.Dependencies">
            <summary>
            Represents a cache of inputs to a compilation-style task.
            </summary>
            <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>
        </member>
        <member name="F:Microsoft.Build.Tasks.Dependencies.dependencies">
            <summary>
            Hashtable of other dependency files.
            Key is filename and value is DependencyFile.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Dependencies.GetDependencyFile(System.String)">
            <summary>
            Look up a dependency file. Return null if its not there.
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Dependencies.AddDependencyFile(System.String,Microsoft.Build.Tasks.DependencyFile)">
            <summary>
            Add a new dependency file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Dependencies.RemoveDependencyFile(System.String)">
            <summary>
            Remove new dependency file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Dependencies.Clear">
            <summary>
            Remove all entries from the dependency table.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.SystemState">
            <summary>
            Class is used to cache system state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.upToDateLocalFileStateCache">
            <summary>
            Cache at the SystemState instance level. Has the same contents as <see cref="F:Microsoft.Build.Tasks.SystemState.instanceLocalFileStateCache"/>.
            It acts as a flag to enforce that an entry has been checked for staleness only once.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.instanceLocalFileStateCache">
            <summary>
            Cache at the SystemState instance level. It is serialized and reused between instances.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.instanceLocalLastModifiedCache">
            <summary>
            LastModified information is purely instance-local. It doesn't make sense to
            cache this for long periods of time since there's no way (without actually 
            calling File.GetLastWriteTimeUtc) to tell whether the cache is out-of-date.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.instanceLocalDirectoryExists">
            <summary>
            DirectoryExists information is purely instance-local. It doesn't make sense to
            cache this for long periods of time since there's no way (without actually 
            calling Directory.Exists) to tell whether the cache is out-of-date.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.instanceLocalDirectories">
            <summary>
            GetDirectories information is also purely instance-local. This information
            is only considered good for the lifetime of the task (or whatever) that owns 
            this instance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.s_processWideFileStateCache">
            <summary>
            Additional level of caching kept at the process level.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.redistList">
            <summary>
            XML tables of installed assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.isDirty">
            <summary>
            True if the contents have changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.getLastWriteTime">
            <summary>
            Delegate used internally.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.getAssemblyName">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.getAssemblyMetadata">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.fileExists">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.directoryExists">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.getDirectories">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.getAssemblyRuntimeVersion">
            <summary>
            Cached delegate
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.SystemState.FileState">
            <summary>
            Class that holds the current file state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.FileState.lastModified">
            <summary>
            The last modified time for this file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.FileState.assemblyName">
            <summary>
            The fusion name of this file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.FileState.dependencies">
            <summary>
            The assemblies that this file depends on.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.FileState.scatterFiles">
            <summary>
            The scatter files associated with this assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.FileState.frameworkName">
            <summary>
            FrameworkName the file was built against
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SystemState.FileState.runtimeVersion">
            <summary>
            The CLR runtime version for the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.FileState.#ctor(System.DateTime)">
            <summary>
            Default construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.FileState.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializing constuctor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.FileState.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize the contents of the class.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.SystemState.FileState.LastModified">
            <summary>
            Gets the last modified date.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.SystemState.FileState.Assembly">
            <summary>
            Get or set the assemblyName.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.SystemState.FileState.RuntimeVersion">
            <summary>
            Get or set the runtimeVersion
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.SystemState.FileState.FrameworkNameAttribute">
            <summary>
            Get or set the framework name the file was built against
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.#ctor">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize the contents of the class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.SetInstalledAssemblyInformation(Microsoft.Build.Tasks.AssemblyTableInfo[])">
            <summary>
            Set the target framework paths.
            This is used to optimize IO in the case of files requested from one 
            of the FX folders.
            </summary>
            <param name="providedFrameworkPaths"></param>
            <param name="installedAssemblyTables"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize the contents of the class.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.SystemState.IsDirty">
            <summary>
            Flag that indicates
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.SetGetLastWriteTime(Microsoft.Build.Tasks.GetLastWriteTime)">
            <summary>
            Set the GetLastWriteTime delegate.
            </summary>
            <param name="getLastWriteTimeValue">Delegate used to get the last write time.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.CacheDelegate(Microsoft.Build.Tasks.GetAssemblyName)">
            <summary>
            Cache the results of a GetAssemblyName delegate. 
            </summary>
            <param name="getAssemblyNameValue">The delegate.</param>
            <returns>Cached version of the delegate.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.CacheDelegate(Microsoft.Build.Tasks.GetAssemblyMetadata)">
            <summary>
            Cache the results of a GetAssemblyMetadata delegate. 
            </summary>
            <param name="getAssemblyMetadataValue">The delegate.</param>
            <returns>Cached version of the delegate.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.CacheDelegate(Microsoft.Build.Shared.FileExists)">
            <summary>
            Cache the results of a FileExists delegate. 
            </summary>
            <param name="fileExistsValue">The delegate.</param>
            <returns>Cached version of the delegate.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.CacheDelegate(Microsoft.Build.Tasks.GetDirectories)">
            <summary>
            Cache the results of a GetDirectories delegate. 
            </summary>
            <param name="getDirectoriesValue">The delegate.</param>
            <returns>Cached version of the delegate.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.CacheDelegate(Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)">
            <summary>
            Cache the results of a GetAssemblyRuntimeVersion delegate. 
            </summary>
            <param name="getAssemblyRuntimeVersion">The delegate.</param>
            <returns>Cached version of the delegate.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.GetAssemblyName(System.String)">
            <summary>
            Cached implementation of GetAssemblyName.
            </summary>
            <param name="path">The path to the file</param>
            <returns>The assembly name.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.GetRuntimeVersion(System.String)">
            <summary>
            Cached implementation. Given a path, crack it open and retrieve runtimeversion for the assembly.
            </summary>
            <param name="path">Path to the assembly.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.GetAssemblyMetadata(System.String,System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Build.Tasks.AssemblyDependency.AssemblyMetadata},Microsoft.Build.Shared.AssemblyNameExtension[]@,System.String[]@,System.Runtime.Versioning.FrameworkName@)">
            <summary>
            Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent 
            assemblies and  the list of scatter files.
            </summary>
            <param name="path">Path to the assembly.</param>
            <param name="assemblyMetadataCache">Cache for pre-extracted assembly metadata.</param>
            <param name="dependencies">Receives the list of dependencies.</param>
            <param name="scatterFiles">Receives the list of associated scatter files.</param>
            <param name="frameworkName"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.GetDirectories(System.String,System.String)">
            <summary>
            Cached implementation of GetDirectories.
            </summary>
            <param name="path"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.FileExists(System.String)">
            <summary>
            Cached implementation of FileExists.
            </summary>
            <param name="path">Path to file.</param>
            <returns>True if the file exists.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SystemState.DirectoryExists(System.String)">
            <summary>
            Cached implementation of DirectoryExists.
            </summary>
            <param name="path">Path to file.</param>
            <returns>True if the directory exists.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.DependencyFile">
            <remarks>
            Represents a single input to a compilation-style task.
            Keeps track of timestamp for later comparison.
            
            On-disk serialization format, don't change field names or types or use readonly.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.DependencyFile.FileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DependencyFile.LastModified">
            <summary>
            The last-modified timestamp when the class was instantiated.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.DependencyFile.Exists">
            <summary>
            Returns true if the file existed when this class was instantiated.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.DependencyFile.#ctor(System.String)">
            <summary>
            Construct.
            </summary>
            <param name="filename">The file name.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.DependencyFile.HasFileChanged">
            <summary>
            Checks whether the file has changed since the last time a timestamp was recorded.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.ZipDirectory.DestinationFile">
            <summary>
            Gets or sets a <see cref="T:Microsoft.Build.Framework.ITaskItem"/> containing the full path to the destination file to create.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ZipDirectory.Overwrite">
            <summary>
            Gets or sets a value indicating if the destination file should be overwritten.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ZipDirectory.SourceDirectory">
            <summary>
            Gets or sets a <see cref="T:Microsoft.Build.Framework.ITaskItem"/> containing the full path to the source directory to create a zip archive from.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AL">
            <summary>
            This class defines the "AL" XMake task, which enables using al.exe to link
            modules and resource files into assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AL.ToolName">
            <summary>
            Return the name of the tool to execute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AL.GenerateFullPathToTool">
            <summary>
            Return the path of the tool to execute
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AL.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Fills the provided CommandLineBuilderExtension with those switches and other information that can go into a response file.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension">
            <summary>
            This class provides the same functionality as the Task class, but derives from MarshalByRefObject so that it can be
            instantiated in its own app domain.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension.Log">
            <summary>
            Gets an instance of a TaskLoggingHelperExtension class containing task logging methods.
            </summary>
            <value>The logging helper object.</value>
        </member>
        <member name="T:Microsoft.Build.Tasks.AspNetCompiler">
            <summary>
            The AspNetCompiler task, which is a wrapper around aspnet_compiler.exe
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.AllowPartiallyTrustedCallers">
            <summary>
            If specified, the strong-name assembly will allow partially
            trusted callers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.DelaySign">
            <summary>
            If specified, the assemblly is not fully signed when created. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.FixedNames">
            <summary>
            If specified, the compiled assemblies will be given fixed names.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.KeyContainer">
            <summary>
            Specifies a strong name key container.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.KeyFile">
            <summary>
            The physical path to the strong name key file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.MetabasePath">
            <summary>
            The full IIS metabase path of the application. This switch 
            cannot be combined with the virtualPath or PhysicalDir option.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.PhysicalPath">
            <summary>
            The physical path of the application to be compiled. If physicalDir
            is missing, the IIS metabase is used to locate the application.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.TargetPath">
            <summary>
            The physical path to which the application is compiled. If not
            specified, the application is precompiled in-place. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.VirtualPath">
            <summary>
            The virtual path of the application to be compiled. If PhysicalDir is
            used to locate the application is specified. Otherwise, the IIS metabase
            is used, and the application is assumed to be in the default site (under
            "/LM/W3SVC/1/Root").
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.Updateable">
            <summary>
            If Updateable is true, then the web is compile with -u flag so that it
            can be updated after compilation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.Force">
            <summary>
            If Force is true, then the web is compile with -f flag overwriting
            files in the target location
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.Debug">
            <summary>
            If Debug is true, then the debug information will be emitted during
            compilation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.Clean">
            <summary>
            If Clean is true, then the application will be built clean. Previously
            compiled components will be re-compiled.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.TargetFrameworkMoniker">
            <summary>
            The TargetFrameworkMoniker indicating which .NET Framework version of 
            aspnet_compiler.exe should be used.  Only accepts .NET Framework monikers. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.ToolName">
            <summary>
            The name of the tool to execute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.ProjectName">
            <summary>
            Small helper property to get the "project name"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AspNetCompiler.TargetName">
            <summary>
            Small helper property for determining the "name of the target" that's currently being built
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AspNetCompiler.Execute">
            <summary>
            Override the Execute method to be able to send ExternalProjectStarted/Finished events.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AspNetCompiler.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Generates command line arguments for aspnet_compiler.exe
            </summary>
            <param name="commandLine">command line builder class to add arguments to</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AspNetCompiler.GenerateFullPathToTool">
            <summary>
            Determine the path to aspnet_compiler.exe
            </summary>
            <returns>path to aspnet_compiler.exe, null if not found</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AspNetCompiler.ValidateParameters">
            <summary>
            Validate the task arguments, log any warnings/errors
            </summary>
            <returns>true if arguments are corrent enough to continue processing, false otherwise</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GacResolver">
            <summary>
            Resolve searchpath type {GAC}
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GacResolver._getAssemblyPathInGac">
            <summary>
            Delegate to get the assembly path in the GAC
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GacResolver.#ctor(System.Reflection.ProcessorArchitecture,System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,Microsoft.Build.Tasks.GetAssemblyPathInGac)">
            <summary>
            Construct.
            </summary>
            <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targeted.</param>
            <param name="searchPathElement">The search path element.</param>
            <param name="getAssemblyName">Delegate to get the assembly name object.</param>
            <param name="fileExists">Delegate to check if the file exists.</param>
            <param name="getRuntimeVersion">Delegate to get the runtime version.</param>
            <param name="targetedRuntimeVesion">The targeted runtime version.</param>
            <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Tasks.GacResolver.Resolve(Microsoft.Build.Shared.AssemblyNameExtension,System.String,System.String,System.Boolean,System.Boolean,System.String[],System.String,System.String,System.Collections.Generic.List{Microsoft.Build.Tasks.ResolutionSearchLocation},System.String@,System.Boolean@)" -->
        <member name="T:Microsoft.Build.Tasks.GlobalAssemblyCache">
            <summary>
            Methods for dealing with the GAC.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GlobalAssemblyCache.pathFromFusionName">
            <summary>
            Default delegate to get the path based on a fusion name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GlobalAssemblyCache.gacEnumerator">
            <summary>
            Default delegate to get the gac enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.GetLocationImpl(Microsoft.Build.Shared.AssemblyNameExtension,System.String,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetPathFromFusionName,Microsoft.Build.Tasks.GetGacEnumerator,System.Boolean)">
            <summary>
            Given a strong name, find its path in the GAC.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
            <returns>The path to the assembly. Empty if none exists.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.GetGacNativeEnumerator(System.String)">
            <summary>
            Given a strong name generate the gac enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.GenerateListOfAssembliesByRuntime(System.String,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetPathFromFusionName,Microsoft.Build.Tasks.GetGacEnumerator,System.Boolean)">
            <summary>
            Enumerate the gac and generate a list of assemblies which match the strongname by runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.RetrievePathFromFusionName(System.String)">
            <summary>
            Given a fusion name get the path to the assembly on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.CheckForFullFusionNameInGac(Microsoft.Build.Shared.AssemblyNameExtension,System.String,Microsoft.Build.Tasks.GetPathFromFusionName)">
            <summary>
            If we know we have a full fusion name we can skip enumerating the gac and just query for the path. This will 
            not check the runtime version of the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.GetLocation(Microsoft.Build.Shared.AssemblyNameExtension,System.Reflection.ProcessorArchitecture,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,System.Boolean,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetPathFromFusionName,Microsoft.Build.Tasks.GetGacEnumerator,System.Boolean)">
            <summary>
            Given a strong name, find its path in the GAC.
            </summary>
            <param name="strongName">The strong name.</param>
            <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
            <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
            <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
            <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
            <returns>The path to the assembly. Empty if none exists.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.GetLocation(Microsoft.Build.Framework.IBuildEngine4,Microsoft.Build.Shared.AssemblyNameExtension,System.Reflection.ProcessorArchitecture,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,System.Version,System.Boolean,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetPathFromFusionName,Microsoft.Build.Tasks.GetGacEnumerator,System.Boolean)">
            <summary>
            Given a strong name, find its path in the GAC.
            </summary>
            <param name="strongName">The strong name.</param>
            <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
            <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
            <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
            <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
            <returns>The path to the assembly. Empty if none exists.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.GlobalAssemblyCache.GetGacPath">
            <summary>
            Return the root path of the GAC
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AssemblyRegistrationCache">
            <remarks>
            This class is a caching mechanism for the Register/UnregisterAssembly task to keep track of registered assemblies to clean up
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyRegistrationCache._assemblies">
            <summary>
            The list of registered assembly files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AssemblyRegistrationCache._typeLibraries">
            <summary>
            The list of registered type library files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AssemblyRegistrationCache.Count">
            <summary>
            The number of entries in the state file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyRegistrationCache.AddEntry(System.String,System.String)">
            <summary>
            Sets the entry with the specified index
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AssemblyRegistrationCache.GetEntry(System.Int32,System.String@,System.String@)">
            <summary>
            Gets the entry with the specified index
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxReference.#ctor(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,Microsoft.Build.Tasks.IComReferenceResolver,Microsoft.Build.Tasks.ComReferenceInfo,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.String,Microsoft.Build.Framework.IBuildEngine,System.String[])">
            <summary>
            internal constructor
            </summary>
            <param name="taskLoggingHelper">task logger instance used for logging</param>
            <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
            <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
            <param name="itemName">reference name (for better logging experience)</param>
            <param name="outputDirectory">directory we should write the wrapper to</param>
            <param name="delaySign">delay sign wrappers?</param>
            <param name="keyFile">file containing public/private keys</param>
            <param name="keyContainer">container name for public/private keys</param>
            <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe</param>
            <param name="sdkToolsPath">Path to the SDK tools directory where aximp.exe can be found</param>
            <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxReference.GetWrapperFileNameInternal(System.String)">
            <summary>
            Constructs the wrapper file name from a type library name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxReference.GenerateWrapper(Microsoft.Build.Tasks.ComReferenceWrapperInfo@)">
            <summary>
            Generates a wrapper for this reference.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AxTlbBaseReference">
            <summary>
            Common abstract base for aximp and tlbimp COM reference wrapper classes. 
            They share the resolution method and only differ in constructing the wrapper file name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.#ctor(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,Microsoft.Build.Tasks.IComReferenceResolver,Microsoft.Build.Tasks.ComReferenceInfo,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.Boolean,System.String,Microsoft.Build.Framework.IBuildEngine,System.String[])">
            <summary>
            internal constructor
            </summary>
            <param name="taskLoggingHelper">task logger instance used for logging</param>
            <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
            <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
            <param name="itemName">reference name (for better logging experience)</param>
            <param name="outputDirectory">directory we should write the wrapper to</param>
            <param name="delaySign">delay sign wrappers?</param>
            <param name="keyFile">file containing public/private keys</param>
            <param name="keyContainer">container name for public/private keys</param>
            <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe or tlbimp.exe</param>
            <param name="toolPath">Path to the SDK tools directory where aximp.exe or tlbimp.exe can be found</param>
            <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.OutputDirectory">
            <summary>
            directory we should write the wrapper to
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.ResolverCallback">
            <summary>
            callback interface for resolving dependent COM refs/NET assemblies
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.KeyContainer">
            <summary>
            container name for public/private keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.KeyFile">
            <summary>
            file containing public/private keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.DelaySign">
            <summary>
            True if generated wrappers should be delay signed
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.ExecuteAsTool">
            <summary>
            Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe and 
            aximp.exe from the appropriate target framework will be run out-of-proc to generate
            the necessary wrapper assemblies.  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.BuildEngine">
            <summary>
            The BuildEngine of the ResolveComReference instance that created this instance
            of the class:  necessary for passing to the AxImp or TlbImp task that is spawned
            when ExecuteAsTool is set to true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.EnvironmentVariables">
            <summary>
            Environment variables to pass to the tool.
            </summary>        
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.ToolPath">
            <summary>
            If ExecuteAsTool is true, this must be set to the SDK 
            tools path for the framework version being targeted. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseReference.IncludeTypeLibVersionInName">
            <summary>
            When true, we include the typelib version number in the name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.FindExistingWrapper(Microsoft.Build.Tasks.ComReferenceWrapperInfo@,System.DateTime)">
            <summary>
            Checks if there's a preexisting wrapper for this reference. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.IsWrapperUpToDate(Microsoft.Build.Tasks.ComReferenceWrapperInfo,System.DateTime)">
            <summary>
            Checks if the existing wrapper is up to date.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.GetWrapperPath">
            <summary>
            Constructs the wrapper file path. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.GetWrapperFileName">
            <summary>
            Helper method for constructing wrapper file name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.GetWrapperFileNameInternal(System.String)">
            <summary>
            Constructs the wrapper file name from a type library name. Specialized wrappers must override it if 
            they want to use the Resolve method from this class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.GetWrapperFileName(System.String,System.String,System.Boolean,System.Int16,System.Int16)">
            <summary>
            Static version of GetWrapperFileName for use when calling from the outside.
            This version need only be used if the interop DLL needs to include the typelib version in the name
            Default implementation
            </summary>
            <param name="interopDllHeader">XXX, when the interop DLL is of the form XXX.typeLibName.[Y.Z.]dll</param>
            <param name="typeLibName">The typelib to generate the wrapper name for</param>
            <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
            <param name="majorVerNum">Major version number to append to the interop DLL's name</param>
            <param name="minorVerNum">Minor version number to append to the interop DLL's name</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.GetAndValidateStrongNameKey(System.Reflection.StrongNameKeyPair@,System.Byte[]@)">
            <summary>
            Given our KeyFile, KeyContainer, and DelaySign parameters, generate the public / private 
            key pair and validate that it exists to the extent needed.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseReference.SigningRequirementsMatchExistingWrapper(Microsoft.Build.Tasks.ComReferenceWrapperInfo)">
            <summary>
            Compare the strong name signing state of the existing wrapper to the signing 
            state we are requesting in this run of the task. Return true if they match (e.g.
            from a signing perspective, the wrapper is up-to-date) or false otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.AxTlbBaseTask">
            <summary>
            ToolTask that contains shared functionality between the AxImp and TlbImp tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.AxTlbBaseTask._delaySigningAndKeyFileOnlyContainsPublicKey">
            <summary>
            True if the keyfile only contains the public key data, and thus 
            we should pass the file using the /publickey: parameter instead of
            /keyfile. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseTask.DelaySign">
            <summary>
            Force strong name delay signing.  Used with KeyFile or KeyContainer.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseTask.KeyContainer">
            <summary>
            Key container containing strong name key pair.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseTask.KeyFile">
            <summary>
            File containing strong name key pair.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseTask.SdkToolsPath">
            <summary>
            Path to the SDK directory where AxImp.exe and TlbImp.exe can be found
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.AxTlbBaseTask.ToolName">
            <summary>
            Returns the name of the tool to execute.  AxTlbBaseTask is not
            executable, so return null for the ToolName -- And make sure that 
            Execute() logs an error!
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseTask.Execute">
            <summary>
            Invokes the ToolTask with the given parameters
            </summary>
            <returns>True if the task succeeded, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseTask.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Adds commands for the tool being executed, that cannot be put in a response file.  
            </summary>
            <param name="commandLine">The CommandLineBuilderExtension to add the commands to</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseTask.GenerateFullPathToTool">
            <summary>
            Generates the full path to the tool being executed by this ToolTask
            </summary>
            <returns>A string containing the full path of this tool, or null if the tool was not found</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseTask.ValidateParameters">
            <summary>
            Validates the parameters passed to the task
            </summary>
            <returns>True if parameters are valid</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseTask.AddStrongNameOptions(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Adds options involving strong name signing -- syntax is the same between 
            AxImp and TlbImp
            </summary>
            <param name="commandLine">The command line to add options to</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.AxTlbBaseTask.ValidateStrongNameParameters">
            <summary>
            Validates the parameters passed to the task that involve strong name signing --
            DelaySign, KeyContainer, and KeyFile
            </summary>
            <returns>true if the parameters are valid, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder">
            <summary>
            This class is the top-level object for the bootstrapper system.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.#ctor">
            <summary>
            Creates a new BootstrapperBuilder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.#ctor(System.String)">
            <summary>
            Creates a new BootstrapperBuilder.
            </summary>
            <param name="visualStudioVersion">The version of Visual Studio that is used to build this bootstrapper.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path">
            <summary>
            Specifies the location of the required bootstrapper files.
            </summary>
            <value>Path to bootstrapper files.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Products">
            <summary>
            Returns all products available at the current bootstrapper Path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings)">
            <summary>
            Generates a bootstrapper based on the specified settings.
            </summary>
            <param name="settings">The properties used to build this bootstrapper.</param>
            <returns>The results of the bootstrapper generation</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.GetOutputFolders(System.String[],System.String,System.String,Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation)">
            <summary>
            Returns the directories bootstrapper component files would be copied to when built given the specified settings
            </summary>
            <param name="productCodes">The productCodes of the selected components</param>
            <param name="culture">The culture used to build the bootstrapper</param>
            <param name="fallbackCulture">The fallback culture used to build the bootstrapper</param>
            <param name="componentsLocation">How the bootstrapper would package the selected components</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage">
            <summary>
            Represents messages that occur during the BootstrapperBuilder's Build operation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Severity">
            <summary>
            This severity of this build message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Message">
            <summary>
            A text string describing the details of the build message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpKeyword">
            <summary>
            The MSBuild F1-help keyword for the host IDE, or null
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpId">
            <summary>
            The MSBuild help id for the host IDE
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults">
            <summary>
            Represents the results of the Build operation of the BootstrapperBuilder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Succeeded">
            <summary>
            Returns true if the bootstrapper build was successful, false otherwise
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.KeyFile">
            <summary>
            The file path to the generated primary bootstrapper file
            </summary>
            <value>Path to setup.exe</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.ComponentFiles">
            <summary>
            File paths to copied component installer files
            </summary>
            <value>Path to component files</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Messages">
            <summary>
            The build messages generated from a bootstrapper build
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings">
            <summary>
            This class defines the settings for the bootstrapper build operation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName">
            <summary>
            The name of the application to be installed after the bootstrapper has installed all required components.  If no application is to be installed, this parameter may be null
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile">
            <summary>
            The file to be installed after the bootstrapper has installed the required components.  It is assumed that this file path is relative to the bootstrapper source path.  If no application is to be installed, this parameter may be null
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation">
            <summary>
            A value of true indicates that the application should require elevation to install on Vista.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl">
            <summary>
            The expected source location if the bootstrapper is published to a website.  It is expected that the ApplicationFile, if specified, will be published to the location consistent to this value. If ComponentsLocation is Relative, required component files will also be published in a manner consistent with this value.  This value may be null if setup.exe is not to be published to the web
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation">
            <summary>
            Specifies the install time location for bootstrapper components
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl">
            <summary>
            The location the bootstrapper install time will use for components if ComponentsLocation is "Absolute"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents">
            <summary>
            If true, the bootstrapper components will be copied to the build output directory.  If false, the files will not be copied
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID">
            <summary>
            The culture identifier for the bootstrapper to be built
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID">
            <summary>
            The culture identifier to use if the LCID identifier is not available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath">
            <summary>
            The file location to copy output files to
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ProductBuilders">
            <summary>
            The product builders to use for generating the bootstrapper
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl">
            <summary>
            Specifies a URL for the Web site containing support information for the bootstrapper
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate">
            <summary>
            True if the bootstrapper will perform XML validation on the component manifests
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder">
            <summary>
            This interface exposes functionality necessary to build a bootstrapper.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path">
            <summary>
            Specifies the location of the required bootstrapper files.
            </summary>
            <value>Path to bootstrapper files.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Products">
            <summary>
            Returns all products available at the current bootstrapper Path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings)">
            <summary>
            Generates a bootstrapper based on the specified settings.
            </summary>
            <param name="settings">The properties used to build this bootstrapper.</param>
            <returns>The results of the bootstrapper generation</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings">
            <summary>
            This interface defines the settings for the bootstrapper build operation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName">
            <summary>
            The name of the application to be installed after the bootstrapper has installed all required components.  If no application is to be installed, this parameter may be null
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile">
            <summary>
            The file to be installed after the bootstrapper has installed the required components.  It is assumed that this file path is relative to the bootstrapper source path.  If no application is to be installed, this parameter may be null
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl">
            <summary>
            The expected source location if the bootstrapper is published to a website.  It is expected that the ApplicationFile, if specified, will be published to the location consistent to this value. If ComponentsLocation is Relative, required component files will also be published in a manner consistent with this value.  This value may be null if setup.exe is not to be published to the web
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl">
            <summary>
            The location the bootstrapper install time will use for components if ComponentsLocation is "Absolute"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents">
            <summary>
            If true, the bootstrapper components will be copied to the build output directory.  If false, the files will not be copied
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID">
            <summary>
            The culture identifier for the bootstrapper to be built
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID">
            <summary>
            The culture identifier to use if the LCID identifier is not available
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath">
            <summary>
            The file location to copy output files to
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ProductBuilders">
            <summary>
            The product builders to use for generating the bootstrapper
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate">
            <summary>
            True if the bootstrapper will perform XML validation on the component manifests
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation">
            <summary>
            Specifies the install time location for bootstrapper components
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl">
            <summary>
            Specifies a URL for the Web site containing support information for the bootstrapper
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation">
            <summary>
            A value of true indicates that the application should require elevation to install on Windows Vista.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct">
            <summary>
            This interface represents a product in the found by the BootstrapperBuilder in the Path property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductBuilder">
            <summary>
            The ProductBuilder representation of this Product
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Name">
            <summary>
            A human-readable name for this product
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductCode">
            <summary>
            A string specifying the unique identifier of this product
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Includes">
            <summary>
            All products which this product also installs
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection">
            <summary>
            This interface describes a collection of Product objects. This collection is a closed set that is generated by the BootstrapperBuilder based on the Path property. The client cannot add or remove items from this collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Count">
            <summary>
            Gets the number of elements actually contained in the ProductCollection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Item(System.Int32)">
            <summary>
            Gets the Product at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get</param>
            <returns>The Product at the specified index</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Product(System.String)">
            <summary>
            Gets the product with the specified product code
            </summary>
            <param name="productCode"></param>
            <returns>The product with the given name, null if the spercified product code is not found</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder">
            <summary>
            This interface represents a buildable version of a Product.  Used for the BootstrapperBuilder's Build method.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder.Product">
            <summary>
            The product corresponding to this builder
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection">
            <summary>
            This class contains a collection of ProductBuilder objects. Used for the BootstrapperBuilder's Build method.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder)">
            <summary>
            Adds a builder to the collection
            </summary>
            <param name="builder">The ProductBuilder to add to the collection</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults">
            <summary>
            Represents the results of the build operation of the BootstrapperBuilder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Succeeded">
            <summary>
            Returns true if the bootstrapper build was successful, false otherwise
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.KeyFile">
            <summary>
            The file path to the generated primary bootstrapper file
            </summary>
            <value>Path to setup.exe</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles">
            <summary>
            File paths to copied component installer files
            </summary>
            <value>Path to component files</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages">
            <summary>
            The build messages generated from a bootstrapper build
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage">
            <summary>
            Represents messages that occur during the BootstrapperBuilder's Build operation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Severity">
            <summary>
            This severity of this build message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Message">
            <summary>
            A text string describing the details of the build message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpKeyword">
            <summary>
            The MSBuild F1-help keyword for the host IDE, or null
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpId">
            <summary>
            The MSBuild help id for the host IDE
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity">
            <summary>
            This enumeration provides three levels of importance for build messages.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Info">
            <summary>
            Indicates that the message corresponds to build information
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Warning">
            <summary>
            Indicates that the message corresponds to a build warning
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Error">
            <summary>
            Indicates that the message corresponds to a build error
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation">
            <summary>
            This enumeration describes the way required components will be published
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite">
            <summary>
            Products will be found according to the redist vendor's designated URL 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Relative">
            <summary>
            Products will be located relative to generated bootstrapper
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Absolute">
            <summary>
            All products will be located at s specific location
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.Product">
            <summary>
            This class represents a product in the found by the BootstrapperBuilder in the Path property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductBuilder">
            <summary>
            The ProductBuilder representation of this Product
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductCode">
            <summary>
            A string specifying the unique identifier of this product
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Name">
            <summary>
            A human-readable name for this product
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Includes">
            <summary>
            All products which this product also installs
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder">
            <summary>
            A buildable version of a Product.  Used for the BootstrapperBuilder's Build method.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder.Product">
            <summary>
            The Product corresponding to this ProductBuilder
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection">
            <summary>
            This class contains a collection of ProductBuilder objects. Used for the BootstrapperBuilder's Build method.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder)">
            <summary>
            Adds a ProductBuilder to the ProductBuilderCollection
            </summary>
            <param name="builder">The ProductBuilder to add to this collection</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the ProductBuilderCollection
            </summary>
            <returns>An enumerator that can iterate through the ProductBuilderCollection</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection">
            <summary>
            This class contains a collection of Product objects. This collection is a closed set that is generated by the BootstrapperBuilder based on the Path property. The client cannot add or remove items from this collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Item(System.Int32)">
            <summary>
            Gets the Product at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get</param>
            <returns>The Product at the specified index</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Product(System.String)">
            <summary>
            Gets the product with the specified product code
            </summary>
            <param name="productCode"></param>
            <returns>The product with the given name, null if the spercified product code is not found</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Count">
            <summary>
            Gets the number of elements actually contained in the ProductCollection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the ProductCollection
            </summary>
            <returns>An enumerator that can iterate through the ProductCollection</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductValidationResults">
            <summary>
            Handles and stores xml validation events for a product, and contains the XmlValidationResults of a package.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductValidationResults.AddPackageResults(System.String,Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults)">
            <summary>
            Adds the validation results of a package of the specified culture into the ProductValidationResults.
            </summary>
            <param name="culture">The culture of the XmlValidationResults to add.</param>
            <param name="results">The vaue of the results to add.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductValidationResults.PackageResults(System.String)">
            <summary>
            Gets the XmlValidationResults for the specified culture.
            </summary>
            <param name="culture">The culture of the XmlValidationResults to get.</param>
            <returns>The XmlValidationResults associated with the specified culture.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults">
            <summary>
            Handles and stores XML validation events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults.#ctor(System.String)">
            <summary>
            Constructor which includes the path to the file being validated.
            </summary>
            <param name="filePath">The file which is being validated.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults.FilePath">
            <summary>
            Gets a string containing the name of the file being validated.
            </summary>
            <value>The name of the file being validated.</value>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults.SchemaValidationEventHandler(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
            The delegate which will handle validation events.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults.ValidationErrors">
            <summary>
            Gets all of the validation errors of the file being validated.
            </summary>
            <value>An array of type string, containing all of the validation errors.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults.ValidationPassed">
            <summary>
            Gets a value indicating if there were no validation errors or warnings.
            </summary>
            <value>true if there were no validation errors or warnings; otherwise false.  The default value is false.</value>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults.ValidationWarnings">
            <summary>
            Gets all of the validation warnings of the file being validated.
            </summary>
            <value>An array of type string, containing all of the validation warnings.</value>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity">
            <summary>
            Provides a unique identifier for a ClickOnce application.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the ApplicationIdentity class.
            </summary>
            <param name="url">The deployment provider URL for the ClickOnce deployment manifest.</param>
            <param name="deployManifestPath">Path to ClickOnce deployment manifest. The assembly identity will be obtained from the specified file.</param>
            <param name="applicationManifestPath">Path to ClickOnce application manifest. The assembly identity will be obtained from the specified file.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.#ctor(System.String,Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity,Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity)">
            <summary>
            Initializes a new instance of the ApplicationIdentity class.
            </summary>
            <param name="url">The deployment provider URL for the ClickOnce deployment manifest.</param>
            <param name="deployManifestIdentity">Assembly identity of the ClickOnce deployment manifest.</param>
            <param name="applicationManifestIdentity">Assembly identity of the ClickOnce application manifest.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ToString">
            <summary>
            Returns the full ClickOnce application identity.
            </summary>
            <returns>A string containing the ClickOnce application identity.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest">
            <summary>
            Describes a ClickOnce or native Win32 application manifest.
            </summary>
            <remarks>
            This is a serialization format, don't remove the private fields.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#ctor">
            <summary>
            Initializes a new instance of the ApplicationManifest class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ApplicationManifest class.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile">
            <summary>
            Indicates the application configuration file.
            For a Win32 native manifest, this input is ignored.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion">
            <summary>
            Specifies the target framework version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl">
            <summary>
            Specifies the link to use if there is a failure launching the application.
            The specified value should be a fully qualified URL or UNC path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser">
            <summary>
            If true, the application will run in IE using WPF's xbap application model.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile">
            <summary>
            Indicates the application icon file.
            The application icon is expressed in the generated application manifest and is used for the start menu and Add/Remove Programs dialog.
            If this input is not specified then a default icon is used.
            For a Win32 native manifest, this input is ignored.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest">
            <summary>
            Indicates whether the manifest is a ClickOnce application manifest or a native Win32 application manifest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath">
            <summary>
            Specifies the maximum allowable length of a file path in a ClickOnce application deployment.
            If this value is specified, then the length of each file path in the application is checked against this limit.
            Any items that exceed the limit will result in a warning message.
            If this input is not specified or is zero, then no checking is performed.
            For a Win32 native manifest, this input is ignored.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription">
            <summary>
            Specifies a textual description for the OS dependency.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl">
            <summary>
            Specifies a support URL for the OS dependency.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion">
            <summary>
            Specifies the minimum required OS version required by the application.
            An example value is "5.1.2600.0" for Windows XP.
            If this input is not specified a default value is used.
            The default value is the minimum supported OS of the .NET Framework, which is "4.10.0.0" for Windows 98SE.
            However, if the application contains any native or Reg-Free COM references, then the default will be the Windows XP version.
            For a Win32 native manifest, this input is ignored.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product">
            <summary>
            Specifies the name of the application.
            If this input is not specified then the Product is not written into the Application Manifest
            This name is used for the shortcut name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher">
            <summary>
            Specifies the publisher of the application.
            If this input is not specified then the Publisher is not written into the Application Manifest
            This name is used for the folder name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName">
            <summary>
            Specifies the suite name of the application.
            This name is used for the sub-folder name on the Start menu (as a child of the publisher)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl">
            <summary>
            Specifies the link that appears in the Add/Remove Programs dialog for the application.
            The specified value should be a fully qualified URL or UNC path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo">
            <summary>
            Specifies a trust object defining the application security.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust">
            <summary>
            If true, the install will use the settings in the application manifest in the trust prompt.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity">
            <summary>
            Describes the identity of an assembly.
            </summary>
            <remarks>This is a serialization format, do not remove or change the private fields.</remarks>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags">
            <summary>
            Specifies which attributes are to be returned by the GetFullName function.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Default">
            <summary>
            Include the Name, Version, Culture, and PublicKeyToken attributes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture">
            <summary>
            Include the Name, Version, Culture, PublicKeyToken, and ProcessorArchitecture attributes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type">
            <summary>
            Include the Name, Version, Culture, PublicKeyToken, and Type attributes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.All">
            <summary>
            Include all attributes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#ctor">
            <summary>
            Initializes a new instance of the AssemblyIdentity class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#ctor(System.String)">
            <summary>
            Initializes a new instance of the AssemblyIdentity class.
            </summary>
            <param name="name">Specifies the simple name of the assembly.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the AssemblyIdentity class.
            </summary>
            <param name="name">Specifies the simple name of the assembly.</param>
            <param name="version">Specifies the version of the assembly.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the AssemblyIdentity class.
            </summary>
            <param name="name">Specifies the simple name of the assembly.</param>
            <param name="version">Specifies the version of the assembly.</param>
            <param name="publicKeyToken">Specifies the public key token of the assembly, which is the last 8 bytes of the SHA-1 hash of the public key under which the assembly is signed.</param>
            <param name="culture">Specifies the culture of the assembly. A blank string indicates the invariant culture.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the AssemblyIdentity class.
            </summary>
            <param name="name">Specifies the simple name of the assembly.</param>
            <param name="version">Specifies the version of the assembly.</param>
            <param name="publicKeyToken">Specifies the public key token of the assembly, which is the last 8 bytes of the SHA-1 hash of the public key under which the assembly is signed.</param>
            <param name="culture">Specifies the culture of the assembly. A blank string indicates the invariant culture.</param>
            <param name="processorArchitecture">Specifies the processor architecture of the assembly. Valid values are "msil", "x86", "ia64", "amd64".</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#ctor(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the AssemblyIdentity class.
            </summary>
            <param name="name">Specifies the simple name of the assembly.</param>
            <param name="version">Specifies the version of the assembly.</param>
            <param name="publicKeyToken">Specifies the public key token of the assembly, which is the last 8 bytes of the SHA-1 hash of the public key under which the assembly is signed.</param>
            <param name="culture">Specifies the culture of the assembly. A blank string indicates the invariant culture.</param>
            <param name="processorArchitecture">Specifies the processor architecture of the assembly. Valid values are "msil", "x86", "ia64", "amd64".</param>
            <param name="type">Specifies the type attribute of the assembly. Valid values are "win32" or a blank string.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#ctor(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity)">
            <summary>
            Initializes a new instance of the AssemblyIdentity class.
            </summary>
            <param name="identity">Specifies another instance to duplicate.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromAssemblyName(System.String)">
            <summary>
            Parses string to obtain an assembly identity.
            Returns null if identity could not be obtained.
            </summary>
            <param name="assemblyName">The full name of the assembly, also known as the display name.</param>
            <returns>The resulting assembly identity.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManifest(System.String)">
            <summary>
            Obtains identity of the specified manifest file.
            File must be a stand-alone xml manifest file.
            Returns null if identity could not be obtained.
            </summary>
            <param name="path">The name of the file from which the identity is to be obtained.</param>
            <returns>The assembly identity of the specified file.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManagedAssembly(System.String)">
            <summary>
            Obtains identity of the specified .NET assembly.
            File must be a .NET assembly.
            Returns null if identity could not be obtained.
            </summary>
            <param name="path">The name of the file from which the identity is to be obtained.</param>
            <returns>The assembly identity of the specified file.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromNativeAssembly(System.String)">
            <summary>
            Obtains identity of the specified native assembly.
            File must be either a PE with an embedded xml manifest, or a stand-alone xml manifest file.
            Returns null if identity could not be obtained.
            </summary>
            <param name="path">The name of the file from which the identity is to be obtained.</param>
            <returns>The assembly identity of the specified file.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromFile(System.String)">
            <summary>
            Obtains identity of the specified assembly.
            File can be a PE with an embedded xml manifest, a stand-alone xml manifest file, or a .NET assembly.
            Returns null if identity could not be obtained.
            </summary>
            <param name="path">The name of the file from which the identity is to be obtained.</param>
            <returns>The assembly identity of the specified file.</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsFrameworkAssembly">
            <summary>
            Returns true if this assembly is part of the .NET Framework.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsInFramework(System.String,System.String)">
            <summary>
            Returns true if this assembly is part of the given framework.
            identifier is “.NETFramework” or “Silverlight”, etc. and the version string looks like this: “4.5” or “v4.5”, or “v4.0.30319"
            If frameworkVersion is null or empty, return true if this assembly is present in any of the given framework versions
            If both arguments are null or empty strings, return true if this assembly is present in any of the frameworks
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture">
            <summary>
            Specifies the culture of the assembly. A blank string indicates the invariant culture.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags)">
            <summary>
            Returns the full name of the assembly.
            </summary>
            <param name="flags">Specifies which attributes to be included in the full name.</param>
            <returns>A string representation of the full name.</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsNeutralPlatform">
            <summary>
            Specifies whether the assembly identity represents a neutral platform assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsStrongName">
            <summary>
            Specifies whether the assembly identity is a strong name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name">
            <summary>
            Specifies the simple name of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture">
            <summary>
            Specifies the processor architecture of the assembly. Valid values are "msil", "x86", "ia64", "amd64".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken">
            <summary>
            Specifies the public key token of the assembly, which is the last 8 bytes of the SHA-1 hash of the public key under which the assembly is signed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type">
            <summary>
            Specifies the type attribute of the assembly. Valid values are "win32" or a blank string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version">
            <summary>
            Specifies the version of the assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest">
            <summary>
            Describes a Win32 assembly manifest.
            </summary>
            <remarks>This is a serialization format, do not remove or rename private fields.</remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs">
            <summary>
            Specifies the set of external proxy stubs referenced by the manifest for isolated applications and Reg-Free COM.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType">
            <summary>
            Describes the type of an assembly reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.Unspecified">
            <summary>
            Assembly type is unspecified and will be determined by the UpdateFileInfo method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ClickOnceManifest">
            <summary>
            Specifies a ClickOnce manifest.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ManagedAssembly">
            <summary>
            Specifies a .NET assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.NativeAssembly">
            <summary>
            Specifies a Win32 native assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference">
            <summary>
            Describes a manifest assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.#ctor">
            <summary>
            Initializes a new instance of the AssemblyReference class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.#ctor(System.String)">
            <summary>
            Initializes a new instance of the AssemblyReference class.
            </summary>
            <param name="path">The specified source path of the file.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity">
            <summary>
            Specifies the identity of the assembly reference.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite">
            <summary>
            Specifies whether the assembly reference is a prerequisite.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType">
            <summary>
            Specifies the type of the assembly reference.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrimary">
            <summary>
            True if the reference is specified in the project file, false if it is added to the manifest as a result
            of computing the closure of all project references.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection">
            <summary>
            Provides a collection for manifest assembly references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the entry to get.</param>
            <returns>The assembly reference instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(System.String)">
            <summary>
            Adds the specified assembly reference to the collection.
            </summary>
            <param name="path">The specified assembly reference to add.</param>
            <returns>The added assembly reference instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference)">
            <summary>
            Adds the specified assembly reference to the collection.
            </summary>
            <param name="assembly">The specified assembly reference to add.</param>
            <returns>The added assembly reference instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Clear">
            <summary>
            Removes all objects from the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Count">
            <summary>
            Gets the number of objects contained in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(System.String)">
            <summary>
            Finds an assembly reference in the collection by simple name.
            </summary>
            <param name="name">The specified assembly simple name.</param>
            <returns>The found assembly reference.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity)">
            <summary>
            Finds an assembly reference in the collection by the specified assembly identity.
            </summary>
            <param name="identity">The specified assembly identity.</param>
            <returns>The found assembly reference.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.FindTargetPath(System.String)">
            <summary>
            Finds an assembly reference in the collection by the specified target path.
            </summary>
            <param name="targetPath">The specified target path.</param>
            <returns>The found assembly reference.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the collection.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference)">
            <summary>
            Removes the specified assembly reference from the collection.
            </summary>
            <param name="assemblyReference">The specified assembly reference to remove.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference">
            <summary>
            Describes base functionality common to both file and assembly references.
            </summary>
            <remarks>Note derived classes are serialization formats. Do not rename or remove private members.</remarks>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group">
            <summary>
            Specifies the group for on-demand download functionality. A blank string indicates a primary file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash">
            <summary>
            Specifies the SHA1 hash of the file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional">
            <summary>
            Specifies whether the file is optional for on-deman download functionality.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath">
            <summary>
            Specifies the resolved path to the file. This path is determined by the Resolve method, and is used to compute the file information by the UpdateFileInfo method.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size">
            <summary>
            Specifies the file size in bytes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath">
            <summary>
            Specifies the source path of the file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath">
            <summary>
            Specifies the target path of the file. This is the path that is used for specification in the generated manifest.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework">
            <summary>
            Describes a CompatibleFramework for an deployment manifest
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode">
            <summary>
            Specifies how the application checks for updates.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Background">
            <summary>
            Check for updates in the background, after the application starts.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Foreground">
            <summary>
            Check for updates in the foreground, before the application starts.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit">
            <summary>
            Specifies the units for the update interval.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Hours">
            <summary>
            Update interval is in hours.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Days">
            <summary>
            Update interval is in days.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Weeks">
            <summary>
            Update interval is in weeks.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest">
            <summary>
            Describes a ClickOnce deployment manifest.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#ctor">
            <summary>
            Initializes a new instance of the DeployManifest class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DeployManifest class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.GetInstallableFrameworkName(System.Runtime.Versioning.FrameworkName)">
            <summary>
            codes from GetInstallableFrameworkForTargetFxInternal in 
            env/vscore/package/FxMultiTargeting/FrameworkMultiTargetingInternal.cs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.GetInstallableFramework(System.String)">
            <summary>
            Gets the InstallableFramework by reading the 'InstallableFramework' attribute in the redist file of the target framework
            </summary>
            <param name="redistListFilePath">the path to the redistlist file</param>
            <returns>InstallableFramework</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.PatchCLRVersion(System.String)">
            <summary>
            conver (MajorVersion).(MinorVersion).(Build).(Revision) to (MajorVersion).(MinorVersion).(Build)
            </summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut">
            <summary>
            Specifies whether the application install will create a shortcut on the desktop
            If True, the installation will create a shortcut to the application on the desktop.
            The default is False
            If Install is False, this value will be ignored
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker">
            <summary>
            Specifies the target framework moniker of this project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CompatibleFrameworks">
            <summary>
            A collection of CompatibleFrameworks
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl">
            <summary>
            Specifies the update location for the application.
            If this input is not specified then no update location will be defined for the application.
            However, if application updates are specified then the update location must be specified.
            The specified value should be a fully qualified URL or UNC path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation">
            <summary>
            Specifies whether the application should be blocked from being activated via a URL.
            If this option is True then application can only be activated from the user's Start menu.
            The default is False.
            This option is ignored if the Install property is False.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl">
            <summary>
            Specifies the link to use if there is a failure launching the application.
            The specified value should be a fully qualified URL or UNC path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install">
            <summary>
            Specifies whether the application is an installed application or an online only application.
            If this flag is True the application will be installed on the user's Start menu, and can be removed from the Add/Remove Programs dialog.
            If this flag is False then the application is intended for online use from a web page.
            The default is True.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions">
            <summary>
            Specifies whether or not the ".deploy" file extension mapping is used.
            If this flag is true then every application file is published with a ".deploy" file extension.
            This option is useful for web server security to limit the number of file extensions that need to be unblocked to enable ClickOnce application deployment.
            The default is false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion">
            <summary>
            Specifies whether or not the user can skip the update.
            If the user has a version less than the minimum required, he or she will not have the option to skip the update.
            The default is to have no minimum required version.
            This input only applies when Install is True.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product">
            <summary>
            Specifies the name of the application.
            If this input is not specified then the name is inferred from the identity of the generated manifest.
            This name is used for the shortcut name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher">
            <summary>
            Specifies the publisher of the application.
            If this input is not specified then the name is inferred from the registered user, or the identity of the generated manifest.
            This name is used for the folder name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName">
            <summary>
            Specifies the suite name of the application.
            This name is used for the sub-folder name on the Start menu (as a child of the publisher)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl">
            <summary>
            Specifies the link that appears in the Add/Remove Programs dialog for the application.
            The specified value should be a fully qualified URL or UNC path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters">
            <summary>
            Specifies whether or not URL query-string parameters should be made available to the application.
            The default is False indicating that parameters will not be available to the application.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled">
            <summary>
            Indicates whether or not the application is updatable.
            The default is False.
            This input only applies when Install is True.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval">
            <summary>
            Specifies the update interval for the application.
            The default is zero.
            This input only applies when Install and UpdateEnabled are both True.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode">
            <summary>
            Specifies whether updates should be checked in the foreground before starting the application, or in the background as the application is running.
            The default is "Background".
            This input only applies when Install and UpdateEnabled are both True.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit">
            <summary>
            Specifies the units for UpdateInterval input.
            This input only applies when Install and UpdateEnabled are both True.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation">
            <summary>
            Describes a fileAssociation for an application manifest
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference">
            <summary>
            Describes a manifest file reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.#ctor">
            <summary>
            Initializes a new instance of the FileReference class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.#ctor(System.String)">
            <summary>
            Initializes a new instance of the FileReference class.
            </summary>
            <param name="path">The specified source path of the file.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses">
            <summary>
            Specifies the set of COM classes referenced by the manifest for isolated applications and Reg-Free COM.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile">
            <summary>
            Specifies whether the file is a data file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs">
            <summary>
            Specifies the set of proxy stubs referenced by the manifest for isolated applications and Reg-Free COM.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs">
            <summary>
            Specifies the set of type libraries referenced by the manifest.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection">
            <summary>
            Provides a collection for manifest file references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the entry to get.</param>
            <returns>The file reference instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(System.String)">
            <summary>
            Adds the specified assembly reference to the collection.
            </summary>
            <param name="path">The specified file reference to add.</param>
            <returns>The added file reference instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference)">
            <summary>
            Adds the specified assembly reference to the collection.
            </summary>
            <param name="file">The specified file reference to add.</param>
            <returns>The added file reference instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Clear">
            <summary>
            Removes all objects from the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Count">
            <summary>
            Gets the number of objects contained in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.FindTargetPath(System.String)">
            <summary>
            Finds a file reference in the collection by the specified target path.
            </summary>
            <param name="targetPath">The specified target path.</param>
            <returns>The found file reference.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the collection.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference)">
            <summary>
            Removes the specified file reference from the collection.
            </summary>
            <param name="file">The specified file reference to remove.</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest">
            <summary>
            Describes base functionality common to all supported manifest types.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity">
            <summary>
            Specifies the identity of the manifest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyReferences">
            <summary>
            Specifies the set of assemblies referenced by the manifest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description">
            <summary>
            Specifies a textual description for the manifest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint">
            <summary>
            Identifies an assembly reference which is the entry point of the application.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.FileReferences">
            <summary>
            Specifies the set of files referenced by the manifest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream">
            <summary>
            The input stream from which the manifest was read.
            Used by ManifestWriter to reconstitute input which is not represented in the object representation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.OutputMessages">
            <summary>
            Contains a collection of current error and warning messages.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly">
            <summary>
            Specifies whether the manifest is operating in read-only or read-write mode.
            If only using to read a manifest then set this flag to true.
            If using to write a new manifest then set this flag to false.
            The default is false.
            This flag provides additional context for the manifest generator, and affects how some error messages are reported.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles">
            <summary>
            Locates all specified assembly and file references by searching in the same directory as the loaded manifest, or in the current directory.
            The location of each referenced assembly and file is required for hash computation and assembly identity resolution.
            Any resulting errors or warnings are reported in the OutputMessages collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles(System.String[])">
            <summary>
            Locates all specified assembly and file references by searching in the specified directories.
            The location of each referenced assembly and file is required for hash computation and assembly identity resolution.
            Any resulting errors or warnings are reported in the OutputMessages collection.
            </summary>
            <param name="searchPaths">An array of strings specify directories to search.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath">
            <summary>
            Specifies the location where the manifest was loaded or saved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo">
            <summary>
            Updates file information for each referenced assembly and file.
            The file information includes a hash computation and a file size for each referenced file and assembly.
            Also, the assembly identity is obtained for any referenced assemblies with an unspecified assembly identity.
            Any resulting errors or warnings are reported in the OutputMessages collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfoImpl(System.String)">
            <summary>
            Implementation of UpdateFileInfo
            </summary>
            <param name="targetFrameworkVersion">null, if not TFV.  If no TFV, it will use sha256 signature algorithm.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Validate">
            <summary>
            Performs various checks to verify the validity of the manifest.
            Any resulting errors or warnings are reported in the OutputMessages collection.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader">
            <summary>
            Reads an XML manifest file into an object representation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.String,System.Boolean)">
            <summary>
            Reads the specified manifest XML and returns an object representation.
            </summary>
            <param name="path">The name of the input file.</param>
            <param name="preserveStream">Specifies whether to preserve the input stream in the InputStream property of the resulting manifest object. Used by ManifestWriter to reconstitute input which is not represented in the object representation. This option is not honored if the specified input file is an embedded manfiest in a PE.</param>
            <returns>A base object representation of the manifest. Can be cast to AssemblyManifest, ApplicationManifest, or DeployManifest to access more specific functionality.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.String,System.String,System.Boolean)">
            <summary>
            Reads the specified manifest XML and returns an object representation.
            </summary>
            <param name="manifestType">Specifies the expected type of the manifest. Valid values are "AssemblyManifest", "ApplicationManifest", or "DepoyManifest".</param>
            <param name="path">The name of the input file.</param>
            <param name="preserveStream">Specifies whether to preserve the input stream in the InputStream property of the resulting manifest object. Used by ManifestWriter to reconstitute input which is not represented in the object representation. This option is not honored if the specified input file is an embedded manfiest in a PE.</param>
            <returns>A base object representation of the manifest. Can be cast to AssemblyManifest, ApplicationManifest, or DeployManifest to access more specific functionality.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.IO.Stream,System.Boolean)">
            <summary>
            Reads the specified manifest XML and returns an object representation.
            </summary>
            <param name="input">Specifies an input stream.</param>
            <param name="preserveStream">Specifies whether to preserve the input stream in the InputStream property of the resulting manifest object. Used by ManifestWriter to reconstitute input which is not represented in the object representation.</param>
            <returns>A base object representation of the manifest. Can be cast to AssemblyManifest, ApplicationManifest, or DeployManifest to access more specific functionality.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.String,System.IO.Stream,System.Boolean)">
            <summary>
            Reads the specified manifest XML and returns an object representation.
            </summary>
            <param name="manifestType">Specifies the expected type of the manifest. Valid values are "AssemblyManifest", "ApplicationManifest", or "DepoyManifest".</param>
            <param name="input">Specifies an input stream.</param>
            <param name="preserveStream">Specifies whether to preserve the input stream in the InputStream property of the resulting manifest object. Used by ManifestWriter to reconstitute input which is not represented in the object representation.</param>
            <returns>A base object representation of the manifest. Can be cast to AssemblyManifest, ApplicationManifest, or DeployManifest to access more specific functionality.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter">
            <summary>
            Writes object representation of a manifest to XML.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest)">
            <summary>
            Writes the specified object representation of a manifest to XML.
            The name of the output file is inferred from the SourcePath property of the manifest.
            </summary>
            <param name="manifest">The object representation of the manifest.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest,System.String)">
            <summary>
            Writes the specified object representation of a manifest to XML.
            </summary>
            <param name="manifest">The object representation of the manifest.</param>
            <param name="path">The name of the output file.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest,System.String,System.String)">
            <summary>
            Writes the specified object representation of a manifest to XML.
            </summary>
            <param name="manifest">The object representation of the manifest.</param>
            <param name="path">The name of the output file.</param>
            <param name="targetframeWorkVersion">The target framework version.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest,System.IO.Stream)">
            <summary>
            Writes the specified object representation of a manifest to XML.
            </summary>
            <param name="manifest">The object representation of the manifest.</param>
            <param name="output">Specifies an output stream.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest,System.IO.Stream,System.String)">
            <summary>
            
            </summary>
            <param name="manifest"></param>
            <param name="output"></param>
            <param name="targetframeWorkVersion">it will always use sha256 as signature algorithm if TFV is null</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType">
            <summary>
            Specifies the type of output message as either an error, warning, or informational.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Info">
            <summary>
            Indicates an informational message.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Warning">
            <summary>
            Indicates a warning.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Error">
            <summary>
            Indicates an error.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage">
            <summary>
            Describes an error, warning, or informational output message for the manifest generator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.GetArguments">
            <summary>
            Returns a string array of arguments for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Name">
            <summary>
            Specifies an identifier for the message.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Text">
            <summary>
            Contains the text of the message.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Type">
            <summary>
            Indicates whether the message is an error, warning, or informational message.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection">
            <summary>
            Provides a collection for output messages.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the entry to get.</param>
            <returns>The file reference instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Clear">
            <summary>
            Removes all objects from the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.ErrorCount">
            <summary>
            Gets the number of error messages in the collecction.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the collection.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.WarningCount">
            <summary>
            Gets the number of warning messages in the collecction.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities">
            <summary>
            Provides a set of utility functions for manipulating security permision sets and signing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.ComputeZonePermissionSet(System.String,System.Security.PermissionSet,System.String[])">
            <summary>
            Generates a permission set by computed the zone default permission set and adding any included permissions.
            </summary>
            <param name="targetZone">Specifies a zone default permission set, which is obtained from machine policy. Valid values are "Internet", "LocalIntranet", or "Custom". If "Custom" is specified, the generated permission set is based only on the includedPermissionSet parameter.</param>
            <param name="includedPermissionSet">A PermissionSet object containing the set of permissions to be explicitly included in the generated permission set. Permissions specified in this parameter will be included verbatim in the generated permission set, regardless of targetZone parameter.</param>
            <param name="excludedPermissions">This property is no longer used.</param>
            <returns>The generated permission set.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.IdentityListToPermissionSet(System.String[])">
            <summary>
            Converts an array of permission identity strings to a permission set object.
            </summary>
            <param name="ids">An array of permission identity strings.</param>
            <returns>The converted permission set.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.PermissionSetToIdentityList(System.Security.PermissionSet)">
            <summary>
            Converts a permission set object to an array of permission identity strings.
            </summary>
            <param name="permissionSet">The input permission set to be converted.</param>
            <returns>An array of permission identity strings.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.XmlToPermissionSet(System.Xml.XmlElement)">
            <summary>
            Converts an XmlElement into a PermissionSet object.
            </summary>
            <param name="element">An XML representation of the permission set.</param>
            <returns>The converted permission set.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.String,System.Uri,System.String)">
            <summary>
            Signs a ClickOnce manifest or PE file.
            </summary>
            <param name="certThumbprint">Hexadecimal string that contains the SHA-1 hash of the certificate.</param>
            <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
            <param name="path">Path of the file to sign with the certificate.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.String,System.Uri,System.String,System.String)">
            <summary>
            Signs a ClickOnce manifest or PE file.
            </summary>
            <param name="certThumbprint">Hexadecimal string that contains the SHA-1 hash of the certificate.</param>
            <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
            <param name="path">Path of the file to sign with the certificate.</param>
            <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.String,System.Security.SecureString,System.Uri,System.String)">
            <summary>
            Signs a ClickOnce manifest.
            </summary>
            <param name="certPath">The certificate to be used to sign the file.</param>
            <param name="certPassword">The certificate password.</param>
            <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
            <param name="path">Path of the file to sign with the certificate.</param>
            <remarks>This function is only for signing a manifest, not a PE file.</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Uri,System.String)">
            <summary>
            Signs a ClickOnce manifest or PE file.
            </summary>
            <param name="cert">The certificate to be used to sign the file.</param>
            <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
            <param name="path">Path of the file to sign with the certificate.</param>
            <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the 
            current user's personal certificate store.</remarks>
        </member>
        <member name="T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo">
            <summary>
            Describes the application security trust information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Clear">
            <summary>
            Resets the object to its default state.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.HasUnmanagedCodePermission">
            <summary>
            Determines whether the application has permission to call unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust">
            <summary>
            Determines whether the application is full trust or partial trust.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PermissionSet">
            <summary>
            Gets or sets the permission set object for the application trust.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet">
            <summary>
            Determines whether to preserve partial trust permission when the full trust flag is set.
            If this option is false with full trust specified, then any permissions defined in the permission set object will be dropped on save.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.String)">
            <summary>
            Reads the application trust from an XML file.
            </summary>
            <param name="path">The name of the input file.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.IO.Stream)">
            <summary>
            Reads the application trust from an XML file.
            </summary>
            <param name="input">Specifies an input stream.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.String)">
            <summary>
            Reads the application trust from a ClickOnce application manifest.
            </summary>
            <param name="path">The name of the input file.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.IO.Stream)">
            <summary>
            Reads the application trust from a ClickOnce application manifest.
            </summary>
            <param name="input">Specifies an input stream.</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess">
            <summary>
            Describes the level of "same site" access permitted, specifying whether the application has permission to communicate with the server from which it was deployed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.String)">
            <summary>
            Writes the application trust to an XML file.
            </summary>
            <param name="path">The name of the output file.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.IO.Stream)">
            <summary>
            Writes the application trust to an XML file.
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.String)">
            <summary>
            Writes the application trust to a ClickOnce application manifest.
            If the file exists, the trust section will be updated.
            If the file does not exist, a new template manifest with the specified trust will be created.
            </summary>
            <param name="path">The name of the output file.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream)">
            <summary>
            Writes the application trust to a new template ClickOnce application manifest.
            </summary>
            <param name="output">Specifies an output stream.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream,System.IO.Stream)">
            <summary>
            Updates an existing ClickOnce application manifest with the specified trust.
            </summary>
            <param name="input">Specifies an input stream.</param>
            <param name="output">Specifies an output stream.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Util.GetClrVersion(System.String)">
            <summary>
            Return a CLRVersion from a given target framework version.
            </summary>
            <param name="targetFrameworkVersion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Deployment.ManifestUtilities.Util.GetTargetFrameworkVersion(System.String)">
            <summary>
            Gets a Version object corresponding to the given target framework version string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ComDependencyWalker">
            <summary>
            COM type library dependency walker class
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComDependencyWalker.EncounteredProblems">
            <summary>
            List of exceptions thrown by the components during scanning
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.#ctor(Microsoft.Build.Tasks.MarshalReleaseComObject)">
            <summary>
            Internal constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.AnalyzeTypeLibrary(System.Runtime.InteropServices.ComTypes.ITypeLib)">
            <summary>
            The main entry point to the dependency walker
            </summary>
            <param name="typeLibrary">type library to be analyzed</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.AnalyzeTypeInfo(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
            <summary>
            Analyze the given type looking for dependencies on other type libraries
            </summary>
            <param name="typeInfo"></param>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.CanSkipType(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Runtime.InteropServices.ComTypes.ITypeLib,System.Runtime.InteropServices.ComTypes.TYPEATTR,System.Runtime.InteropServices.ComTypes.TYPELIBATTR)">
            <summary>
            Returns true if we don't need to analyze this particular type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.ScanImplementedTypes(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Runtime.InteropServices.ComTypes.TYPEATTR)">
            <summary>
            For a given type, analyze recursively all the types implemented by it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.ScanDefinedVariables(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Runtime.InteropServices.ComTypes.TYPEATTR)">
            <summary>
            For a given type, analyze all the variables defined by it
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.ScanDefinedFunctions(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Runtime.InteropServices.ComTypes.TYPEATTR)">
            <summary>
            For a given type, analyze all the functions implemented by it. That means all the argument and return types.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.AnalyzeElement(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Runtime.InteropServices.ComTypes.ELEMDESC)">
            <summary>
            Analyze the given element (i.e. composite type of an argument) recursively
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.GetDependencies">
            <summary>
            Get all the dependencies of the processed libraries
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.GetAnalyzedTypeNames">
            <summary>
            FOR UNIT-TESTING ONLY
            Returns a list of the analyzed type names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.ClearDependencyList">
            <summary>
            Clear the dependency list so we can read dependencies incrementally but still have the advantage of 
            not scanning previously seen types
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComDependencyWalker.ClearAnalyzedTypeCache">
            <summary>
            Clear the analyzed type cache.  This is necessary if we have to resolve dependencies that are also 
            COM references in the project, or we may get an inaccurate view of what their dependencies are. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ComReference">
            <summary>
            Abstract base class for COM reference wrappers providing common functionality. 
            This class hierarchy is used by the ResolveComReference task.Every class deriving from ComReference
            provides functionality for wrapping Com type libraries in a given way(for example AxReference, or PiaReference).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.#ctor(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,Microsoft.Build.Tasks.ComReferenceInfo,System.String)">
            <summary>
            Internal constructor
            </summary>
            <param name="taskLoggingHelper">task logger instance used for logging</param>
            <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
            <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
            <param name="itemName">reference name (for better logging experience)</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComReference.ReferenceInfo">
            <summary>
            various data for this reference (type lib attrs, name, path, ITypeLib pointer etc)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComReference.ItemName">
            <summary>
            item name as it appears in the project file
            (used for logging purposes, we use the actual typelib name for interesting operations)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComReference.Log">
            <summary>
            task used for logging messages
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComReference.Silent">
            <summary>
            True if this class should only log errors, but no messages or warnings.  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComReference.Ado27Installed">
            <summary>
            lazy-init property, returns true if ADO 2.7 is installed on the machine
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComReference.Ado27ErrorMessage">
            <summary>
            Error message if Ado27 is not installed on the machine (usually something like "type lib not registered")
            Only contains valid data if ADO 2.7 is not installed and Ado27Installed was called before
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.UniqueKeyFromTypeLibAttr(System.Runtime.InteropServices.ComTypes.TYPELIBATTR)">
            <summary>
            Given a TYPELIBATTR structure, generates a key that can be used in hashtables to identify it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.AreTypeLibAttrEqual(System.Runtime.InteropServices.ComTypes.TYPELIBATTR,System.Runtime.InteropServices.ComTypes.TYPELIBATTR)">
            <summary>
            Compares two TYPELIBATTR structures
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.GetTypeLibAttrForTypeLib(System.Runtime.InteropServices.ComTypes.ITypeLib@,System.Runtime.InteropServices.ComTypes.TYPELIBATTR@)">
            <summary>
            Helper method for retrieving type lib attributes for the given type lib
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.GetTypeAttrForTypeInfo(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Runtime.InteropServices.ComTypes.TYPEATTR@)">
            <summary>
            Helper method for retrieving type attributes for a given type info
            </summary>
            <param name="typeInfo"></param>
            <param name="typeAttr"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.GetVarDescForVarIndex(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Int32,System.Runtime.InteropServices.ComTypes.VARDESC@,System.IntPtr@)">
            <summary>
            Helper method for retrieving type attributes for a given type info
            This method needs to also return the native pointer to be released when we're done with our VARDESC.
            It's not really possible to copy everything to a managed struct and then release the ptr immediately
            here, since VARDESCs contain other native pointers we may need to access.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.GetFuncDescForDescIndex(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Int32,System.Runtime.InteropServices.ComTypes.FUNCDESC@,System.IntPtr@)">
            <summary>
            Helper method for retrieving the function description structure for the given function index.
            This method needs to also return the native pointer to be released when we're done with our FUNCDESC.
            It's not really possible to copy everything to a managed struct and then release the ptr immediately
            here, since FUNCDESCs contain other native pointers we may need to access.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.GetTypeLibNameForITypeLib(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,System.Runtime.InteropServices.ComTypes.ITypeLib,System.String,System.String@)">
            <summary>
            Gets the name of given type library. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.GetTypeLibNameForTypeLibAttrs(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,System.Runtime.InteropServices.ComTypes.TYPELIBATTR,System.String@)">
            <summary>
            Gets the name of given type library.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.StripTypeLibNumberFromPath(System.String,Microsoft.Build.Shared.FileExists)">
            <summary>
            Strips type library number from a type library path (for example, "ref.dll\2" becomes "ref.dll")
            </summary>
            <param name="typeLibPath">type library path with possible typelib number appended to it</param>
            <returns>proper file path to the type library</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.GetPathOfTypeLib(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,System.Runtime.InteropServices.ComTypes.TYPELIBATTR@,System.String@)">
            <summary>
            Gets the type lib path for given type lib attributes(reused almost verbatim from vsdesigner utils code)
            NOTE:  If there's a typelib number at the end of the path, does NOT strip it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.RemapAdoTypeLib(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,System.Runtime.InteropServices.ComTypes.TYPELIBATTR@)">
            <summary>
            Tries to remap an ADO type library to ADO 2.7. If the type library passed in is an older ADO tlb,
            then remap it to ADO 2.7 if it's registered on the machine (!). Otherwise don't modify the typelib.
            Returns true if the type library passed in was successfully remapped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReference.FindExistingWrapper(Microsoft.Build.Tasks.ComReferenceWrapperInfo@,System.DateTime)">
            <summary>
            Finds an existing wrapper for the specified component
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ComReferenceInfo">
            <summary>
            Internal class representing information about a COM reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.typeLibPointer">
            <summary>
            ITypeLib pointer 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.attr">
            <summary>
            type library attributes for the reference. Taken from the task item itself or type library if
            reference is specified as file on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.typeLibName">
            <summary>
            type library name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.strippedTypeLibPath">
            <summary>
            path to the reference, with typelibrary number stripped, if any (so ref1.dll\2 becomes ref1.dll).
            The full path is only used for loading the type library, and it's not necessary 
            to do it after the interface pointer is cached in this object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.fullTypeLibPath">
            <summary>
            When using TlbImp.exe, we need to make sure that we keep track of the non-stripped typelib path, 
            because that's what we need to pass to TlbImp.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.taskItem">
            <summary>
            reference to the original ITaskItem, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.primaryOfAxImpRef">
            <summary>
            Path to the resolved reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.resolvedWrapper">
            <summary>
            The wrapper that resulted from resolving the COM reference.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.dependentWrapperPaths">
            <summary>
            List of the paths to COM wrapper assemblies that this reference is dependent upon. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ComReferenceInfo.referencePathItem">
            <summary>
            Reference to the ITaskItem generated from the resolved reference, if any. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceInfo.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceInfo.#ctor(Microsoft.Build.Tasks.ComReferenceInfo)">
            <summary>
            Construct a new ComReferenceInfo copying all state from the given ComReferenceInfo instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceInfo.InitializeWithTypeLibAttrs(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,System.Runtime.InteropServices.ComTypes.TYPELIBATTR,Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            Initialize the object with type library attributes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceInfo.InitializeWithPath(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,System.String,Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            Initialize the object with a type library path 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceInfo.GetTypeLibId(Microsoft.Build.Utilities.TaskLoggingHelper)">
            <summary>
            A unique id string of this reference, it's either the item spec or (in the case of a dependency ref)
            guid and version from typelib attributes
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ComReferenceInfo.SourceItemSpec">
            <summary>
            Get the source item, if available. Null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceInfo.ReleaseTypeLibPtr">
            <summary>
            Release the COM ITypeLib pointer for this reference
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ComReferenceItemMetadataNames">
            <summary>
            Predefined XML attributes of a ComReference Item.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ComReferenceResolutionException">
            <summary>
            Internal exception thrown when there's an unrecoverable failure resolving a COM reference and we should 
            move on to the next one, if it makes sense.
            </summary>
            <remarks>
            WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
            promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
            without following certain special FX guidelines, can break both forward and backward compatibility
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceResolutionException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceResolutionException.#ctor(System.Exception)">
            <summary>
            Constructor that allows to preserve the original exception information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializing constructor. It should not be necessary if everything goes well, but if it doesn't
            then we don't want to crash when trying to deserialize the uncaught exception into another AppDomain.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Microsoft.Build.Tasks.ComReferenceTypes">
            <summary>
            Predefined typelib wrapper types.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceTypes.IsTlbImp(System.String)">
            <summary>
            returns true is refType equals tlbimp
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceTypes.IsAxImp(System.String)">
            <summary>
            returns true is refType equals aximp
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceTypes.IsPia(System.String)">
            <summary>
            returns true is refType equals pia
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ComReferenceTypes.IsPiaOrTlbImp(System.String)">
            <summary>
            returns true if refType equals primaryortlbimp, which is basically an unknown reference type
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ComReferenceWrapperInfo">
            <summary>
            Class containing info about wrapper location, used for caching.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.FindInvalidProjectReferences">
            <summary>
            Returns the reference assembly paths to the various frameworks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FindInvalidProjectReferences.s_platformMonikerFormat">
            <summary>
             Regex for breaking up the platform moniker
             Example: XNA, Version=8.0
             </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FindInvalidProjectReferences.ReferencePlatformMonikerMetadata">
            <summary>
            Reference moniker metadata
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FindInvalidProjectReferences.PlatformSimpleNameGroup">
            <summary>
            SimpleName group
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.FindInvalidProjectReferences.PlatformVersionGroup">
            <summary>
            Version group
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences">
            <summary>
            List of Platform monikers for each referenced project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion">
            <summary>
            Target platform version of the current project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier">
            <summary>
            Target platform identifier of the current project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.FindInvalidProjectReferences.InvalidReferences">
            <summary>
            Invalid references to be unresolved 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute">
            <summary>
            Execute the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.FindInvalidProjectReferences.ParseMoniker(System.String,System.String@,System.Version@)">
            <summary>
            Take the identity and the version of a platform moniker
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.FormatUrl">
            <summary>
            Formats a url by canonicalizing it (i.e. " " -> "%20") and transforming "localhost" to "machinename".
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateApplicationManifest">
            <summary>
            Generates an application manifest for ClickOnce projects.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateBootstrapper">
            <summary>
            Generates a bootstrapper for ClickOnce deployment projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GenerateBootstrapper.Execute">
            <summary>
            Generate the bootstrapper.
            </summary>
            <returns> Return true on success, false on failure.</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateDeploymentManifest">
            <summary>
            Generates a deploy manifest for ClickOnce projects.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateManifestBase">
            <summary>
            Base class for all manifest generation tasks.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GenerateTrustInfo">
            <summary>
            This task generates the application trust from the base manifest
            and the TargetZone and ExcludedPermissions properties.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetFrameworkSdkPath">
            <summary>
            Returns paths to the frameworks SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.Path">
            <summary>
            The path to the latest .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion20Path">
            <summary>
            The path to the v2.0 .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion35Path">
            <summary>
            The path to the v3.5 .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion40Path">
            <summary>
            The path to the v4.0 .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion45Path">
            <summary>
            The path to the v4.5 .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion451Path">
            <summary>
            The path to the v4.5.1 .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion46Path">
            <summary>
            The path to the v4.6 .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion461Path">
            <summary>
            The path to the v4.6.1 .NET SDK if it could be found. It will be String.Empty if the SDK was not found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetFrameworkSdkPath.Execute">
            <summary>
            Get the SDK.
            </summary>
            <returns>true</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetInstalledSDKLocations">
            <summary>
             Gathers the list of installed SDKS in the registry and on disk and outputs them into the project
             so they can be used during SDK reference resolution and RAR for single files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetInstalledSDKLocations.DirectoryRootsMetadataName">
            <summary>
            Metadata name for directory roots on installed SDK items
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName">
            <summary>
            Metadata name for extension directory roots on installed SDK items
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKNameMetadataName">
            <summary>
            Metadata name for SDK Name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetInstalledSDKLocations.RegistryRootMetadataName">
            <summary>
            Metadata name for registry roots on installed SDK items
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetInstalledSDKLocations.StaticSDKCacheKey">
            <summary>
            Key into our build cache
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetInstalledSDKLocations._targetPlatformVersion">
            <summary>
            Target platform version
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetInstalledSDKLocations._targetPlatformIdentifier">
            <summary>
            Target platform identifier
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion">
            <summary>
            Platform version we are targeting
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier">
            <summary>
            Platform identifier we are targeting
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot">
            <summary>
            Root registry root to look for SDKs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots">
            <summary>
            Root directory on disk to look for SDKs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots">
            <summary>
            Root directories on disk to look for new style extension SDKs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound">
            <summary>
            When set to true, the task will produce a warning if there were no SDKs found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs">
            <summary>
            Set of items that represent all of the installed SDKs found in the SDKDirectory and SDKRegistry roots.
            The itemspec is the SDK install location. There is a piece of metadata called SDKName which contains the name of the SDK.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute">
            <summary>
            Get the SDK.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetSDKReferenceFiles">
            <summary>
            Resolves an SDKReference to a full path on disk
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._resolvedSDKReferences">
            <summary>
            Set of resolvedSDK references which we will use to find the reference assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._resolvedReferences">
            <summary>
            Set of resolved reference assemblies. This removes any duplicate ones between sdks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._resolveRedistFiles">
            <summary>
            Set of resolved reference assemblies. This removes any duplicate ones between sdks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._referenceExtensions">
            <summary>
            Set of reference assembly extensions to look for.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._cacheFileForSDKs">
            <summary>
            Dictionary of SDK Identity to the cache file that contains the file information for it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._exceptions">
            <summary>
            Set of exceptions which were thrown while reading or writing to the cache file, this needs to be thread safe since TPL code will add exceptions into this structure at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._getAssemblyName">
            <summary>
            Delegate to get the assembly name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._getRuntimeVersion">
            <summary>
            Get the image runtime version from a file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._fileExists">
            <summary>
            File exists delegate
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._synchronous">
            <summary>
            When false, allow fire-and-forget background work.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles._cacheFilePath">
            <summary>
            Folder where the cache files are written to
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath">
            <summary>
            Path where the cache files should be stored
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences">
            <summary>
            Resolved SDK references which we will get the reference assemblies from.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions">
            <summary>
            Extensions which should be considered reference files, we will look for 
            the files in the order they are specified in the array.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList">
            <summary>
            Should the references found as part of resolving the sdk be logged.
            The default is true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList">
            <summary>
            Should the redist files found as part of resolving the sdk be logged.
            The default is true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier">
            <summary>
            The targetted SDK identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion">
            <summary>
            The targeted SDK version.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier">
            <summary>
            The targetted platform identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion">
            <summary>
            The targeted platform version.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.References">
            <summary>
            Resolved reference items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles">
            <summary>
            Resolved redist files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles">
            <summary>
            Files that need to be copied locally, this is the reference assemblies and the xml intellisense files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning">
            <summary>
            Should conflicts between redist files within an SDK be logged as a message or a warning.
            The default is to log them as a message.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning">
            <summary>
            Should conflicts between redist files across different referenced SDKs be logged as a message or a warning.
            The default is to log them as a warning.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning">
            <summary>
            Should conflicts between reference files within an SDK be logged as a message or a warning.
            The default is to log them as a message.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning">
            <summary>
            Should conflicts between reference files across different referenced SDKs be logged as a message or a warning.
            The default is to log them as a warning.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions">
            <summary>
            Should we log exceptions which were hit when the cache file is being read and written to
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute">
            <summary>
            Execute the task
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute(Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,Microsoft.Build.Shared.FileExists,System.Boolean)">
            <summary>
            Execute the task
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.FindRedistFiles(Microsoft.Build.Framework.ITaskItem,System.String,System.String,System.String)">
            <summary>
            Find the redist files
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.FindReferences(Microsoft.Build.Framework.ITaskItem,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Find references for the sdk
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.GenerateOutputItems">
            <summary>
            Generate the output groups
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.GatherReferenceAssemblies(System.Collections.Generic.HashSet{Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly},Microsoft.Build.Framework.ITaskItem,System.String,Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo)">
            <summary>
            Gather the reference assemblies from the referenceassembly directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.GatherRedistFiles(System.Collections.Generic.HashSet{Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile},Microsoft.Build.Framework.ITaskItem,System.String,Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo)">
            <summary>
            Gather the redist files from from the redist directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.PopulateReferencesForSDK(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ITaskItem})">
            <summary>
            Gather the contents of all of the SDK into a cache file and save it to disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.GetReferencePathsFromManifest(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Get the referenced file names from the SDK's manifest if applicable- may return null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly">
            <summary>
            Class which represents a resolved reference assembly
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly._copyLocal">
            <summary>
             Is the reference copy local
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.#ctor(Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.FileName">
            <summary>
            What is the file name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.AssemblyLocation">
            <summary>
            What is the location of the assembly on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.CopyLocal">
            <summary>
            Is the assembly copy local or not.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.SDKReferenceItem">
            <summary>
            Original resolved SDK reference item passed in.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.Equals(System.Object)">
            <summary>
            Override object equals to use the equals redist in this object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.GetHashCode">
            <summary>
            Override get hash code
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly.Equals(Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedReferenceAssembly)">
            <summary>
            Are two resolved references items Equal
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile">
            <summary>
            Class which represents a resolved redist file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.#ctor(Microsoft.Build.Framework.ITaskItem,System.String,System.String,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.RedistFile">
            <summary>
             What is the file name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.TargetPath">
            <summary>
            What is the targetPath for the redist file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.TargetRoot">
            <summary>
            What is the root directory of the target path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.SDKReferenceItem">
            <summary>
            Original resolved SDK reference item passed in.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.Equals(System.Object)">
            <summary>
            Override object equals to use the equals redist in this object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.GetHashCode">
            <summary>
            Override get hash code
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile.Equals(Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedRedistFile)">
            <summary>
            Are two resolved references items Equal
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache">
            <summary>
            Methods which are used to save and read the cache files per sdk from and to disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache._exceptionMessages">
            <summary>
             Thread-safe queue which contains exceptions throws during cache file reading and writing.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache._getAssemblyName">
            <summary>
            Delegate to get the assembly name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache._getRuntimeVersion">
            <summary>
            Get the image runtime version from a file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache._fileExists">
            <summary>
            File exists delegate
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache._cacheFileDirectory">
            <summary>
            Location for the cache files to be written to
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.#ctor(System.Collections.Concurrent.ConcurrentQueue{System.String},System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion,Microsoft.Build.Shared.FileExists)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.LoadAssemblyListFromCacheFile(System.String,System.String)">
            <summary>
            Load reference assembly information from the cache file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.SaveAssemblyListToCacheFile(System.Object)">
            <summary>
            Save assembly reference information to the cache file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.GetCacheFileInfoFromSDK(System.String,System.String[])">
            <summary>
            Get references from the paths provided, and populate the provided cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.PopulateReferencesDictionaryFromManifestPaths(System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Collections.Generic.List{System.String}},System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo},System.String[])">
            <summary>
            Populate an existing assembly dictionary for the given framework moniker utilizing provided manifest reference information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.PopulateReferencesDictionaryFromPaths(System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Collections.Generic.List{System.String}},System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Populate an existing assembly dictionary for the given framework moniker
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.PopulateRedistDictionaryFromPaths(System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Collections.Generic.List{System.String}},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Populate an existing assembly dictionary for the given framework moniker
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.IsAssemblyListCacheFileUpToDate(System.String,System.String,System.String)">
            <summary>
            Is the assembly list cache file up to date. 
            This is done by comparing the last write time of the cache file to the last write time of the code.
            If our code is newer than the last write time of the cache file then there may be some different serialization used so we should say it is out of date and just regenerate it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.GetSDKReferenceInfo(System.String)">
            <summary>
            Generate an SDKReferenceInfo object
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.GetCacheFileName(System.String,System.String,System.String)">
            <summary>
            Generate cache file name from sdkIdentity, sdkRoot and suffixHash.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.GetAllRedistDirectories(System.String)">
            <summary>
            Get all redist subdirectories under the given path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKFilesCache.GetAllReferenceDirectories(System.String)">
            <summary>
            Get all reference subdirectories under the given path
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo">
            <summary>
            Class to contain some identity information about a file in an sdk
            </summary>
            <remarks>This is a serialization format. Do not change member naming.</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo.#ctor(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo.FusionName">
            <summary>
            The fusionName
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo.IsWinMD">
            <summary>
            Is the file a winmd or not
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo.IsManagedWinmd">
            <summary>
            Is the file a managed winmd or not
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo.ImageRuntime">
            <summary>
            What is the imageruntime information on it.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo">
            <summary>
            Structure that contains the on disk representation of the SDK in memory.
            </summary>
            <remarks>This is a serialization format. Do not change member naming.</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo.#ctor(System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Build.Tasks.GetSDKReferenceFiles.SdkReferenceInfo},System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Collections.Generic.List{System.String}},System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo.PathToReferenceMetadata">
            <summary>
            A dictionary which maps a file path to a structure that contain some metadata information about that file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo.DirectoryToFileList">
            <summary>
            Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo.Hash">
            <summary>
            Hashset
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.GetSDKReferenceFiles.SaveContext">
            <summary>
            This class represents the context information used by the background cache serialization thread.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.GetSDKReferenceFiles.SaveContext.#ctor(System.String,System.String,Microsoft.Build.Tasks.GetSDKReferenceFiles.SDKInfo)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SaveContext.SdkIdentity">
            <summary>
            Identity of the sdk
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SaveContext.SdkRoot">
            <summary>
            Root path of the sdk
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.GetSDKReferenceFiles.SaveContext.Assemblies">
            <summary>
            Assembly metadata information
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.IComReferenceResolver">
            <summary>
            Callback interface for COM references to resolve their dependencies
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.IComReferenceResolver.ResolveComClassicReference(System.Runtime.InteropServices.ComTypes.TYPELIBATTR,System.String,System.String,System.String,Microsoft.Build.Tasks.ComReferenceWrapperInfo@)">
             <summary>
             Resolves a COM classic reference given the type library attributes and the type of wrapper to use.
             If wrapper type is not specified, this method will first look for an existing reference in the project,
             fall back to looking for a PIA and finally try to generate a regular tlbimp wrapper.
            
             This method is available for references to call back to resolve their dependencies
             </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.IComReferenceResolver.ResolveNetAssemblyReference(System.String,System.String@)">
             <summary>
             Resolves a .NET assembly reference using the list of resolved managed references supplied to the task.
            
             This method is available for references to call back to resolve their dependencies
             </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.IComReferenceResolver.ResolveComAssemblyReference(System.String,System.String@)">
             <summary>
             Resolves a COM wrapper assembly reference based on the COM references resolved so far. This method is necessary
             for Ax wrappers only, so all necessary references will be resolved by then(since we resolve them in
             the following order: pia, tlbimp, aximp)
            
             This method is available for references to call back to resolve their dependencies
             </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1">
            <summary>
            Create an RCW for the current context/apartment. 
            This improves performance of cross apartment calls as the CLR will only
            cache marshalled pointers for an RCW created in the current context.
            </summary>
            <typeparam name="T">Type of the RCW object</typeparam>
        </member>
        <member name="F:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1._rcwForCurrentCtx">
            <summary>
            The last RCW that was created for the current context.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1._shouldReleaseRCW">
            <summary>
            Indicates if we created the RCW and therefore need to release it's com reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1.#ctor(`0)">
            <summary>
            Constructor creates the new RCW in the current context.
            </summary>
            <param name="rcw">The RCW created in the original context.</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1.RCW">
            <summary>
            Call this helper if your managed object is really an RCW to a COM object
            and that COM object was created in a different apartment from where it is being accessed
            </summary>
            <param name="rcw">An RCW object created in the original apartment context.</param>
            <returns>A new RCW created in the current apartment context</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1.Dispose">
            <summary>
            Override for IDisposable::Dispose
            </summary>
            <remarks>
            We created an RCW for the current apartment. When this object goes out of scope
            we need to release the COM object before the apartment is released (via COUninitialize)
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1.CleanupComObject">
            <summary>
            Cleanup our RCW com object references if required.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.LC">
            <summary>
            The License Compiler task
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.Sources">
            <summary>
            Specifies the items that contain licensed components that need to be included in the .licenses file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.OutputLicense">
            <summary>
            The name of the .licenses file, output only. It's inferred from LicenseTarget and OutputDirectory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.LicenseTarget">
            <summary>
            Specifies the executable for which the .licenses files are being generated
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.OutputDirectory">
            <summary>
            Output directory for the generated .licenses file
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.ReferencedAssemblies">
            <summary>
            Specifies the referenced components (licensed controls and possibly their dependent assemblies)
            to load when generating the .license file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.NoLogo">
            <summary>
            Suppresses the display of the startup banner
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.TargetFrameworkVersion">
            <summary>
            Targeted version of the framework (i.e. 4.5 or 2.0, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.LC.ToolName">
            <summary>
            The name of the tool to execute
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.LC.ValidateParameters">
            <summary>
            Validate the task arguments, log any warnings/errors
            </summary>
            <returns>true if arguments are corrent enough to continue processing, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.LC.GenerateFullPathToTool">
            <summary>
            Determing the path to lc.exe
            </summary>
            <returns>path to lc.exe, null if not found</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.LC.AddCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Generates arguments to be passed to lc.exe
            </summary>
            <param name="commandLine">command line builder class to add arguments to</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Generates response file with arguments for lc.exe
            Used when targeting framework version is 4.6 or later
            </summary>
            <param name="commandLine">command line builder class to add arguments to the response file</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension)">
            <summary>
            Generates command line arguments for lc.exe
            Used when targeting framework version is less than 4.6
            </summary>
            <param name="commandLine">command line builder class to add arguments to the command line</param>
        </member>
        <member name="T:Microsoft.Build.Tasks.PiaReference">
            <summary>
            COM reference wrapper class for the tlbimp tool using a PIA. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.PiaReference.FindExistingWrapper(Microsoft.Build.Tasks.ComReferenceWrapperInfo@,System.DateTime)">
            <summary>
            Gets the resolved assembly path for the typelib wrapper.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.RegisterAssembly">
            <summary>
            Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code doesn't actually call the exe).
            </summary>
            <comment>ITypeLibExporterNotifySink is necessary for the ITypeLibConverter.ConvertAssemblyToTypeLib call.</comment>
        </member>
        <member name="P:Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile">
            <summary>
            The cache file for Register/UnregisterAssembly. Necessary for UnregisterAssembly to do the proper clean up.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RegisterAssembly.Execute">
            <summary>
            Task entry point
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind,System.Int32,System.String)">
            <summary>
            Callback method for reporting type library export events
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RegisterAssembly.ResolveRef(System.Reflection.Assembly)">
            <summary>
             Callback method for finding type libraries for given assemblies. If we are here, it means
             the type library we're looking for is not in the current directory and it's not registered.
             Currently we assume that all dependent type libs are already registered.
            </summary>
            <comment>
             In theory, we could automatically register dependent assemblies for COM interop and return
             a newly created typelib here. However, one danger of such approach is the following scenario:
             The user creates several projects registered for COM interop, all of them referencing assembly A.
             The first project that happens to be built will register assembly A for COM interop, creating
             a type library in its output directory and registering it. The other projects will then refer to that
             type library, since it's already registered. If then for some reason the first project is deleted
             from disk, the typelib for assembly A goes away too, and all the other projects, built five years ago,
             suddenly stop working.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Tasks.RegisterAssembly.Register(System.String,System.String)">
            <summary>
            Helper registration method
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.RegisterAssembly.ExportTypeLib(System.Reflection.Assembly,System.String)">
            <summary>
             Helper method - exports a type library for an assembly. Returns true if succeeded.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveComReferenceCache">
            <remarks>
            Stores timestamps of COM components processed in the last run. The problem here is that installing/uninstalling
            COM components does not update their timestamps with the current time (for a good reason). So if you revert to
            an earlier revision of a COM component, its timestamp can go back in time and we still need to regenerate its
            wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if 
            they are different, we regenerate the wrapper.
            
            This is an on-disk serialization format, don't change field names or types or use readonly.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveComReferenceCache.componentTimestamps">
            <summary>
            Component timestamps. 
            Key: Component path on disk
            Value: DateTime struct
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReferenceCache.Dirty">
            <summary>
            indicates whether the cache contents have changed since it's been created
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReferenceCache.#ctor(System.String,System.String)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveComReferenceCache.ToolPathsMatchCachePaths(System.String,System.String)">
            <summary>
            Compares the tlbimp and aximp paths to what the paths were when the cache was created
            If these are different return false.
            </summary>
            <returns>True if both paths match what is in the cache, false otherwise</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveComReferenceCache.Item(System.String)">
            <summary>
            Gets or sets the timestamp associated with the specified component file
            </summary>
            <param name="componentPath"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.Build.Tasks.ResolveManifestFiles" -->
        <member name="T:Microsoft.Build.Tasks.ResolveSDKReference">
            <summary>
            Resolves an SDKReference to a full path on disk
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.s_sdkReferenceFormat">
            <summary>
             Regex for breaking up the sdk reference include into pieces.
             Example: XNA, Version=8.0
             </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKsimpleNameGroup">
            <summary>
            SimpleName group
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKVersionGroup">
            <summary>
            Version group
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.CommaSpaceDelimiter">
            <summary>
            Delimiter used to delimit the dependent sdk's in the warning message
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.s_appxSplitChar">
            <summary>
            Split char for the appx attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKName">
            <summary>
            SDKName
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKPlatformVersion">
            <summary>
            PlatformVersion
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.s_defaultTargetPlatformVersion">
            <summary>
            Default target platform version
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference._sdkReferences">
            <summary>
             Set of sdk references to resolve to paths on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference._installedSDKs">
            <summary>
            The list of installed SDKs the location of the SDK, the SDKName metadata is the SDKName.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference._targetPlatformVersion">
            <summary>
            stores value of TargetPlatformVersion property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference._targetPlatformIdentifier">
            <summary>
            Stores TargetPlatform property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference._projectName">
            <summary>
            Stores ProjectName property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference._runtimeReferenceOnlyDependenciesByName">
            <summary>
            Stores dictionary with runtime only reference dependencies
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences">
            <summary>
            Set of SDK References to resolve to paths on disk
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs">
            <summary>
            The list of installed SDKs the location of the SDK, the SDKName metadata is the SDKName.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier">
            <summary>
            TargetPlatform used in warning/error messages
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.ProjectName">
            <summary>
            ProjectName used in warning/error messages
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion">
            <summary>
            TargetPlatformVersion property used to filter SDKs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.References">
            <summary>
            Reference may be passed in so their SDKNames can be resolved and then sdkroot paths can be tacked onto the reference
            so RAR can find the assembly correctly in the sdk location.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies">
            <summary>
            List of disallowed dependencies passed from the targets file (deprecated)
            For instance "VCLibs 11" should be disallowed in projects targeting Win 8.1 or higher.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies">
            <summary>
            List of dependencies passed from the targets file that will have the metadata RuntimeReferenceOnly set as true. 
            For instance "VCLibs 11" should have such a metadata set to true in projects targeting Win 8.1 or higher.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration">
            <summary>
            Configuration for SDK's which are resolved
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture">
            <summary>
            Architecture of the SDK's we are targeting
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion">
            <summary>
            Enables warning when MaxPlatformVersion is not present in the manifest and the ESDK platform version (from its path) 
            is different than the target platform version (from the project)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings">
            <summary>
            Should problems resolving SDKs be logged as a warning or an error.
            If the resolution problem is logged as an error the build will fail.
            If the resolution problem is logged as a warning we will warn and continue.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit">
            <summary>
            The prefer32bit flag used during the build
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences">
            <summary>
            Resolved SDK References
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformAsVersion">
            <summary>
            Version object containing target platform version
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.Execute">
            <summary>
            Execute the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.AddMetadataToReferences(Microsoft.Build.Utilities.TaskLoggingHelper,System.Collections.Generic.HashSet{Microsoft.Build.Tasks.ResolveSDKReference.SDKReference},System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Add metadata to a specified subset of reference items
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.VerifySDKDependsOn(Microsoft.Build.Utilities.TaskLoggingHelper,System.Collections.Generic.HashSet{Microsoft.Build.Tasks.ResolveSDKReference.SDKReference})">
            <summary>
            Verify the dependencies SDKs have for each other
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.GetUnresolvedDependentSDKs(System.Collections.Generic.HashSet{Microsoft.Build.Tasks.ResolveSDKReference.SDKReference},System.Collections.Generic.List{System.String})">
            <summary>
            Get a set of unresolved SDK identities
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.ParseDependsOnSDK(System.String)">
            <summary>
            Parse out the sdk identities
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.ParseSDKReference(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Parse the item include of the SDKReference item into its simple name and version parts.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.ParseSDKReference(System.String,System.String@,System.String@)">
            <summary>
            Take the identity of an sdk and use a regex to parse out the version and simple name
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.LogResolution(Microsoft.Build.Tasks.ResolveSDKReference.SDKReference)">
            <summary>
            Log where we searched ect, for sdk references and if we found them or not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.LogErrorOrWarning(System.Tuple{System.String,System.Object[]})">
            <summary>
            Log an error or warning depending on the LogErrorsAsWarnigns propertry.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference">
            <summary>
            This class holds the sdk reference task item and the split versions of the simple name and version.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.s_supportedArchitecturesSplitChars">
            <summary>
            Delimiter for supported architectures
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.SupportedArchitectureJoinDelimiter">
            <summary>
            Delimiter used to delimit the supported architectures in the error message
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.NeutralArch">
            <summary>
            Neutral architecture name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.X64Arch">
            <summary>
            Neutral architecture name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.X86Arch">
            <summary>
            X86 architecture name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ARMArch">
            <summary>
            ARM architecture name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.AnyCPUArch">
            <summary>
            ANY CPU architecture name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.TargetedSDKArchitecture">
            <summary>
            TargetedSDKArchitecture metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.TargetedSDKConfiguration">
            <summary>
            TargetedSDKConfiguration metadata name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.Retail">
            <summary>
            Retail config name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.Debug">
            <summary>
            Debug config name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference._sdkManifestPath">
            <summary>
            Path to the sdk manifest file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference._sdkManifest">
            <summary>
            SDKManifest object encapsulating all the information contained in the manifest xml file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference._supportsMultipleVersions">
            <summary>
            What should happen if this sdk is resolved with other sdks of the same productfamily or same sdk name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference._prefer32BitFromProject">
            <summary>
            Value of the prefer32Bit property from the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.#ctor(Microsoft.Build.Framework.ITaskItem,System.String,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ReferenceItem">
            <summary>
             Sdk reference item passed in from the build
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.SimpleName">
            <summary>
            Parsed simple name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.Version">
            <summary>
            Parsed version.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ResolvedPath">
            <summary>
            Resolved full path to the root of the sdk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.Resolved">
            <summary>
            Has the reference been resolved
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ResolutionErrors">
            <summary>
            Messages which may be warnings or errors depending on the logging setting.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ResolutionWarnings">
            <summary>
            Warning messages only
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.StatusMessages">
            <summary>
            Messages generated during resolution
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.SDKName">
            <summary>
            SDKName, this is a formatted name based on the SimpleName and the Version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ResolvedItem">
            <summary>
            Resolved item which will be output by the task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.SDKType">
            <summary>
            SDKType found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.TargetPlatform">
            <summary>
            The target platform in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.TargetPlatformMinVersion">
            <summary>
            The target platform min version in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.TargetPlatformVersion">
            <summary>
            The target platform max version in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.DisplayName">
            <summary>
            DisplayName found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.SupportPrefer32Bit">
            <summary>
            Support Prefer32bit found in the sdk manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.CopyRedistToSubDirectory">
            <summary>
            CopyRedistToSubDirectory specifies where the redist files should be copied to relative to the root of the package.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ProductFamilyName">
            <summary>
            ProductFamilyName specifies the product family for the SDK. This is offered up as metadata on the resolved sdkreference and is used to detect sdk conflicts.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.SupportsMultipleVersions">
            <summary>
            SupportsMultipleVersions specifies what should happen if multiple versions of the product family or sdk name are detected
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.SupportedArchitectures">
            <summary>
            Supported Architectures is a semicolon delimited list of architectures that the SDK supports.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.DependsOnSDK">
            <summary>
            DependsOnSDK is a semicolon delimited list of SDK identities that the SDK requires be resolved in order to function.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.MaxPlatformVersion">
            <summary>
            MaxPlatformVersion as in the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.MinOSVersion">
            <summary>
            MinOSVersion as in the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.MaxOSVersionTested">
            <summary>
            MaxOSVersionTested as in the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.MoreInfo">
            <summary>
            MoreInfo as in the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.FrameworkIdentitiesFromManifest">
            <summary>
            What ever framework identities we found in the manifest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.FrameworkIdentity">
            <summary>
            The frameworkIdentity for the sdk, this may be a single name or a | delimited name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.PlatformIdentity">
            <summary>
            PlatformIdentity if it exists in the appx manifest for this sdk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.AppxLocationsFromManifest">
            <summary>
            Whatever appx locations we found in the manifest
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.AppxLocation">
            <summary>
            The appxlocation for the sdk can be a single name or a | delimited list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.Resolve(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Framework.ITaskItem},System.String,System.String,System.Collections.Generic.HashSet{System.String},System.Boolean,System.Boolean,System.String,System.Version,System.String,System.Boolean)">
            <summary>
            Set the location where the reference was resolved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.Equals(System.Object)">
            <summary>
            Override object equals to use the equals implementation in this object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.GetHashCode">
            <summary>
            Override get hash code
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.Equals(Microsoft.Build.Tasks.ResolveSDKReference.SDKReference)">
            <summary>
            Are two SDKReference items Equal
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.AddResolutionErrorOrWarning(System.String,System.Object[])">
            <summary>
            Add a resolution error or warning to the reference
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.AddResolutionWarning(System.String,System.Object[])">
            <summary>
            Add a resolution warning to the reference
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.GetItemMetadataTrimmed(Microsoft.Build.Framework.ITaskItem,System.String)">
            <summary>
            Get a piece of metadata off an item and make sureit is trimmed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.GetSDKManifestAttributes">
            <summary>
            After resolving a reference we need to check to see if there is a SDKManifest file in the root directory and if there is we need to extract the frameworkidentity.
            We ignore other attributes to leave room for expansion of the file format.
            
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.ParseSupportMultipleVersions(System.String)">
            <summary>
            Parse the multipleversions string and set supportsMultipleVersions if it can be parsed correctly.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.CreateResolvedReferenceItem(System.String,System.String,System.Collections.Generic.HashSet{System.String},System.String,System.Version,System.Version,System.String,System.Boolean)">
            <summary>
            Create a resolved output item which contains the path to the SDK and the associated metadata about it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.FindFrameworkIdentity(System.String)">
            <summary>
            Check to see if an FrameworkIdentity is in the list of framework identities found in the SDKManifest.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.ResolveSDKReference.SDKReference.AddStatusMessage(System.String,System.Object[])">
            <summary>
            Keep track of messages which are status information about resolving this reference. We want to print it out in a nicer format at the end of resolution.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.SdkToolsPathUtility">
            <summary>
            This class will provide the ability for classes given an SdkToolsPath and their tool name to find that tool. 
            The tool will be looked for either under the SDKToolPath passed into the task or as fallback to look for the toolname using the toolslocation helper. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.SdkToolsPathUtility.s_fileInfoExists">
            <summary>
            Cache the file exists delegate which will determine if a file exists or not but will not eat the CAS exceptions.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.SdkToolsPathUtility.FileInfoExists">
            <summary>
            Provide a delegate which will do the correct file exists.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.SdkToolsPathUtility.GeneratePathToTool(Microsoft.Build.Shared.FileExists,System.String,System.String,System.String,Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean)">
            <summary>
            This method will take a sdkToolsPath and a toolName and return the path to the tool if it is found and exists.
            
            First the method will try and find the tool under the sdkToolsPath taking into account the current processor architecture
            If the tool could not be found the method will try and find the tool under the sdkToolsPath (which should point to the x86 sdk directory).
            
            Finally if the method has not found the tool yet it will fallback and use the toolslocation helper method to try and find the tool.
            </summary>
            <returns>Path including the toolName of the tool if found, null if it is not found</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SdkToolsPathUtility.FindSDKToolUsingToolsLocationHelper(System.String)">
            <summary>
            This method will take the toolName and use the Legacy ToolLocation helper methods to try and find the tool.
            This is a last ditch effort to find the tool when we cannot find it using the passed in SDKToolsPath (in either the x86 or processor specific directories).
            </summary>
            <param name="toolName">Name of the tool to find the sdk path for</param>
            <returns>A path to the tool or null if the path does not exist.</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.SdkToolsPathUtility.FileExists(System.String)">
             <summary>
             Provide a method which can be used with a delegate to provide a specific FileExists behavior.
            
             Use FileInfo instead of FileSystems.Default.FileExists(...) because the latter fails silently (by design) if CAS
             doesn't grant access. We want the security exception if there is going to be one.
             </summary>
             <returns>True if the file exists. False if it does not</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.SignFile">
            <summary>
            This task signs the passed in file using the Authenticode cert
            provided and optionally uses a timestamp if a URL is provided.
            It can sign ClickOnce manifests as well as exe's.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.StrongNameException">
            <summary>
            Internal exception thrown when there's an unrecoverable failure extracting public/private keys.
            </summary>
            <remarks>
            WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
            promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
            without following certain special FX guidelines, can break both forward and backward compatibility
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.StrongNameException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.StrongNameException.#ctor(System.Exception)">
            <summary>
            Constructor that allows to preserve the original exception information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.StrongNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor to implement required constructors for serialization
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.StrongNameLevel">
            <summary>
            Possible strong name states of an assembly
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.StrongNameUtils">
            <summary>
            Strong naming utilities.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.StrongNameUtils.ReadKeyFile(Microsoft.Build.Utilities.TaskLoggingHelper,System.String,System.Reflection.StrongNameKeyPair@,System.Byte[]@)">
            <summary>
            Reads contents of a key file. Reused from vsdesigner code.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.StrongNameUtils.GetStrongNameKey(Microsoft.Build.Utilities.TaskLoggingHelper,System.String,System.String,System.Reflection.StrongNameKeyPair@,System.Byte[]@)">
            <summary>
            Given a key file or container, extract private/public key data. Reused from vsdesigner code.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.StrongNameUtils.GetAssemblyStrongNameLevel(System.String)">
            <summary>
            Given an assembly path, determine if the assembly is [delay] signed or not. This code is based on similar unmanaged
            routines in vsproject and sn.exe (ndp tools) codebases.
            </summary>
            <param name="assemblyPath"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.StrongNameUtils.GetCor20HeaderRva(System.IntPtr)">
            <summary>
            Retrieves the relative virtual address of the COR20 header, given the address of the NT headers structure. The catch
            here is that the NT headers struct can be either 32 or 64 bit version, and some fields have different sizes there. We
            need to see if we're dealing with a 32bit header or a 64bit one first.
            </summary>
            <param name="ntHeadersPtr"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.TlbReference.#ctor(Microsoft.Build.Utilities.TaskLoggingHelper,System.Boolean,Microsoft.Build.Tasks.IComReferenceResolver,System.Collections.Generic.IEnumerable{System.String},Microsoft.Build.Tasks.ComReferenceInfo,System.String,System.String,System.Boolean,System.Boolean,System.String,System.String,System.Boolean,System.String,System.Boolean,System.Boolean,System.String,Microsoft.Build.Framework.IBuildEngine,System.String[])">
            <summary>
            internal constructor
            </summary>
            <param name="taskLoggingHelper">task logger instance used for logging</param>
            <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
            <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
            <param name="itemName">reference name (for better logging experience)</param>
            <param name="outputDirectory">directory we should write the wrapper to</param>
            <param name="delaySign">delay sign wrappers?</param>
            <param name="keyFile">file containing public/private keys</param>
            <param name="keyContainer">container name for public/private keys</param>
            <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using tlbimp.exe</param>
            <param name="sdkToolsPath">Path to the SDK tools directory where tlbimp.exe can be found</param>
            <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
        </member>
        <member name="P:Microsoft.Build.Tasks.TlbReference.HasTemporaryWrapper">
            <summary>
            does this reference have a temporary (i.e. written to tmp directory) wrapper?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.TlbReference.OutputDirectory">
            <summary>
            directory we should write the wrapper to
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.TlbReference.GetWrapperFileName(System.String)">
            <summary>
            Static version of GetWrapperFileName, as it really doesn't depend on
            anything specific to the class, and this way it can be called using
            TlbReference.GetWrapperFileName from outside
            </summary>
            <param name="typeLibName">The typelib to generate the wrapper name for</param>
            <returns>The appropriate wrapper filename</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.TlbReference.GetWrapperFileName(System.String,System.Boolean,System.Int16,System.Int16)">
            <summary>
            Static version of GetWrapperFileName, as it really doesn't depend on
            anything specific to the class, and this way it can be called using
            TlbReference.GetWrapperFileName from outside
            </summary>
            <param name="typeLibName">The typelib to generate the wrapper name for</param>
            <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
            <param name="majorVerNum">Major version number to append to the interop DLL's name</param>
            <param name="minorVerNum">Minor version number to append to the interop DLL's name</param>
            <returns>The appropriate wrapper filename</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.UnregisterAssembly">
            <summary>
            Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code
            doesn't actually call the exe).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.UnregisterAssembly.AssemblyListFile">
            <summary>
            The cache file for Register/UnregisterAssembly. Necessary for UnregisterAssembly to do the proper clean up.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.UnregisterAssembly.Execute">
            <summary>
            Task entry point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.UnregisterAssembly.Unregister(System.String,System.String)">
            <summary>
            Helper unregistration method
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.UpdateManifest">
            <summary>
            Updates selected properties in a manifest and resigns.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.WinMDExp">
            <summary>
            Exports a managed assembly to a windows runtime metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.References">
            <summary>
            Set of references to pass to the winmdexp tool.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.DisabledWarnings">
            <summary>
            Warning codes to disable
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.InputDocumentationFile">
            <summary>
            Input documentation file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.OutputDocumentationFile">
            <summary>
            Output documentation file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.InputPDBFile">
            <summary>
            Input PDB file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.OutputPDBFile">
            <summary>
            Output PDB file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.WinMDModule">
            <summary>
            WinMDModule to generate the WinMDFile for.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.OutputWindowsMetadataFile">
            <summary>
            Output windows metadata file  .winmd
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.SdkToolsPath">
            <summary>
            Path to the SDK directory which contains this tool
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.UTF8Output">
            <summary>
            Use output stream encoding as UTF-8.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.TreatWarningsAsErrors">
            <summary>
            Path to the SDK directory which contains this tool
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.AssemblyUnificationPolicy">
            <summary>
            The policy used for assembly unification.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.ToolName">
            <summary>
            The name of the tool to execute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.StandardOutputEncoding">
            <summary>
            Overridable property specifying the encoding of the captured task standard output stream
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.WinMDExp.StandardErrorEncoding">
            <summary>
            Overridable property specifying the encoding of the captured task standard error stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.WinMDExp.GenerateFullPathToTool">
            <summary>
            The full path of the tool to execute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.WinMDExp.ValidateParameters">
            <summary>
            Validate parameters, log errors and warnings and return true if Execute should proceed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.WinMDExp.SkipTaskExecution">
            <summary>
            Returns true if task execution is not necessary. Executed after ValidateParameters
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.CommandLineGenerator">
            <summary>
            The list of active switches in the order they should be emitted.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineGenerator._switchOrderList">
            <summary>
            The list of active switches in the order they should be emitted.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineGenerator._activeCommandLineToolSwitches">
            <summary>
            The dictionary that holds all set switches
            The string is the name of the property, and the CommandLineToolSwitch holds all of the relevant information
            i.e., switch, boolean value, type, etc.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.#ctor(Microsoft.Build.Framework.XamlTypes.Rule,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Creates a generator that generates a command-line based on the specified Xaml file and parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.#ctor(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a generator that generates a command-line based on the specified Xaml file and parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AdditionalOptions">
            <summary>
            Any additional options (as a literal string) that may have been specified in the project file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineTemplate">
            <summary>
            The template which, if set, will be used to govern formatting of the command line(s)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AlwaysAppend">
            <summary>
            The string to append to the end of a non-templated commandline.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GenerateCommandLine">
            <summary>
            Generate the command-line
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.BuildAdditionalArgs(Microsoft.Build.Utilities.CommandLineBuilder)">
            <summary>
            Appends a literal string containing the verbatim contents of any
            "AdditionalOptions" parameter. This goes last on the command
            line in case it needs to cancel any earlier switch.
            Ideally this should never be needed because the MSBuild task model
            is to set properties, not raw switches
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GenerateCommandsAccordingToType(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch,System.Boolean)">
            <summary>
            Generates a part of the command line depending on the type
            </summary>
            <remarks>Depending on the type of the switch, the switch is emitted with the proper values appended.
            e.g., File switches will append file names, directory switches will append filenames with "\" on the end</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.VerifyRequiredArgumentsArePresent(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch,System.Boolean)">
            <summary>
            Verifies that the required args are present. This function throws if we have missing required args
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.VerifyDependenciesArePresent(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Verifies that the dependencies are present, and if the dependencies are present, or if the property
            doesn't have any dependencies, the switch gets emitted
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.IsPropertySet(System.String)">
            <summary>
            Returns true if the property has a value in the list of active tool switches
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.HasSwitch(System.String)">
            <summary>
            Checks to see if the switch name is empty
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.PropertyExists(System.String)">
            <summary>
            Returns true if the property exists (regardless of whether it is 
            set or not) and false otherwise. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.EmitTaskItemArraySwitch(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Emit a switch that's an array of task items
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.EmitStringArraySwitch(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Generates the commands for the switches that may have an array of arguments
            The switch may be empty.
            </summary>
            <remarks>For stringarray switches (e.g., Sources), the CommandLineToolSwitchName (if it exists) is emitted
            along with each and every one of the file names separately (if no separator is included), or with all of the
            file names separated by the separator.
            e.g., AdditionalIncludeDirectores = "@(Files)" where Files has File1, File2, and File3, the switch
            /IFile1 /IFile2 /IFile3 or the switch /IFile1;File2;File3 is emitted (the latter case has a separator
            ";" specified)</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.PerformSwitchValueSubstition(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch,System.String)">
            <summary>
            Substitute the value for the switch into the switch value where the [value] string is found, if it exists.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.EmitIntegerSwitch(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Generates the commands for switches that have integers appended.
            </summary>
            <remarks>For integer switches (e.g., WarningLevel), the CommandLineToolSwitchName is emitted
            with the appropriate integer appended, as well as any arguments
            e.g., WarningLevel = "4" will emit /W4</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.EmitStringSwitch(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Generates the switches for switches that either have literal strings appended, or have
            different switches based on what the property is set to.
            </summary>
            <remarks>The string switch emits a switch that depends on what the parameter is set to, with and
            arguments
            e.g., Optimization = "Full" will emit /Ox, whereas Optimization = "Disabled" will emit /Od</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GatherArguments(System.String,System.Collections.Generic.ICollection{System.Tuple{System.String,System.Boolean}},System.String)">
            <summary>
            Gets the arguments required by the specified switch and collects them into a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.EmitBooleanSwitch(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Generates the switches that are nonreversible
            </summary>
            <remarks>A boolean switch is emitted if it is set to true. If it set to false, nothing is emitted.
            e.g. nologo = "true" will emit /Og, but nologo = "false" will emit nothing.</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.EmitReversibleBooleanSwitch(Microsoft.Build.Utilities.CommandLineBuilder,Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Generates the command line for switches that are reversible
            </summary>
            <remarks>A reversible boolean switch will emit a certain switch if set to true, but emit that
            exact same switch with a flag appended on the end if set to false.
            e.g., GlobalOptimizations = "true" will emit /Og, and GlobalOptimizations = "false" will emit /Og-</remarks>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GenerateStandardCommandLine(Microsoft.Build.Utilities.CommandLineBuilder,System.Boolean)">
            <summary>
            Generates the command line using the standard algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GenerateTemplatedCommandLine(Microsoft.Build.Utilities.CommandLineBuilder)">
            <summary>
            Generates the command-line using the template specified.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType">
            <summary>
            This enumeration specifies the different types for each switch in a tool
            The types are used in the documentation
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Boolean">
            <summary>
            The boolean type has a boolean value, and there are types: one that can have a flag appended on the end
            and one that can't
            e.g. GlobalOptimizations = "true" would be /Og, and GlobalOptimizations="false" would be /Og-, but
            WarnAsError = "true" would be /WX, while WarnAsError = "false" would be nothing.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Integer">
            <summary>
            The integer switch is used for properties that have several different integer values,
            and depending on the value the property is set to, appends an integer to the end 
            of a certain switch
            e.g. WarningLevel = "0" is /W0, WarningLevel = "2" is /W2
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.String">
            <summary>
            The string switch is used for two kinds of properties.
            The first is the kind that has multiple values, and has a different switch for each value
            e.g. Optimization="disabled" is /Od, "Full" is /Ox
            The second is the kind that has a literal string appended to the end of a switch.
            This type is similar to the File type, but in this case, will never get quoted.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.StringArray">
            <summary>
            The stringarray switch is used for properties that may have more 
            than one string appended to the end of the switch
            e.g. InjectPrecompiledHeaderReference = myfile is /Ylmyfile
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.ITaskItemArray">
            <summary>
            The ITaskItemArray type is used for properties that pass multiple files, but
            want to keep the metadata. Otherwise, it is used in the same way as a StringArray type.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch">
            <summary>
            The class CommandLineToolSwitch holds information about the properties
            for each task
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TypeBoolean">
            <summary>
            Boolean switch type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TypeInteger">
            <summary>
            Integer switch type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TypeITaskItemArray">
            <summary>
            ITaskItemArray switch type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TypeStringArray">
            <summary>
            String array switch type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch._booleanValue">
            <summary>
            The value for a boolean switch.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch._number">
            <summary>
            The value for the integer type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch._stringList">
            <summary>
            The list of strings for a string array.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch._taskItemArray">
            <summary>
            The list of task items for ITaskItemArray types.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.#ctor">
            <summary>
            The default constructor creates a new CommandLineToolSwitch to hold the name of
            the tool, the attributes, the dependent switches, and the values (if they exist)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.#ctor(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType)">
            <summary>
            Overloaded constructor. Takes a CommandLineToolSwitchType and sets the type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Name">
            <summary>
            The name of the parameter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IncludeInCommandLine">
            <summary>
            Specifies if this switch should be included on the command-line.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Value">
            <summary>
            The Value of the parameter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IsValid">
            <summary>
            Flag indicating if the switch is valid.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.SwitchValue">
            <summary>
            The SwitchValue of the parameter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ReverseSwitchValue">
            <summary>
            The SwitchValue of the parameter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Arguments">
            <summary>
            The arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.DisplayName">
            <summary>
            The DisplayName of the parameter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Description">
            <summary>
            The Description of the parameter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Type">
            <summary>
            The type of the switch, i.e., boolean, string, stringarray, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Reversible">
            <summary>
            Indicates whether or not the switch is emitted with a flag when false
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.AllowMultipleValues">
            <summary>
            True if multiple values are allowed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FalseSuffix">
            <summary>
            The flag to append at the end of a switch when the switch is set to false
            i.e., for all CL switches that are reversible, the FalseSuffix is "-"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TrueSuffix">
            <summary>
            The flag to append to the end of the switch when that switch is true
            i.e., In the OptimizeForWindows98, the switch is OPT, the FalseSuffix is
            :NOWIN98, and the TrueSuffix is :WIN98
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Separator">
            <summary>
            The separator indicates the characters that go between the switch and the string
            in the string typed case, the characters that go between each name for the 
            string array case, or the characters that go between the switch and the 
            appendage for the boolean case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FallbackArgumentParameter">
            <summary>
            The Fallback attribute is used to specify which property to look at in the
            case that the argument property is not set, or if the file that the 
            argument property indicates is nonexistent.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ArgumentRequired">
            <summary>
            This attribute specifies whether or not an argument attribute is required.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Required">
            <summary>
            This property indicates whether or not the property is required in the project file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Parents">
            <summary>
            This property indicates the parent of the dependency
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Overrides">
            <summary>
            This property indicates the parent of the dependency
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.BooleanValue">
            <summary>
            The BooleanValue is used for the boolean switches, and are set to true
            or false, depending on what you set it to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Number">
            <summary>
            The number is the number you wish to append to the end of integer switches
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.StringList">
            <summary>
            Returns the set of inputs to a switch
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TaskItemArray">
            <summary>
            Returns the set of inputs to a switch that is a set of ITaskItems
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.PropertyRelation">
            <summary>
            Expresses a relationship between an argument and a property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.PropertyRelation.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.PropertyRelation.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.PropertyRelation.Argument">
            <summary>
            The name of the argument
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.PropertyRelation.Value">
            <summary>
            The value.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.PropertyRelation.Required">
            <summary>
            Flag indicating if the argument is required or not.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation">
            <summary>
            Derived class indicating how to separate values from the specified argument.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.#ctor(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.Separator">
            <summary>
            The separator.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.SwitchRelations">
            <summary>
            Class describing the relationship between switches.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.RelationsParser">
            <summary>
            The RelationsParser class takes an xml file and parses the parameters for a task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.RelationsParser._isImport">
            <summary>
            A boolean to see if the current file parsed is an import file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.GeneratedTaskName">
            <summary>
            The name of the task
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.BaseClass">
            <summary>
            The base type of the class
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.Namespace">
            <summary>
            The namespace of the class
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.ResourceNamespace">
            <summary>
            Namespace for the resources
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.ToolName">
            <summary>
            The name of the executable
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.DefaultPrefix">
            <summary>
            The default prefix for each switch
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.Properties">
            <summary>
            All of the parameters that were parsed
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.DefaultSet">
            <summary>
            All of the parameters that have a default value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.FallbackSet">
            <summary>
            All of the properties that serve as fallbacks for unset properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.ErrorCount">
            <summary>
            Returns the number of errors encountered
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.RelationsParser.ErrorLog">
            <summary>
            Returns the log of errors
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.LoadFile(System.String)">
            <summary>
            The method that loads in an XML file
            </summary>
            <param name="fileName">the xml file containing switches and properties</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.LoadXml(System.String)">
            <summary>
            Overloaded method that reads from a stream to load.
            </summary>
            <param name="xml">the xml file containing switches and properties</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.ParseXmlDocument(System.String)">
            <summary>
            Parses the xml file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.ParseXmlDocument(System.Xml.XmlDocument)">
            <summary>
            Parses the loaded xml file, creates toolSwitches and adds them to the properties list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.VerifyAttributeExists(System.Xml.XmlNode,System.String)">
            <summary>
            Checks to see if the "name" attribute exists
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.VerifyNodeName(System.Xml.XmlNode)">
            <summary>
            Checks to see if the element's name is "task"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.ObtainAttributes(System.Xml.XmlNode,Microsoft.Build.Tasks.Xaml.SwitchRelations)">
            <summary>
            Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
            this parameter group
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.LogError(System.String,System.Object[])">
            <summary>
            Increases the error count by 1, and logs the error message
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.RelationsParser.IsXmlRootElement(System.Xml.XmlNode)">
            <summary>
            An XML document can have many root nodes, but usually we want the single root 
            element. Callers can test each root node in turn with this method, until it returns
            true.
            </summary>
            <param name="node">Candidate root node</param>
            <returns>true if node is the root element</returns>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.PropertyType">
            <summary>
            The type of value this property takes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.PropertyType.None">
            <summary>
            The property has no value type specified
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.PropertyType.Boolean">
            <summary>
            The property takes values of type Boolean
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.PropertyType.String">
            <summary>
            The property takes values of type String
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.PropertyType.Integer">
            <summary>
            The property takes values of type Integer
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.PropertyType.StringArray">
            <summary>
            The property takes values of type String[]
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.PropertyType.ItemArray">
            <summary>
            The property takes values of type ITaskItem[]
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.Property">
            <summary>
            The class Property holds information about the properties
            for each task
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Type">
            <summary>
            The type of the switch, i.e., boolean, stringarray, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.IncludeInCommandLine">
            <summary>
            Specifies if the property should be included on the command line.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Reversible">
            <summary>
            Specifies whether the switch is reversible (has a false suffix) or not
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.SwitchName">
            <summary>
            The name of the switch, without the / in front of it
            i.e., Od for the Optimization property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.ReverseSwitchName">
            <summary>
            The name of the reverse switch, without the / in front of it
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.FalseSuffix">
            <summary>
            The flag to append at the end of a switch when the switch is set to false
            i.e., for all CL switches that are reversible, the FalseSuffix is "-"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.TrueSuffix">
            <summary>
            The flag to append to the end of the switch when that switch is true
            i.e., In the OptimizeForWindows98, the switch is OPT, the FalseSuffix is
            :NOWIN98, and the TrueSuffix is :WIN98
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Max">
            <summary>
            The max integer value an integer typed switch can have
            An exception should be thrown in the number the user specifies is 
            larger than the max
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Min">
            <summary>
            The minimum integer value an integer typed switch can have
            An exception should be thrown in the number the user specifies is 
            less than the minimum
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Separator">
            <summary>
            The separator indicates the characters that go between the switch and the string
            in the string typed case, the characters that go between each name for the 
            string array case, or the characters that go between the switch and the 
            appendage for the boolean case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.DefaultValue">
            <summary>
            The default value for the switch to have (in the case of reversibles, true
            or false, in the case of files, a default file name)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Argument">
            <summary>
            The argument specifies which property to look for when appending a
            file name, and that property contains the actual file name.
            i.e., UsePrecompiledHeader has the argument "PrecompiledHeaderThrough"
            and the values "CreateUsingSpecific", "GenerateAuto", and "UseUsingSpecific"
            that have the switches /Yc, /YX, and /Yu.
            If PrecompiledHeaderThrough has the value "myfile", then the emitted switch
            would be /Ycmyfile, /YXmyfile, or /Yumyfile
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Fallback">
            <summary>
            The Fallback attribute is used to specify which property to look at in the
            case that the argument property is not set, or if the file that the 
            argument property indicates is nonexistent.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Required">
            <summary>
            This property whether or not the property is required in the project file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Output">
            <summary>
            This property indicates whether the property is an output, i.e., object files
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Parents">
            <summary>
            The name of the property this one is dependent on.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Name">
            <summary>
            The name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.DependentArgumentProperties">
            <summary>
            The list of switches that are dependent with this one.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Values">
            <summary>
            The different choices for each property, and the corresponding switch
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Prefix">
            <summary>
            The prefix for each switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Category">
            <summary>
            The Category for each switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.DisplayName">
            <summary>
            The Display Name for each switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Description">
            <summary>
            The Description for each switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Property.Arguments">
            <summary>
            The arguments which apply to this property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.Property.Clone">
            <summary>
            creates a new Property with the exact same information as this one
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.Value">
            <summary>
            An enum value.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Value.Name">
            <summary>
            The name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Value.SwitchName">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Value.ReverseSwitchName">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Value.Description">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Value.DisplayName">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Value.Prefix">
            <summary>
            The prefix for each switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Value.Arguments">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.Argument">
            <summary>
            An argument for the property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Argument.Parameter">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Argument.Separator">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.Argument.Required">
            <summary>
            The switch Name of the property
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.TaskGenerator">
            <summary>
            The TaskGenerator class creates code for the specified file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ToolNamePropertyName">
            <summary>
            The property for the tool name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.IsOn">
            <summary>
            IsOn
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.IsOff">
            <summary>
            IsOff
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ValueAttribute">
            <summary>
            The value attribute.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeBoolean">
            <summary>
            The boolean type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeInteger">
            <summary>
            The integer type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeString">
            <summary>
            The string type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeStringArray">
            <summary>
            The string array type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeITaskItemArray">
            <summary>
            The ITaskItemArray type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeKeyValuePairStrings">
            <summary>
            The KeyValue pair type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ImportType">
            <summary>
            The import type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeToolSwitch">
            <summary>
            The ToolSwitch.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TypeToolSwitchType">
            <summary>
            The ToolSwitch type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.SwitchToAdd">
            <summary>
            The switchToAdd field.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.DictionaryOfSwitches">
            <summary>
            The ActiveToolSwitches property.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.SwitchMap">
            <summary>
            The switchMap field.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.MultiValues">
            <summary>
            The MultiValues property.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.AddLastMethod">
            <summary>
            The AddLast method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ValidateIntegerMethod">
            <summary>
            The ValidateInteger method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ReadSwitchMapMethod">
            <summary>
            The ReadSwitchMap method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.IsPropertySetMethod">
            <summary>
            The IsPropertySet method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.IsSwitchValueSetMethod">
            <summary>
            The IsSwitchValueSet method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.AddDefaultsToActiveSwitchList">
            <summary>
            The AddDefaultsToActiveSwitchList method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.AddFallbacksToActiveSwitchList">
            <summary>
            The AddFallbacksToActiveSwitchList method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ValidateRelationsMethod">
            <summary>
            The ValidateRelations method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ReplaceToolSwitchMethod">
            <summary>
            The ReplaceToolSwitch method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.Overrides">
            <summary>
            The Overrides method.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.NameProperty">
            <summary>
            The Name property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.BooleanValueProperty">
            <summary>
            The BooleanValue property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.FileNameProperty">
            <summary>
            The FileName property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TaskItemArrayProperty">
            <summary>
            The TaskItemArray property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.StringListProperty">
            <summary>
            The StringList property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.NumberProperty">
            <summary>
            The Number property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.FalseSuffixProperty">
            <summary>
            The FalseSuffix property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.TrueSuffixProperty">
            <summary>
            The TrueSuffix property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.SeparatorProperty">
            <summary>
            The Separator property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.FallbackProperty">
            <summary>
            The FallbackArgumentParameter property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.OutputProperty">
            <summary>
            The Output property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ArgumentProperty">
            <summary>
            The ArgumentParameter property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.PropertyRequiredProperty">
            <summary>
            The Required property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ParentProperty">
            <summary>
            The Parents property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ReversibleProperty">
            <summary>
            The Reversible property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.SwitchValueProperty">
            <summary>
            The SwitchValue property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ValueProperty">
            <summary>
            The Value property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.RequiredProperty">
            <summary>
            The Required property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.DisplayNameProperty">
            <summary>
            The DisplayName property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.DescriptionProperty">
            <summary>
            The Description property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.ReverseSwitchValueProperty">
            <summary>
            The ReverseSwitchValue property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.IsValidProperty">
            <summary>
            The IsValid property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator.PropertiesTypesToIgnore">
            <summary>
            Types to ignore.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator._taskParser">
            <summary>
            The xml parsers
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskGenerator._relationsParser">
            <summary>
            The relations parser
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateComments">
            <summary>
            When set to true, the generated code will include comments.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.#ctor(Microsoft.Build.Tasks.Xaml.TaskParser)">
            <summary>
            Constructor that takes a parser
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskGenerator.Platform">
            <summary>
            The platform
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.RemovePropertiesWithIgnoredTypes(System.Collections.Generic.LinkedList{Microsoft.Build.Tasks.Xaml.Property})">
            <summary>
            Removes properties that have types we are ignoring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateCode">
            <summary>
            Generates the source code for the task in the specified file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateDefaultSetProperties(System.CodeDom.CodeTypeDeclaration)">
            <summary>
            Generates a method called "AddDefaultsToActiveSwitchList" that takes all of the properties that have 
            default values and adds them to the active switch list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateFallbacks(System.CodeDom.CodeTypeDeclaration)">
            <summary>
            Generates a method called "AddFallbacksToActiveSwitchList" that takes all of the properties that 
            are not set but have fallbacks and adds the fallbacks to the active list if they are set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateProperties(System.CodeDom.CodeTypeDeclaration,System.Collections.Generic.LinkedList{Microsoft.Build.Tasks.Xaml.Property})">
            <summary>
            Generates code for the different properties in a task
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateAssignPropertyToString(System.CodeDom.CodeMemberProperty,System.String,System.String)">
            <summary>
            Generates an assignment statment for the setters of properties, where the rhs is a string
            e.g., switchToAdd.Name = "Optimizations";
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateAssignPropertyToValue(System.CodeDom.CodeMemberProperty,System.String,System.CodeDom.CodeExpression)">
            <summary>
            Generates an assignment statment for the setters of properties, where the rhs is an expression
            e.g., switchToAdd.ArgumentRequired = true;
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateAssignToolSwitch(System.CodeDom.CodeMemberProperty,System.String,System.String,System.String)">
            <summary>
            Generates an assignment for the toolswitch, with a prefix included
            i.e., switchToAdd.ToolSwitchName = "/Ox";
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateCommon(Microsoft.Build.Tasks.Xaml.Property,System.CodeDom.CodeMemberProperty,System.String,System.Type,System.String)">
            <summary>
            This method generates all of the common cases between different property types.
            The common cases are:
            1) A new ToolSwitch object has to be created for each property
            2) The newly created ToolSwitch has to be added to the ActiveToolSwitches list
            4) For all non-empty common attributes that don't need customization, set the property
               These would be:
                name, type, separator, argument, argumentRequired, fallback, dependencies
            </summary>
            <param name="property">The property</param>
            <param name="propertyName">The CodeDom property</param>
            <param name="type">The type of the property</param>
            <param name="returnType">The return type of the property</param>
            <param name="valueName">The lhs of the assignment statement lhs = value</param>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateCommonSetStatements(System.CodeDom.CodeMemberProperty,System.String)">
            <summary>
            Generates standart set statements for properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateITaskItemArray(Microsoft.Build.Tasks.Xaml.Property,System.CodeDom.CodeMemberProperty)">
            <summary>
            Generates an ITaskItem array property type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateIntegers(Microsoft.Build.Tasks.Xaml.Property,System.CodeDom.CodeMemberProperty)">
            <summary>
            This method generates all of the switches for integer typed properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateBooleans(Microsoft.Build.Tasks.Xaml.Property,System.CodeDom.CodeMemberProperty)">
            <summary>
            This method generates the switches for all of the nonreversible properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateStrings(Microsoft.Build.Tasks.Xaml.Property,System.CodeDom.CodeMemberProperty)">
            <summary>
            This method generates all of the switches for the string type property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.ContainsCurrentPlatform(Microsoft.Build.Tasks.Xaml.Property)">
            <summary>
            Returns true if the property refers to the current platform.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.ContainsCurrentPlatform(System.String)">
            <summary>
            Returns true if the switch value refers to the current platform.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateOverrides(Microsoft.Build.Tasks.Xaml.Property,System.CodeDom.CodeMemberProperty)">
            <summary>
            This method generates overrides array 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateStringArrays(Microsoft.Build.Tasks.Xaml.Property,System.CodeDom.CodeMemberProperty)">
            <summary>
            This method generates switches for all the properties that are of type
            string array
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateToolNameProperty(System.CodeDom.CodeTypeDeclaration)">
            <summary>
            This method generates the property that returns the tool exe value set by the ToolExe property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateImports(System.CodeDom.CodeNamespace)">
            <summary>
            This method generates the code that appears at the top of each class (that imports other libraries)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateConstructor(System.CodeDom.CodeTypeDeclaration)">
            <summary>
            This method generates the default constructor for the generated task
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.GenerateRelations(System.CodeDom.CodeTypeDeclaration)">
            <summary>
            This method generates the relations which will be used at runtime to validate the command line
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.LogError(System.String,System.Object[])">
            <summary>
            Increases the error count by 1, and logs the error message
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskGenerator.SurroundWithQuotes(System.String)">
            <summary>
            Puts a string inside two quotes
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskGenerator.ErrorCount">
            <summary>
            Returns the number of errors encountered
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskGenerator.ErrorLog">
            <summary>
            Returns the log of errors
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.TaskParser">
            <summary>
            The TaskParser class takes an xml file and parses the parameters for a task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.TaskParser._switchOrderList">
            <summary>
            The ordered list of how the switches get emitted.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.GeneratedTaskName">
            <summary>
            The name of the task
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.BaseClass">
            <summary>
            The base type of the class
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.Namespace">
            <summary>
            The namespace of the class
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.ResourceNamespace">
            <summary>
            Namespace for the resources
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.ToolName">
            <summary>
            The name of the executable
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.DefaultPrefix">
            <summary>
            The default prefix for each switch
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.Properties">
            <summary>
            All of the parameters that were parsed
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.DefaultSet">
            <summary>
            All of the parameters that have a default value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.FallbackSet">
            <summary>
            All of the properties that serve as fallbacks for unset properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.SwitchOrderList">
            <summary>
            The ordered list of properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.TaskParser.ErrorLog">
            <summary>
            Returns the log of errors
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskParser.Parse(System.String,System.String)">
            <summary>
            Parse the specified string, either as a file path or actual XML content.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskParser.ParseXamlDocument(System.IO.TextReader,System.String)">
            <summary>
            Parse a Xaml document from a TextReader
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskParser.ParseXamlDocument(Microsoft.Build.Framework.XamlTypes.Rule)">
            <summary>
            Parse a Xaml document from a rule
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskParser.ParseParameterGroupOrParameter(Microsoft.Build.Framework.XamlTypes.BaseProperty,System.Collections.Generic.LinkedList{Microsoft.Build.Tasks.Xaml.Property},Microsoft.Build.Tasks.Xaml.Property,System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Tasks.Xaml.Property})">
            <summary>
            Reads in the nodes of the xml file one by one and builds the data structure of all existing properties
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskParser.ParseParameter(Microsoft.Build.Framework.XamlTypes.BaseProperty,System.Collections.Generic.LinkedList{Microsoft.Build.Tasks.Xaml.Property},Microsoft.Build.Tasks.Xaml.Property,System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Tasks.Xaml.Property})">
            <summary>
            Fills in the property data structure
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.TaskParser.ObtainAttributes(Microsoft.Build.Framework.XamlTypes.BaseProperty,Microsoft.Build.Tasks.Xaml.Property)">
            <summary>
            Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
            this parameter group
            </summary>
        </member>
        <member name="T:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask">
            <summary>
            Part of the base class for tasks generated by the Xaml task factory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask._skipResponseFileCommandGeneration">
            <summary>
            True if we returned our commands directly from the command line generation and do not need to use the
            response file (because the command-line is short enough)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask._logPrivate">
            <summary>
            The task logging helper
            </summary>
        </member>
        <member name="F:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask._commandLine">
            <summary>
            The command line for this task. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.#ctor(System.String[],System.Resources.ResourceManager)">
            <summary>
            Constructor called by the generated task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLineTemplate">
            <summary>
            The command-line template to use, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AdditionalOptions">
            <summary>
            The additional options that have been set. These are raw switches that
            go last on the command line.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AcceptableNonZeroExitCodes">
            <summary>
            Retrieves the list of acceptable non-zero exit codes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitchesValues">
            <summary>
            Gets or set the dictionary of active tool switch values.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.SwitchOrderList">
            <summary>
            Ordered list of switches
            </summary>
            <returns>Switches in declaration order</returns>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitches">
            <summary>
            The list of all the switches that have been set
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ResponseFileEncoding">
            <summary>
            Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLine">
            <summary>
            Made a property to abstract out the "if null, call GenerateCommands()" logic. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.IsPropertySet(System.String)">
            <summary>
            Returns true if the property has a value in the list of active tool switches
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReplaceToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Replace an existing switch with the specifed one of the same name. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AddActiveSwitchToolValue(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch)">
            <summary>
            Add the value for a switch to the list of active values
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.Execute">
            <summary>
            Override Execute so that we can close the event handle we've created
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GetCommandLine_ForUnitTestsOnly">
            <summary>
            For testing purposes only
            Returns the generated command line
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.HasSwitch(System.String)">
            <summary>
            Checks to see if the switch name is empty
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.IsAcceptableReturnValue">
            <summary>
            Determine if the return value is in the list of acceptable exit codes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.PostProcessSwitchList">
            <summary>
            Validate the data
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateRelations">
            <summary>
            Validate relationships.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateOverrides">
            <summary>
            Validate the overrides.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateResponseFileCommands">
            <summary>
            Creates the command line and returns it as a string by:
            1. Adding all switches with the default set to the active switch list
            2. Customizing the active switch list (overridden in derived classes)
            3. Iterating through the list and appending switches 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.HandleTaskExecutionErrors">
            <summary>
            Allows tool to handle the return code.
            This method will only be called with non-zero exitCode. If the non zero code is an acceptable one then we return true
            </summary>
            <returns>The return value of this method will be used as the task return value</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateCommands">
            <summary>
            Generates the command line for the tool.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateInteger(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            A method that will validate the integer type arguments
            If the min or max is set, and the value a property is set to is not within
            the range, the build fails
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap(System.String,System.String[][],System.String)">
            <summary>
            A method for the enumerated values a property can have
            This method checks the value a property is set to, and finds the corresponding switch
            </summary>
            <returns>The switch that a certain value is mapped to</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap2(System.String,System.Tuple{System.String,System.String,System.Tuple{System.String,System.Boolean}[]}[],System.String)">
            <summary>
            A method for the enumerated values a property can have
            This method checks the value a property is set to, and finds the corresponding switch
            </summary>
            <returns>The switch that a certain value is mapped to</returns>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CreateSwitchValue(System.String,System.String,System.String,System.Tuple{System.String,System.Boolean}[])">
            <summary>
            Gets a switch value by concatenating the switch's base value (usually the switch itself) with its argument, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.InitializeLogger(System.Resources.ResourceManager)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateFullPathToTool">
            <summary>
            This method is called to find the tool if ToolPath wasn't specified.
            We just return the name of the tool so it can be found on the path.
            Deriving classes can choose to do something else.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateParameters">
            <summary>
            Validates all of the set properties that have either a string type or an integer type
            </summary>
        </member>
        <member name="M:Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateCommandLineCommands">
            <summary>
            Generate the command line if it is less than 32k.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnWriteDictionary`2">
             <summary>
             A dictionary that has copy-on-write semantics.
             KEYS AND VALUES MUST BE IMMUTABLE OR COPY-ON-WRITE FOR THIS TO WORK.
             </summary>
             <typeparam name="K">The key type.</typeparam>
             <typeparam name="V">The value type.</typeparam>
             <remarks>
             This dictionary works by having a backing dictionary which is ref-counted for each
             COWDictionary which references it.  When a write operation is performed on any
             COWDictionary, we check the reference count on the backing dictionary.  If it is 
             greater than 1, it means any changes we make to it would be visible to other readers.
             Therefore, we clone the backing dictionary and decrement the reference count on the
             original.  From there on we use the cloned dictionary, which now has a reference count
             of 1.
            
             Thread safety: for all users, this class is as thread safe as the underlying Dictionary implementation, that is,
             safe for concurrent readers or one writer from EACH user. It achieves this by locking itself and cloning before
             any write, if it is being shared - i.e., stopping sharing before any writes occur.
             </remarks>
             <comment>
             This class must be serializable as it is used for metadata passed to tasks, which may
             be run in a separate appdomain.
             </comment>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.capacity">
            <summary>
            The default capacity.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.backing">
            <summary>
            The backing dictionary.
            Lazily created.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor">
            <summary>
            Constructor. Consider supplying a comparer instead.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Int32)">
            <summary>
            Constructor taking an initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys and an initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor, for crossing appdomain boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1})">
            <summary>
            Cloning constructor. Defers the actual clone.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Keys">
            <summary>
            Returns the collection of keys in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Values">
            <summary>
            Returns the collection of values in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Count">
            <summary>
            Returns the number of items in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.IsReadOnly">
            <summary>
            Returns true if the collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#Count">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Dummy">
            <summary>
            A special single dummy instance that always appears empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.IsDummy">
            <summary>
            Whether this is a dummy instance that always appears empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Comparer">
            <summary>
            Comparer used for keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.ReadOperation">
            <summary>
            Gets the backing dictionary for reading.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.WriteOperation">
            <summary>
            Gets the backing dictionary for writing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Item(`0)">
            <summary>
            Accesses the value for the specified key.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Add(`0,`1)">
            <summary>
            Adds a value to the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if the dictionary contains the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Remove(`0)">
            <summary>
            Removes the entry for the specified key from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to find the value for the specified key in the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item to the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Returns true ff the collection contains the specified item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies all of the elements of the collection to the specified array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Remove an item from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.GetEnumerator">
            <summary>
            Implementation of generic IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Clear">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Clone">
            <summary>
            Clone, with the actual clone deferred
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.HasSameBacking(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1})">
            <summary>
            Returns true if these dictionaries have the same backing.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2">
            <summary>
            A dictionary which is reference counted to allow several references for read operations, but knows when to clone for
            write operations.
            </summary>
            <typeparam name="K1">The key type.</typeparam>
            <typeparam name="V1">The value type.</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.s_readOnlyEmptyDictionary">
            <summary>
            An empty dictionary 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2._refCount">
            <summary>
            The reference count. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`2})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor, for crossing appdomain boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor">
            <summary>
            Empty constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1}.CopyOnWriteBackingDictionary{`2,`3})">
            <summary>
            Cloning constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.ReadOnlyEmptyInstance">
            <summary>
            Returns a read-only empty instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.HasNoClones">
            <summary>
            Returns true if this collection has no clones.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.CloneForWriteIfNecessary">
            <summary>
            Clones backing dictionary if necessary for a write operation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.AddRef">
            <summary>
            Adds a reader-reference to this backing dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization does not call any constructors, not even
            the parameterless constructor. Therefore since we do not serialize
            this field, we must populate it here.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1">
            <summary>
            A read-only wrapper over an empty collection.
            </summary>
            <remarks>
            Thus this is an omission from the BCL.
            </remarks>
            <typeparam name="T">Type of element in the collection</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.s_instance">
            <summary>
            Backing live collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.#ctor">
            <summary>
            Private default constructor as this is a singleton
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Instance">
            <summary>
            Get the instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Count">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.IsReadOnly">
            <summary>
            Returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Whether collection is synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Sync root
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Add(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Contains(`0)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.GetEnumerator">
            <summary>
            Get an enumerator over an empty collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator over an empty collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            ICollection version of CopyTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyCollection`1">
            <summary>
            A read-only live wrapper over a collection.
            It does not prevent modification of the values themselves.
            </summary>
            <remarks>
            There is a type with the same name in the BCL, but it is actually a ReadOnlyList and does not accept an ICollection&gt;T&lt;.
            Thus this is an omission from the BCL.
            </remarks>
            <typeparam name="T">Type of element in the collection</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyCollection`1._backing">
            <summary>
            Backing live enumerable.
            May be a collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Construct a read only wrapper around the current contents 
            of the IEnumerable, or around the backing collection if the 
            IEnumerable is in fact a collection. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.Count">
            <summary>
            Return the number of items in the backing collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.IsReadOnly">
            <summary>
            Returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Whether collection is synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Sync root
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.BackingCollection">
            <summary>
            Get a backing ICollection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Add(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Contains(`0)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.GetEnumerator">
            <summary>
            Pass through for underlying collection
            </summary>
            <comment>
            NOTE: This does NOT cause a copy into a List, since the
            backing enumerable suffices.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Pass through for underlying collection
            </summary>
            <comment>
            NOTE: This does NOT cause a copy into a List, since the
            backing enumerable suffices.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            ICollection version of CopyTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2">
            <summary>
            A special singleton enumerable that enumerates a read-only empty dictionary
            </summary>
            <typeparam name="K">Key</typeparam>
            <typeparam name="V">Value</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.s_backing">
            <summary>
            The single instance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.s_instance">
            <summary>
            The single instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.#ctor">
            <summary>
            Private default constructor as this is a singleton
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Instance">
            <summary>
            Get the instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Count">
            <summary>
            Empty returns zero
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsReadOnly">
            <summary>
            Returns true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Keys">
            <summary>
            Gets empty collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Values">
            <summary>
            Gets empty collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsFixedSize">
            <summary>
            Is it fixed size
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsSynchronized">
            <summary>
            Not synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.SyncRoot">
            <summary>
            No sync root
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Values
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Item(System.Object)">
            <summary>
            Indexer
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Item(`0)">
            <summary>
            Get returns null as read-only
            Set is prohibited and throws.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(`0,`1)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.ContainsKey(`0)">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Empty does nothing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.GetEnumerator">
            <summary>
            Get empty enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get empty enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(System.Object,System.Object)">
            <summary>
            Add
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Contains(System.Object)">
            <summary>
            Contains
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(System.Object)">
            <summary>
            Remove
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.CopyTo(System.Array,System.Int32)">
            <summary>
            CopyTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern">
             <summary>
             This class is used to selectively intern strings. It should be used at the point of new string creation.
             For example,
            
                 string interned = OpportunisticIntern.Intern(String.Join(",",someStrings));
            
             This class uses heuristics to decide whether it will be efficient to intern a string or not. There is no
             guarantee that a string will intern.
            
             The thresholds and sizes were determined by experimentation to give the best number of bytes saved
             at reasonable elapsed time cost.
             </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_smallMruSize">
            <summary>
            The size of the small mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_largeMruSize">
            <summary>
            The size of the large mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_hugeMruSize">
            <summary>
            The size of the huge mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_smallMruThreshold">
            <summary>
            The smallest size a string can be to be considered small.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_largeMruThreshold">
            <summary>
            The smallest size a string can be to be considered large.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_hugeMruThreshold">
            <summary>
            The smallest size a string can be to be considered huge.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_ginormousThreshold">
            <summary>
            The smallest size a string can be to be ginormous.
            8K for large object heap.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_si">
            <summary>
            Manages the separate MRU lists.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfInfinite">
            <summary>
            What if Mru lists were infinitely long?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfDoubled">
            <summary>
            What if we doubled the size of the Mru lists?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfHalved">
            <summary>
            What if we halved the size of the Mru lists?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfZero">
            <summary>
            What if the size of Mru lists was zero? (We still intern tiny strings in this case)
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.IInternable">
            <summary>
            Define the methods needed to intern something.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.IInternable.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.IInternable.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.ReferenceEquals(System.String)">
            <summary>
            Reference compare target to string. If target is non-string this should return false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.AssignViaEnvironment(System.String,System.Int32)">
            <summary>
            Assign an int from an environment variable. If its not present, use the default.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.EnableStatisticsGathering">
            <summary>
            Turn on statistics gathering.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.InternableToString(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Intern the given internable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderToString(System.Text.StringBuilder)">
            <summary>
            Potentially Intern the given string builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayToString(System.Char[],System.Int32)">
            <summary>
            Potentially Intern the given char array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayToString(System.Char[],System.Int32,System.Int32)">
            <summary>
            Potentially Intern the given char array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.InternStringIfPossible(System.String)">
            <summary>
            Potentially Intern the given string.
            </summary>
            <param name="candidate">The string to intern.</param>
            <returns>The interned string, or the same string if it could not be interned.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.ReportStatistics">
            <summary>
            Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget">
            <summary>
            A wrapper over StringBuilder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget._target">
            <summary>
            The held StringBuilder
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.#ctor(System.Text.StringBuilder)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ReferenceEquals(System.String)">
            <summary>
            Never reference equals to string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ToString">
            <summary>
            Don't use this function. Use ExpensiveConvertToString
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget">
            <summary>
            A wrapper over char[].
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget._startIndex">
            <summary>
            Start index for the string
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget._target">
            <summary>
            The held array
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.#ctor(System.Char[],System.Int32)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ReferenceEquals(System.String)">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ToString">
            <summary>
            Don't use this function. Use ExpensiveConvertToString
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.StringInternTarget">
            <summary>
            Wrapper over a string.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.StringInternTarget._target">
            <summary>
            Stores the wrapped string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.#ctor(System.String)">
            <summary>
            Constructor of the class
            </summary>
            <param name="target">The string to wrap</param>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringInternTarget.Length">
            <summary>
            Gets the length of the target string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringInternTarget.Item(System.Int32)">
            <summary>
            Gets the n character in the target string.
            </summary>
            <param name="index">Index of the character to gather.</param>
            <returns>The character in the position marked by index.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.ExpensiveConvertToString">
            <summary>
            Returns the target which is already a string.
            </summary>
            <returns>The target string.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare if the target string is equal to the given string.
            </summary>
            <param name="other">The string to compare with the target.</param>
            <returns>True if the strings are equal, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.ReferenceEquals(System.String)">
            <summary>
            Verifies if the reference of the target string is the same of the given string.
            </summary>
            <param name="other">The string reference to compare to.</param>
            <returns>True if both references are equal, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList">
            <summary>
            Manages a set of mru lists that hold strings in varying size ranges.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._smallMru">
            <summary>
            The small string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._largeMru">
            <summary>
            The large string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._hugeMru">
            <summary>
            The huge string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormous">
            <summary>
            Three most recently used strings over 8K.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._smallMruThreshold">
            <summary>
            The smallest size a string can be to be considered small.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._largeMruThreshold">
            <summary>
            The smallest size a string can be to be considered large.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._hugeMruThreshold">
            <summary>
            The smallest size a string can be to be considered huge.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousThreshold">
            <summary>
            The smallest size a string can be to be ginormous.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._gatherStatistics">
            <summary>
            Whether or not to gather statistics
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internHits">
            <summary>
            Number of times interning worked.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internMisses">
            <summary>
            Number of times interning didn't work.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internRejects">
            <summary>
            Number of times interning wasn't attempted.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internEliminatedStrings">
            <summary>
            Total number of strings eliminated by interning.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internEliminatedChars">
            <summary>
            Total number of chars eliminated across all strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousHits">
            <summary>
            Number of times the ginourmous string hit.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousMisses">
            <summary>
            Number of times the ginourmous string missed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousCharsSaved">
            <summary>
            Chars interned for ginormous range.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._dontTrack">
            <summary>
            Whether or not to track ginormous strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._stopwatch">
            <summary>
            The time spent interning.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._missedStrings">
            <summary>
            Strings which did not intern
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._rejectedStrings">
            <summary>
            Strings which we didn't attempt to intern
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.GinormousSize">
            <summary>
            Number of ginormous strings to keep
            By observation of Auto7, there are about three variations of the huge solution config blob
            There aren't really any other strings of this size, but make it 10 to be sure. (There will barely be any misses)
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.InterningToString(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Intern the given internable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.ReportStatistics(System.String)">
            <summary>
            Report statistics to the console.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.TryIntern(Microsoft.Build.OpportunisticIntern.IInternable,System.String@)">
            <summary>
            Try to intern the string.
            Return true if an interned value could be returned.
            Return false if it was added to the intern list, but wasn't there already.
            Return null if it didn't meet the length criteria for any of the buckets. Interning was rejected
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.InternWithStatistics(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Version of Intern that gathers statistics
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList">
            <summary>
            A singly linked list of strings where the most recently accessed string is at the top.
            Size expands up to a fixed number of strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList._size">
            <summary>
            Maximum size of the mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList._mru">
            <summary>
            Head of the mru list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.#ctor(System.Int32)">
            <summary>
            Construct an Mru list with a fixed maximum size.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.TryGet(Microsoft.Build.OpportunisticIntern.IInternable,System.String@)">
            <summary>
            Try to get one element from the list. Upon leaving the function 'candidate' will be at the head of the Mru list.
            This function is not thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Statistics">
            <summary>
            Returns the number of strings held and the total number of chars held.
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node">
            <summary>
            Singly linked list node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.#ctor(System.String)">
            <summary>
            Construct a Node
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.Next">
            <summary>
            The next node in the list.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.Value">
            <summary>
            The held string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.Tracing">
            <summary>
            A debug only helper class for tracing
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_counts">
            <summary>
            A dictionary of named counters
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_last">
            <summary>
            Last time logging happened
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_interval">
            <summary>
            How often to log
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_slot">
            <summary>
            A place callers can put something worth logging later
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_currentAssemblyName">
            <summary>
            Short name of the current assembly - to distinguish statics when this type is shared into different assemblies
            </summary> 
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Slot(System.String,System.String)">
            <summary>
            Put something in the slot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Slot``2(System.String,System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Put something in the slot
            </summary>
            <typeparam name="K">The key type.</typeparam>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Record(System.String)">
            <summary>
            Increment the named counter, and dump if it's time to do so
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.List``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Log the provided items
            </summary>
            <typeparam name="T">The item type.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Dump">
            <summary>
            Dump all the named counters, if any
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.Traits">
            <summary>
                Represents toggleable features of the MSBuild engine
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.UseLazyWildCardEvaluation">
            <summary>
            Do not expand wildcards that match a certain pattern
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.CacheFileExistence">
            <summary>
            Cache file existence for the entire process
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.UseSimpleInternConcurrency">
            <summary>
            Eliminate locking in OpportunisticIntern at the expense of memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.MSBuildCacheFileEnumerations">
            <summary>
            Cache wildcard expansions for the entire process
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.EnableRestoreFirst">
            <summary>
            Enable restore first functionality in MSBuild.exe
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.CopyTaskParallelism">
            <summary>
            Setting the associated environment variable to 1 restores the pre-15.8 single
            threaded (slower) copy behavior. Zero implies Int32.MaxValue, less than zero
            (default) uses the empirical default in Copy.cs, greater than zero can allow
            perf tuning beyond the defaults chosen.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.EmitSolutionMetaproj">
            <summary>
            Instruct MSBuild to write out the generated "metaproj" file to disk when building a solution file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.LogPropertyFunctionsRequiringReflection">
            <summary>
            Log statistics about property functions which require reflection
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.LogPropertyTracking">
            <summary>
            Log property tracking information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DoNotSendDeferredMessagesToBuildManager">
            <summary>
            Do not log command line information to build loggers. Useful to unbreak people who parse the msbuild log and who are unwilling to change their code.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DoNotExpandQualifiedMetadataInUpdateOperation">
            <summary>
            https://github.com/microsoft/msbuild/pull/4975 started expanding qualified metadata in Update operations. Before they'd expand to empty strings.
            This escape hatch turns back the old empty string behavior.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.EvaluateElementsWithFalseConditionInProjectEvaluation">
            <summary>
            Force whether Project based evaluations should evaluate elements with false conditions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.AlwaysUseContentTimestamp">
            <summary>
            Always use the accurate-but-slow CreateFile approach to timestamp extraction.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.TruncateTaskInputs">
            <summary>
            Truncate task inputs when logging them. This can reduce memory pressure
            at the expense of log usefulness.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches._logProjectImports">
            <summary>
            Emit events for project imports.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.EscapeHatches.LogProjectImports">
            <summary>
            Emit events for project imports.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.CacheAssemblyInformation">
            <summary>
            Read information only once per file per ResolveAssemblyReference invocation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime">
            <summary>
            Never use the slow (but more accurate) CreateFile approach to timestamp extraction.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.ReuseTaskHostNodes">
            <summary>
            Allow node reuse of TaskHost nodes. This results in task assemblies locked past the build lifetime, preventing them from being rebuilt if custom tasks change, but may improve performance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.IgnoreEmptyImports">
            <summary>
            Whether or not to ignore imports that are considered empty.  See ProjectRootElement.IsEmptyXmlFile() for more info.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.IgnoreTreatAsLocalProperty">
            <summary>
            Whether to to respect the TreatAsLocalProperty parameter on the Project tag. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DebugEvaluation">
            <summary>
            Whether to write information about why we evaluate to debug output.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.WarnOnUninitializedProperty">
            <summary>
            Whether to warn when we set a property for the first time, after it was previously used.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseCaseSensitiveItemNames">
            <summary>
            MSBUILDUSECASESENSITIVEITEMNAMES is an escape hatch for the fix
            for https://github.com/Microsoft/msbuild/issues/1751. It should
            be removed (permanently set to false) after establishing that
            it's unneeded (at least by the 16.0 timeframe).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableLongPaths">
            <summary>
            Disable the use of paths longer than Windows MAX_PATH limits (260 characters) when running on a long path enabled OS.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableSdkResolutionCache">
            <summary>
            Disable the use of any caching when resolving SDKs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableNuGetSdkResolver">
            <summary>
            Disable the NuGet-based SDK resolver.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.TargetPathForRelatedFiles">
            <summary>
            Don't delete TargetPath metadata from associated files found by RAR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseSingleLoadContext">
            <summary>
            Disable AssemblyLoadContext isolation for plugins.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseAutoRunWhenLaunchingProcessUnderCmd">
            <summary>
            Enables the user of autorun functionality in CMD.exe on Windows which is disabled by default in MSBuild.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.AvoidUnicodeWhenWritingToolTaskBatch">
            <summary>
            Disables switching codepage to UTF-8 after detection of characters that can't be represented in the current codepage.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout">
            <summary>
            Workaround for https://github.com/Microsoft/vstest/issues/1503.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseMinimalResxParsingInCoreScenarios">
            <summary>
            Use the original, string-only resx parsing in .NET Core scenarios.
            </summary>
            <remarks>
            Escape hatch for problems arising from https://github.com/microsoft/msbuild/pull/4420.
            </remarks>
        </member>
        <member name="T:Microsoft.Runtime.Hosting.StrongNameHelpers">
            <summary>
            The methods here are designed to aid in transition from the v2 StrongName APIs on mscoree.dll to the
            v4 metahost APIs (which are in-proc SxS aware).
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.Hosting.IClrStrongNameUsingIntPtr">
            <summary>
            This is a managed wrapper for the IClrStrongName interface defined in metahost.idl
            This uses IntPtrs in some places where you'd normally expect a byte[] in order to
            be compatible with callers who wrote their PInvoke signatures that way.
            Ideally we'd probably just simplify all such callers to using byte[] and remove this
            version of the interface.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.Hosting.IClrStrongName">
            <summary>
            This is a managed wrapper for the IClrStrongName interface defined in metahost.idl
            This is very similar to the standard RCWs provided in 
            ndp/fx/src/hosting/interop/microsoft/runtime/hosting/interop, but we don't want to
            reference that assembly (part of the SDK only, not .NET redist).  Also, our version
            is designed specifically for easy migration from the old mscoree APIs, for example
            all APIs return HResults rather than throw exceptions.
            </summary> 
        </member>
        <member name="M:System.Deployment.Internal.CodeSigning.SignedCmiManifest2.GetFixedRSACryptoServiceProvider(System.Security.Cryptography.RSACryptoServiceProvider,System.Boolean)">
            <summary>
            The reason you need provider type 24, is because that’s the only RSA provider type that supports SHA-2 operations.   (For instance, PROV_RSA_FULL does not support SHA-2).
            As for official guidance – I’m not sure of any.    For workarounds though, if you’re using the Microsoft software CSPs, they share the underlying key store.  You can get the key container name from your RSA object, then open up a new RSA object with the same key container name but with PROV_RSA_AES.   At that point, you should be able to use SHA-2 algorithms.
            </summary>
            <param name="oldCsp"></param>
            <returns></returns>
        </member>
    </members>
</doc>
