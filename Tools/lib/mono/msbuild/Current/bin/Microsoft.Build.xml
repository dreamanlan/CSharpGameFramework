<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Build</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Build.Shared.FileSystem.FileSystems">
            <summary>
            Factory for <see cref="T:Microsoft.Build.Shared.FileSystem.IFileSystem"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.IFileSystem">
            <summary>
            Abstracts away some file system operations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of file names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of directory names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Returns an enumerable collection of file names and directory names that match a search pattern in a specified path, and optionally searches subdirectories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.DirectoryExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing directory on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.FileExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.IFileSystem.DirectoryEntryExists(System.String)">
            <summary>
            Determines whether the given path refers to an existing entry in the directory service.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.ManagedFileSystem">
            <summary>
            Implementation of file system operations directly over the dot net managed layer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.ManagedFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem">
            <summary>
            Implementation of file system operations directly over the dot net managed layer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.NativeWin32Exception">
            <summary>
            A possibly-recoverable exception wrapping a failed native call. The <see cref="P:System.ComponentModel.Win32Exception.NativeErrorCode" /> captures the
            associated recent error code (<see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />). The <see cref="P:System.Exception.Message" />
            accounts for the native code as well as a human readable portion.
            </summary>
            <remarks>
            This is much like <see cref="T:System.ComponentModel.Win32Exception"/>, but the message field contains the caller-provided part in addition
            to the system-provided message (rather than replacing the system provided message).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.#ctor(System.Int32,System.String)">
            <summary>
            Creates an exception representing a native failure (with a corresponding Win32 error code).
            The exception's <see cref="P:System.Exception.Message" /> includes the error code, a system-provided message describing it,
            and the provided application-specific message prefix (e.g. "Unable to open log file").
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.#ctor(System.Int32)">
            <summary>
            Creates an exception representing a native failure (with a corresponding Win32 error code).
            The exception's <see cref="P:System.Exception.Message" /> includes the error code and a system-provided message describing it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.GetFormattedMessageForNativeErrorCode(System.Int32,System.String)">
            <summary>
            Returns a human readable error string for a native error code, like <c>Native: Can't access the log file (0x5: Access is denied)</c>.
            The message prefix (e.g. "Can't access the log file") is optional.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.NativeWin32Exception.HResultFromWin32(System.Int32)">
            <summary>
            Converts a Win32 error code to HResult
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle">
            <summary>
            Handle for a volume iteration as returned by WindowsNative.FindFirstVolumeW />
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle.#ctor">
            <summary>
            Private constructor for the PInvoke marshaller.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.SafeFindFileHandle.ReleaseHandle">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.FileArtifactType">
            <summary>
            The type of file artifact to search for
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.File">
            <nodoc/>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.Directory">
            <nodoc/>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.FileArtifactType.FileOrDirectory">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsFileSystem">
            <summary>
            Windows-specific implementation of file system operations using Windows native invocations
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.DirectoryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.FileExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsFileSystem.DirectoryEntryExists(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative">
            <summary>
            Native implementation of file system operations
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.MaxPath">
            <summary>
            Maximum path length.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorSuccess">
            <summary>
            ERROR_SUCCESS
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorFileNotFound">
            <summary>
            ERROR_FILE_NOT_FOUND
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorPathNotFound">
            <summary>
            ERROR_PATH_NOT_FOUND
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorDirectory">
            <summary>
            ERROR_DIRECTORY
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorAccessDenied">
            <summary>
            ERROR_ACCESS_DENIED
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.ErrorNoMoreFiles">
            <summary>
            ERROR_NO_MORE_FILES
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags">
            <summary>
            Modifies the search condition of PathMatchSpecEx
            </summary>
            <remarks>
            <see ref="https://msdn.microsoft.com/en-us/library/windows/desktop/bb773728(v=vs.85).aspx"/>
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfNormal">
            <summary>
            The pszSpec parameter points to a single file name pattern to be matched.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfMultiple">
            <summary>
            The pszSpec parameter points to a semicolon-delimited list of file name patterns to be matched.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.DwFlags.PmsfDontStripSpaces">
            <summary>
            If PMSF_NORMAL is used, ignore leading spaces in the string pointed to by pszSpec. If PMSF_MULTIPLE is used, 
            ignore leading spaces in each file type contained in the string pointed to by pszSpec. This flag can be combined with PMSF_NORMAL and PMSF_MULTIPLE.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus">
            <summary>
            Status of attempting to enumerate a directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.Success">
            <summary>
            Enumeration of an existent directory succeeded.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound">
            <summary>
            One or more path components did not exist, so the search directory could not be opened.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.CannotEnumerateFile">
            <summary>
            A path component in the search path refers to a file. Only directories can be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.AccessDenied">
            <summary>
            Directory enumeration could not complete due to denied access to the search directory or a file inside.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.UnknownError">
            <summary>
            Directory enumeration failed without a well-known status (see <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.NativeErrorCode"/>).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult">
            <summary>
            Represents the result of attempting to enumerate a directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Directory">
            <summary>
            Enumerated directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Status">
            <summary>
            Overall status indication.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.NativeErrorCode">
            <summary>
            Native error code. Note that an error code other than <c>ERROR_SUCCESS</c> may be present even on success.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.#ctor(System.String,Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus,System.Int32)">
            <nodoc />
        </member>
        <member name="P:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Succeeded">
            <summary>
            Indicates if enumeration succeeded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.ThrowForUnknownError">
            <summary>
            Throws an exception if the native error code could not be canonicalized (a fairly exceptional circumstance).
            This is allowed when <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.Status"/> is <see cref="F:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus.UnknownError"/>.
            </summary>
            <remarks>
            This is a good <c>default:</c> case when switching on every possible <see cref="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus"/>
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.ThrowForKnownError">
            <summary>
            Throws an exception if the native error code was corresponds to a known <see cref="T:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryStatus"/>
            (and enumeration was not successful).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.EnumerateDirectoryResult.CreateExceptionForError">
            <summary>
            Creates (but does not throw) an exception for this result. The result must not be successful.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData">
            <summary>
            <c>Win32FindData</c>
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwFileAttributes">
            <summary>
            The file attributes of a file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtCreationTime">
            <summary>
            Specified when a file or directory was created
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtLastAccessTime">
            <summary>
            Specifies when the file was last read from, written to, or for executable files, run.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.FtLastWriteTime">
            <summary>
            For a file, the structure specifies when the file was last written to, truncated, or overwritten.
            For a directory, the structure specifies when the directory is created.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.NFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.NFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.DwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.CFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData.CAlternate">
            <summary>
            An alternative name for the file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindFirstFileW(System.String,Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData@)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindNextFileW(System.Runtime.InteropServices.SafeHandle,Microsoft.Build.Shared.FileSystem.WindowsNative.Win32FindData@)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.PathMatchSpecExW(System.String,System.String,System.Int32)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Shared.FileSystem.WindowsNative.FindClose(System.IntPtr)">
            <nodoc/>
        </member>
        <member name="T:Microsoft.Build.Shared.Debugging.PrintLineDebugger">
            <summary>
                A class to help with printline debugging in difficult environments like CI, or when debugging msbuild through other
                tools like VS or CLI.
                See example usages in PrintLineDebugger_Tests
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.Debugging.PrintLineDebuggerWriters">
            <summary>
                A collection of useful writers
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.EncodingUtilities">
            <summary>
            This class contains utility methods for dealing with encoding.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.EncodingUtilities.CurrentSystemOemEncoding">
            <summary>
            Get the current system locale code page, OEM version. OEM code pages are used for console-based input/output
            for historical reasons.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.SimilarToEncoding(System.Text.Encoding,System.Text.Encoding)">
            <summary>
            Checks two encoding types to determine if they are similar to each other (equal or if
            the Encoding Name is the same).
            </summary>
            <param name="encoding1"></param>
            <param name="encoding2"></param>
            <returns>True if the two Encoding objects are equal or similar.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.IsUtf8Encoding(System.Text.Encoding)">
            <summary>
            Check if an encoding type is UTF8 (with or without BOM).
            </summary>
            <param name="encoding"></param>
            <returns>True if the encoding is UTF8.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.StartsWithPreamble(System.IO.Stream)">
            <summary>
            Check the first 3 bytes of a stream to determine if it matches the UTF8 preamble.
            </summary>
            <param name="stream">Steam to check.</param>
            <returns>True when the first 3 bytes of the Stream are equal to the UTF8 preamble (BOM).</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.StartsWithPreamble(System.IO.Stream,System.Byte[])">
            <summary>
            Check the first 3 bytes of a stream to determine if it matches the given preamble.
            </summary>
            <param name="stream">Steam to check.</param>
            <param name="preamble">Preamble to look for.</param>
            <returns>True when the first 3 bytes of the Stream are equal to the preamble.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.FileStartsWithPreamble(System.String)">
            <summary>
            Check the first 3 bytes of a file to determine if it matches the 3-byte UTF8 preamble (BOM).
            </summary>
            <param name="file">Path to file to check.</param>
            <returns>True when the first 3 bytes of the file are equal to the UTF8 BOM.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.CanEncodeString(System.Int32,System.String)">
            <summary>
            Checks to see if a string can be encoded in a specified code page.
            </summary>
            <remarks>Internal for testing purposes.</remarks>
            <param name="codePage">Code page for encoding.</param>
            <param name="stringToEncode">String to encode.</param>
            <returns>True if the string can be encoded in the specified code page.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingUtilities.BatchFileEncoding(System.String,System.String)">
             <summary>
             Find the encoding for the batch file.
             </summary>
             <remarks>
             The "best" encoding is the current OEM encoding, unless it's not capable of representing
             the characters we plan to put in the file. If it isn't, we can fall back to UTF-8.
            
             Why not always UTF-8? Because tools don't always handle it well. See
             https://github.com/Microsoft/msbuild/issues/397
             </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_visualStudioProcess" -->
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_msBuildProcess">
            <summary>
            Name of the MSBuild process(es)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentHelper.s_msBuildExeNames">
            <summary>
            Name of MSBuild executable files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironmentHelper.Instance">
            <summary>
            Gets the cached Build Environment instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.Initialize">
            <summary>
            Find the location of MSBuild.exe based on the current environment.
            </summary>
            <remarks>
            This defines the order and precedence for various methods of discovering MSBuild and associated toolsets.
            At a high level, an install under Visual Studio is preferred as the user may have SDKs installed to a
            specific instance of Visual Studio and build will only succeed if we can discover those. See
            https://github.com/Microsoft/msbuild/issues/1461 for details.
            </remarks>
            <returns>Build environment.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.IsProcessInList(System.String,System.String[])">
            <summary>
            Returns true if processName appears in the processList
            </summary>
            <param name="processName">Name of the process</param>
            <param name="processList">List of processes to check</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(System.Func{System.String},System.Func{System.String},System.Func{System.String},System.Func{System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.VisualStudioInstance}},System.Func{System.String,System.String},System.Func{System.Boolean})">
            <summary>
            Resets the current singleton instance (for testing).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.BuildEnvironmentMode">
            <summary>
            Enum which defines which environment / mode MSBuild is currently running.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.VisualStudio">
            <summary>
            Running from Visual Studio directly or from MSBuild installed under an instance of Visual Studio.
            Toolsets and extensions will be loaded from the Visual Studio instance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.Standalone">
            <summary>
            Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app 
            running and not dependent on Visual Studio. (e.g. dotnet CLI, open source clone of our repo)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.BuildEnvironmentMode.None">
            <summary>
            Running without any defined toolsets. Most functionality limited. Likely will not be able to
            build or evaluate a project. (e.g. reference to Microsoft.*.dll without a toolset definition
            or Visual Studio instance installed).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.BuildEnvironment">
            <summary>
            Defines the current environment for build tools.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.RunningTests">
            <summary>
            Gets the flag that indicates if we are running in a test harness.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.RunningInVisualStudio">
            <summary>
            Returns true when the entry point application is Visual Studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildToolsDirectory32">
            <summary>
            Path to the MSBuild 32-bit tools directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildToolsDirectory64">
            <summary>
            Path to the MSBuild 64-bit (AMD64) tools directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildSDKsPath">
            <summary>
            Path to the Sdks folder for this MSBuild instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildConfigurationFile">
            <summary>
            Full path to the current MSBuild configuration file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildExePath">
            <summary>
            Full path to current MSBuild.exe.
            <remarks>
            This path is likely not the current running process. We may be inside
            Visual Studio or a test harness. In that case this will point to the
            version of MSBuild found to be associated with the current environment.
            </remarks>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.CurrentMSBuildToolsDirectory">
            <summary>
            Full path to the current MSBuild tools directory. This will be 32-bit unless
            we're executing from the 'AMD64' folder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.VisualStudioInstallRootDirectory">
            <summary>
            Path to the root Visual Studio install directory
            (e.g. 'C:\Program Files (x86)\Microsoft Visual Studio\Preview\Enterprise')
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEnvironment.MSBuildExtensionsPath">
            <summary>
            MSBuild extensions path. On Standalone this defaults to the MSBuild folder. In
            VisualStudio mode this folder will be %VSINSTALLDIR%\MSBuild.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.EncodingStringWriter">
            <summary>
            StringWriter class that allows Encoding to be specified. In the standard StringWriter
            class only UTF16 is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EncodingStringWriter.#ctor">
            <summary>
            Default ctor (Encoding = UTF8)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.EncodingStringWriter.Encoding">
            <summary>
            Overload to specify encoding.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyNameComparer">
            <summary>
            IKeyComparer implementation that compares AssemblyNames for using in Hashtables.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.Comparer">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.ComparerConsiderRetargetable">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.GenericComparer">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.GenericComparerConsiderRetargetable">
            <summary>
            Comparer for two assembly name extensions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameComparer.considerRetargetableFlag">
            <summary>
            Should the comparer consider the retargetable flag when doing comparisons
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.#ctor(System.Boolean)">
            <summary>
            Private construct so there's only one instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare o1 and o2 as AssemblyNames.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.Equals(System.Object,System.Object)">
            <summary>
            Treat o1 and o2 as AssemblyNames. Are they equal?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.GetHashCode(System.Object)">
            <summary>
            Get a hashcode for AssemblyName.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.Equals(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Determine if the assembly name extensions are equal
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameComparer.GetHashCode(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Get a hashcode for AssemblyName.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AwaitExtensions">
            <summary>
            Class defining extension methods for awaitable objects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AwaitExtensions.s_staSchedulerSync">
            <summary>
            Synchronizes access to the staScheduler field.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AwaitExtensions.s_staScheduler">
            <summary>
            The singleton STA scheduler object.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AwaitExtensions.OneSTAThreadPerTaskSchedulerInstance">
            <summary>
            Gets the STA scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AwaitExtensions.GetAwaiter(System.Threading.WaitHandle)">
            <summary>
            Provides await functionality for ordinary <see cref="T:System.Threading.WaitHandle"/>s.
            </summary>
            <param name="handle">The handle to wait on.</param>
            <returns>The awaiter.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AwaitExtensions.GetAwaiter(System.Threading.WaitHandle[])">
            <summary>
            Provides await functionality for an array of ordinary <see cref="T:System.Threading.WaitHandle"/>s.
            </summary>
            <param name="handles">The handles to wait on.</param>
            <returns>The awaiter.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AwaitExtensions.ToTask(System.Threading.WaitHandle,System.Int32)">
            <summary>
            Creates a TPL Task that is marked as completed when a <see cref="T:System.Threading.WaitHandle"/> is signaled.
            </summary>
            <param name="handle">The handle whose signal triggers the task to be completed.  Do not use a <see cref="T:System.Threading.Mutex"/> here.</param>
            <param name="timeout">The timeout (in milliseconds) after which the task will fault with a <see cref="T:System.TimeoutException"/> if the handle is not signaled by that time.</param>
            <returns>A Task that is completed after the handle is signaled.</returns>
            <remarks>
            There is a (brief) time delay between when the handle is signaled and when the task is marked as completed.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.AwaitExtensions.ToTask(System.Threading.WaitHandle[],System.Int32)">
            <summary>
            Creates a TPL Task that is marked as completed when any <see cref="T:System.Threading.WaitHandle"/> in the array is signaled.
            </summary>
            <param name="handles">The handles whose signals triggers the task to be completed.  Do not use a <see cref="T:System.Threading.Mutex"/> here.</param>
            <param name="timeout">The timeout (in milliseconds) after which the task will return a value of WaitTimeout.</param>
            <returns>A Task that is completed after any handle is signaled.</returns>
            <remarks>
            There is a (brief) time delay between when the handles are signaled and when the task is marked as completed.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.AwaitExtensions.OneSTAThreadPerTaskScheduler">
            <summary>
            A class which acts as a task scheduler and ensures each scheduled task gets its 
            own STA thread.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AwaitExtensions.OneSTAThreadPerTaskScheduler._queuedTasks">
            <summary>
            The current queue of tasks.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AwaitExtensions.OneSTAThreadPerTaskScheduler.GetScheduledTasks">
            <summary>
            Returns the list of queued tasks.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AwaitExtensions.OneSTAThreadPerTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            Queues a task to the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AwaitExtensions.OneSTAThreadPerTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Tries to execute the task immediately.  This method will always return false for the STA scheduler.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyNameReverseVersionComparer">
            <summary>
            Compare the version numbers only for an AssemblyNameExtension and make sure they are in reverse order. This assumes the names are the same.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameReverseVersionComparer.GenericComparer">
            <summary>
            A static instance of the comparer for use in a sort method
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameReverseVersionComparer.Compare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare x and y by version only.
            
            Change the return value to sort the values in reverse order.
            
            If x is greater than y  return -1 indicating x is less than y. 
            If x is less than y  return 1 indicating x is greater than  y.
            If x and y are equal return 0.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError">
             <summary>
             Functions for dealing with the specially formatted errors returned by
             build tools.
             </summary>
             <remarks>
             Various tools produce and consume CanonicalErrors in various formats.
            
             DEVENV Format When Clicking on Items in the Output Window
             (taken from env\msenv\core\findutil.cpp ParseLocation function)
            
                  v:\dir\file.ext (loc) : msg
                  \\server\share\dir\file.ext(loc):msg
                  url
            
                  loc:
                  (line)
                  (line-line)
                  (line,col)
                  (line,col-col)
                  (line,col,len)
                  (line,col,line,col)
            
             DevDiv Build Process
             (taken from tools\devdiv2.def)
            
                  To echo warnings and errors to the build console, the
                  "description block" must be recognized by build. To do this,
                  add a $(ECHO_COMPILING_COMMAND) or $(ECHO_PROCESSING_COMMAND)
                  to the first line of the description block, e.g.
            
                      $(ECHO_COMPILING_CMD) Resgen_$&lt;
            
                  Errors must have the format:
            
                      &lt;text&gt; : error [num]: &lt;msg&gt;
            
                  Warnings must have the format:
            
                      &lt;text&gt; : warning [num]: &lt;msg&gt;
             </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError.Parts">
            <summary>
            Represents the parts of a decomposed canonical message.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.CanonicalError.Parts.Category">
            <summary>
            Defines the error category\severity level.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.numberNotSpecified">
            <summary>
            Value used for unspecified line and column numbers, which are 1-relative.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.Parts.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Shared.CanonicalError.Parts"/> class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.origin">
            <summary>
            Name of the file or tool (not localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.line">
            <summary>
            The line number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.column">
            <summary>
            The column number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.endLine">
            <summary>
            The ending line number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.endColumn">
            <summary>
            The ending column number.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.category">
            <summary>
            The category/severity level
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.subcategory">
            <summary>
            The sub category (localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.code">
            <summary>
            The error code (not localized)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.CanonicalError.Parts.text">
            <summary>
            The error message text (localized)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.ConvertToIntWithDefault(System.String)">
            <summary>
            A small custom int conversion method that treats invalid entries as missing (0). This is done to work around tools
            that don't fully conform to the canonical message format - we still want to salvage what we can from the message.
            </summary>
            <param name="value"></param>
            <returns>'value' converted to int or 0 if it can't be parsed or is negative</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.CanonicalError.Parse(System.String)">
            <summary>
            Decompose an error or warning message into constituent parts. If the message isn't in the canonical form, return null.
            </summary>
            <remarks>This method is thread-safe, because the Regex class is thread-safe (per MSDN).</remarks>
            <param name="message"></param>
            <returns>Decomposed canonical message, or null.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.NGen`1">
            <summary>
            To avoid CA908 warnings (types that in ngen images that will JIT)
            wrap each problematic value type in the collection in 
            one of these objects.
            </summary>
            <comment>
            This trick is based on advice from 
            http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
            It works because although this is a value type, it is not defined in mscorlib.
            </comment>
            <typeparam name="T">Wrapped type</typeparam>
        </member>
        <member name="F:Microsoft.Build.Shared.NGen`1._value">
            <summary>
            Wrapped value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NGen`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NGen`1.op_Implicit(Microsoft.Build.Shared.NGen{`0})~`0">
            <summary>
            Exposes the value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NGen`1.op_Implicit(`0)~Microsoft.Build.Shared.NGen{`0}">
            <summary>
            Consumes the value
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.Pair`2">
            <summary>
            This struct is functionally identical to KeyValuePair, but avoids
            CA908 warnings (types that in ngen images that will JIT).
            Instead of generic collections of KeyValuePair, use Pair.
            </summary>
            <comment>
            This trick is based on advice from 
            http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
            It works because although this is a value type, it is not defined in mscorlib.
            </comment>
            <typeparam name="TKey">Key</typeparam>
            <typeparam name="TValue">Value</typeparam>
        </member>
        <member name="F:Microsoft.Build.Shared.Pair`2._key">
            <summary>
            Key
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.Pair`2._value">
            <summary>
            Value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.Pair`2.#ctor(`0,`1)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.Pair`2.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.Pair`2.Value">
            <summary>
            Value
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult">
            <summary>
            A result of executing a target or task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.#ctor(Microsoft.Build.BackEnd.TaskCompleteType)">
            <summary>
            Constructor 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.#ctor(Microsoft.Build.BackEnd.TaskCompleteType,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.#ctor(Microsoft.Build.BackEnd.TaskCompleteType,System.Exception)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.#ctor(Microsoft.Build.BackEnd.TaskCompleteType,System.Exception,System.String,System.String[])">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.#ctor(Microsoft.Build.BackEnd.TaskCompleteType,System.Collections.Generic.IDictionary{System.String,System.Object},System.Exception,System.String,System.String[])">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.Result">
            <summary>
            The overall result of the task execution. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.FinalParameterValues">
            <summary>
            Dictionary of the final values of the task parameters
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.TaskException">
            <summary>
            The exception thrown by the task during initialization or execution, 
            if any. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.ExceptionMessage">
            <summary>
            The name of the resource representing the message to be logged along with the 
            above exception. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.OutOfProcTaskHostTaskResult.ExceptionMessageArgs">
            <summary>
            The arguments to be used when formatting ExceptionMessage
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.TaskLoader">
            <summary>
            Class for loading tasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TaskLoader.s_resolverLoadedType">
            <summary>
            For saving the assembly that was loaded by the TypeLoader
            We only use this when the assembly failed to load properly into the appdomain
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.TaskLoader.LogError">
            <summary>
            Delegate for logging task loading errors. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TaskLoader.IsTaskClass(System.Type,System.Object)">
            <summary>
            Checks if the given type is a task factory.
            </summary>
            <remarks>This method is used as a type filter delegate.</remarks>
            <returns>true, if specified type is a task</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.TaskLoader.CreateTask(Microsoft.Build.Shared.LoadedType,System.String,System.String,System.Int32,System.Int32,Microsoft.Build.Shared.TaskLoader.LogError,System.AppDomainSetup,System.Boolean,System.AppDomain@)">
            <summary>
            Creates an ITask instance and returns it.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TaskLoader.AssemblyResolver(System.Object,System.ResolveEventArgs)">
            <summary>
            This is a resolver to help created AppDomains when they are unable to load an assembly into their domain we will help
            them succeed by providing the already loaded one in the currentdomain so that they can derive AssemblyName info from it
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TaskLoader.RemoveAssemblyResolver">
            <summary>
            Check if we added a resolver and remove it
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.LoggingEventType">
            <summary>
            An enumeration of all the types of BuildEventArgs that can be
            packaged by this logMessagePacket
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.Invalid">
            <summary>
            An invalid eventId, used during initialization of a LoggingEventType
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.CustomEvent">
            <summary>
            Event is a CustomEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.BuildErrorEvent">
            <summary>
            Event is a BuildErrorEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.BuildFinishedEvent">
            <summary>
            Event is a BuildFinishedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.BuildMessageEvent">
            <summary>
            Event is a BuildMessageEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.BuildStartedEvent">
            <summary>
            Event is a BuildStartedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.BuildWarningEvent">
            <summary>
            Event is a BuildWarningEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.ProjectFinishedEvent">
            <summary>
            Event is a ProjectFinishedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.ProjectStartedEvent">
            <summary>
            Event is a ProjectStartedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.TargetStartedEvent">
            <summary>
            Event is a TargetStartedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.TargetFinishedEvent">
            <summary>
            Event is a TargetFinishedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.TaskStartedEvent">
            <summary>
            Event is a TaskStartedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.TaskFinishedEvent">
            <summary>
            Event is a TaskFinishedEventArgs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LoggingEventType.TaskCommandLineEvent">
            <summary>
            Event is a TaskCommandLineEventArgs
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.LogMessagePacketBase">
            <summary>
            A packet to encapsulate a BuildEventArg logging message.
            Contents:
            Build Event Type
            Build Event Args
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase.s_defaultPacketVersion">
            <summary>
            The packet version, which is based on the CLR version. Cached because querying Environment.Version each time becomes an allocation bottleneck.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase.s_readMethodCache">
            <summary>
            Dictionary of methods used to read BuildEventArgs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase.s_writeMethodCache">
            <summary>
            Dictionary of methods used to write BuildEventArgs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase.s_customEventsLoaded">
            <summary>
            Dictionary of assemblies we've added to the resolver.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase.s_resolver">
            <summary>
            The resolver used to load custom event types.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase.s_lockObject">
            <summary>
            The object used to synchronize access to shared data.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase._targetFinishedTranslator">
            <summary>
            Delegate for translating targetfinished events. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase._eventType">
            <summary>
            The event type of the buildEventArg based on the 
            LoggingEventType enumeration
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase._buildEvent">
            <summary>
            The buildEventArg which is encapsulated by the packet
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.LogMessagePacketBase._sinkId">
            <summary>
            The sink id
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.#ctor(System.Nullable{System.Collections.Generic.KeyValuePair{System.Int32,Microsoft.Build.Framework.BuildEventArgs}},Microsoft.Build.Shared.LogMessagePacketBase.TargetFinishedTranslator)">
            <summary>
            Encapsulates the buildEventArg in this packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for deserialization
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.LogMessagePacketBase.TargetFinishedTranslator">
            <summary>
            Delegate for translating TargetFinishedEventArgs
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.LogMessagePacketBase.ArgsWriterDelegate">
            <summary>
            Delegate representing a method on the BuildEventArgs classes used to write to a stream.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.LogMessagePacketBase.ArgsReaderDelegate">
            <summary>
            Delegate representing a method on the BuildEventArgs classes used to read from a stream.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.LogMessagePacketBase.Type">
            <summary>
            The nodePacket Type, in this case the packet is a Logging Message
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.LogMessagePacketBase.NodeBuildEvent">
            <summary>
            The buildEventArg wrapped by this packet
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.LogMessagePacketBase.EventType">
            <summary>
            The event type of the wrapped buildEventArg 
            based on the LoggingEventType enumeration 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads/writes this packet
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteToStream(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Writes the logging packet to the translator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadFromStream(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads the logging packet from the translator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.CreateDelegateRobust(System.Type,System.Object,System.Reflection.MethodInfo)">
            <summary>
            Wrapper for Delegate.CreateDelegate with retries.
            </summary>
            <comment>
            TODO:  Investigate if it would be possible to use one of the overrides of CreateDelegate 
            that doesn't force the delegate to be closed over its first argument, so that we can 
            only create the delegate once per event type and cache it.  
            </comment>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.GetBuildEventArgFromId">
            <summary>
            Takes in a id (LoggingEventType as an int) and creates the correct specific logging class
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.GetLoggingEventId(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Based on the type of the BuildEventArg to be wrapped
            generate an Id which identifies which concrete type the
            BuildEventArg is.
            </summary>
            <param name="eventArg">Argument to get the type Id for</param>
            <returns>An enumeration entry which represents the type</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteEventToStream(Microsoft.Build.Framework.BuildEventArgs,Microsoft.Build.Shared.LoggingEventType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Given a build event that is presumed to be 2.0 (due to its lack of a "WriteToStream" method) and its 
            LoggingEventType, serialize that event to the stream. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteExternalProjectFinishedEventToStream(Microsoft.Build.Framework.ExternalProjectFinishedEventArgs,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Serialize ExternalProjectFinished Event Argument to the stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteExternalProjectStartedEventToStream(Microsoft.Build.Framework.ExternalProjectStartedEventArgs,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            ExternalProjectStartedEvent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteBuildWarningEventToStream(Microsoft.Build.Framework.BuildWarningEventArgs,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Write Build Warning Log message into the translator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteBuildErrorEventToStream(Microsoft.Build.Framework.BuildErrorEventArgs,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Write a Build Error message into the translator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteTaskCommandLineEventToStream(Microsoft.Build.Framework.TaskCommandLineEventArgs,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Write Task Command Line log message into the translator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.WriteBuildMessageEventToStream(Microsoft.Build.Framework.BuildMessageEventArgs,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Write a "standard" Message Log the translator 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadEventFromStream(Microsoft.Build.Shared.LoggingEventType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Given a build event that is presumed to be 2.0 (due to its lack of a "ReadFromStream" method) and its 
            LoggingEventType, read that event from the stream. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadExternalProjectFinishedEventFromStream(Microsoft.Build.BackEnd.ITranslator,System.String,System.String,System.String)">
            <summary>
            Read and reconstruct a ProjectFinishedEventArgs from the stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadExternalProjectStartedEventFromStream(Microsoft.Build.BackEnd.ITranslator,System.String,System.String,System.String)">
            <summary>
            Read and reconstruct a ProjectStartedEventArgs from the stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadBuildWarningEventFromStream(Microsoft.Build.BackEnd.ITranslator,System.String,System.String,System.String)">
            <summary>
            Read and reconstruct a BuildWarningEventArgs from the stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadTaskBuildErrorEventFromStream(Microsoft.Build.BackEnd.ITranslator,System.String,System.String,System.String)">
            <summary>
            Read and reconstruct a BuildErrorEventArgs from the stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadTaskCommandLineEventFromStream(Microsoft.Build.BackEnd.ITranslator,System.String,System.String,System.String)">
            <summary>
            Read and reconstruct a TaskCommandLineEventArgs from the stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LogMessagePacketBase.ReadBuildMessageEventFromStream(Microsoft.Build.BackEnd.ITranslator,System.String,System.String,System.String)">
            <summary>
            Read and reconstruct a BuildMessageEventArgs from the stream 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ReuseableStringBuilder">
            <summary>
            A StringBuilder lookalike that reuses its internal storage.
            </summary>
            <remarks>
            You can add any properties or methods on the real StringBuilder that are needed.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._borrowedBuilder">
            <summary>
            Captured string builder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._cachedString">
            <summary>
            Profiling showed that the hot code path for large string builder calls first IsOrdinalEqualToStringOfSameLength followed by ExpensiveConvertToString
            when IsOrdinalEqualToStringOfSameLength did return true. We can therefore reduce the costs for large strings by over a factor two. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder._capacity">
            <summary>
            Capacity to initialize the builder with.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.#ctor(System.Int32)">
            <summary>
            Create a new builder, under the covers wrapping a reused one.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ReuseableStringBuilder.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.MaxByCharCompareLength">
            <summary>
            The number here is arbitrary. For a StringBuilder we have a chunk length of 8000 characters which corresponds to
            5 StringBuilder chunks which need to be walked before the next character can be fetched (see MaxChunkSize of StringBuilder).
            That should be a good compromise to not allocate to much but still make use of the intern cache. The actual cutoff where it is cheaper
            to allocate a temp string might be well below that limit but that depends on many other factors such as GC Heap size and other allocating threads. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Microsoft#Build#OpportunisticIntern#IInternable#ReferenceEquals(System.String)">
            <summary>
            Never reference equals to string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ToString">
            <summary>
            Convert to a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.System#IDisposable#Dispose">
            <summary>
            Dispose, indicating you are done with this builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.Char)">
            <summary>
            Append a character.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.String)">
            <summary>
            Append a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Append(System.String,System.Int32,System.Int32)">
            <summary>
            Append a substring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a substring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.LazyPrepare">
            <summary>
            Grab a backing builder if necessary.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory">
            <summary>
            A utility class that mediates access to a shared string builder.
            </summary>
            <remarks>
            If this shared builder is highly contended, this class could add
            a second one and try both in turn.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.MaxBuilderSize">
            <summary>
            Made up limit beyond which we won't share the builder
            because we could otherwise hold a huge builder indefinitely.
            This size seems reasonable for MSBuild uses (mostly expression expansion)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.s_sharedBuilder">
            <summary>
            The shared builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.Get(System.Int32)">
            <summary>
            Obtains a string builder which may or may not already
            have been used. 
            Never returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReuseableStringBuilder.ReuseableStringBuilderFactory.Release(System.Text.StringBuilder)">
            <summary>
            Returns the shared builder for the next caller to use.
            ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ThreadPoolExtensions">
            <summary>
            Class to wrap the saving and restoring of the culture of a threadpool thread
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ThreadPoolExtensions.QueueThreadPoolWorkItemWithCulture(System.Threading.WaitCallback,System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            <summary>
            Queue a threadpool thread and set it to a certain culture.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioLocationHelper">
            <summary>
            Helper class to wrap the Microsoft.VisualStudio.Setup.Configuration.Interop API to query
            Visual Studio setup for instances installed on the machine.
            Code derived from sample: https://code.msdn.microsoft.com/Visual-Studio-Setup-0cedd331
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VisualStudioLocationHelper.GetInstances">
            <summary>
            Query the Visual Studio setup API to get instances of Visual Studio installed
            on the machine. Will not include anything before Visual Studio "15".
            </summary>
            <returns>Enumerable list of Visual Studio instances</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioInstance">
            <summary>
            Wrapper class to represent an installed instance of Visual Studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Version">
            <summary>
            Version of the Visual Studio Instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Path">
            <summary>
            Path to the Visual Studio installation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.VisualStudioInstance.Name">
            <summary>
            Full name of the Visual Studio instance with SKU name
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.CollectionHelpers">
            <summary>
            Utilities for collections
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.CollectionHelpers.RemoveNulls``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns a new list containing the input list
            contents, except for nulls
            </summary>
            <typeparam name="T">Type of list elements</typeparam>
        </member>
        <member name="M:Microsoft.Build.Shared.CollectionHelpers.ContainsValueAndIsEqual(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String,System.StringComparison)">
            <summary>
            Extension method -- combines a TryGet with a check to see that the value is equal. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyResources">
            <summary>
            This class provides access to the assembly's resources.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyResources.s_msbuildExeResourceManager">
            <summary>
            A slot for msbuild.exe to add a resource manager over its own resources, that can also be consulted.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.RegisterMSBuildExeResources(System.Resources.ResourceManager)">
            <summary>
            The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and 
            ResourceUtilities class that uses it. To make this possible, MSBuild.exe registers its resources here and they are
            normally consulted last. This assumes that there are no duplicated resource ID's between the Engine and MSBuild.exe.
            (Actually there are currently two: LoggerCreationError and LoggerNotFoundError.
            We can't change the resource ID's this late in the cycle and we sometimes want to load the MSBuild.exe ones,
            because they're a little different. So for that purpose we call GetStringLookingInMSBuildExeResourcesFirst() )
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.GetString(System.String)">
            <summary>
            Loads the specified resource string, either from the assembly's primary resources, or its shared resources.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="name"></param>
            <returns>The resource string, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.GetStringLookingInMSBuildExeResourcesFirst(System.String)">
            <summary>
            Loads the specified resource string.
            </summary>
            <returns>The resource string, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.GetStringFromEngineResources(System.String)">
            <summary>
            Loads the specified resource string, from the Engine or else Shared resources.
            </summary>
            <returns>The resource string, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyResources.GetStringFromMSBuildExeResources(System.String)">
            <summary>
            Loads the specified resource string, from the MSBuild.exe resources.
            </summary>
            <returns>The resource string, or null if not found.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyLoadInfo">
            <summary>
            This class packages information about how to load a given assembly -- an assembly can be loaded by either its assembly
            name (strong or weak), or its filename/path.
            </summary>
            <remarks>
            Uses factory to instantiate correct private class to save space: only one field is ever used of the two.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyLoadInfo.Create(System.String,System.String)">
            <summary>
            This constructor initializes the assembly information.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyName">
            <summary>
            Gets the assembly's identity denoted by its strong/weak name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyFile">
            <summary>
            Gets the path to the assembly file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLocation">
            <summary>
            Get the assembly location
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyLoadInfo.GetHashCode">
            <summary>
            Computes a hashcode for this assembly info, so this object can be used as a key into
            a hash table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyLoadInfo.Equals(System.Object)">
            <summary>
            Determines if two AssemblyLoadInfos are effectively the same.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithName">
            <summary>
            Assembly represented by name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithName._assemblyName">
            <summary>
            Assembly name
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithName.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithName.AssemblyName">
            <summary>
            Gets the assembly's identity denoted by its strong/weak name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithName.AssemblyFile">
            <summary>
            Gets the path to the assembly file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithName.AssemblyLocation">
            <summary>
            Get the assembly location
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithFile">
            <summary>
            Assembly info that uses a file path
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithFile._assemblyFile">
            <summary>
            Path to assembly
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithFile.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithFile.AssemblyName">
            <summary>
            Gets the assembly's identity denoted by its strong/weak name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithFile.AssemblyFile">
            <summary>
            Gets the path to the assembly file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyLoadInfo.AssemblyLoadInfoWithFile.AssemblyLocation">
            <summary>
            Get the assembly location
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.PartialComparisonFlags">
            <summary>
            Specifies the parts of the assembly name to partially match
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.SimpleName">
            <summary>
            Compare SimpleName  A.PartialCompare(B,SimpleName)  match the simple name on A and B if the simple name on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.Version">
            <summary>
            Compare Version A.PartialCompare(B, Version)  match the Version on A and B if the Version on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.Culture">
            <summary>
            Compare Culture A.PartialCompare(B, Culture)  match the Culture on A and B if the Culture on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.PublicKeyToken">
            <summary>
            Compare PublicKeyToken A.PartialCompare(B, PublicKeyToken)  match the PublicKeyToken on A and B if the PublicKeyToken on A is not null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.PartialComparisonFlags.Default">
            <summary>
            When doing a comparison   A.PartialCompare(B, Default) compare all fields of A which are not null with B.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyNameExtension">
            <summary>
            A replacement for AssemblyName that optimizes calls to FullName which is expensive.
            The assembly name is represented internally by an AssemblyName and a string, conversion
            between the two is done lazily on demand.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.AssemblyNameExtension.remappedFrom">
            <summary>
            Set of assemblyNameExtensions that THIS assemblyname was remapped from.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor">
            <summary>
            Construct an unnamed assembly.
            Private because we want only one of these.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.Reflection.AssemblyName)">
            <summary>
            Construct with AssemblyName.
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.String)">
            <summary>
            Construct with string.
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.String,System.Boolean)">
            <summary>
            Construct from a string, but immediately construct a real AssemblyName.
            This will cause an exception to be thrown up front if the assembly name 
            isn't well formed.
            </summary>
            <param name="assemblyName">
            The string version of the assembly name.
            </param>
            <param name="validate">
            Used when the assembly name comes from a user-controlled source like a project file or config file.
            Does extra checking on the assembly name and will throw exceptions if something is invalid.
            </param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Ctor for deserializing from state file (binary serialization).
            <remarks>This is required because AssemblyName is not Serializable on .NET Core.</remarks>
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetAssemblyNameEx(System.String)">
            <summary>
            To be used as a delegate. Gets the AssemblyName of the given file.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.SetRemappedFromDefaultAfterSerialization(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Run after the object has been deserialized
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.InitializeRemappedFrom">
            <summary>
            Initialize the remapped from structure.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CreateAssemblyName">
            <summary>
            Assume there is a string version, create the AssemblyName version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CreateFullName">
            <summary>
            Assume there is a string version, create the AssemblyName version.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Name">
            <summary>
            The base name of the assembly.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.ProcessorArchitecture">
            <summary>
            Gets the backing AssemblyName, this can be None.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Version">
            <summary>
            The assembly's version number.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.IsSimpleName">
            <summary>
            Is the assembly a complex name or a simple name. A simple name is where only the name is set 
            a complex name is where the version, culture or publickeytoken is also set
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.HasProcessorArchitectureInFusionName">
            <summary>
            Does the fullName have the processor architecture defined
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ReplaceVersion(System.Version)">
            <summary>
            Replace the current version with a new version.
            </summary>
            <param name="version"></param>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.CultureInfo">
            <summary>
            The assembly's Culture
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Retargetable">
            <summary>
            The assembly's retargetable bit
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.RemappedFromEnumerator">
            <summary>
            The full name of the original extension we were before being remapped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.AddRemappedAssemblyName(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Add an assemblyNameExtension which represents an assembly name which was mapped to THIS assemblyName.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.AssemblyName">
            <summary>
            As an AssemblyName
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.FullName">
            <summary>
            The assembly's full name.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetPublicKeyToken">
            <summary>
            Get the assembly's public key token.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.UnnamedAssembly">
            <summary>
            A special "unnamed" instance of AssemblyNameExtension.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareTo(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare one assembly name to another.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareTo(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean)">
            <summary>
            Compare one assembly name to another.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetHashCode">
            <summary>
            Get a hash code for this assembly name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareBaseNameTo(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare two base names as quickly as possible.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareBaseNameToImpl(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            An implementation of compare that compares two base 
            names as quickly as possible.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareBaseNamesStringWise(System.String,System.String)">
            <summary>
            Compare two basenames.
            </summary>
            <param name="asString1"></param>
            <param name="asString2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.Clone">
            <summary>
            Clone this assemblyNameExtension
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CloneImmutable">
            <summary>
            Clone the object but mark and mark the cloned object as immutable
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.Immutable">
            <summary>
            Is this object immutable
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.MarkImmutable">
            <summary>
            Mark this object as immutable
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.Equals(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare two assembly names for equality.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.System#IEquatable{Microsoft#Build#Shared#AssemblyNameExtension}#Equals(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Interface method for IEquatable&lt;AssemblyNameExtension&gt;
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.EqualsIgnoreVersion(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare two assembly names for equality ignoring version.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.Equals(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean)">
            <summary>
            Compare two assembly names and consider the retargetable flag during the comparison
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.EqualsImpl(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean,System.Boolean)">
            <summary>
            Compare two assembly names for equality.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.CompareCultures(System.Reflection.AssemblyName,System.Reflection.AssemblyName)">
            <summary>
            Allows the comparison of the culture.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ComparePublicKeyToken(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
             Allows the comparison of just the PublicKeyToken
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ComparePublicKeyTokens(System.Byte[],System.Byte[])">
            <summary>
            Compare two public key tokens.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.AssemblyNameExtension.IsUnnamedAssembly">
            <summary>
            Only the unnamed assembly has both null assemblyname and null string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.GetAssemblyNameFromDisplayName(System.String)">
            <summary>
            Given a display name, construct an assembly name.
            </summary>
            <param name="displayName">The display name.</param>
            <returns>The assembly name.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.EscapeDisplayNameCharacters(System.String)">
            <summary>
            Return a string that has AssemblyName special characters escaped. 
            Those characters are Equals(=), Comma(,), Quote("), Apostrophe('), Backslash(\).
            </summary>
            <remarks>
            WARNING! This method is not meant as a general purpose escaping method for assembly names.
            Use only if you really know that this does what you need.
            </remarks>
            <param name="displayName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.ToString">
            <summary>
            Convert to a string for display.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension)">
            <summary>
            Compare the fields of this with that if they are not null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean)">
            <summary>
            Compare the fields of this with that if they are not null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.PartialComparisonFlags)">
            <summary>
            Do a partial comparison between two assembly name extensions.
            Compare the fields of A and B on the following conditions:
            1) A.Field has a non null value 
            2) The field has been selected in the comparison flags or the default comparison flags are passed in.
            
            If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.AssemblyNameExtension.PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.PartialComparisonFlags,System.Boolean)">
            <summary>
            Do a partial comparison between two assembly name extensions.
            Compare the fields of A and B on the following conditions:
            1) A.Field has a non null value 
            2) The field has been selected in the comparison flags or the default comparison flags are passed in.
            
            If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.BuildEventFileInfo">
            <summary>
            This class encapsulates information about a file that is associated with a build event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEventFileInfo.#ctor(System.String)">
            <summary>
            Creates an instance of this class using the given filename/path.
            Filename may be an empty string, if there is truly no file associated.
            This overload may also be used if there is a file but truly no line/column,
            for example when failing to load a project file.
            
            IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEventFileInfo.#ctor(Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Creates an instance of this class using the given location.
            This does not provide end-line or end-column information.
            This is the preferred overload.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEventFileInfo.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates an instance of this class using the given filename/path and a line/column of interest in the file.
            
            IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
            </summary>
            <param name="file"></param>
            <param name="line">Set to zero if not available.</param>
            <param name="column">Set to zero if not available.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEventFileInfo.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance of this class using the given filename/path and a range of lines/columns of interest in the file.
            
            IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
            </summary>
            <param name="file"></param>
            <param name="line">Set to zero if not available.</param>
            <param name="column">Set to zero if not available.</param>
            <param name="endLine">Set to zero if not available.</param>
            <param name="endColumn">Set to zero if not available.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEventFileInfo.#ctor(System.Xml.XmlException)">
            <summary>
            Creates an instance of this class using the information in the given XmlException.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.BuildEventFileInfo.#ctor(System.String,System.Xml.XmlException)">
            <summary>
            Creates an instance of this class using the information in the given XmlException and file location.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEventFileInfo.File">
            <summary>
            Gets the filename/path to be associated with some build event.
            </summary>
            <value>The filename/path string.</value>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEventFileInfo.Line">
            <summary>
            Gets the line number of interest in the file.
            </summary>
            <value>Line number, or zero if not available.</value>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEventFileInfo.Column">
            <summary>
            Gets the column number of interest in the file.
            </summary>
            <value>Column number, or zero if not available.</value>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEventFileInfo.EndLine">
            <summary>
            Gets the last line number of a range of interesting lines in the file.
            </summary>
            <value>Last line number, or zero if not available.</value>
        </member>
        <member name="P:Microsoft.Build.Shared.BuildEventFileInfo.EndColumn">
            <summary>
            Gets the last column number of a range of interesting columns in the file.
            </summary>
            <value>Last column number, or zero if not available.</value>
        </member>
        <member name="T:Microsoft.Build.Shared.ConversionUtilities">
            <summary>
            This class contains only static methods, which are useful throughout many
            of the MSBuild classes and don't really belong in any specific class.   
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertStringToBool(System.String)">
            <summary>
            Converts a string to a bool.  We consider "true/false", "on/off", and 
            "yes/no" to be valid boolean representations in the XML.
            </summary>
            <param name="parameterValue">The string to convert.</param>
            <returns>Boolean true or false, corresponding to the string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertByteArrayToHex(System.Byte[])">
            <summary>
            Returns a hex representation of a byte array.
            </summary>
            <param name="bytes">The bytes to convert</param>
            <returns>A string byte types formated as X2.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.CanConvertStringToBool(System.String)">
            <summary>
            Returns true if the string can be successfully converted to a bool,
            such as "on" or "yes"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidBooleanTrue(System.String)">
            <summary>
            Returns true if the string represents a valid MSBuild boolean true value,
            such as "on", "!false", "yes"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidBooleanFalse(System.String)">
            <summary>
            Returns true if the string represents a valid MSBuild boolean false value,
            such as "!on" "off" "no" "!true"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertDecimalToDouble(System.String)">
            <summary>
            Converts a string like "123.456" into a double. Leading sign is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertHexToDouble(System.String)">
            <summary>
            Converts a hex string like "0xABC" into a double.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ConvertDecimalOrHexToDouble(System.String)">
            <summary>
            Converts a string like "123.456" or "0xABC" into a double.
            Tries decimal conversion first.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidHexNumber(System.String)">
            <summary>
            Returns true if the string is a valid hex number, like "0xABC"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidDecimalNumber(System.String)">
            <summary>
            Returns true if the string is a valid decimal number, like "-123.456"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ConversionUtilities.ValidDecimalOrHexNumber(System.String)">
            <summary>
            Returns true if the string is a valid decimal or hex number
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.DirectoryGetFiles">
            <summary>
            delegate for System.IO.Directory.GetFiles, used for testing
            </summary>
            <param name="path">Directory path to start search for files in</param>
            <param name="searchPattern">pattern of files to match</param>
            <returns>string array of files which match search pattern</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.GetDirectories">
            <summary>
            delegate for Directory.GetDirectories.
            </summary>
            <param name="path">The path to get directories for.</param>
            <param name="pattern">The pattern to search for.</param>
            <returns>An array of directories.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.DirectoryExists">
            <summary>
            Delegate for System.IO.Directory.Exists
            </summary>
            <param name="path">Directory path to check if it exists</param>
            <returns>true if directory exists</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileExists">
            <summary>
            File exists delegate
            </summary>
            <param name="path">The path to check for existence.</param>
            <returns>'true' if the file exists.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileCopy">
            <summary>
            File.Copy delegate
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileDelete">
            <summary>
            File.Delete delegate
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileCreate">
            <summary>
            File create delegate
            </summary>
            <param name="path">The path to create.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.ErrorUtilities">
            <summary>
            This class contains methods that are useful for error checking and validation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ErrorUtilities.s_throwExceptions">
            <summary>
            Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
            and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
            then we can give them this undocumented environment variable as an immediate workaround.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Object[])">
            <summary>
            Throws InternalErrorException. 
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Exception,System.Object[])">
            <summary>
            Throws InternalErrorException. 
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInternalErrorUnreachable">
            <summary>
            Throws InternalErrorException. 
            Indicates the code path followed should not have been possible.
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowIfTypeDoesNotImplementToString(System.Object)">
            <summary>
            Throws InternalErrorException. 
            Indicates the code path followed should not have been possible.
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalNull(System.Object,System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is null.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="parameter">The value of the argument.</param>
            <param name="parameterName">Parameter that should not be null</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalLockHeld(System.Object)">
            <summary>
            Helper to throw an InternalErrorException when a lock on the specified object is not already held.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="locker">The object that should already have been used as a lock.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalLength(System.String,System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is null or zero length.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="parameterValue">The value of the argument.</param>
            <param name="parameterName">Parameter that should not be null or zero length</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalRooted(System.String)">
            <summary>
            Helper to throw an InternalErrorException when the specified parameter is not a rooted path.
            This should be used ONLY if this would indicate a bug in MSBuild rather than
            anything caused by user action.
            </summary>
            <param name="value">Parameter that should be a rooted path</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String)">
            <summary>
            This method should be used in places where one would normally put
            an "assert". It should be used to validate that our assumptions are
            true, where false would indicate that there must be a bug in our
            code somewhere. This should not be used to throw errors based on bad
            user input or anything that the user did wrong.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowInvalidOperation(System.String,System.Object[])">
            <summary>
            Throws an InvalidOperationException with the specified resource string
            </summary>
            <param name="resourceName">Resource to use in the exception</param>
            <param name="args">Formatting args.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String)">
            <summary>
            Throws an InvalidOperationException if the given condition is false.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgument(System.String,System.Object[])">
            <summary>
            Throws an ArgumentException that can include an inner exception.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgument(System.Exception,System.String,System.Object[])">
            <summary>
            Throws an ArgumentException that can include an inner exception.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>
            This method is thread-safe.
            </remarks>
            <param name="innerException">Can be null.</param>
            <param name="resourceName"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String)">
            <summary>
            Throws an ArgumentException if the given condition is false.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String)">
            <summary>
            Throws an ArgumentException that includes an inner exception, if
            the given condition is false.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException">Can be null.</param>
            <param name="resourceName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="condition"></param>
            <param name="innerException"></param>
            <param name="resourceName"></param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.ThrowArgumentOutOfRange(System.String)">
            <summary>
            Throws an argument out of range exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentOutOfRange(System.Boolean,System.String)">
            <summary>
            Throws an ArgumentOutOfRangeException using the given parameter name
            if the condition is false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentLength(System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given string parameter is null
            and ArgumentException if it has zero length.
            </summary>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentInvalidPath(System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given string parameter is null
            and ArgumentException if it has zero length.
            </summary>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(System.String,System.String)">
            <summary>
            Throws an ArgumentException if the string has zero length, unless it is 
            null, in which case no exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentNull(System.Object,System.String)">
            <summary>
            Throws an ArgumentNullException if the given parameter is null.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="parameter"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentNull(System.Object,System.String,System.String)">
            <summary>
            Throws an ArgumentNullException if the given parameter is null.
            </summary>
            <remarks>This method is thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ErrorUtilities.VerifyThrowArgumentArraysSameLength(System.Array,System.Array,System.String,System.String)">
            <summary>
            Verifies the given arrays are not null and have the same length
            </summary>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="parameter1Name"></param>
            <param name="parameter2Name"></param>
        </member>
        <member name="T:Microsoft.Build.Shared.EscapingUtilities">
            <summary>
            This class implements static methods to assist with unescaping of %XX codes
            in the MSBuild file format.
            </summary>
            <remarks>
            PERF: since we escape and unescape relatively frequently, it may be worth caching
            the last N strings that were (un)escaped
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.EscapingUtilities.s_unescapedToEscapedStrings">
            <summary>
            Optional cache of escaped strings for use when needing to escape in performance-critical scenarios with significant
            expected string reuse.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.UnescapeAll(System.String)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.UnescapeAll(System.String,System.Boolean@)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <param name="escapingWasNecessary">Whether any replacements were made.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.EscapeWithCaching(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Interns and caches the result.
            </summary>
            <comment>
            NOTE:  Only recommended for use in scenarios where there's expected to be significant
            repetition of the escaped string.  Cache currently grows unbounded.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.Escape(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <returns>escaped string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.EscapeWithOptionalCaching(System.String,System.Boolean)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Caches if requested.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <param name="cache">
            True if the cache should be checked, and if the resultant string
            should be cached.
            </param>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.ContainsReservedCharacters(System.String)">
            <summary>
            Before trying to actually escape the string, it can be useful to call this method to determine
            if escaping is necessary at all.  This can save lots of calls to copy around item metadata
            that is really the same whether escaped or not.
            </summary>
            <param name="unescapedString"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.ContainsEscapedWildcards(System.String)">
            <summary>
            Determines whether the string contains the escaped form of '*' or '?'.
            </summary>
            <param name="escapedString"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.HexDigitChar(System.Int32)">
            <summary>
            Convert the given integer into its hexadecimal representation.
            </summary>
            <param name="x">The number to convert, which must be non-negative and less than 16</param>
            <returns>The character which is the hexadecimal representation of <paramref name="x"/>.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.AppendEscapedChar(System.Text.StringBuilder,System.Char)">
            <summary>
            Append the escaped version of the given character to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/> to which to append.</param>
            <param name="ch">The character to escape.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.EscapingUtilities.AppendEscapedString(System.Text.StringBuilder,System.String)">
            <summary>
            Append the escaped version of the given string to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/> to which to append.</param>
            <param name="unescapedString">The unescaped string.</param>
        </member>
        <member name="F:Microsoft.Build.Shared.EscapingUtilities.s_charsToEscape">
            <summary>
            Special characters that need escaping.
            It's VERY important that the percent character is the FIRST on the list - since it's both a character
            we escape and use in escape sequences, we can unintentionally escape other escape sequences if we
            don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits
            (that would require rewriting the algorithm) but since it seems unlikely that we ever do, this should
            be good enough to avoid complicating the algorithm at this point.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.VersionUtilities">
            <summary>
            Set of methods to deal with versions in the tasks
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.ConvertToVersion(System.String)">
            <summary>
            Convert a version number like 0.0.0.0 to a Version instance.
            The method will return null if the string is not a valid value
            </summary>
            <param name="version">Version string to convert to a version object</param>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.GatherVersionStrings(System.Version,System.Collections.IEnumerable)">
            <summary>
            Go though an enumeration and create a sorted list of strings which can be parsed as versions. Keep around the original 
            string because it may contain a v and this would be required to create the correct path on disk if the string was part of a path.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.VersionUtilities.ConvertToVersion(System.String,System.Boolean)">
            <summary>
             Convert a version number like 0.0.0.0 to a Version instance.
            </summary>
            <param name="version"></param>
            <param name="throwException">Should we use Parse to TryParse (parse means we throw an exception, tryparse means we will not).</param>
        </member>
        <member name="F:Microsoft.Build.Shared.ReverseStringGenericComparer.Comparer">
            <summary>
            Static accessor for a ReverseVersionGenericComparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReverseStringGenericComparer.System#Collections#Generic#IComparer{System#String}#Compare(System.String,System.String)">
            <summary>
            The Compare implements a reverse comparison
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ReverseVersionGenericComparer.Comparer">
            <summary>
            Static accessor for a ReverseVersionGenericComparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ReverseVersionGenericComparer.System#Collections#Generic#IComparer{System#Version}#Compare(System.Version,System.Version)">
            <summary>
            The Compare implements a reverse comparison
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.EventArgsFormatting">
            <summary>
            Offers a default string format for Error and Warning events
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Format the error event message and all the other event data into
            a single string.
            </summary>
            <param name="e">Error to format</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildErrorEventArgs,System.Boolean)">
            <summary>
            Format the error event message and all the other event data into
            a single string.
            </summary>
            <param name="e">Error to format</param>
            <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Format the warning message and all the other event data into a
            single string.
            </summary>
            <param name="e">Warning to format</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildWarningEventArgs,System.Boolean)">
            <summary>
            Format the warning message and all the other event data into a
            single string.
            </summary>
            <param name="e">Warning to format</param>
            <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Format the message and all the other event data into a
            single string.
            </summary>
            <param name="e">Message to format</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(Microsoft.Build.Framework.BuildMessageEventArgs,System.Boolean)">
            <summary>
            Format the message and all the other event data into a
            single string.
            </summary>
            <param name="e">Message to format</param>
            <param name="showProjectFile">Show project file or not</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Format the event message and all the other event data into a
            single string.
            </summary>
            <param name="category">category ("error" or "warning")</param>
            <param name="subcategory">subcategory</param>
            <param name="message">event message</param>
            <param name="code">error or warning code number</param>
            <param name="file">file name</param>
            <param name="lineNumber">line number (0 if n/a)</param>
            <param name="endLineNumber">end line number (0 if n/a)</param>
            <param name="columnNumber">column number (0 if n/a)</param>
            <param name="endColumnNumber">end column number (0 if n/a)</param>
            <param name="threadId">thread id</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.FormatEventMessage(System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Format the event message and all the other event data into a
            single string.
            </summary>
            <param name="category">category ("error" or "warning")</param>
            <param name="subcategory">subcategory</param>
            <param name="message">event message</param>
            <param name="code">error or warning code number</param>
            <param name="file">file name</param>
            <param name="projectFile">the project file name</param>
            <param name="lineNumber">line number (0 if n/a)</param>
            <param name="endLineNumber">end line number (0 if n/a)</param>
            <param name="columnNumber">column number (0 if n/a)</param>
            <param name="endColumnNumber">end column number (0 if n/a)</param>
            <param name="threadId">thread id</param>
            <returns>The formatted message string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.EventArgsFormatting.SplitStringOnNewLines(System.String)">
            <summary>
            Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
            </summary>
            <param name="s">String to split.</param>
        </member>
        <member name="F:Microsoft.Build.Shared.EventArgsFormatting.s_newLines">
            <summary>
            The kinds of newline breaks we expect.
            </summary>
            <remarks>Currently we're not supporting "\r".</remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.ExceptionHandling">
            <summary>
            Utility methods for classifying and handling exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.GetDebugDumpPath">
            <summary>
            Gets the location of the directory used for diagnostic log files.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.DebugDumpPath">
            <summary>
            The directory used for diagnostic log files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.ExceptionHandling.s_dumpFileName">
            <summary>
            The filename that exceptions will be dumped to
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(System.Exception)">
            <summary>
            If the given exception is "ignorable under some circumstances" return false.
            Otherwise it's "really bad", and return true.
            This makes it possible to catch(Exception ex) without catching disasters.
            </summary>
            <param name="e"> The exception to check. </param>
            <returns> True if exception is critical. </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedException(System.Exception)">
            <summary>
            If the given exception is file IO related or expected return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
            <returns>True if exception is not IO related or expected otherwise false.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsIoRelatedException(System.Exception)">
            <summary>
            Determine whether the exception is file-IO related.
            </summary>
            <param name="e">The exception to check.</param>
            <returns>True if exception is IO related.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.IsXmlException(System.Exception)">
            <summary> Checks if the exception is an XML one. </summary>
            <param name="e"> Exception to check. </param>
            <returns> True if exception is related to XML parsing. </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.GetXmlLineAndColumn(System.Exception)">
            <summary> Extracts line and column numbers from the exception if it is XML-related one. </summary>
            <param name="e"> XML-related exception. </param>
            <returns> Line and column numbers if available, (0,0) if not. </returns>
            <remarks> This function works around the fact that XmlException and XmlSchemaException are not directly related. </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedIoOrXmlException(System.Exception)">
            <summary>
            If the given exception is file IO related or Xml related return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedReflectionException(System.Exception)">
            <summary>
            If the given exception is reflection-related return false.
            Otherwise, return true.
            </summary>
            <param name="e">The exception to check.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedSerializationException(System.Exception)">
            <summary>
            Serialization has been observed to throw TypeLoadException as
            well as SerializationException and IO exceptions. (Obviously
            it has to do reflection but it ought to be wrapping the exceptions.)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedRegistryException(System.Exception)">
            <summary>
            Returns false if this is a known exception thrown by the registry API.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.NotExpectedFunctionException(System.Exception)">
            <summary>
            Returns false if this is a known exception thrown by function evaluation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.UnhandledExceptionHandler(System.Object,System.UnhandledExceptionEventArgs)">
            <summary>
            Dump any unhandled exceptions to a file so they can be diagnosed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.DumpExceptionToFile(System.Exception)">
            <summary>
            Dump the exception information to a file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ExceptionHandling.ReadAnyExceptionFromFile(System.DateTime)">
            <summary>
            Returns the content of any exception dump files modified
            since the provided time, otherwise returns an empty string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn">
            <summary> Line and column pair. </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn.Line">
            <summary> Gets or sets line number. </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.ExceptionHandling.LineAndColumn.Column">
            <summary> Gets or sets column position. </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher">
            <summary>
            Functions for matching file names with patterns. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.s_invalidPathChars">
            <summary>
            Cache of the list of invalid path characters, because this method returns a clone (for security reasons)
            which can cause significant transient allocations
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.Default">
            <summary>
            The Default FileMatcher does not cache directory enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.FileSystemEntity">
            <summary>
            The type of entity that GetFileSystemEntries should return.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.GetFileSystemEntries">
            <summary>
            Delegate defines the GetFileSystemEntries signature that GetLongPathName uses
            to enumerate directories on the file system.
            </summary>
            <param name="entityType">Files, Directories, or Files and Directories</param>
            <param name="path">The path to search.</param>
            <param name="pattern">The file pattern.</param>
            <param name="projectDirectory"></param>
            <param name="stripProjectDirectory"></param>
            <returns>An immutable array of filesystem entries.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.HasWildcards(System.String)">
            <summary>
            Determines whether the given path has any wild card characters.
            </summary>
            <param name="filespec"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.HasWildcardsSemicolonItemOrPropertyReferences(System.String)">
            <summary>
            Determines whether the given path has any wild card characters or any semicolons.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFileSystemEntries(Microsoft.Build.Shared.FileSystem.IFileSystem,Microsoft.Build.Shared.FileMatcher.FileSystemEntity,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get the files and\or folders specified by the given path and pattern.
            </summary>
            <param name="entityType">Whether Files, Directories or both.</param>
            <param name="path">The path to search.</param>
            <param name="pattern">The pattern to search.</param>
            <param name="projectDirectory">The directory for the project within which the call is made</param>
            <param name="stripProjectDirectory">If true the project directory should be stripped</param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFilesAndDirectories(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String)">
            <summary>
            Returns an immutable array of file system entries matching the specified search criteria. Inaccessible or non-existent file
            system entries are skipped.
            </summary>
            <param name="path"></param>
            <param name="pattern"></param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>An immutable array of matching file system entries (can be empty).</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.ShouldEnforceMatching(System.String)">
            <summary>
            Determine if the given search pattern will match loosely on Windows
            </summary>
            <param name="searchPattern">The search pattern to check</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleFiles(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Same as Directory.EnumerateFiles(...) except that files that
            aren't accessible are skipped instead of throwing an exception.
            
            Other exceptions are passed through.
            </summary>
            <param name="path">The path.</param>
            <param name="filespec">The pattern.</param>
            <param name="projectDirectory">The project directory</param>
            <param name="stripProjectDirectory"></param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>Files that can be accessed.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetAccessibleDirectories(Microsoft.Build.Shared.FileSystem.IFileSystem,System.String,System.String)">
            <summary>
            Same as Directory.EnumerateDirectories(...) except that files that
            aren't accessible are skipped instead of throwing an exception.
            
            Other exceptions are passed through.
            </summary>
            <param name="path">The path.</param>
            <param name="pattern">Pattern to match</param>
            <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
            <returns>Accessible directories.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetLongPathName(System.String)">
            <summary>
            Given a path name, get its long version.
            </summary>
            <param name="path">The short path.</param>
            <returns>The long path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetLongPathName(System.String,Microsoft.Build.Shared.FileMatcher.GetFileSystemEntries)">
            <summary>
            Given a path name, get its long version.
            </summary>
            <param name="path">The short path.</param>
            <param name="getFileSystemEntries">Delegate.</param>
            <returns>The long path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.SplitFileSpec(System.String,System.String@,System.String@,System.String@)">
            <summary>
            Given a filespec, split it into left-most 'fixed' dir part, middle 'wildcard' dir part, and filename part.
            The filename part may have wildcard characters in it.
            </summary>
            <param name="filespec">The filespec to be decomposed.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.PreprocessFileSpecForSplitting(System.String,System.String@,System.String@,System.String@)">
            <summary>
            Do most of the grunt work of splitting the filespec into parts.
            Does not handle post-processing common to the different matching
            paths.
            </summary>
            <param name="filespec">The filespec to be decomposed.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RemoveInitialDotSlash(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Removes the leading ".\" from all of the paths in the array. 
            </summary>
            <param name="paths">Paths to remove .\ from.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsDirectorySeparator(System.Char)">
            <summary>
            Checks if the char is a DirectorySeparatorChar or a AltDirectorySeparatorChar
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RemoveProjectDirectory(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Removes the current directory converting the file back to relative path 
            </summary>
            <param name="paths">Paths to remove current directory from.</param>
            <param name="projectDirectory"></param>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.Filespec">
            <summary>
            The filespec.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.RegexFileMatch">
            <summary>
            Wild-card matching.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FileMatcher.FilesSearchData.NeedsRecursion">
            <summary>
            If true, then recursion is required.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.BaseDirectory">
            <summary>
            The directory to search in
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.RemainingWildcardDirectory">
            <summary>
            The remaining, wildcard part of the directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.RecursionState.SearchData">
            <summary>
            Data about a search that does not change as the search recursively traverses directories
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFilesRecursive(System.Collections.Concurrent.ConcurrentStack{System.Collections.Generic.List{System.String}},Microsoft.Build.Shared.FileMatcher.RecursionState,System.String,System.Boolean,System.Collections.Generic.IList{Microsoft.Build.Shared.FileMatcher.RecursionState},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.Build.Shared.FileMatcher.RecursionState}},Microsoft.Build.Shared.FileMatcher.TaskOptions)">
            <summary>
            Get all files that match either the file-spec or the regular expression. 
            </summary>
            <param name="listOfFiles">List of files that gets populated.</param>
            <param name="recursionState">Information about the search</param>
            <param name="projectDirectory"></param>
            <param name="stripProjectDirectory"></param>
            <param name="searchesToExclude">Patterns to exclude from the results</param>
            <param name="searchesToExcludeInSubdirs">exclude patterns that might activate farther down the directory tree. Keys assume paths are normalized with forward slashes and no trailing slashes</param>
            <param name="taskOptions">Options for tuning the parallelization of subdirectories</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.RegularExpressionFromFileSpec(System.String,System.String,System.String,System.Boolean@)">
            <summary>
            Given a split file spec consisting of a directory without wildcard characters,
            a sub-directory containing wildcard characters,
            and a filename which may contain wildcard characters,
            create a regular expression that will match that file spec.
            
            PERF WARNING: this method is called in performance-critical
            scenarios, so keep it fast and cheap
            </summary>
            <param name="fixedDirectoryPart">The fixed directory part.</param>
            <param name="wildcardDirectoryPart">The wildcard directory part.</param>
            <param name="filenamePart">The filename part.</param>
            <param name="isLegalFileSpec">Receives whether this pattern is legal or not.</param>
            <returns>The regular expression string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsLegalFileSpec(System.String,System.String)">
            <summary>
            Determine if the filespec is legal according to the following conditions:
            
            (1) It is not legal for there to be a ".." after a wildcard.
            
            (2) By definition, "**" must appear alone between directory slashes.If there is any remaining "**" then this is not
                a valid filespec.
            </summary>
            <returns>True if both parts meet all conditions for a legal filespec.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromFixedDirectory(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the fixed directory part of a filespec:
            
             (1) The leading \\ in UNC paths, so that the doubled slash isn't reduced in the last step
             
             (2) Common filespec characters
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromWildcardDirectory(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the wildcard directory part of a filespec:
            
             (1) The leading **\ if existing
            
             (2) Each occurrence of recursive wildcard \**\
             
             (3) Common filespec characters
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromFilename(Microsoft.Build.Shared.ReuseableStringBuilder,System.String)">
             <summary>
             Append the regex equivalents for character sequences in the filename part of a filespec:
            
             (1) Trailing dots in file names have to be treated specially.
                 We want:
            
                     *. to match foo
            
                 but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful
                 not to match 'foo.txt' by modifying the generated regex for wildcard characters * and ?
             
             (2) Common filespec characters
            
             (3) Ignore the .* portion of any *.* sequence when no trailing dot exists
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.AppendRegularExpressionFromChar(Microsoft.Build.Shared.ReuseableStringBuilder,System.Char)">
            <summary>
            Append the regex equivalents for characters common to all filespec parts.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.LastIndexOfDirectorySequence(System.String,System.Int32)">
             <summary>
             Given an index at a directory separator,
             iteratively skip to the end of two sequences:
            
              (1) \.\ -> \
                 This is an identity, so for example, these two are equivalent,
            
                     dir1\.\dir2 == dir1\dir2
             
                 (2) \\ -> \
                     Double directory separators are treated as a single directory separator,
                     so, for example, this is an identity:
            
                         f:\dir1\\dir2 == f:\dir1\dir2
            
                     The single exemption is for UNC path names, like this:
            
                         \\server\share != \server\share
             
                     This case is handled by isUncPath in
                     a prior step.
            
             </summary>
             <returns>The last index of a directory sequence.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.LastIndexOfDirectoryOrRecursiveSequence(System.String,System.Int32)">
             <summary>
             Given an index at a directory separator or start of a recursive operator,
             iteratively skip to the end of three sequences:
             
             (1), (2) Both sequences handled by IndexOfNextNonCollapsibleChar
             
             (3) \**\**\ -> \**\
                          This is an identity, so for example, these two are equivalent,
            
                             dir1\**\**\ == dir1\**\
             </summary>
             <returns>]
             If starting at a recursive operator, the last index of a recursive sequence.
             Otherwise, the last index of a directory sequence.
             </returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFileSpecInfoWithRegexObject(System.String,System.Text.RegularExpressions.Regex@,System.Boolean@,System.Boolean@)">
            <summary>
            Given a filespec, get the information needed for file matching. 
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="regexFileMatch">Receives the regular expression.</param>
            <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
            <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFileSpecInfo(System.String,System.String@,System.String@,System.String@,System.String@,System.Boolean@,System.Boolean@,Microsoft.Build.Shared.FileMatcher.FixupParts)">
            <summary>
            Given a filespec, parse it and construct the regular expression string.
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
            <param name="wildcardDirectoryPart">Receives the wildcard directory part.</param>
            <param name="filenamePart">Receives the filename part.</param>
            <param name="matchFileExpression">Receives the regular expression.</param>
            <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
            <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
            <param name="fixupParts">hook method to further change the parts</param>
        </member>
        <member name="T:Microsoft.Build.Shared.FileMatcher.Result">
            <summary>
            The results of a match between a filespec and a file name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.Result.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsMatch(System.String,System.String,System.Boolean)">
            <summary>
            A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
            </summary>
            <param name="input">String which is matched against the pattern.</param>
            <param name="pattern">Pattern against which string is matched.</param>
            <param name="ignoreCase">Determines whether ignoring case when comparing two characters</param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.FileMatch(System.String,System.String)">
            <summary>
            Given a pattern (filespec) and a candidate filename (fileToMatch)
            return matching information.
            </summary>
            <param name="filespec">The filespec.</param>
            <param name="fileToMatch">The candidate to match against.</param>
            <returns>The result class.</returns>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.MaxTasks">
            <summary>
            The maximum number of tasks that are allowed to run concurrently
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.AvailableTasks">
            <summary>
            The number of currently available tasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileMatcher.TaskOptions.MaxTasksPerIteration">
            <summary>
            The maximum number of tasks that Parallel.ForEach may use
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFiles(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Given a filespec, find the files that match. 
            Will never throw IO exceptions: if there is no match, returns the input verbatim.
            </summary>
            <param name="projectDirectoryUnescaped">The project directory.</param>
            <param name="filespecUnescaped">Get files that match the given file spec.</param>
            <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
            <returns>The array of files.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.Normalize(System.String)">
            <summary>
            Replace all slashes to the OS slash, collapse multiple slashes into one, trim trailing slashes
            </summary>
            <param name="aString">A string</param>
            <returns>The normalized string</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.SkipCharacters(System.String,System.Int32,System.Func{System.Char,System.Boolean})">
            <summary>
            Skips characters that satisfy the condition <param name="jumpOverCharacter"></param>
            </summary>
            <param name="aString">The working string</param>
            <param name="startingIndex">Offset in string to start the search in</param>
            <returns>First index that does not satisfy the condition. Returns the string's length if end of string is reached</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.IsValidDriveChar(System.Char)">
            <summary>
            Returns true if the given character is a valid drive letter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileMatcher.GetFilesImplementation(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Given a filespec, find the files that match. 
            Will never throw IO exceptions: if there is no match, returns the input verbatim.
            </summary>
            <param name="projectDirectoryUnescaped">The project directory.</param>
            <param name="filespecUnescaped">Get files that match the given file spec.</param>
            <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
            <returns>The array of files.</returns>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilities">
            <summary>
            This class contains utility methods for file IO.
            PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
            each class get pulled into the resulting assembly.
            </summary>
            <summary>
            This class contains utility methods for file IO.
            It is in a separate file so that it can be selectively included into an assembly.
            </summary>
            <summary>
            This class contains utility methods for file IO.
            </summary>
            <comment>
            Partial class in order to reduce the amount of sharing into different assemblies
            </comment>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.cacheDirectory">
            <summary>
            The directory where MSBuild stores cache information used during the build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearCacheDirectoryPath">
            <summary>
            FOR UNIT TESTS ONLY
            Clear out the static variable used for the cache directory so that tests that
            modify it can validate their modifications.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.InvalidPathChars">
            <summary>
            Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
            MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FileUtilities.InvalidFileNameChars">
            <summary>
            Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
            MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetCacheDirectory">
            <summary>
            Retrieves the MSBuild runtime cache directory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetHexHash(System.String)">
            <summary>
            Get the hex hash string for the string
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetPathsHash(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Get the hash for the assemblyPaths
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearCacheDirectory">
            <summary>
            Clears the MSBuild runtime cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureTrailingSlash(System.String)">
            <summary>
            If the given path doesn't have a trailing slash then add one.
            If the path is an empty string, does not modify it.
            </summary>
            <param name="fileSpec">The path to check.</param>
            <returns>A path with a slash.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureNoLeadingSlash(System.String)">
            <summary>
            Ensures the path does not have a leading slash.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EnsureNoTrailingSlash(System.String)">
            <summary>
            Ensures the path does not have a trailing slash.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.EndsWithSlash(System.String)">
            <summary>
            Indicates if the given file-spec ends with a slash.
            </summary>
            <param name="fileSpec">The file spec.</param>
            <returns>true, if file-spec has trailing slash</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsSlash(System.Char)">
            <summary>
            Indicates if the given character is a slash.
            </summary>
            <param name="c"></param>
            <returns>true, if slash</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.TrimAndStripAnyQuotes(System.String)">
            <summary>
            Trims the string and removes any double quotes around it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectoryNameOfFullPath(System.String)">
            <summary>
            Get the directory name of a rooted full path
            </summary>
            <param name="fullPath"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.NormalizePath(System.String)">
            <summary>
            Gets the canonicalized full path of the provided path.
            Guidance for use: call this on all paths accepted through public entry
            points that need normalization. After that point, only verify the path
            is rooted, using ErrorUtilities.VerifyThrowPathRooted.
            ASSUMES INPUT IS ALREADY UNESCAPED.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.MaybeAdjustFilePath(System.String,System.String)">
             <summary>
             If on Unix, convert backslashes to slashes for strings that resemble paths.
             The heuristic is if something resembles paths (contains slashes) check if the
             first segment exists and is a directory.
             Use a native shared method to massage file path. If the file is adjusted,
             that qualifies is as a path.
            
             @baseDirectory is just passed to LooksLikeUnixFilePath, to help with the check
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.LooksLikeUnixFilePath(System.String,System.String)">
             <summary>
             If on Unix, check if the string looks like a file path.
             The heuristic is if something resembles paths (contains slashes) check if the
             first segment exists and is a directory.
            
             If @baseDirectory is not null, then look for the first segment exists under
             that
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectory(System.String)">
            <summary>
            Extracts the directory from the given file-spec.
            </summary>
            <param name="fileSpec">The filespec.</param>
            <returns>directory path</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.HasExtension(System.String,System.String[])">
            <summary>
            Determines whether the given assembly file name has one of the listed extensions.
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="allowedExtensions">Array of extensions to consider.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Shared.FileUtilities.ExecutingAssemblyPath">
            <summary>
            Get the currently executing assembly path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFullPath(System.String,System.String)">
            <summary>
            Determines the full path for the given file-spec.
            ASSUMES INPUT IS STILL ESCAPED
            </summary>
            <param name="fileSpec">The file spec to get the full path of.</param>
            <param name="currentDirectory"></param>
            <returns>full path</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)">
            <summary>
            A variation of Path.GetFullPath that will return the input value
            instead of throwing any IO exception.
            Useful to get a better path for an error message, without the risk of throwing
            if the error message was itself caused by the path being invalid!
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ComparePathsNoThrow(System.String,System.String,System.String)">
            <summary>
            Compare if two paths, relative to the given currentDirectory are equal.
            Does not throw IO exceptions. See <see cref="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)"/>
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <param name="currentDirectory"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.NormalizePathForComparisonNoThrow(System.String,System.String)">
             <summary>
             Normalizes a path for path comparison
             Does not throw IO exceptions. See <see cref="M:Microsoft.Build.Shared.FileUtilities.GetFullPathNoThrow(System.String)"/>
            
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteNoThrow(System.String)">
            <summary>
            A variation on File.Delete that will throw ExceptionHandling.NotExpectedException exceptions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteDirectoryNoThrow(System.String,System.Boolean,System.Int32,System.Int32)">
            <summary>
            A variation on Directory.Delete that will throw ExceptionHandling.NotExpectedException exceptions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DeleteWithoutTrailingBackslash(System.String,System.Boolean)">
            <summary>
            Deletes a directory, ensuring that Directory.Delete does not get a path ending in a slash.
            </summary>
            <remarks>
            This is a workaround for https://github.com/dotnet/corefx/issues/3780, which clashed with a common
            pattern in our tests.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFileInfoNoThrow(System.String)">
            <summary>
            Gets a file info object for the specified file path. If the file path
            is invalid, or is a directory, or cannot be accessed, or does not exist,
            it returns null rather than throwing or returning a FileInfo around a non-existent file.
            This allows it to be called where File.Exists() (which never throws, and returns false
            for directories) was called - but with the advantage that a FileInfo object is returned
            that can be queried (e.g., for LastWriteTime) without hitting the disk again.
            </summary>
            <param name="filePath"></param>
            <returns>FileInfo around path if it is an existing /file/, else null</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.DirectoryExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Returns if the directory exists
            </summary>
            <param name="fullPath">Full path to the directory in the filesystem</param>
            <param name="fileSystem">The file system</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.FileExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Returns if the directory exists
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <param name="fileSystem">The file system</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.FileOrDirectoryExistsNoThrow(System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            If there is a directory or file at the specified path, returns true.
            Otherwise, returns false.
            Does not throw IO exceptions, to match Directory.Exists and File.Exists.
            Unlike calling each of those in turn it only accesses the disk once, which is faster.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsSolutionFilename(System.String)">
            <summary>
            This method returns true if the specified filename is a solution file (.sln), otherwise
            it returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsVCProjFilename(System.String)">
            <summary>
            Returns true if the specified filename is a VC++ project file, otherwise returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsMetaprojectFilename(System.String)">
            <summary>
            Returns true if the specified filename is a metaproject file (.metaproj), otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.MakeRelative(System.String,System.String)">
            <summary>
            Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
            Throws UriFormatException.
            </summary>
            <param name="basePath">
            The base path we want to be relative to. Must be absolute.
            Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
            </param>
            <param name="path">
            The path we need to make relative to basePath.  The path can be either absolute path or a relative path in which case it is relative to the base path.
            If the path cannot be made relative to the base path (for example, it is on another drive), it is returned verbatim.
            If the basePath is an empty string, returns the path.
            </param>
            <returns>relative path (can be the full path)</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.CreateUriFromPath(System.String)">
            <summary>
            Helper function to create an Uri object from path.
            </summary>
            <param name="path">path string</param>
            <returns>uri object</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.AttemptToShortenPath(System.String)">
            <summary>
            Normalizes the path if and only if it is longer than max path,
            or would be if rooted by the current directory.
            This may make it shorter by removing ".."'s.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.IsRootedNoThrow(System.String)">
            <summary>
            A variation of Path.IsRooted that not throw any IO exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetFolderAbove(System.String,System.Int32)">
            <summary>
            Get the folder N levels above the given. Will stop and return current path when rooted.
            </summary>
            <param name="path">Path to get the folder above.</param>
            <param name="count">Number of levels up to walk.</param>
            <returns>Full path to the folder N levels above the path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.CombinePaths(System.String,System.String[])">
            <summary>
            Combine multiple paths. Should only be used when compiling against .NET 2.0.
            <remarks>
            Only use in .NET 2.0. Otherwise, use System.IO.Path.Combine(...)
            </remarks>
            </summary>
            <param name="root">Root path.</param>
            <param name="paths">Paths to concatenate.</param>
            <returns>Combined path.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ToSlash(System.String)">
            <summary>
            Replace all backward slashes to forward slashes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ToPlatformSlash(System.String)">
            <summary>
            Ensure all slashes are the current platform's slash
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetDirectoryNameOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Locate a file in either the directory specified or a location in the
            directory structure above that directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetPathOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Searches for a file based on the specified starting directory.
            </summary>
            <param name="file">The file to search for.</param>
            <param name="startingDirectory">An optional directory to start the search in.  The default location is the directory
                of the file containing the property function.</param>
            <param name="fileSystem">The filesystem</param>
            <returns>The full path of the file if it is found, otherwise an empty string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ClearFileExistenceCache">
            <summary>
            Clears the file existence cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryDirectory(System.Boolean)">
            <summary>
            Generates a unique directory name in the temporary folder.  
            Caller must delete when finished. 
            </summary>
            <param name="createDirectory"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName(System.String)">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            File will NOT be created.
            May throw IOException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            If no extension is provided, uses ".tmp".
            File is guaranteed to be unique.
            Caller must delete it when finished.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile(System.String)">
            <summary>
            Generates a unique temporary file name with a given extension in the temporary folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            Caller must delete it when finished.
            May throw IOException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.GetTemporaryFile(System.String,System.String,System.Boolean)">
            <summary>
            Creates a file with unique temporary file name with a given extension in the specified folder.
            File is guaranteed to be unique.
            Extension may have an initial period.
            If folder is null, the temporary folder will be used.
            Caller must delete it when finished.
            May throw IOException.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers">
            <summary>
            Encapsulates the definitions of the item-spec modifiers a.k.a. reserved item metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsItemSpecModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for an item-spec modifier.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsDefiningProjectModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for one of the specific subset of itemspec 
            modifiers to do with the defining project of the item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(System.String)">
            <summary>
            Indicates if the given name is reserved for a derivable item-spec modifier.
            Derivable means it can be computed given a file name.
            </summary>
            <param name="name">Name to check.</param>
            <returns>true, if name of a derivable modifier</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.GetItemSpecModifier(System.String,System.String,System.String,System.String)">
            <summary>
            Performs path manipulations on the given item-spec as directed.
            Does not cache the result.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.GetItemSpecModifier(System.String,System.String,System.String,System.String,System.String@)">
            <summary>
            Performs path manipulations on the given item-spec as directed.
            
            Supported modifiers:
                %(FullPath)         = full path of item
                %(RootDir)          = root directory of item
                %(Filename)         = item filename without extension
                %(Extension)        = item filename extension
                %(RelativeDir)      = item directory as given in item-spec
                %(Directory)        = full path of item directory relative to root
                %(RecursiveDir)     = portion of item path that matched a recursive wildcard
                %(Identity)         = item-spec as given
                %(ModifiedTime)     = last write time of item
                %(CreatedTime)      = creation time of item
                %(AccessedTime)     = last access time of item
            
            NOTES:
            1) This method always returns an empty string for the %(RecursiveDir) modifier because it does not have enough
               information to compute it -- only the BuildItem class can compute this modifier.
            2) All but the file time modifiers could be cached, but it's not worth the space. Only full path is cached, as the others are just string manipulations.
            </summary>
            <remarks>
            Methods of the Path class "normalize" slashes and periods. For example:
            1) successive slashes are combined into 1 slash
            2) trailing periods are discarded
            3) forward slashes are changed to back-slashes
            
            As a result, we cannot rely on any file-spec that has passed through a Path method to remain the same. We will
            therefore not bother preserving slashes and periods when file-specs are transformed.
            
            Never returns null.
            </remarks>
            <param name="currentDirectory">The root directory for relative item-specs. When called on the Engine thread, this is the project directory. When called as part of building a task, it is null, indicating that the current directory should be used.</param>
            <param name="itemSpec">The item-spec to modify.</param>
            <param name="definingProjectEscaped">The path to the project that defined this item (may be null).</param>
            <param name="modifier">The modifier to apply to the item-spec.</param>
            <param name="fullPath">Full path if any was previously computed, to cache.</param>
            <returns>The modified item-spec (can be empty string, but will never be null).</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the item-spec is not a path.</exception>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.IsRootDirectory(System.String)">
            <summary>
            Indicates whether the given path is a UNC or drive pattern root directory.
            <para>Note: This function mimics the behavior of checking if Path.GetDirectoryName(path) == null.</para>
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilities.ItemSpecModifiers.ThrowForUrl(System.String,System.String,System.String)">
            <summary>
            Temporary check for something like http://foo which will end up like c:\foo\bar\http://foo
            We should either have no colon, or exactly one colon.
            UNDONE: This is a minimal safe change for Dev10. The correct fix should be to make GetFullPath/NormalizePath throw for this.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FileUtilitiesRegex">
            <summary>
            This class contains utility methods for file IO.
            Separate from FileUtilities because some assemblies may only need the patterns.
            PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
            each class get pulled into the resulting assembly.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsDrivePattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsDrivePatternWithSlash(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithDrivePattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithDrivePatternWithSlash(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.IsUncPattern(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithUncPattern(System.String)" -->
        <member name="M:Microsoft.Build.Shared.FileUtilitiesRegex.StartsWithUncPatternMatchLength(System.String)">
            <summary>
            Indicates whether the file-spec begins with a UNC pattern and how long the match is. -1 indicates no match.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FileUtilitiesRegex.MeetsUncPatternMinimumRequirements(System.String)">
            <summary>
            Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
            UNC pattern requires a minimum length of 5 and first two characters must be a slash.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Shared.DotNetFrameworkArchitecture">
            <summary>
            Used to specify the targeted bitness of the .NET Framework for some methods of FrameworkLocationHelper
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.DotNetFrameworkArchitecture.Current">
            <summary>
            Indicates the .NET Framework that is currently being run under.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.DotNetFrameworkArchitecture.Bitness32">
            <summary>
            Indicates the 32-bit .NET Framework
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.DotNetFrameworkArchitecture.Bitness64">
            <summary>
            Indicates the 64-bit .NET Framework
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FrameworkLocationHelper">
            <summary>
            FrameworkLocationHelper provides utility methods for locating .NET Framework and .NET Framework SDK directories and files
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.ToolsVersionsRegistryPath">
            <summary>
            Path to the ToolsVersion definitions in the registry
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.programFiles">
            <summary>
            By default when a root path is not specified we would like to use the program files directory \ reference assemblies\framework as the root location
            to generate the reference assembly paths from.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.s_dotNetFrameworkSpecs">
            <summary>
            List the supported .net versions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.s_visualStudioSpecs">
            <summary>
            List the supported visual studio versions.
            </summary>
            <remarks>
            The items must be ordered by the version, because some methods depend on that fact to find the previous visual studio version.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools">
            <summary>
            Define explicit fallback rules for the request to get path of .net framework sdk tools folder.
            The default rule is fallback to previous VS. However, there are some special cases that need
            explicit rules, i.e. v4.5.1 on VS12 fallbacks to v4.5 on VS12.
            </summary>
            <remarks>
            The rules are maintained in a 2-dimensions array. Each row defines a rule. The first column
            defines the trigger condition. The second column defines the fallback .net and VS versions.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.FallbackDotNetFrameworkSdkInstallPath">
             <summary>
             Because there is no longer a strong 1:1 mapping between FX versions and SDK
             versions, if we're unable to locate the desired SDK version, we will try to 
             use whichever SDK version is installed by looking at the key pointing to the
             "latest" version.
            
             This isn't ideal, but it will allow our tasks to function on any of several 
             related SDKs even if they don't have exactly the same versions.
             
             NOTE:  This returns the path to the root of the fallback SDK
             </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.PathToV35ToolsInFallbackDotNetFrameworkSdk">
             <summary>
             Because there is no longer a strong 1:1 mapping between FX versions and SDK
             versions, if we're unable to locate the desired SDK version, we will try to 
             use whichever SDK version is installed by looking at the key pointing to the
             "latest" version.
            
             This isn't ideal, but it will allow our tasks to function on any of several 
             related SDKs even if they don't have exactly the same versions.
             
             NOTE:  This explicitly returns the path to the 3.5 tools (bin) under the fallback
             SDK, to match the data we're pulling from the registry now.  
             </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.PathToV4ToolsInFallbackDotNetFrameworkSdk">
             <summary>
             Because there is no longer a strong 1:1 mapping between FX versions and SDK
             versions, if we're unable to locate the desired SDK version, we will try to 
             use whichever SDK version is installed by looking at the key pointing to the
             "latest" version.
            
             This isn't ideal, but it will allow our tasks to function on any of several 
             related SDKs even if they don't have exactly the same versions.
             
             NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools) 
             under the fallback SDK, to match the data we're pulling from the registry now.  
             </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.CheckForFrameworkInstallation(System.String,System.String)">
            <summary>
            Check the registry key and value to see if the .net Framework is installed on the machine.
            </summary>
            <param name="registryEntryToCheckInstall">Registry path to look for the value</param>
            <param name="registryValueToCheckInstall">Key to retrieve the value from</param>
            <returns>True if the registry key is 1 false if it is not there. This method also return true if the complus enviornment variables are set.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.FindDotNetFrameworkPath(System.String,System.String,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Shared.GetDirectories,Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Heuristic that first considers the current runtime path and then searches the base of that path for the given
            frameworks version.
            </summary>
            <param name="currentRuntimePath">The path to the runtime that is currently executing.</param>
            <param name="prefix">Should be something like 'v1.2' that indicates the runtime version we want.</param>
            <param name="directoryExists">Function that checks if directory exists.</param>
            <param name="getDirectories">Delegate to method that can return filesystem entries.</param>
            <param name="architecture">.NET framework architecture</param>
            <returns>Will return 'null' if there is no target frameworks on this machine.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateProgramFiles32">
            <summary>
            Determine the 32 bit program files directory, this is used for finding where the reference assemblies live.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateProgramFiles64">
            <summary>
            Determine the 64-bit program files directory, used as the basis for MSBuildExtensionsPath64.
            Returns null if we're not on a 64-bit machine
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateProgramFilesReferenceAssemblyRoot">
            <summary>
            Generate the path to the program files reference assembly location by taking in the program files special folder and then 
            using that path to generate the path to the reference assemblies location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GeneratePathToBuildToolsForToolsVersion(System.String,Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion. 
            </summary>
            <param name="toolsVersion">The ToolsVersion to look up</param>
            <param name="architecture">Target build tools architecture.</param>
            <returns>The path to the build tools folder for that ToolsVersion, if it exists, or 
            null otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateReferenceAssemblyPath(System.String,System.Runtime.Versioning.FrameworkName)">
            <summary>
            Take the parts of the Target framework moniker and formulate the reference assembly path based on the the following pattern:
            For a framework and version:
                $(TargetFrameworkRootPath)\$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)
            For a subtype:
                $(TargetFrameworkRootPath)\$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)\SubType\$(TargetFrameworkSubType)
            e.g.NET Framework v4.0 would locate its reference assemblies in:
                \Program Files\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0
            e.g.Silverlight v2.0 would locate its reference assemblies in:
                \Program Files\Reference Assemblies\Microsoft\Framework\Silverlight\v2.0
            e.g.NET Compact Framework v3.5, subtype PocketPC would locate its reference assemblies in:
                \Program Files\Reference Assemblies\Microsoft\Framework\.NETCompactFramework\v3.5\SubType\PocketPC
            </summary>
            <returns>The path to the reference assembly location</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.RemoveDirectories(System.String,System.Int32)">
            <summary>
            Given a path, subtracts the requested number of directories and returns the result.
            </summary>
            <comments>
            Internal only so that I can have the unit tests use it too, instead of duplicating the same code
            </comments>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GetPathToBuildToolsFromEnvironment(Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GetPathToBuildToolsFromRegistry(System.String,Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.GenerateReferenceAssemblyDirectory(System.String)">
            <summary>
            Will return the path to the dot net framework reference assemblies if they exist under the program files\reference assembies\microsoft\framework directory
            or null if the directory does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.FindRegistryValueUnderKey(System.String,System.String,Microsoft.Win32.RegistryView)">
            <summary>
            Look for the given registry value under the given key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.CreateDotNetFrameworkSpecForV4(System.Version,System.Version)">
            <summary>
            Helper method to create an instance of <see cref="T:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec"/> for .net v4.x,
            because most of attributes are the same for v4.x versions.
            </summary>
            <param name="version">.net framework version.</param>
            <param name="visualStudioVersion">Version of Visual Studio</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec._dotNetFrameworkSdkRegistryKey">
            <summary>
            The key in registry to indicate the corresponding .net framework in this visual studio.
            i.e. 'v8.0A' for VS11.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.Version">
            <summary>
            The version of this visual studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.SupportedDotNetFrameworkVersions">
            <summary>
            The list of supported .net framework versions in this visual studio.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.WindowsSdkRegistryKey">
            <summary>
            The key in registry to indicate the corresponding windows sdk, i.e. "v8.0" for VS11.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.WindowsSdkRegistryInstallationFolderName">
            <summary>
            The name in registry to indicate the sdk installation folder path, i.e. "InstallationFolder" for windows v8.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec.GetDotNetFrameworkSdkRegistryKey(System.Version)">
            <summary>
            The key in the registry to indicate the corresponding .net framework in this visual studio.
            i.e. 'v8.0A' for VS11.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._dotNetFrameworkRegistryKey">
            <summary>
            The registry key of this .net framework, i.e. "SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" for .net v4.5.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._dotNetFrameworkSetupRegistryInstalledName">
            <summary>
            The name in registry to indicate that this .net framework is installed, i.e. "Install" for .net v4.5.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._dotNetFrameworkSdkRegistryToolsKey">
            <summary>
            The key in registry to indicate the sdk tools folder, i.e. "WinSDK-NetFx40Tools-x86" for .net v4.5.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._visualStudioVersion">
            <summary>
            The version of visual studio that shipped with this .net framework.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._hasMsBuild">
            <summary>
            Does this .net framework include MSBuild?
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathsToDotNetFramework">
            <summary>
            Cached paths of .net framework on different architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathsToDotNetFrameworkSdkTools">
            <summary>
            Cached paths of .net framework sdk tools folder path on different visual studio version.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathToWindowsSdk">
            <summary>
            Cached path of the corresponding windows sdk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec._pathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Cached path of .net framework reference assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.Version">
            <summary>
            The version of this .net framework.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.DotNetFrameworkSdkRegistryInstallationFolderName">
            <summary>
            The name in registry to indicate the sdk installation folder path, i.e. "InstallationFolder" for .net v4.5.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.DotNetFrameworkFolderPrefix">
            <summary>
            Folder prefix, i.e. v4.0 for .net v4.5.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.FrameworkName">
            <summary>
            Get the FrameworkName for this version of the .NET Framework.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full registry key of this .net framework Sdk for the given visual studio version.
            i.e. "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx40Tools-x86" for .net v4.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFramework(Microsoft.Build.Shared.DotNetFrameworkArchitecture)">
            <summary>
            Gets the full path of .net framework for the given architecture.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFrameworkSdkTools(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk tools for the given visual studio version.
            i.e. "C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0A\bin\NETFX 4.0 Tools\" for .net v4.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFrameworkSdk(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk.
            i.e. "C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0A\" for .net v4.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Gets the full path of reference assemblies folder.
            i.e. "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5\" for .net v4.5.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpec.GetPathToWindowsSdk">
            <summary>
            Gets the full path of the corresponding windows sdk shipped with this .net framework.
            i.e. "C:\Program Files (x86)\Windows Kits\8.0\" for v8.0 (shipped with .net v4.5 and VS11).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy">
            <summary>
            Specialized implementation for legacy .net framework v1.1 and v2.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full registry key of this .net framework Sdk for the given visual studio version.
            i.e. "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework" for v1.1 and v2.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetPathToDotNetFrameworkSdkTools(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk tools for the given visual studio version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetPathToDotNetFrameworkSdk(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk, which is the full path of .net framework sdk tools for v1.1 and v2.0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecLegacy.GetPathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Gets the full path of reference assemblies folder, which is the full path of .net framework for v1.1 and v2.0.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecV3">
            <summary>
            Specialized implementation for legacy .net framework v3.0 and v3.5.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecV3.GetPathToDotNetFrameworkSdk(Microsoft.Build.Shared.FrameworkLocationHelper.VisualStudioSpec)">
            <summary>
            Gets the full path of .net framework sdk.
            i.e. "C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\" for .net v3.5 on VS11.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.FrameworkLocationHelper.DotNetFrameworkSpecV3.GetPathToDotNetFrameworkReferenceAssemblies">
            <summary>
            Gets the full path of reference assemblies folder.
            i.e. "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\v3.5\" for v3.5.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.IElementLocation">
            <summary>
            Represents the location information for error reporting purposes.  This is normally used to
            associate a run-time error with the original XML.
            This is not used for arbitrary errors from tasks, which store location in a BuildXXXXEventArgs.
            All implementations should be IMMUTABLE.
            This is not public because the current implementation only provides correct data for unedited projects.
            DO NOT make it public without considering a solution to this problem.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.IElementLocation.File">
            <summary>
            The file from which this particular element originated.  It may
            differ from the ProjectFile if, for instance, it was part of
            an import or originated in a targets file.
            Should always have a value.
            If not known, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.IElementLocation.Line">
            <summary>
            The line number where this element exists in its file.
            The first line is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.IElementLocation.Column">
            <summary>
            The column number where this element exists in its file.
            The first column is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.IElementLocation.LocationString">
            <summary>
            The location in a form suitable for replacement
            into a message.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.InternalErrorException">
            <summary>
            This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
            exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
            did wrong.
            
            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
            WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
                     Don't throw this exception from one assembly and catch it in another.
            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
                
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor">
            <summary>
            Default constructor.
            SHOULD ONLY BE CALLED BY DESERIALIZER. 
            SUPPLY A MESSAGE INSTEAD.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.String)">
            <summary>
            Creates an instance of this exception using the given message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using the given message and inner exception.
            Adds the inner exception's details to the exception message because most bug reporters don't bother
            to provide the inner exception details which is typically what we care about.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor used for (de)serialization. The constructor is private as this class is sealed
            If we ever add new members to this class, we'll need to update this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.InternalErrorException.ConsiderDebuggerLaunch(System.String,System.Exception)">
            <summary>
            A fatal internal error due to a bug has occurred. Give the dev a chance to debug it, if possible.
            
            Will in all cases launch the debugger, if the environment variable "MSBUILDLAUNCHDEBUGGER" is set.
            
            In DEBUG build, will always launch the debugger, unless we are in razzle (_NTROOT is set) or in NUnit,
            or MSBUILDDONOTLAUNCHDEBUGGER is set (that could be useful in suite runs).
            We don't launch in retail or LKG so builds don't jam; they get a callstack, and continue or send a mail, etc.
            We don't launch in NUnit as tests often intentionally cause InternalErrorExceptions.
            
            Because we only call this method from this class, just before throwing an InternalErrorException, there is 
            no danger that this suppression will cause a bug to only manifest itself outside NUnit
            (which would be most unfortunate!). Do not make this non-private.
            
            Unfortunately NUnit can't handle unhandled exceptions like InternalErrorException on anything other than
            the main test thread. However, there's still a callstack displayed before it quits.
            
            If it is going to launch the debugger, it first does a Debug.Fail to give information about what needs to
            be debugged -- the exception hasn't been thrown yet. This automatically displays the current callstack.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.LoadedType">
            <summary>
            This class packages information about a type loaded from an assembly: for example,
            the GenerateResource task class type or the ConsoleLogger logger class type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LoadedType.#ctor(System.Type,Microsoft.Build.Shared.AssemblyLoadInfo)">
            <summary>
            Creates an instance of this class for the given type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.LoadedType.#ctor(System.Type,Microsoft.Build.Shared.AssemblyLoadInfo,System.Reflection.Assembly)">
            <summary>
            Creates an instance of this class for the given type.
            </summary>
            <param name="type">The Type to be loaded</param>
            <param name="assemblyLoadInfo">Information used to load the assembly</param>
            <param name="loadedAssembly">The assembly which has been loaded, if any</param>
        </member>
        <member name="M:Microsoft.Build.Shared.LoadedType.HasLoadInSeparateAppDomainAttribute">
            <summary>
            Gets whether there's a LoadInSeparateAppDomain attribute on this type.
            Caches the result - since it can't change during the build.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LoadedType.HasSTAThreadAttribute">
            <summary>
            Gets whether there's a STAThread attribute on the Execute method of this type.
            Caches the result - since it can't change during the build.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.LoadedType.CheckForHardcodedSTARequirement">
            <summary>
            Determines if the task has a hardcoded requirement for STA thread usage.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.LoadedType.Type">
            <summary>
            Gets the type that was loaded from an assembly.
            </summary>
            <value>The loaded type.</value>
        </member>
        <member name="P:Microsoft.Build.Shared.LoadedType.LoadedAssembly">
            <summary>
            If we loaded an assembly for this type.
            We use this information to help created AppDomains to resolve types that it could not load successfully
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.LoadedType.Assembly">
            <summary>
            Gets the assembly the type was loaded from.
            </summary>
            <value>The assembly info for the loaded type.</value>
        </member>
        <member name="F:Microsoft.Build.Shared.LoadedType._loadedAssembly">
            <summary>
            Assembly, if any, that we loaded for this type.
            We use this information to help created AppDomains to resolve types that it could not load successfully
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared">
            <summary>
            Interop methods.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MAX_PATH">
            <summary>
            Default buffer size to use when dealing with the Windows API.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS">
            <summary>
            Flags for CoWaitForMultipleHandles
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_NONE">
            <summary>
            Exit when a handle is signaled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_WAITALL">
            <summary>
            Exit when all handles are signaled AND a message is received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS.COWAIT_ALERTABLE">
            <summary>
            Exit when an RPC call is serviced.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitectures">
            <summary>
            Processor architecture values
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SYSTEM_INFO">
            <summary>
            Structure that contain information about the system on which we are running
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SafeProcessHandle">
            <summary>
            Wrap the intptr returned by OpenProcess in a safe handle.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus">
            <summary>
            Contains information about the current state of both physical and virtual memory, including extended memory
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus._length">
            <summary>
            Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.MemoryLoad">
            <summary>
            Number between 0 and 100 that specifies the approximate percentage of physical
            memory that is in use (0 indicates no memory use and 100 indicates full memory use).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalPhysical">
            <summary>
            Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailablePhysical">
            <summary>
            Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalPageFile">
            <summary>
            Size of the committed memory limit, in bytes. This is physical memory plus the
            size of the page file, minus a small overhead.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailablePageFile">
            <summary>
            Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.TotalVirtual">
            <summary>
            Total size of the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailableVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the user mode portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.MemoryStatus.AvailableExtendedVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the extended portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA">
            <summary>
            Contains information about a file or directory; used by GetFileAttributesEx.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.NativeMethodsShared.SecurityAttributes">
            <summary>
            Contains the security descriptor for an object and specifies whether
            the handle retrieved by specifying this structure is inheritable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ProcessorArchitectureType">
            <summary>
            Architecture as far as the current process is concerned.
            It's x86 in wow64 (native architecture is x64 in that case).
            Otherwise it's the same as the native architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ProcessorArchitectureTypeNative">
            <summary>
            Actual architecture of the system.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.ConvertSystemArchitecture(System.UInt16)">
            <summary>
            Convert SYSTEM_INFO architecture values to the internal enum
            </summary>
            <param name="arch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.SystemInformationData.#ctor">
            <summary>
            Read system info values
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.MaxPath">
            <summary>
            Gets the max path limit of the current OS.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared._maxPath">
            <summary>
            Cached value for MaxPath.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_isUnixLike">
            <summary>
            Cached value for IsUnixLike (this method is called frequently during evaluation).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsUnixLike">
            <summary>
            Gets a flag indicating if we are running under a Unix-like system (Mac, Linux, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsLinux">
            <summary>
            Gets a flag indicating if we are running under Linux
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsBSD">
            <summary>
            Gets a flag indicating if we are running under flavor of BSD (NetBSD, OpenBSD, FreeBSD)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsMono">
            <summary>
            Gets a flag indicating if we are running under MONO
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsWindows">
            <summary>
            Gets a flag indicating if we are running under some version of Windows
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.IsOSX">
            <summary>
            Gets a flag indicating if we are running under Mac OSX
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.OSName">
            <summary>
            Gets a string for the current OS. This matches the OS env variable
            for Windows (Windows_NT).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetOSNameForExtensionsPath">
            <summary>
            OS name that can be used for the msbuildExtensionsPathSearchPaths element
            for a toolset
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_frameworkBasePath">
            <summary>
            The base directory for all framework paths in Mono
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.NativeMethodsShared.s_frameworkCurrentPath">
            <summary>
            The directory of the current framework
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.FrameworkCurrentPath">
            <summary>
            Gets the currently running framework path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.FrameworkBasePath">
            <summary>
            Gets the base directory of all Mono frameworks
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.SystemInformation">
            <summary>
            System information, initialized when required.
            </summary>
            <remarks>
            Initially implemented as <see cref="T:System.Lazy`1"/>, but
            that's .NET 4+, and this is used in MSBuildTaskHost.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitecture">
            <summary>
            Architecture getter
            </summary>
        </member>
        <member name="P:Microsoft.Build.Shared.NativeMethodsShared.ProcessorArchitectureNative">
            <summary>
            Native architecture getter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.WaitForMultipleObjects(System.UInt32,System.IntPtr[],System.Boolean,System.UInt32)">
            <summary>
            Really truly non pumping wait.
            Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
            single SafeHandles.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLastWriteDirectoryUtcTime(System.String,System.DateTime@)">
            <summary>
            Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
            if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetShortFilePath(System.String)">
            <summary>
            Takes the path and returns the short path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLongFilePath(System.String)">
            <summary>
            Takes the path and returns a full path
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetMemoryStatus">
            <summary>
            Retrieves the current global memory status.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetLastWriteFileUtcTime(System.String)">
            <summary>
            Get the last write time of the fullpath to the file.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
            <remarks>
            This method should be accurate for regular files and symlinks, but can report incorrect data
            if the file's content was modified by writing to it through a different link, unless
            MSBUILDALWAYSCHECKCONTENTTIMESTAMP=1.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetContentLastWriteFileUtcTime(System.String)">
            <summary>
            Get the last write time of the content pointed to by a file path.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
            <remarks>
            This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
            See https://github.com/Microsoft/msbuild/issues/2052.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.HResultSucceeded(System.Int32)">
            <summary>
            Did the HRESULT succeed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.HResultFailed(System.Int32)">
            <summary>
            Did the HRESULT Fail
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.ThrowExceptionForErrorCode(System.Int32)">
            <summary>
            Given an error code, converts it to an HRESULT and throws the appropriate exception.
            </summary>
            <param name="errorCode"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.KillTree(System.Int32)">
            <summary>
            Kills the specified process by id and all of its children recursively.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetParentProcessId(System.Int32)">
            <summary>
            Returns the parent process id for the specified process.
            Returns zero if it cannot be gotten for some reason.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetChildProcessIds(System.Int32,System.DateTime)">
            <summary>
            Returns an array of all the immediate child processes by id.
            NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetCurrentDirectory">
            <summary>
            Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.AreStringsEqual(System.Char*,System.Int32,System.String)">
            <summary>
            Compare an unsafe char buffer with a <see cref="T:System.String"/> to see if their contents are identical.
            </summary>
            <param name="buffer">The beginning of the char buffer.</param>
            <param name="len">The length of the buffer.</param>
            <param name="s">The string.</param>
            <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetOEMCP">
            <summary>
            Gets the current OEM code page which is used by console apps
            (as opposed to the Windows/ANSI code page)
            Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
            that needs to be used for instance when writing to batch files
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.GetModuleFileName(System.Runtime.InteropServices.HandleRef,System.Text.StringBuilder,System.Int32)">
            <summary>
            Gets the fully qualified filename of the currently executing .exe
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.CoWaitForMultipleHandles(Microsoft.Build.Shared.NativeMethodsShared.COWAIT_FLAGS,System.Int32,System.Int32,System.IntPtr[],System.Int32@)">
            <summary>
            CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
            VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
            build thread which the main thread (blocked on BuildSubmission.Execute) must service.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle,System.TimeSpan)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.NativeMethodsShared.MsgWaitOne(System.Threading.WaitHandle,System.Int32)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.AssemblyUtilities">
            <summary>
            This class contains common reflection tasks
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ProjectErrorUtilities">
            <summary>
            This class contains methods that are useful for error checking and
            validation of project files.
            </summary>
            <remarks>
            FUTURE: This class could except an optional inner exception to put in the
            InvalidProjectFileException, which could make debugging a host easier in some circumstances.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject(System.Boolean,Microsoft.Build.Shared.IElementLocation,System.String)">
            <summary>
            This method is used to flag errors in the project file being processed.
            Do NOT use this method in place of ErrorUtilities.VerifyThrow(), because
            ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject``1(Microsoft.Build.Shared.IElementLocation,System.String,``0)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``1(System.Boolean,Microsoft.Build.Shared.IElementLocation,System.String,``0)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject``2(Microsoft.Build.Shared.IElementLocation,System.String,``0,``1)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject``3(Microsoft.Build.Shared.IElementLocation,System.String,``0,``1,``2)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject``4(Microsoft.Build.Shared.IElementLocation,System.String,``0,``1,``2,``3)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject(Microsoft.Build.Shared.IElementLocation,System.String,System.Object[])">
            <summary>
            Overload for if there are more than four string format arguments.
            </summary>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``2(System.Boolean,Microsoft.Build.Shared.IElementLocation,System.String,``0,``1)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``3(System.Boolean,Microsoft.Build.Shared.IElementLocation,System.String,``0,``1,``2)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``4(System.Boolean,Microsoft.Build.Shared.IElementLocation,System.String,``0,``1,``2,``3)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject(System.Boolean,System.String,Microsoft.Build.Shared.IElementLocation,System.String)">
            <summary>
            This method is used to flag errors in the project file being processed.
            Do NOT use this method in place of ErrorUtilities.VerifyThrow(), because
            ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="errorSubCategoryResourceName">The resource string for the
            error sub-category (can be null).</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``1(System.Boolean,System.String,Microsoft.Build.Shared.IElementLocation,System.String,``0)">
            <summary>
            Overload for one string format argument.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="errorSubCategoryResourceName">The resource string for the
            error sub-category (can be null).</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``2(System.Boolean,System.String,Microsoft.Build.Shared.IElementLocation,System.String,``0,``1)">
            <summary>
            Overload for two string format arguments.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="errorSubCategoryResourceName">The resource string for the
            error sub-category (can be null).</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``3(System.Boolean,System.String,Microsoft.Build.Shared.IElementLocation,System.String,``0,``1,``2)">
            <summary>
            Overload for three string format arguments.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="errorSubCategoryResourceName">The resource string for the
            error sub-category (can be null).</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject``4(System.Boolean,System.String,Microsoft.Build.Shared.IElementLocation,System.String,``0,``1,``2,``3)">
            <summary>
            Overload for four string format arguments.
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="errorSubCategoryResourceName">The resource string for the
            error sub-category (can be null).</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject(System.String,Microsoft.Build.Shared.IElementLocation,System.String,System.Object[])">
            <summary>
            Throws an InvalidProjectFileException using the given data.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            
            </summary>
            <param name="errorSubCategoryResourceName">The resource string for the
            error sub-category (can be null).</param>
            <param name="elementLocation">The <see cref="T:Microsoft.Build.Shared.IElementLocation"/> of the element.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="args">Extra arguments for formatting the error message.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.ProjectFileErrorUtilities">
            <summary>
            This class contains methods that are useful for error checking and validation of project files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectFileErrorUtilities.ThrowInvalidProjectFile(Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            This method is used to flag errors in the project file being processed. Do NOT use this method in place of
            ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <param name="projectFile">The invalid project file.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="args">Extra arguments for formatting the error message.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectFileErrorUtilities.ThrowInvalidProjectFile(Microsoft.Build.Shared.BuildEventFileInfo,System.Exception,System.String,System.Object[])">
            <summary>
            This method is used to flag errors in the project file being processed. Do NOT use this method in place of
            ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <param name="projectFile">The invalid project file.</param>
            <param name="innerException">Any inner exception. May be null.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="args">Extra arguments for formatting the error message.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(System.Boolean,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            This method is used to flag errors in the project file being processed. Do NOT use this method in place of
            ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="projectFile">The invalid project file.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="args">Extra arguments for formatting the error message.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(System.Boolean,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            This method is used to flag errors in the project file being processed. Do NOT use this method in place of
            ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
            <param name="projectFile">The invalid project file.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="args">Extra arguments for formatting the error message.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(System.Boolean,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.Exception,System.String,System.Object[])">
            <summary>
            This method is used to flag errors in the project file being processed. Do NOT use this method in place of
            ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <param name="condition">The condition to check.</param>
            <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
            <param name="projectFile">The invalid project file.</param>
            <param name="innerException">The inner <see cref="T:System.Exception"/>.</param>
            <param name="resourceName">The resource string for the error message.</param>
            <param name="args">Extra arguments for formatting the error message.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.ProjectWriter">
            <summary>
            This class is used to save MSBuild project files. It contains special handling for MSBuild notations that are not saved
            correctly by the XML DOM's default save mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Creates an instance of this class using the specified TextWriter.
            </summary>
            <param name="w"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectWriter.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates an instance of this class using the specified file.
            </summary>
            <param name="filename"></param>
            <param name="encoding">If null, defaults to UTF-8 and omits encoding attribute from processing instruction.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectWriter.Initialize(System.Xml.XmlDocument)">
            <summary>
            Initializes settings for the project to be saved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectWriter.Initialize(System.Xml.XmlDocument,System.Xml.XmlDeclaration)">
            <summary>
            Initializes settings for the project to be saved.
            </summary>
            <param name="project"></param>
            <param name="projectRootElementDeclaration">If null, XML declaration is not written.</param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectWriter.WriteString(System.String)">
            <summary>
            Writes item vector transforms embedded in the given string without escaping '->' into "-&amp;gt;".
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Microsoft.Build.Shared.ProjectWriter.WriteStartDocument">
            <summary>
            Override method in order to omit the xml declaration tag in certain cases. The tag will be written if:
             - The tag was present in the file/stream loaded.
             - The Encoding is specified and not default (UTF8)
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.ResourceUtilities">
            <summary>
            This class contains utility methods for dealing with resources.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.ExtractMessageCode(System.Boolean,System.String,System.String@)">
            <summary>
            Extracts the message code (if any) prefixed to the given string. 
            <![CDATA[
            MSBuild codes match "^\s*(?<CODE>MSB\d\d\d\d):\s*(?<MESSAGE>.*)$"
            Arbitrary codes match "^\s*(?<CODE>[A-Za-z]+\d+):\s*(?<MESSAGE>.*)$"
            ]]>
            Thread safe.
            </summary>
            <param name="msbuildCodeOnly">Whether to match only MSBuild error codes, or any error code.</param>
            <param name="message">The string to parse.</param>
            <param name="code">[out] The message code, or null if there was no code.</param>
            <returns>The string without its message code prefix, if any.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.GetHelpKeyword(System.String)">
            <summary>
            Retrieves the MSBuild F1-help keyword for the given resource string. Help keywords are used to index help topics in
            host IDEs.
            </summary>
            <param name="resourceName">Resource string to get the MSBuild F1-keyword for.</param>
            <returns>The MSBuild F1-help keyword string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.GetResourceString(System.String)">
            <summary>
            Retrieves the contents of the named resource string.
            </summary>
            <param name="resourceName">Resource string name.</param>
            <returns>Resource string contents.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringStripCodeAndKeyword(System.String@,System.String@,System.String,System.Object[])">
            <summary>
            Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
            message code and help keyword associated with it, they too are returned.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="code">[out] The MSBuild message code, or null.</param>
            <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
            <param name="resourceName">Resource string to load.</param>
            <param name="args">Optional arguments for formatting the resource string.</param>
            <returns>The formatted resource string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringStripCodeAndKeyword(System.String,System.Object[])">
            <summary>
            Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
            message code and help keyword associated with it, they are discarded.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="resourceName">Resource string to load.</param>
            <param name="args">Optional arguments for formatting the resource string.</param>
            <returns>The formatted resource string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(System.String,System.Object[])">
            <summary>
            Formats the resource string with the given arguments.
            Ignores error codes and keywords
            </summary>
            <param name="resourceName"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.FormatString(System.String,System.Object[])">
            <summary>
            Formats the given string using the variable arguments passed in.
            
            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            
            Thread safe.
            </summary>
            <param name="unformatted">The string to format.</param>
            <param name="args">Optional arguments for formatting the given string.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.ResourceUtilities.VerifyResourceStringExists(System.String)">
            <summary>
            Verifies that a particular resource string actually exists in the string table. This will only be called in debug
            builds. It helps catch situations where a dev calls VerifyThrowXXX with a new resource string, but forgets to add the
            resource string to the string table, or misspells it!
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <param name="resourceName">Resource string to check.</param>
        </member>
        <member name="T:Microsoft.Build.Shared.TypeLoader">
            <summary>
            This class is used to load types from their assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.s_cacheOfLoadedTypesByFilter">
            <summary>
            Cache to keep track of the assemblyLoadInfos based on a given type filter.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.s_cacheOfReflectionOnlyLoadedTypesByFilter">
            <summary>
            Cache to keep track of the assemblyLoadInfos based on a given type filter for assemblies which are to be loaded for reflectionOnlyLoads.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader._isDesiredType">
            <summary>
            Type filter for this typeloader
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.#ctor(System.Func{System.Type,System.Object,System.Boolean})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.IsPartialTypeNameMatch(System.String,System.String)">
            <summary>
            Given two type names, looks for a partial match between them. A partial match is considered valid only if it occurs on
            the right side (tail end) of the name strings, and at the start of a class or namespace name.
            </summary>
            <remarks>
            1) Matches are case-insensitive.
            2) .NET conventions regarding namespaces and nested classes are respected, including escaping of reserved characters.
            </remarks>
            <example>
            "Csc" and "csc"                                                 ==> exact match
            "Microsoft.Build.Tasks.Csc" and "Microsoft.Build.Tasks.Csc"     ==> exact match
            "Microsoft.Build.Tasks.Csc" and "Csc"                           ==> partial match
            "Microsoft.Build.Tasks.Csc" and "Tasks.Csc"                     ==> partial match
            "MyTasks.ATask+NestedTask" and "NestedTask"                     ==> partial match
            "MyTasks.ATask\\+NestedTask" and "NestedTask"                   ==> partial match
            "MyTasks.CscTask" and "Csc"                                     ==> no match
            "MyTasks.MyCsc" and "Csc"                                       ==> no match
            "MyTasks.ATask\.Csc" and "Csc"                                  ==> no match
            "MyTasks.ATask\\\.Csc" and "Csc"                                ==> no match
            </example>
            <returns>true, if the type names match exactly or partially; false, if there is no match at all</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.LoadAssembly(Microsoft.Build.Shared.AssemblyLoadInfo)">
            <summary>
            Load an assembly given its AssemblyLoadInfo
            </summary>
            <param name="assemblyLoadInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.Load(System.String,Microsoft.Build.Shared.AssemblyLoadInfo)">
            <summary>
            Loads the specified type if it exists in the given assembly. If the type name is fully qualified, then a match (if
            any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
            found will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.ReflectionOnlyLoad(System.String,Microsoft.Build.Shared.AssemblyLoadInfo)">
            <summary>
            Loads the specified type if it exists in the given assembly. If the type name is fully qualified, then a match (if
            any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
            found will be returned.
            </summary>
            <returns>The loaded type, or null if the type was not found.</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.GetLoadedType(System.Collections.Concurrent.ConcurrentDictionary{System.Func{System.Type,System.Object,System.Boolean},System.Collections.Concurrent.ConcurrentDictionary{Microsoft.Build.Shared.AssemblyLoadInfo,Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes}},System.String,Microsoft.Build.Shared.AssemblyLoadInfo)">
            <summary>
            Loads the specified type if it exists in the given assembly. If the type name is fully qualified, then a match (if
            any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
            found will be returned.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes">
            <summary>
            Given a type filter and an asssemblyInfo object keep track of what types in a given assembly which match the type filter.
            Also, use this information to determine if a given TypeName is in the assembly which is pointed to by the AssemblyLoadInfo object.
            
            This type represents a combination of a type filter and an assemblyInfo object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes._lockObject">
            <summary>
            Lock to prevent two threads from using this object at the same time.
            Since we fill up internal structures with what is in the assembly 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes._isDesiredType">
            <summary>
            Type filter to pick the correct types out of an assembly
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes._assemblyLoadInfo">
            <summary>
            Assembly load information so we can load an assembly
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes._typeNameToType">
            <summary>
            What is the type for the given type name, this may be null if the typeName does not map to a type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes._publicTypeNameToType">
            <summary>
            List of public types in the assembly which match the type filter and their corresponding types
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes._haveScannedPublicTypes">
            <summary>
            Have we scanned the public types for this assembly yet.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes._loadedAssembly">
            <summary>
            Assembly, if any, that we loaded for this type.
            We use this information to set the LoadedType.LoadedAssembly so that this object can be used
            to help created AppDomains to resolve those that it could not load successfully
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes.#ctor(System.Func{System.Type,System.Object,System.Boolean},Microsoft.Build.Shared.AssemblyLoadInfo)">
            <summary>
            Given a type filter, and an assembly to load the type information from determine if a given type name is in the assembly or not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes.GetLoadedTypeByTypeName(System.String)">
            <summary>
            Determine if a given type name is in the assembly or not. Return null if the type is not in the assembly
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes.ScanAssemblyForPublicTypes">
            <summary>
            Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on 
            to find tasks, loggers, and task factories.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.VisualStudioConstants">
            <summary>
            Shared Visual Studio related constants
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.VisualStudioConstants.CurrentVisualStudioSolutionFileVersion">
            <summary>
            This is the version number of the most recent solution file format
            we will read. It will be the version number used in solution files
            by the latest version of Visual Studio.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Shared.VisualStudioConstants.CurrentVisualStudioVersion">
            <summary>
            This is the version number of the latest version of Visual Studio.
            </summary>
            <remarks>
            We use it for the version of the VC PIA we try to load and to find
            Visual Studio registry hive that we use to find where vcbuild.exe might be.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Shared.XMakeAttributes">
            <summary>
            Contains the names of the known attributes in the XML project file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.IsSpecialTaskAttribute(System.String)">
            <summary>
            Returns true if and only if the specified attribute is one of the attributes that the engine specifically recognizes
            on a task and treats in a special way.
            </summary>
            <param name="attribute"></param>
            <returns>true, if given attribute is a reserved task attribute</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.IsBadlyCasedSpecialTaskAttribute(System.String)">
            <summary>
            Checks if the specified attribute is a reserved task attribute with incorrect casing.
            </summary>
            <param name="attribute"></param>
            <returns>true, if the given attribute is reserved and badly cased</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.IsNonBatchingTargetAttribute(System.String)">
            <summary>
            Indicates if the specified attribute cannot be used for batching targets.
            </summary>
            <param name="attribute"></param>
            <returns>true, if a target cannot batch on the given attribute</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.IsValidMSBuildRuntimeValue(System.String)">
            <summary>
            Returns true if the given string is a valid member of the MSBuildRuntimeValues set
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.IsValidMSBuildArchitectureValue(System.String)">
            <summary>
            Returns true if the given string is a valid member of the MSBuildArchitectureValues set
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.RuntimeValuesMatch(System.String,System.String)">
            <summary>
            Compares two members of MSBuildRuntimeValues, returning true if they count as a match, and false otherwise.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.TryMergeRuntimeValues(System.String,System.String,System.String@)">
            <summary>
            Given two MSBuildRuntime values, returns the concrete result of merging the two.  If the merge fails, the merged runtime 
            string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns 
            true with the merged runtime value.  E.g.: 
            "CLR4" + "CLR2" = null (false)
            "CLR2" + "don't care" = "CLR2" (true)
            "current runtime" + "CLR4" = "CLR4" (true) 
            "current runtime" + "don't care" = "CLR4" (true)
            If both specify "don't care", then defaults to the current runtime -- CLR4. 
            A null or empty string is interpreted as "don't care".
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.ArchitectureValuesMatch(System.String,System.String)">
            <summary>
            Compares two members of MSBuildArchitectureValues, returning true if they count as a match, and false otherwise.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.GetExplicitMSBuildRuntime(System.String)">
            <summary>
            Given an MSBuildRuntime value that may be non-explicit -- e.g. "CurrentRuntime" or "Any" --
            return the specific MSBuildRuntime value that it would map to in this case. If it does not map 
            to any known runtime, just return it as is -- maybe someone else knows what to do with it; if 
            not, they'll certainly have more context on logging or throwing the error. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.TryMergeArchitectureValues(System.String,System.String,System.String@)">
            <summary>
            Given two MSBuildArchitecture values, returns the concrete result of merging the two.  If the merge fails, the merged architecture 
            string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns 
            true with the merged architecture value.  E.g.: 
            "x86" + "x64" = null (false)
            "x86" + "don't care" = "x86" (true)
            "current architecture" + "x86" = "x86" (true) on a 32-bit process, and null (false) on a 64-bit process
            "current architecture" + "don't care" = "x86" (true) on a 32-bit process, and "x64" (true) on a 64-bit process
            A null or empty string is interpreted as "don't care".
            If both specify "don't care", then defaults to whatever the current process architecture is.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.GetCurrentMSBuildArchitecture">
            <summary>
            Returns the MSBuildArchitecture value corresponding to the current process' architecture. 
            </summary>
            <comments>
            Revisit if we ever run on something other than Intel.  
            </comments>
        </member>
        <member name="M:Microsoft.Build.Shared.XMakeAttributes.GetExplicitMSBuildArchitecture(System.String)">
            <summary>
            Given an MSBuildArchitecture value that may be non-explicit -- e.g. "CurrentArchitecture" or "Any" --
            return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map 
            to any known architecture, just return it as is -- maybe someone else knows what to do with it; if 
            not, they'll certainly have more context on logging or throwing the error. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.XMakeElements">
            <summary>
            Contains the names of the known elements in the XML project file.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Shared.XmlUtilities">
            <summary>
            This class contains utility methods for XML manipulation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Shared.XmlUtilities.RenameXmlElement(Microsoft.Build.Construction.XmlElementWithLocation,System.String,System.String)">
            <summary>
            This method renames an XML element.  Well, actually you can't directly
            rename an XML element using the DOM, so what you have to do is create
            a brand new XML element with the new name, and copy over all the attributes
            and children.  This method returns the new XML element object.
            If the name is the same, does nothing and returns the element passed in.
            </summary>
            <param name="oldElement"></param>
            <param name="newElementName"></param>
            <param name="xmlNamespace">Can be null if global namespace.</param>
            <returns>new/renamed element</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.XmlUtilities.VerifyThrowArgumentValidElementName(System.String)">
            <summary>
            Verifies that a name is valid for the name of an item, property, or piece of metadata.
            If it isn't, throws an ArgumentException indicating the invalid character.
            </summary>
            <remarks>
            Note that our restrictions are more stringent than the XML Standard's restrictions.
            </remarks>
            <throws>ArgumentException</throws>
            <param name="name">name to validate</param>
        </member>
        <member name="M:Microsoft.Build.Shared.XmlUtilities.VerifyThrowProjectValidElementName(System.String,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Verifies that a name is valid for the name of an item, property, or piece of metadata.
            If it isn't, throws an InvalidProjectException indicating the invalid character.
            </summary>
            <remarks>
            Note that our restrictions are more stringent than the XML Standard's restrictions.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.XmlUtilities.VerifyThrowProjectValidElementName(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Verifies that a name is valid for the name of an item, property, or piece of metadata.
            If it isn't, throws an InvalidProjectException indicating the invalid character.
            </summary>
            <remarks>
            Note that our restrictions are more stringent than the XML Standard's restrictions.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Shared.XmlUtilities.IsValidElementName(System.String)">
            <summary>
            Indicates if the given name is valid as the name of an item, property or metadatum.
            </summary>
            <remarks>
            Note that our restrictions are more stringent than those of the XML Standard.
            </remarks>
            <param name="name"></param>
            <returns>true, if name is valid</returns>
        </member>
        <member name="M:Microsoft.Build.Shared.XmlUtilities.LocateFirstInvalidElementNameCharacter(System.String)">
            <summary>
            Finds the location of the first invalid character, if any, in the name of an 
            item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none. 
            Valid names must match this pattern:  [A-Za-z_][A-Za-z_0-9\-.]*
            Note, this is a subset of all possible valid XmlElement names: we use a subset because we also
            have to match this same set in our regular expressions, and allowing all valid XmlElement name
            characters in a regular expression would be impractical.
            </summary>
            <remarks>
            Note that our restrictions are more stringent than the XML Standard's restrictions.
            PERF: This method has to be as fast as possible, as it's called when any item, property, or piece
            of metadata is constructed.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Collections.IConstrainedEqualityComparer`1">
            <summary>
                Defines methods to support the comparison of objects for
                equality over constrained inputs.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.IConstrainedEqualityComparer`1.Equals(`0,`0,System.Int32,System.Int32)">
            <summary>
            Determines whether the specified objects are equal, factoring in the specified bounds when comparing <paramref name="y"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.IConstrainedEqualityComparer`1.GetHashCode(`0,System.Int32,System.Int32)">
            <summary>
            Returns a hash code for the specified object factoring in the specified bounds.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1">
            <summary>
            A read-only wrapper over an empty collection.
            </summary>
            <remarks>
            Thus this is an omission from the BCL.
            </remarks>
            <typeparam name="T">Type of element in the collection</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.s_instance">
            <summary>
            Backing live collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.#ctor">
            <summary>
            Private default constructor as this is a singleton
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Instance">
            <summary>
            Get the instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Count">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.IsReadOnly">
            <summary>
            Returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Whether collection is synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Sync root
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Add(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Contains(`0)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.GetEnumerator">
            <summary>
            Get an enumerator over an empty collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator over an empty collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            ICollection version of CopyTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.IKeyed">
            <summary>
            Interface allowing items and metadata and properties to go into keyed collections
            </summary>
            <remarks>
            This can be internal as it is a constraint only on internal collections.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Collections.IKeyed.Key">
            <summary>
            Returns some value useful for a key in a dictionary
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ConcurrentQueueExtensions">
            <summary>
            The extensions class for ConcurrentQueue&lt;T&gt;
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConcurrentQueueExtensions.Dequeue``1(System.Collections.Concurrent.ConcurrentQueue{``0})">
            <summary>
            The dequeue method.
            </summary>
            <typeparam name="T">The type contained within the queue</typeparam>
        </member>
        <member name="T:Microsoft.Build.Collections.ConcurrentStackExtensions">
            <summary>
            The extensions class for ConcurrentStack&lt;T&gt;
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConcurrentStackExtensions.Peek``1(System.Collections.Concurrent.ConcurrentStack{``0})">
            <summary>
            The peek method.
            </summary>
            <typeparam name="T">The type contained within the stack.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Collections.ConcurrentStackExtensions.Pop``1(System.Collections.Concurrent.ConcurrentStack{``0})">
            <summary>
            The pop method.
            </summary>
            <typeparam name="T">The type contained within the stack.</typeparam>
        </member>
        <member name="T:Microsoft.Build.Collections.LookasideStringInterner">
            <summary>
            A simple string interner designed for IPC.
            </summary>
            <remarks>
            This interner works by providing a way to convert strings to integer IDs.  When used as a form of compression, 
            clients will intern their strings and record the set of IDs returned, then transmit those IDs instead of the
            original strings.  The interner itself is also transmitted ahead of time, with the IDs, allowing 
            reconstruction of the original strings.  This ensures each string is transmitted exactly once.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Collections.LookasideStringInterner.NullStringIndex">
            <summary>
            Index used for null strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.LookasideStringInterner.EmptyStringIndex">
            <summary>
            Index used for empty strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.LookasideStringInterner._stringToIdsMap">
            <summary>
            The map used to intern strings for serialization.  This map doesn't exist when the strings
            are deserialized (it is not needed.)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.LookasideStringInterner._strings">
            <summary>
            The list of strings by ID.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.LookasideStringInterner.#ctor(System.StringComparer,System.Int32)">
            <summary>
            Constructor to be used during serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.LookasideStringInterner.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor to be used during deserialization.
            </summary>
            <remarks>
            Intern cannot be used on this interner if it came from serialization, since we do 
            not reconstruct the interning dictionary.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Collections.LookasideStringInterner.Intern(System.String)">
            <summary>
            Interns the specified string.
            </summary>
            <param name="str">The string to intern.</param>
            <returns>The index representing the string.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.LookasideStringInterner.GetString(System.Int32)">
            <summary>
            Retrieves a string corresponding to the provided index.
            </summary>
            <param name="index">The index.</param>
            <returns>The corresponding string.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.LookasideStringInterner.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            The translator, for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.RetrievableEntryHashSet`1">
            <summary>
            Implementation notes:
            This uses an array-based implementation similar to <see cref="T:Dictionary{T}" />, using a buckets array
            to map hash values to the Slots array. Items in the Slots array that hash to the same value
            are chained together through the "next" indices. 
            
            The capacity is always prime; so during resizing, the capacity is chosen as the next prime
            greater than double the last capacity. 
            
            The underlying data structures are lazily initialized. Because of the observation that, 
            in practice, hashtables tend to contain only a few elements, the initial capacity is
            set very small (3 elements) unless the ctor with a collection is used.
            
            The +/- 1 modifications in methods that add, check for containment, etc allow us to 
            distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
            reset each bucket to -1 when resizing. See Contains, for example.
            
            Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
            this set.
            
            Some operations can perform faster if we can assume "other" contains unique elements
            according to this equality comparer. The only times this is efficient to check is if
            other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
            also have to check that the hashset is using the same equality comparer. If other 
            has a different equality comparer, it will have unique elements according to its own
            equality comparer, but not necessarily according to ours. Therefore, to go these 
            optimized routes we check that other is a hashset using the same equality comparer.
            
            A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
            special empty set checks.)
            
            A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
            If we didn't have these checks, we could be iterating over the set and modifying at
            the same time. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add item to this hashset. This is the explicit implementation of the <see cref="T:System.Collections.Generic.ICollection`1" />
            interface. The other Add method returns bool indicating whether item was added.
            </summary>
            <param name="item">item to add</param>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying 
            buckets and slots array. Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Contains(`0)">
            <summary>
            Checks if this hashset contains the item
            </summary>
            <param name="item">item to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Get(System.String)">
            <summary>
            Gets the item if any with the given name
            </summary>
            <param name="key">key to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Get(System.String,System.Int32,System.Int32)">
            <summary>
            Gets the item if any with the given name
            </summary>
            <param name="key">key to check for containment</param>
            <param name="index">The position of the substring within <paramref name="key"/>.</param>
            <param name="length">The maximum number of characters in the <paramref name="key"/> to lookup.</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.GetCore(System.String,System.Int32,System.Int32)">
            <summary>
            Gets the item if any with the given name
            </summary>
            <param name="item">item to check for containment</param>
            <param name="index">The position of the substring within <paramref name="item"/>.</param>
            <param name="length">The maximum number of characters in the <paramref name="item"/> to lookup.</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Remove(`0)">
            <summary>
            Remove entry that compares equal to T
            </summary>        
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Remove(System.String)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="P:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Count">
            <summary>
            Number of elements in this hashset
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.RetrievableEntryHashSet`1.IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.MakeReadOnly">
            <summary>
            Permanently prevent changes to the set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Add(`0)">
            <summary>
            Add item to this HashSet. 
            *** MSBUILD NOTE: Always added - overwrite semantics
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Take the union of this HashSet with other. Modifies this set.
            
            Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
            multiple resizes ended up not being useful in practice; quickly gets to the 
            point where it's a wasteful check.
            </summary>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list (rounded up to nearest prime),
            unless count is 0, in which case we release references.
            
            This method can be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and release all 
            memory referenced by the list, execute the following statements:
            
            list.Clear();
            list.TrimExcess(); 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.IncreaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested 
            size. This is called when the underlying array is filled. This performs no 
            defragmentation, allowing faster execution; note that this is reasonable since 
            AddEvenIfPresent attempts to insert new elements in re-opened spots.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.AddEvenIfPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already
            Returns true if added and false if already present
            ** MSBUILD: Modified so that it DOES add even if present. It will return false in that case, though.**
            </summary>
            <param name="value">value to find</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.EntriesAreReferenceEquals(Microsoft.Build.Collections.RetrievableEntryHashSet{`0})">
            <summary>
            Equality comparer against another of this type.
            Compares entries by reference - not merely by using the comparer on the key
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.ToArray">
            <summary>
            Copies this to an array. Used for DebugView
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Collections.RetrievableEntryHashSet`1.InternalGetHashCode(System.String)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <param name="item"></param>
            <returns>hash code</returns>
        </member>
        <member name="T:Microsoft.Build.Collections.BitHelper">
            <summary>
            ABOUT:
            Helps with operations that rely on bit marking to indicate whether an item in the 
            collection should be added, removed, visited already, etc. 
            
            BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the 
            stack or heap. ToIntArrayLength() tells you the int array size you must allocate. 
            
            USAGE:
            Suppose you need to represent a bit array of length (i.e. logical bit array length)
            BIT_ARRAY_LENGTH. Then this is the suggested way to instantiate BitHelper:
            ***************************************************************************
            int intArrayLength = BitHelper.ToIntArrayLength(BIT_ARRAY_LENGTH);
            BitHelper bitHelper;
            if (intArrayLength less than stack alloc threshold)
                int* m_arrayPtr = stackalloc int[intArrayLength];
                bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
            else
                int[] m_arrayPtr = new int[intArrayLength];
                bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
            ***************************************************************************
            
            IMPORTANT:
            The second ctor args, length, should be specified as the length of the int array, not
            the logical bit array. Because length is used for bounds checking into the int array,
            it's especially important to get this correct for the stackalloc version. See the code 
            samples above; this is the value gotten from ToIntArrayLength(). 
            
            The length ctor argument is the only exception; for other methods -- MarkBit and 
            IsMarked -- pass in values as indices into the logical bit array, and it will be mapped
            to the position within the array of ints.
            
            FUTURE OPTIMIZATIONS:
            A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate 
            on a bit array and then need to loop over it. In particular, if it avoided visiting 
            every bit, it would allow good perf improvements when the bit array is sparse.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.BitHelper.#ctor(System.Int32*,System.Int32)">
            <summary>
            Instantiates a BitHelper with a heap alloc'd array of ints
            </summary>
            <param name="bitArrayPtr">int array to hold bits</param>
            <param name="length">length of int array</param>
        </member>
        <member name="M:Microsoft.Build.Collections.BitHelper.#ctor(System.Int32[],System.Int32)">
            <summary>
            Instantiates a BitHelper with a heap alloc'd array of ints
            </summary>
            <param name="bitArray">int array to hold bits</param>
            <param name="length">length of int array</param>
        </member>
        <member name="M:Microsoft.Build.Collections.BitHelper.MarkBit(System.Int32)">
            <summary>
            Mark bit at specified position
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.BitHelper.IsMarked(System.Int32)">
            <summary>
            Is bit at specified position marked?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>
            How many ints must be allocated to represent n bits. Returns (n+31)/32, but 
            avoids overflow
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Collections.HashSetDebugView`1">
            <summary>
            Debug view for HashSet
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.Build.Collections.HashHelpers">
            <summary>
            Duplicated because internal to mscorlib
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ConvertingEnumerable`2">
            <summary>
            Enumerable that uses a provided Converter delegate to
            convert each item from a backing enumerator as it is returned.
            </summary>
            <typeparam name="TFrom">Type of underlying enumerator</typeparam>
            <typeparam name="TTo">Type returned</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ConvertingEnumerable`2._backingEnumerable">
            <summary>
            Enumerable behind this one
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ConvertingEnumerable`2._converter">
            <summary>
            Converter delegate used on each item in the backing enumerable as it is returned
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConvertingEnumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConvertingEnumerable`2.GetEnumerator">
            <summary>
            Gets the converting enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConvertingEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            IEnumerable version of GetEnumerator
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2">
            <summary>
            Enumerable that uses a provided Converter delegate to
            convert each item from a backing enumerator as it is returned.
            </summary>
            <typeparam name="TFrom2">Type of underlying enumerator</typeparam>
            <typeparam name="TTo2">Type returned</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2._backingEnumerator">
            <summary>
            Enumerator behind this one
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2._converter">
            <summary>
            Converter delegate used on each item in the backing enumerator as it is returned
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2.#ctor(System.Collections.Generic.IEnumerator{`2},System.Func{`2,`3})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2.Current">
            <summary>
            Get the current element, converted
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2.System#Collections#IEnumerator#Current">
            <summary>
            Get the current element, converted
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2.MoveNext">
            <summary>
            Move to the next element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2.Reset">
            <summary>
            Reset the enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ConvertingEnumerable`2.ConvertingEnumerator`2.Dispose">
            <summary>
            Dispose of the enumerator
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnReadEnumerable`1">
            <summary>
            A class which implements IEnumerable by creating an optionally-deep copy of the backing collection.
            </summary>
            <remarks>
            If the type contained in the collection implements IDeepCloneable then the copies will be deep clones instead
            of mere reference copies.
            <see cref="M:Microsoft.Build.Collections.CopyOnReadEnumerable`1.GetEnumerator"/> is thread safe for concurrent access.
            </remarks>
            <typeparam name="T">The type contained in the backing collection.</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnReadEnumerable`1._backingEnumerable">
            <summary>
            The backing collection.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnReadEnumerable`1._syncRoot">
            <summary>
            The object used to synchronize access for copying.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnReadEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="backingEnumerable">The collection which serves as a source for enumeration.</param>
            <param name="syncRoot">The object used to synchronize access for copying.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnReadEnumerable`1.GetEnumerator">
            <summary>
            Returns an enumerator over the collection.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnReadEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an numerator over the collection.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnWriteDictionary`2">
             <summary>
             A dictionary that has copy-on-write semantics.
             KEYS AND VALUES MUST BE IMMUTABLE OR COPY-ON-WRITE FOR THIS TO WORK.
             </summary>
             <typeparam name="K">The key type.</typeparam>
             <typeparam name="V">The value type.</typeparam>
             <remarks>
             This dictionary works by having a backing dictionary which is ref-counted for each
             COWDictionary which references it.  When a write operation is performed on any
             COWDictionary, we check the reference count on the backing dictionary.  If it is 
             greater than 1, it means any changes we make to it would be visible to other readers.
             Therefore, we clone the backing dictionary and decrement the reference count on the
             original.  From there on we use the cloned dictionary, which now has a reference count
             of 1.
            
             Thread safety: for all users, this class is as thread safe as the underlying Dictionary implementation, that is,
             safe for concurrent readers or one writer from EACH user. It achieves this by locking itself and cloning before
             any write, if it is being shared - i.e., stopping sharing before any writes occur.
             </remarks>
             <comment>
             This class must be serializable as it is used for metadata passed to tasks, which may
             be run in a separate appdomain.
             </comment>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.capacity">
            <summary>
            The default capacity.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.backing">
            <summary>
            The backing dictionary.
            Lazily created.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor">
            <summary>
            Constructor. Consider supplying a comparer instead.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Int32)">
            <summary>
            Constructor taking an initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys and an initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor, for crossing appdomain boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.#ctor(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1})">
            <summary>
            Cloning constructor. Defers the actual clone.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Keys">
            <summary>
            Returns the collection of keys in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Values">
            <summary>
            Returns the collection of values in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Count">
            <summary>
            Returns the number of items in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.IsReadOnly">
            <summary>
            Returns true if the collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#Count">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Dummy">
            <summary>
            A special single dummy instance that always appears empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.IsDummy">
            <summary>
            Whether this is a dummy instance that always appears empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Comparer">
            <summary>
            Comparer used for keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.ReadOperation">
            <summary>
            Gets the backing dictionary for reading.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.WriteOperation">
            <summary>
            Gets the backing dictionary for writing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Item(`0)">
            <summary>
            Accesses the value for the specified key.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            IDictionary implementation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Add(`0,`1)">
            <summary>
            Adds a value to the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if the dictionary contains the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Remove(`0)">
            <summary>
            Removes the entry for the specified key from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to find the value for the specified key in the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item to the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Returns true ff the collection contains the specified item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies all of the elements of the collection to the specified array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Remove an item from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.GetEnumerator">
            <summary>
            Implementation of generic IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Clear">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            IDictionary implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.Clone">
            <summary>
            Clone, with the actual clone deferred
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.HasSameBacking(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1})">
            <summary>
            Returns true if these dictionaries have the same backing.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2">
            <summary>
            A dictionary which is reference counted to allow several references for read operations, but knows when to clone for
            write operations.
            </summary>
            <typeparam name="K1">The key type.</typeparam>
            <typeparam name="V1">The value type.</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.s_readOnlyEmptyDictionary">
            <summary>
            An empty dictionary 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2._refCount">
            <summary>
            The reference count. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`2})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor, for crossing appdomain boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor">
            <summary>
            Empty constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.#ctor(Microsoft.Build.Collections.CopyOnWriteDictionary{`0,`1}.CopyOnWriteBackingDictionary{`2,`3})">
            <summary>
            Cloning constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.ReadOnlyEmptyInstance">
            <summary>
            Returns a read-only empty instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.HasNoClones">
            <summary>
            Returns true if this collection has no clones.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.CloneForWriteIfNecessary">
            <summary>
            Clones backing dictionary if necessary for a write operation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.AddRef">
            <summary>
            Adds a reader-reference to this backing dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWriteDictionary`2.CopyOnWriteBackingDictionary`2.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization does not call any constructors, not even
            the parameterless constructor. Therefore since we do not serialize
            this field, we must populate it here.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1">
             <summary>
             A dictionary of unordered property or metadata name/value pairs, with copy-on-write semantics.
             
             The copy-on-write semantics are only possible if the contained type is immutable, which currently
             means it can only be used for ProjectMetadataInstance's.
             USE THIS DICTIONARY ONLY FOR IMMUTABLE TYPES. OTHERWISE USE PROPERTYDICTIONARY.
             
             </summary>
             <remarks>
             The value that this adds over IDictionary&lt;string, T&gt; is:
                 - enforces that key = T.Name
                 - default enumerator is over values
                 - (marginal) enforces the correct key comparer
                 - potentially makes copy on write possible
             
             Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
             Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
             either not expose this collection or expose it through a readonly wrapper.
            
             At various places in this class locks are taken on the backing collection.  The reason for this is to allow
             this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
             lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
             the state of the enumeration until the collection has been fully copied.
            
             The use of a CopyOnWriteDictionary does not reduce the concurrency of this collection, because CopyOnWriteDictionary
             offers the same concurrency guarantees (concurrent readers OR single writer) for EACH user of the dictionary.
             
             Since we use the mutable ignore case comparer we need to make sure that we lock our self before we call the comparer since the comparer can call back 
             into this dictionary which could cause a deadlock if another thread is also accessing another method in the dictionary.
             </remarks>
             <typeparam name="T">Property or Metadata class type to store</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1._properties">
            <summary>
            Backing dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.#ctor">
            <summary>
            Creates empty dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.#ctor(System.Int32)">
            <summary>
            Creates empty dictionary with specified initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.#ctor(Microsoft.Build.Collections.CopyOnWritePropertyDictionary{`0})">
            <summary>
            Cloning constructor, with deferred cloning semantics
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Keys">
            <summary>
            Accessor for the list of property names
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Values">
            <summary>
            Accessor for the list of properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Count">
            <summary>
            Returns the number of properties in the collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#IsReadOnly">
            <summary>
            Whether the collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Count">
            <summary>
            Returns the number of property in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.PropertyNames">
            <summary>
            Retrieves a collection containing the names of all the properties present in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Item(System.String)">
            <summary>
            Get the property with the specified name, or null if none exists.
            Sets the property with the specified name, overwriting it if already exists.
            </summary>
            <remarks>
            Unlike Dictionary&lt;K,V&gt;[K], the getter returns null instead of throwing if the key does not exist.
            This better matches the semantics of property, which are considered to have a blank value if they
            are not defined.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Item(System.String)">
            <summary>
            Get the property with the specified name, or null if none exists.
            Sets the property with the specified name, overwriting it if already exists.
            </summary>
            <remarks>
            Unlike Dictionary&lt;K,V&gt;[K], the getter returns null instead of throwing if the key does not exist.
            This better matches the semantics of property, which are considered to have a blank value if they
            are not defined.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.GetCopyOnReadEnumerable">
            <summary>
            Returns an enumerable which clones the properties 
            </summary>
            <returns>Returns a cloning enumerable.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Contains(System.String)">
            <summary>
            Returns true if a property with the specified name is present in the collection,
            otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Clear">
            <summary>
            Empties the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.GetEnumerator">
            <summary>
            Gets an enumerator over all the properties in the collection
            Enumeration is in undefined order
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator over entries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Equals(Microsoft.Build.Collections.CopyOnWritePropertyDictionary{`0})">
            <summary>
            Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
            same values as the other, unequal otherwise.
            </summary>
            <param name="other">The dictionary to which this should be compared</param>
            <returns>True if they are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Add(System.String,`0)">
            <summary>
            Adds a property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#ContainsKey(System.String)">
            <summary>
            Returns true if the dictionary contains the key
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Remove(System.String)">
            <summary>
            Removes a property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#TryGetValue(System.String,`0@)">
            <summary>
            Attempts to retrieve the a property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Add(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Adds a property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Clear">
            <summary>
            Clears the property collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Contains(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Checks for a property in the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#CopyTo(System.Collections.Generic.KeyValuePair{System.String,`0}[],System.Int32)">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Remove(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Removes a property from the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#String,T}}#GetEnumerator">
            <summary>
            Get an enumerator over the entries.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Remove(System.String)">
            <summary>
            Removes any property with the specified name.
            Returns true if the property was in the collection, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Remove(System.String,System.Boolean)">
            <summary>
            Removes any property with the specified name.
            Returns true if the property was in the collection, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.Set(`0)">
            <summary>
            Add the specified property to the collection.
            Overwrites any property with the same name already in the collection.
            To remove a property, use Remove(...) instead.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.ImportProperties(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified properties to this dictionary.
            </summary>
            <param name="other">An enumerator over the properties to add.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.RemoveProperties(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes the specified properties from this dictionary
            </summary>
            <param name="other">An enumerator over the properties to remove.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.ToDictionary">
            <summary>
            Helper to convert into a read-only dictionary of string, string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1.DeepClone">
            <summary>
            Clone. As we're copy on write, this 
            should be cheap.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.IDeepCloneable`1">
            <summary>
            An interface representing an item which can clone itself.
            </summary>
            <typeparam name="T">The type returned by the clone operation.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Collections.IDeepCloneable`1.DeepClone">
            <summary>
            Creates a clone of the item where no data references are shared.  Changes made to the clone
            do not affect the original item.
            </summary>
            <returns>The cloned item.</returns>
        </member>
        <member name="T:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer">
            <summary>
            This is a custom string comparer that has three advantages over the regular
            string comparer:
            1) It can generate hash codes and perform equivalence operations on parts of a string rather than a whole
            2) It uses "unsafe" pointers to maximize performance of those operations
            3) It takes advantage of limitations on MSBuild Property/Item names to cheaply do case insensitive comparison.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.s_runningProcessorArchitecture">
            <summary>
            The processor architecture on which we are running, but default it will be x86
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.#cctor">
            <summary>
            We need a static constructor to retrieve the running ProcessorArchitecture that way we can
            avoid using optimized code that will not run correctly on IA64 due to alignment issues
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.Default">
            <summary>
            The default immutable comparer instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.Equals(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Performs the "Equals" operation on two MSBuild property, item or metadata names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer.GetHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Getting a case insensitive hash code for the msbuild property, item or metadata name
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.HashTableUtility">
            <summary>
            Tools for working with Hashtables.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.HashTableUtility.Compare(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Compares the given hashtables.
            </summary>
            <param name="h1">May be null</param>
            <param name="h2">May be null</param>
            <returns>
            -1, if first hashtable is "less than" the second one
             0, if hashtables have identical keys and equivalent (case-insensitive) values
            +1, if first hashtable is "greater than" the second one
            </returns>
        </member>
        <member name="T:Microsoft.Build.Collections.ItemDictionary`1">
            <summary>
            Collection of items that allows a list of all items of a specified type to be 
            retrieved in O(1), and specific items to be added, removed, or checked for in O(1). 
            All items of a particular type can also be removed in O(1).
            Items are ordered with respect to all other items of their type.
            </summary>
            <remarks>
            Really a Dictionary&lt;string, ICollection&lt;T&gt;&gt; where the key (the item type) is obtained from IKeyed.Key
            Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
            either not expose this collection or expose it through a readonly wrapper.
            At various places in this class locks are taken on the backing collection.  The reason for this is to allow
            this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
            lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
            the state of the enumeration until the collection has been fully copied.
            </remarks>
            <typeparam name="T">Item class type to store</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ItemDictionary`1._itemLists">
            <summary>
            Dictionary of item lists used as a backing store.
            An empty list should never be stored in here unless it is an empty marker.
            See <see cref="M:Microsoft.Build.Collections.ItemDictionary`1.AddEmptyMarker(System.String)">AddEmptyMarker</see>.
            This collection provides quick access to the ordered set of items of a particular type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ItemDictionary`1._nodes">
            <summary>
            Dictionary of items in the collection, to speed up Contains,
            Remove, and Replace. For those operations, we look up here,
            then modify the other dictionary to match.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.#ctor">
            <summary>
            Constructor for an empty collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for an empty collection taking an initial capacity
            for the number of distinct item types
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructor for an collection holding items from a specified enumerable.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ItemDictionary`1.Count">
            <summary>
            Number of items in total, for debugging purposes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ItemDictionary`1.ItemTypes">
            <summary>
            Get the item types that have at least one item in this collection
            </summary>
            <remarks>
            KeyCollection&lt;K&gt; is already a read only collection, so no protection
            is necessary.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Collections.ItemDictionary`1.Item(System.String)">
            <summary>
            Returns the item list for a particular item type,
            creating and adding a new item list if necessary.
            Does not throw if there are no items of this type.
            This is a read-only list.
            If the result is not empty it is a live list.
            Use AddItem or RemoveItem to modify items in this project.
            Using the return value from this in a multithreaded situation is unsafe.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Clear">
            <summary>
            Empty the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.GetCopyOnReadEnumerable">
            <summary>
            Returns an enumerable which copies the underlying data on read.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.GetEnumerator">
            <summary>
            Gets an enumerator over the items in the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator over entries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.GetItems(System.String)">
            <summary>
            Returns all of the items for the specified type.
            If there are no items of this type, returns an empty list.
            Using the return from this method in a multithreaded scenario is unsafe.
            </summary>
            <param name="itemType">The item type to return</param>
            <returns>The list of matching items.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Contains(`0)">
            <summary>
            Whether the provided item is in this table or not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Add(`0)">
            <summary>
            Add a new item to the collection, at the
            end of the list of other items with its key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Remove(`0)">
            <summary>
            Removes an item, if it is in the collection.
            Returns true if it was found, otherwise false.
            </summary>
            <remarks>
            If a list is emptied, removes the list from the enclosing collection
            so it can be garbage collected.
            </remarks>        
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Replace(`0,`0)">
            <summary>
            Replaces an exsting item with a new item.  This is necessary to preserve the original ordering semantics of Lookup.GetItems
            when items with metadata modifications are being returned.  See Dev10 bug 480737.
            If the item is not found, does nothing.
            </summary>
            <param name="existingItem">The item to be replaced.</param>
            <param name="newItem">The replacement item.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.ImportItems(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the set of items specified to this dictionary
            </summary>
            <param name="other">An enumerator over the items to remove.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.ImportItemsOfType(System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the set of items specified, all sharing an item type, to this dictionary.
            </summary>
            <comment>
            This is a little faster than ImportItems where all the items have the same item type.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.RemoveItems(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove the set of items specified from this dictionary
            </summary>
            <param name="other">An enumerator over the items to remove.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.AddEmptyMarker(System.String)">
            <summary>
            Special method used for batching buckets.
            Adds an explicit marker indicating there are no items for the specified item type.
            In the general case, this is redundant, but batching buckets use this to indicate that they are
            batching over the item type, but their bucket does not contain items of that type.
            See <see cref="M:Microsoft.Build.Collections.ItemDictionary`1.HasEmptyMarker(System.String)">HasEmptyMarker</see>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.HasEmptyMarker(System.String)">
            <summary>
            Special method used for batching buckets.
            Lookup can call this to see whether there was an explicit marker placed indicating that
            there are no items of this type. See comment on <see cref="M:Microsoft.Build.Collections.ItemDictionary`1.AddEmptyMarker(System.String)">AddEmptyMarker</see>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ItemDictionary`1.Enumerator">
            <summary>
            Custom enumerator that allows enumeration over all the items in the collection
            as though they were in a single list.
            All items of a type are returned consecutively in their correct order.
            However the order in which item types are returned is not defined.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ItemDictionary`1.Enumerator._listEnumerator">
            <summary>
            Enumerator over lists
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ItemDictionary`1.Enumerator._itemEnumerator">
            <summary>
            Enumerator over items in the current list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.ICollection{`0}})">
            <summary>
            Constructs an item enumerator over a list enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.Current">
            <summary>
            Get the current item
            </summary>
            <remarks>Undefined if enumerator is before or after collection: we return null.</remarks>
        </member>
        <member name="P:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Implementation of IEnumerator.Current, which unlike IEnumerator&gt;T&lt;.Current throws
            if there is no current object
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.MoveNext">
            <summary>
            Move to the next object if any,
            otherwise returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.Reset">
            <summary>
            Reset the enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.Dispose(System.Boolean)">
            <summary>
            The real disposer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ItemDictionary`1.Enumerator.GetNextItemEnumerator">
            <summary>
            Get an item enumerator over the next list with items in it
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.IImmutable">
            <summary>
            Interface indicating a type is immutable, to constrain generic types.
            </summary>
            <remarks>
            This can be internal as it is a constraint only on internal collections.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Collections.MultiDictionary`2">
            <summary>
            A dictionary that can hold more than one distinct value with the same key.
            All keys must have at least one value: null values are currently rejected.
            </summary>
            <remarks>
            Order of values for a key is not defined but is currently the order of add.
            A variation could store the values in a HashSet, for different tradeoffs.
            </remarks>
            <typeparam name="K">Type of key</typeparam>
            <typeparam name="V">Type of value</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.MultiDictionary`2._backing">
            <summary>
            Backing dictionary
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.MultiDictionary`2._valueCount">
            <summary>
            Number of values over all keys
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.MultiDictionary`2.KeyCount">
            <summary>
            Number of keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.MultiDictionary`2.ValueCount">
            <summary>
            Number of values over all keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.MultiDictionary`2.Keys">
            <summary>
            return keys in the dictionary
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.MultiDictionary`2.Item(`0)">
            <summary>
            Enumerator over values that have the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.Add(`0,`1)">
            <summary>
            Add a single value under the specified key.
            Value may not be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.Remove(`0,`1)">
            <summary>
            Removes an entry with the specified key and value.
            Returns true if found, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.Clear">
            <summary>
            Empty the collection
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1">
            <summary>
            List capable of holding 0-n items.
            Uses less memory than List for less than 2 items.
            </summary>
            <typeparam name="TT">Type of the value</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1._entry">
            <summary>
            Entry - either a TT or a list of TT.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1.#ctor(`2)">
            <summary>
            Constructor taking the initial object
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1.Count">
            <summary>
            Number of entries in this multivalue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1.GetEnumerator">
            <summary>
            Enumerable over the values.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerable over the values.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1.Add(`2)">
            <summary>
            Add a value.
            Does not verify the value is not already present.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.MultiDictionary`2.SmallList`1.Remove(`2)">
            <summary>
            Remove a value.
            Returns true if the value existed, otherwise false.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.IValued">
            <summary>
            Interface allowing values of things to be gotten.
            </summary>
            <remarks>
            This can be internal as it is a constraint only on internal collections.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Collections.IValued.EscapedValue">
            <summary>
            Returns some value of a thing
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.PropertyDictionary`1">
            <summary>
            A dictionary of unordered property or metadata name/value pairs.
            </summary>
            <remarks>
            The value that this adds over IDictionary&lt;string, T&gt; is:
                - enforces that key = T.Name
                - default enumerator is over values
                - (marginal) enforces the correct key comparer
                - potentially makes copy on write possible
            
            Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
            Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
            either not expose this collection or expose it through a readonly wrapper.
            At various places in this class locks are taken on the backing collection.  The reason for this is to allow
            this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
            lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
            the state of the enumeration until the collection has been fully copied.
            
            Since we use the mutable ignore case comparer we need to make sure that we lock our self before we call the comparer since the comparer can call back 
            into this dictionary which could cause a deadlock if another thread is also accessing another method in the dictionary.
            </remarks>
            <typeparam name="T">Property or Metadata class type to store</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.PropertyDictionary`1._properties">
            <summary>
            Backing dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.#ctor">
            <summary>
            Creates empty dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.#ctor(System.Int32)">
            <summary>
            Creates empty dictionary, optionally specifying initial capacity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new dictionary from an enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.#ctor(Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer)">
            <summary>
            Creates empty dictionary, specifying a comparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new dictionary from an enumerator
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Keys">
            <summary>
            Accessor for the list of property names
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Values">
            <summary>
            Accessor for the list of properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Count">
            <summary>
            Returns the number of properties in the collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#IsReadOnly">
            <summary>
            Whether the collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.PropertyDictionary`1.Count">
            <summary>
            Returns the number of property in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Item(System.String)">
            <summary>
            Get the property with the specified name, or null if none exists.
            Sets the property with the specified name, overwriting it if already exists.
            </summary>
            <remarks>
            Unlike Dictionary&lt;K,V&gt;[K], the getter returns null instead of throwing if the key does not exist.
            This better matches the semantics of property, which are considered to have a blank value if they
            are not defined.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Collections.PropertyDictionary`1.Item(System.String)">
            <summary>
            Get the property with the specified name, or null if none exists.
            Sets the property with the specified name, overwriting it if already exists.
            </summary>
            <remarks>
            Unlike Dictionary&lt;K,V&gt;[K], the getter returns null instead of throwing if the key does not exist.
            This better matches the semantics of property, which are considered to have a blank value if they
            are not defined.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.GetCopyOnReadEnumerable">
            <summary>
            Returns an enumerable which clones the properties 
            </summary>
            <returns>Returns a cloning enumerable.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.Contains(System.String)">
            <summary>
            Returns true if a property with the specified name is present in the collection,
            otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.Clear">
            <summary>
            Empties the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.GetEnumerator">
            <summary>
            Gets an enumerator over all the properties in the collection
            Enumeration is in undefined order
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator over entries
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.Equals(Microsoft.Build.Collections.PropertyDictionary{`0})">
            <summary>
            Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
            same values as the other, unequal otherwise.
            </summary>
            <param name="other">The dictionary to which this should be compared</param>
            <returns>True if they are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.GetProperty(System.String)">
            <summary>
            Get the property with the specified name or null if it is not present
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.GetProperty(System.String,System.Int32,System.Int32)">
            <summary>
            Get the property with the specified name or null if it is not present.
            Name is the segment of the provided string with the provided start and end indexes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Add(System.String,`0)">
            <summary>
            Adds a property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#ContainsKey(System.String)">
            <summary>
            Returns true if the dictionary contains the key
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#Remove(System.String)">
            <summary>
            Removes a property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IDictionary{System#String,T}#TryGetValue(System.String,`0@)">
            <summary>
            Attempts to retrieve the a property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Add(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Adds a property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Clear">
            <summary>
            Clears the property collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Contains(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Checks for a property in the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#CopyTo(System.Collections.Generic.KeyValuePair{System.String,`0}[],System.Int32)">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String,T}}#Remove(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Removes a property from the collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#String,T}}#GetEnumerator">
            <summary>
            Get an enumerator over the entries.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.Remove(System.String)">
            <summary>
            Removes any property with the specified name.
            Returns true if the property was in the collection, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.Set(`0)">
            <summary>
            Add the specified property to the collection.
            Overwrites any property with the same name already in the collection.
            To remove a property, use Remove(...) instead.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.ImportProperties(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified properties to this dictionary.
            </summary>
            <param name="other">An enumerator over the properties to add.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.RemoveProperties(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes the specified properties from this dictionary
            </summary>
            <param name="other">An enumerator over the properties to remove.</param>
        </member>
        <member name="M:Microsoft.Build.Collections.PropertyDictionary`1.ToDictionary">
            <summary>
            Helper to convert into a read-only dictionary of string, string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyCollection`1">
            <summary>
            A read-only live wrapper over a collection.
            It does not prevent modification of the values themselves.
            </summary>
            <remarks>
            There is a type with the same name in the BCL, but it is actually a ReadOnlyList and does not accept an ICollection&gt;T&lt;.
            Thus this is an omission from the BCL.
            </remarks>
            <typeparam name="T">Type of element in the collection</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyCollection`1._backing">
            <summary>
            Backing live enumerable.
            May be a collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Construct a read only wrapper around the current contents 
            of the IEnumerable, or around the backing collection if the 
            IEnumerable is in fact a collection. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.Count">
            <summary>
            Return the number of items in the backing collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.IsReadOnly">
            <summary>
            Returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Whether collection is synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Sync root
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyCollection`1.BackingCollection">
            <summary>
            Get a backing ICollection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Add(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Contains(`0)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.GetEnumerator">
            <summary>
            Pass through for underlying collection
            </summary>
            <comment>
            NOTE: This does NOT cause a copy into a List, since the
            backing enumerable suffices.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Pass through for underlying collection
            </summary>
            <comment>
            NOTE: This does NOT cause a copy into a List, since the
            backing enumerable suffices.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            ICollection version of CopyTo
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3">
            <summary>
            Implementation of a dictionary which acts as a read-only wrapper on another dictionary, but
            converts values as they are accessed to another type.
            </summary>
            <typeparam name="K">The backing dictionary's key type.</typeparam>
            <typeparam name="V">The backing dictionary's value type.</typeparam>
            <typeparam name="N">The desired value type.</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3._backing">
            <summary>
            The backing dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3._converter">
            <summary>
            The delegate used to convert values.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Func{`1,`2})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Keys">
            <summary>
            Returns the collection of keys in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Values">
            <summary>
            Returns the collection of values in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Count">
            <summary>
            Returns the number of items in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.IsReadOnly">
            <summary>
            Returns true if the collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Item(`0)">
            <summary>
            Accesses the value for the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Add(`0,`2)">
            <summary>
            Adds a value to the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.ContainsKey(`0)">
            <summary>
            Returns true if the dictionary contains the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Remove(`0)">
            <summary>
            Removes the entry for the specified key from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.TryGetValue(`0,`2@)">
            <summary>
            Attempts to find the value for the specified key in the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Add(System.Collections.Generic.KeyValuePair{`0,`2})">
            <summary>
            Adds an item to the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Contains(System.Collections.Generic.KeyValuePair{`0,`2})">
            <summary>
            Returns true ff the collection contains the specified item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.CopyTo(System.Collections.Generic.KeyValuePair{`0,`2}[],System.Int32)">
            <summary>
            Copies all of the elements of the collection to the specified array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.Remove(System.Collections.Generic.KeyValuePair{`0,`2})">
            <summary>
            Remove an item from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.GetEnumerator">
            <summary>
            Implementation of generic IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation of IEnumerable.GetEnumerator()
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3.KeyValueConverter(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Delegate used by ConvertingEnumerable
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.WeakValueDictionary`2">
            <summary>
            Dictionary that does not prevent values from being garbage collected.
            </summary>
            <typeparam name="K">Type of key</typeparam>
            <typeparam name="V">Type of value, without the WeakReference wrapper.</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.WeakValueDictionary`2._dictionary">
            <summary>
            The dictionary used internally to store the keys and values.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.WeakValueDictionary`2._capacity">
            <summary>
            Improvised capacity. See comment in item setter.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.WeakValueDictionary`2.#ctor">
            <summary>
            Constructor for a collection using the default key comparer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.WeakValueDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor taking a specified comparer for the keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.WeakValueDictionary`2.Count">
            <summary>
            Count of entries.
            Some entries may represent keys or values that have already been garbage collected.
            To clean these out call <see cref="M:Microsoft.Build.Collections.WeakValueDictionary`2.Scavenge"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.WeakValueDictionary`2.Keys">
            <summary>
            Return keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.WeakValueDictionary`2.Item(`0)">
            <summary>
            Obtains the value for a given key.
            </summary>
            <remarks>
            If we find the entry but its value's target is null, we take the opportunity
            to remove the entry, as if the GC had done it.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Collections.WeakValueDictionary`2.Contains(`0)">
            <summary>
            Whether there is a key present with the specified key
            </summary>
            <remarks>
            As usual, don't just call Contained as the wrapped value may be null.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Collections.WeakValueDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value for the provided key.
            Returns true if the key is found, otherwise false.
            </summary>
            <remarks>
            If we find the entry but its value's target is null, we take the opportunity
            to remove the entry, as if the GC had done it.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Collections.WeakValueDictionary`2.Remove(`0)">
            <summary>
            Removes an entry with the specified key.
            Returns true if found, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.WeakValueDictionary`2.Scavenge">
            <summary>
            Remove any entries from the dictionary that represent keys
            that have been garbage collected.
            </summary>
            <returns>The number of entries removed.</returns>
        </member>
        <member name="M:Microsoft.Build.Collections.WeakValueDictionary`2.Clear">
            <summary>
            Empty the collection
            </summary>
        </member>
        <member name="T:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2">
            <summary>
            A special singleton enumerable that enumerates a read-only empty dictionary
            </summary>
            <typeparam name="K">Key</typeparam>
            <typeparam name="V">Value</typeparam>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.s_backing">
            <summary>
            The single instance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.s_instance">
            <summary>
            The single instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.#ctor">
            <summary>
            Private default constructor as this is a singleton
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Instance">
            <summary>
            Get the instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Count">
            <summary>
            Empty returns zero
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsReadOnly">
            <summary>
            Returns true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Keys">
            <summary>
            Gets empty collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Values">
            <summary>
            Gets empty collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsFixedSize">
            <summary>
            Is it fixed size
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.IsSynchronized">
            <summary>
            Not synchronized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.SyncRoot">
            <summary>
            No sync root
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Keys
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Values
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Item(System.Object)">
            <summary>
            Indexer
            </summary>
        </member>
        <member name="P:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Item(`0)">
            <summary>
            Get returns null as read-only
            Set is prohibited and throws.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(`0,`1)">
            <summary>
            Pass through for underlying collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.ContainsKey(`0)">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(`0)">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Clear">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Empty returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Empty does nothing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Prohibited on read only collection: throws
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.GetEnumerator">
            <summary>
            Get empty enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get empty enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Add(System.Object,System.Object)">
            <summary>
            Add
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Contains(System.Object)">
            <summary>
            Contains
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.Remove(System.Object)">
            <summary>
            Remove
            </summary>
        </member>
        <member name="M:Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2.CopyTo(System.Array,System.Int32)">
            <summary>
            CopyTo
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.PropertyParser.GetTable(Microsoft.Build.BackEnd.TaskLoggingHelper,System.String,System.String[],System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
            a hash table containing the property names as keys and the property values as values.  
            </summary>
            <returns>true on success, false on failure.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.PropertyParser.GetTableWithEscaping(Microsoft.Build.BackEnd.TaskLoggingHelper,System.String,System.String,System.String[],System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
            a hash table containing the property names as keys and the property values as values.  
            This method escapes any special characters found in the property values, in case they 
            are going to be passed to a method (such as that expects the appropriate escaping to have happened
            already.
            </summary>
            <returns>true on success, false on failure.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.PropertyParser.PropertyNameValuePair">
            <summary>
            A very simple class that holds two strings, a property name and property value.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.PropertyParser.PropertyNameValuePair.Name">
            <summary>
            Property name
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.PropertyParser.PropertyNameValuePair.Value">
            <summary>
            Property value
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskHostConfiguration">
            <summary>
            TaskHostConfiguration contains information needed for the task host to 
            configure itself for to execute a particular task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._nodeId">
            <summary>
            The node id (of the parent node, to make the logging work out)
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._startupDirectory">
            <summary>
            The startup directory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._buildProcessEnvironment">
            <summary>
            The process environment.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._culture">
            <summary>
            The culture
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._uiCulture">
            <summary>
            The UI culture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._appDomainSetup">
            <summary>
            The AppDomainSetup that we may want to use on AppDomainIsolated tasks. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._lineNumberOfTask">
            <summary>
            Line number where the instance of this task is defined. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._columnNumberOfTask">
            <summary>
            Column number where the instance of this task is defined. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._projectFileOfTask">
            <summary>
            Project file where the instance of this task is defined. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._continueOnError">
            <summary>
            ContinueOnError flag for this particular task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._taskName">
            <summary>
            Name of the task to be executed on the task host. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._taskLocation">
            <summary>
            Location of the assembly containing the task to be executed. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostConfiguration._taskParameters">
            <summary>
            The set of parameters to apply to the task prior to execution.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostConfiguration.#ctor(System.Int32,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Globalization.CultureInfo,System.Globalization.CultureInfo,System.AppDomainSetup,System.Int32,System.Int32,System.String,System.Boolean,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructor
            </summary>
            <param name="nodeId">The ID of the node being configured.</param>
            <param name="startupDirectory">The startup directory for the task being executed.</param>
            <param name="buildProcessEnvironment">The set of environment variables to apply to the task execution process.</param>
            <param name="culture">The culture of the thread that will execute the task.</param>
            <param name="uiCulture">The UI culture of the thread that will execute the task.</param>
            <param name="appDomainSetup">The AppDomainSetup that may be used to pass information to an AppDomainIsolated task.</param>
            <param name="lineNumberOfTask">The line number of the location from which this task was invoked.</param>
            <param name="columnNumberOfTask">The column number of the location from which this task was invoked.</param>
            <param name="projectFileOfTask">The project file from which this task was invoked.</param>
            <param name="continueOnError">Flag to continue with the build after a the task failed</param>
            <param name="taskName">Name of the task.</param>
            <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
            <param name="taskParameters">Parameters to apply to the task.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostConfiguration.#ctor">
            <summary>
            Constructor for deserialization. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.NodeId">
            <summary>
            The node id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.StartupDirectory">
            <summary>
            The startup directory
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.BuildProcessEnvironment">
            <summary>
            The process environment.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.Culture">
            <summary>
            The culture
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.UICulture">
            <summary>
            The UI culture.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.AppDomainSetup">
            <summary>
            The AppDomain configuration bytes that we may want to use to initialize
            AppDomainIsolated tasks. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.LineNumberOfTask">
            <summary>
            Line number where the instance of this task is defined. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.ColumnNumberOfTask">
            <summary>
            Column number where the instance of this task is defined. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.ContinueOnError">
            <summary>
            ContinueOnError flag for this particular task
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.ProjectFileOfTask">
            <summary>
            Project file where the instance of this task is defined. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.TaskName">
            <summary>
            Name of the task to execute. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.TaskLocation">
            <summary>
            Path to the assembly to load the task from. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.TaskParameters">
            <summary>
            Parameters to set on the instantiated task prior to execution. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.GlobalProperties">
            <summary>
            Gets the global properties for the current project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostConfiguration.Type">
            <summary>
            The NodePacketType of this NodePacket
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostConfiguration.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates the packet to/from binary form.
            </summary>
            <param name="translator">The translator to use.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostConfiguration.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskHostTaskCancelled">
            <summary>
            TaskHostTaskCancelled informs the task host that the task it is 
            currently executing has been canceled.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTaskCancelled.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskCancelled.Type">
            <summary>
            The type of this NodePacket
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTaskCancelled.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates the packet to/from binary form.
            </summary>
            <param name="translator">The translator to use.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTaskCancelled.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskCompleteType">
            <summary>
            How the task completed -- successful, failed, or crashed
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskCompleteType.Success">
            <summary>
            Task execution succeeded
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskCompleteType.Failure">
            <summary>
            Task execution failed
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskCompleteType.CrashedDuringInitialization">
            <summary>
            Task crashed during initialization steps -- loading the task, 
            validating or setting the parameters, etc. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskCompleteType.CrashedDuringExecution">
            <summary>
            Task crashed while being executed
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskCompleteType.CrashedAfterExecution">
            <summary>
            Task crashed after being executed
            -- Getting outputs, etc
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskHostTaskComplete">
            <summary>
            TaskHostTaskComplete contains all the information the parent node 
            needs from the task host on completion of task execution.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTaskComplete._taskResult">
            <summary>
            Result of the task's execution. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTaskComplete._taskException">
            <summary>
            If the task threw an exception during its initialization or execution, 
            save it here. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTaskComplete._taskExceptionMessage">
            <summary>
            If there's an additional message that should be attached to the error 
            logged beyond "task X failed unexpectedly", save it here.  May be null. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTaskComplete._taskExceptionMessageArgs">
            <summary>
            If the message saved in taskExceptionMessage requires arguments, save 
            them here. May be null. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTaskComplete._taskOutputParameters">
            <summary>
            The set of parameters / values from the task after it finishes execution. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTaskComplete._buildProcessEnvironment">
            <summary>
            The process environment at the end of task execution.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTaskComplete.#ctor(Microsoft.Build.Shared.OutOfProcTaskHostTaskResult,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Constructor
            </summary>
            <param name="result">Result of the task's execution.</param>
            <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTaskComplete.#ctor">
            <summary>
            For deserialization.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskComplete.TaskResult">
            <summary>
            Result of the task's execution.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskComplete.TaskException">
            <summary>
            If the task threw an exception during its initialization or execution, 
            save it here. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskComplete.TaskExceptionMessage">
            <summary>
            If there's an additional message that should be attached to the error 
            logged beyond "task X failed unexpectedly", put it here.  May be null. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskComplete.TaskExceptionMessageArgs">
            <summary>
            If there are arguments that need to be formatted into the message being 
            sent, set them here.  May be null. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskComplete.TaskOutputParameters">
            <summary>
            Task parameters and their values after the task has finished.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskComplete.BuildProcessEnvironment">
            <summary>
            The process environment.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTaskComplete.Type">
            <summary>
            The type of this packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTaskComplete.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates the packet to/from binary form.
            </summary>
            <param name="translator">The translator to use.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTaskComplete.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.LinkStatusChangedDelegate">
            <summary>
            Used to receive link status updates from an endpoint.
            </summary>
            <param name="endpoint">The endpoint invoking the delegate.</param>
            <param name="status">The current status of the link.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.DataReceivedDelegate">
            <summary>
            Used to receive data from a node 
            </summary>
            <param name="endpoint">The endpoint invoking the delegate.</param>
            <param name="packet">The packet received.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.LinkStatus">
            <summary>
            The connection status of a link between the NodeEndpoint on the host and the NodeEndpoint
            on the peer.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.LinkStatus.Inactive">
            <summary>
            The connection has never been started.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.LinkStatus.Active">
            <summary>
            The connection is active, the most recent data has been successfully sent, and the 
            node is responding to pings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.LinkStatus.Failed">
            <summary>
            The connection has failed and been terminated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.LinkStatus.ConnectionFailed">
            <summary>
            The connection could not be made/timed out.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.INodeEndpoint">
            <summary>
            This interface represents one end of a connection between the INodeProvider and a Node.
            Implementations of this interface define the actual mechanism by which data is communicated.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.INodeEndpoint.OnLinkStatusChanged">
            <summary>
            Raised when the status of the node's link has changed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.INodeEndpoint.LinkStatus">
            <summary>
            The current link status for this endpoint.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeEndpoint.Listen(Microsoft.Build.BackEnd.INodePacketFactory)">
            <summary>
            Waits for the remote node to establish a connection.
            </summary>
            <param name="factory">The factory used to deserialize packets.</param>
            <remarks>Only one of Listen() or Connect() may be called on an endpoint.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeEndpoint.Connect(Microsoft.Build.BackEnd.INodePacketFactory)">
            <summary>
            Instructs the node to connect to its peer endpoint.
            </summary>
            <param name="factory">The factory used to deserialize packets.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeEndpoint.Disconnect">
            <summary>
            Instructs the node to disconnect from its peer endpoint.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeEndpoint.SendData(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends a data packet to the node.
            </summary>
            <param name="packet">The packet to be sent.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase">
            <summary>
            This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.PipeBufferSize">
            <summary>
            The size of the buffers to use for named pipes
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._debugCommunications">
            <summary>
            Flag indicating if we should debug communications or not.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._status">
            <summary>
            The current communication status of the node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._pipeServer">
            <summary>
            The pipe client used by the nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._asyncDataMonitor">
            <summary>
            Object used as a lock source for the async data
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._packetAvailable">
            <summary>
            Set when a packet is available in the packet queue
            </summary>      
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._terminatePacketPump">
            <summary>
            Set when the asynchronous packet pump should terminate
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._packetPump">
            <summary>
            The thread which runs the asynchronous packet pump
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._packetFactory">
            <summary>
            The factory used to create and route packets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._packetQueue">
            <summary>
            The asynchronous packet queue.  
            </summary>
            <remarks>
            Operations on this queue must be synchronized since it is accessible by multiple threads.
            Use a lock on the packetQueue itself.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase._sharedReadBuffer">
            <summary>
            Per-node shared read buffer.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.OnLinkStatusChanged">
            <summary>
            Raised when the link status has changed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.LinkStatus">
            <summary>
            Returns the link status of this node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.Listen(Microsoft.Build.BackEnd.INodePacketFactory)">
            <summary>
            Causes this endpoint to wait for the remote endpoint to connect
            </summary>
            <param name="factory">The factory used to create packets.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.Connect(Microsoft.Build.BackEnd.INodePacketFactory)">
            <summary>
            Causes this node to connect to the matched endpoint.  
            </summary>
            <param name="factory">The factory used to create packets.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.Disconnect">
            <summary>
            Shuts down the link
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.SendData(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the peer endpoint.
            </summary>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.InternalConstruct(System.String)">
            <summary>
            Instantiates an endpoint to act as a client
            </summary>
            <param name="pipeName">The name of the pipe to which we should connect.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.GetHostHandshake">
            <summary>
            Returns the host handshake for this node endpoint
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.GetClientHandshake">
            <summary>
            Returns the client handshake for this node endpoint
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.ChangeLinkStatus(Microsoft.Build.BackEnd.LinkStatus)">
            <summary>
            Updates the current link status if it has changed and notifies any registered delegates.
            </summary>
            <param name="newStatus">The status the node should now be in.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.RaiseLinkStatusChanged(Microsoft.Build.BackEnd.LinkStatus)">
            <summary>
            Invokes the OnLinkStatusChanged event in a thread-safe manner.
            </summary>
            <param name="newStatus">The new status of the endpoint link.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.InternalDisconnect">
            <summary>
            This does the actual work of changing the status and shutting down any threads we may have for
            disconnection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.EnqueuePacket(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Adds a packet to the packet queue when asynchronous mode is enabled.
            </summary>
            <param name="packet">The packet to be transmitted.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.InitializeAsyncPacketThread">
            <summary>
            Initializes the packet pump thread and the supporting events as well as the packet queue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.PacketPumpProc">
            <summary>
            This method handles the asynchronous message pump.  It waits for messages to show up on the queue
            and calls FireDataAvailable for each such packet.  It will terminate when the terminate event is
            set.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodePacketType">
            <summary>
            Enumeration of all of the packet types used for communication.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.NodeConfiguration">
            <summary>
            Notifies the Node to set a configuration for a particular build.  This is sent before
            any BuildRequests are made and will not be sent again for a particular build.  This instructs
            the node to prepare to receive build requests.
            
            Contains:
            Build ID
            Environment variables
            Logging Services Configuration
            Node ID
            Default Global Properties
            Toolset Definition Locations
            Startup Directory
            UI Culture Information
            App Domain Configuration XML
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.BuildRequestConfiguration">
            <summary>
            A BuildRequestConfiguration object.  
            When sent TO a node, this informs the node of a build configuration.
            When sent FROM a node, this requests a BuildRequestConfigurationResponse to map the configuration to the
            appropriate global configuration ID.
            
            Contents:
            Configuration ID
            Project Filename
            Project Properties
            Project Tools Version
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.BuildRequestConfigurationResponse">
            <summary>
            A response to a request to map a build configuration
            
            Contents:
            Node Configuration ID
            Global Configuration ID
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.ProjectLoadInfo">
            <summary>
            Information about a project that has been loaded by a node.
            
            Contents:
            Global Configuration ID
            Initial Targets
            Default Targets
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.BuildRequestBlocker">
            <summary>
            Packet used to inform the scheduler that a node's active build request is blocked.
            
            Contents:
            Build Request ID
            Active Targets
            Blocked Target, if any
            Child Requests, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.BuildRequestUnblocker">
            <summary>
            Packet used to unblocked a blocked request on a node.
            
            Contents:
            Build Request ID
            Build Results for child requests, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.BuildRequest">
            <summary>
            A BuildRequest object
            
            Contents:
            Build Request ID
            Configuration ID
            Project Instance ID
            Targets
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.BuildResult">
            <summary>
            A BuildResult object
            
            Contents:
            Build ID
            Project Instance ID
            Targets
            Outputs (per Target)
            Results (per Target)
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.LogMessage">
            <summary>
            A logging message.
            
            Contents:
            Build Event Type
            Build Event Args
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.NodeBuildComplete">
            <summary>
            Informs the node that the build is complete.  
            
            Contents:
            Prepare For Reuse
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.NodeShutdown">
            <summary>
            Reported by the node (or node provider) when a node has terminated.  This is the final packet that will be received
            from a node.
            
            Contents:
            Reason
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.TaskHostConfiguration">
            <summary>
            Notifies the task host to set the task-specific configuration for a particular task execution. 
            This is sent in place of NodeConfiguration and gives the task host all the information it needs
            to set itself up and execute the task that matches this particular configuration. 
            
            Contains:
            Node ID (of parent MSBuild node, to make the logging work out) 
            Startup directory
            Environment variables 
            UI Culture information
            App Domain Configuration XML
            Task name
            Task assembly location
            Parameter names and values to set to the task prior to execution
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.TaskHostTaskComplete">
            <summary>
            Informs the parent node that the task host has finished executing a 
            particular task.  Does not need to contain identifying information 
            about the task, because the task host will only ever be connected to 
            one parent node at a a time, and will only ever be executing one task 
            for that node at any one time.  
            
            Contents:
            Task result (success / failure)
            Resultant parameter values (for output gathering)
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.TaskHostTaskCancelled">
            <summary>
            Message sent from the node to its paired task host when a task that 
            supports ICancellableTask is cancelled.  
            
            Contents:
            (nothing) 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.ResolveSdkRequest">
            <summary>
            Message sent from a node when it needs to have an SDK resolved.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketType.ResolveSdkResponse">
            <summary>
            Message sent from back to a node when an SDK has been resolved.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.INodePacket">
            <summary>
            This interface represents a packet which may be transmitted using an INodeEndpoint.
            Implementations define the serialized form of the data.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.INodePacket.Type">
            <summary>
            The type of the packet.  Used to reconstitute the packet using the correct factory.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodePacketFactoryMethod">
            <summary>
            A delegate representing factory methods used to re-create packets deserialized from a stream.
            </summary>
            <param name="translator">The translator containing the packet data.</param>
            <returns>The packet reconstructed from the stream.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.INodePacketFactory">
            <summary>
            This interface represents an object which is used to reconstruct packet objects from
            binary data.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodePacketFactory.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers the specified handler for a particular packet type.
            </summary>
            <param name="packetType">The packet type.</param>
            <param name="factory">The factory for packets of the specified type.</param>
            <param name="handler">The handler to be called when packets of the specified type are received.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodePacketFactory.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.
            </summary>
            <param name="packetType">The packet type.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodePacketFactory.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Takes a serializer, deserializes the packet and routes it to the appropriate handler.
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packetType">The packet type.</param>
            <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodePacketFactory.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the specified packet
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packet">The packet to route.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.INodePacketHandler">
            <summary>
            Objects which wish to receive packets from the NodePacketRouter must implement this interface.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            This method is invoked by the NodePacketRouter when a packet is received and is intended for
            this recipient.
            </summary>
            <param name="node">The node from which the packet was received.</param>
            <param name="packet">The packet.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Translator`1">
            <summary>
            Delegate for users that want to translate an arbitrary structure that cannot implement <see cref="T:Microsoft.Build.BackEnd.ITranslatable"/> (e.g. translating a complex collection)
            </summary>
            <param name="translator">the translator</param>
            <param name="obj">the object to translate</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ITranslatable">
            <summary>
            An interface representing an object which may be serialized by the node packet serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslatable.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodePacketValueFactory`1">
            <summary>
            This delegate is used for objects which do not have public parameterless constructors and must be constructed using
            another method.  When invoked, this delegate should return a new object which has been translated appropriately.
            </summary>
            <typeparam name="T">The type to be translated.</typeparam>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodePacketCollectionCreator`1">
            <summary>
            This delegate is used to create arbitrary collection types for serialization.
            </summary>
            <typeparam name="T">The type of dictionary to be created.</typeparam>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TranslationDirection">
            <summary>
            The serialization mode.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TranslationDirection.WriteToStream">
            <summary>
            Indicates the serializer is operating in write mode.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TranslationDirection.ReadFromStream">
            <summary>
            Indicates the serializer is operating in read mode.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ITranslator">
            <summary>
            This interface represents an object which aids objects in serializing and 
            deserializing INodePackets.
            </summary>
            <remarks>
            The reason we bother with a custom serialization mechanism at all is two fold:
            1. The .Net serialization mechanism is inefficient, even if you implement ISerializable
               with your own custom mechanism.  This is because the serializer uses a bag called
               SerializationInfo into which you are expected to drop all your data.  This adds
               an unnecessary level of indirection to the serialization routines and prevents direct,
               efficient access to the byte-stream.
            2. You have to implement both a reader and writer part, which introduces the potential for
               error should the classes be later modified.  If the reader and writer methods are not
               kept in perfect sync, serialization errors will occur.  Our custom serializer eliminates
               that by ensuring a single Translate method on a given object can handle both reads and
               writes without referencing any field more than once.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ITranslator.Mode">
            <summary>
            Returns the current serialization mode.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ITranslator.Reader">
            <summary>
            Returns the binary reader.
            </summary>
            <remarks>
            This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the 
            translating object to know the direction of translation.  Use one of the Translate methods instead.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ITranslator.Writer">
            <summary>
            Returns the binary writer.
            </summary>
            <remarks>
            This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the 
            translating object to know the direction of translation.  Use one of the Translate methods instead.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Boolean@)">
            <summary>
            Translates a boolean.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Byte@)">
            <summary>
            Translates a byte.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Int16@)">
            <summary>
            Translates a short.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.UInt16@)">
            <summary>
            Translates a unsigned short.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Int32@)">
            <summary>
            Translates an integer.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Int64@)">
            <summary>
            Translates a long.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.String@)">
            <summary>
            Translates a string.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Double@)">
            <summary>
            Translates a double.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.String[]@)">
            <summary>
            Translates a string array.
            </summary>
            <param name="array">The array to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Collections.Generic.List{System.String}@)">
            <summary>
            Translates a list of strings
            </summary>
            <param name="list">The list to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Collections.Generic.HashSet{System.String}@)">
            <summary>
            Translates a set of strings
            </summary>
            <param name="set">The set to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate``1(System.Collections.Generic.List{``0}@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates a list of T where T implements INodePacketTranslateable
            </summary>
            <param name="list">The list to be translated.</param>
            <param name="factory">factory to create type T</param>
            <typeparam name="T">A TaskItemType</typeparam>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate``2(System.Collections.Generic.IList{``0}@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0},Microsoft.Build.BackEnd.NodePacketCollectionCreator{``1})">
            <summary>
            Translates a list of T where T implements INodePacketTranslateable using a collection factory
            </summary>
            <param name="list">The list to be translated.</param>
            <param name="factory">factory to create type T</param>
            <typeparam name="T">An ITranslatable subtype</typeparam>
            <typeparam name="L">An IList subtype</typeparam>
            <param name="collectionFactory">factory to create a collection</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.DateTime@)">
            <summary>
            Translates a DateTime.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.TimeSpan@)">
            <summary>
            Translates a TimeSpan.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(Microsoft.Build.Framework.BuildEventContext@)">
            <summary>
            Translates a BuildEventContext
            </summary>
            <remarks>
            This method exists only because there is no serialization method built into the BuildEventContext
            class, and it lives in Framework and we don't want to add a public method to it.
            </remarks>
            <param name="value">The context to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateEnum``1(``0@,System.Int32)">
            <summary>
            Translates an enumeration.
            </summary>
            <typeparam name="T">The enumeration type.</typeparam>
            <param name="value">The enumeration instance to be translated.</param>
            <param name="numericValue">The enumeration value as an integer.</param>
            <remarks>This is a bit ugly, but it doesn't seem like a nice method signature is possible because
            you can't pass the enum type as a reference and constrain the generic parameter to Enum.  Nor
            can you simply pass as ref Enum, because an enum instance doesn't match that function signature.
            Finally, converting the enum to an int assumes that we always want to transport enums as ints.  This
            works in all of our current cases, but certainly isn't perfectly generic.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateDotNet``1(``0@)">
            <summary>
            Translates a value using the .Net binary formatter.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
            <remarks>
            The primary purpose of this method is to support serialization of Exceptions and
            custom build logging events, since these do not support our custom serialization
            methods.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate``1(``0@)">
            <summary>
            Translates an object implementing INodePacketTranslatable.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate``1(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates an object implementing INodePacketTranslatable which does not expose a
            public parameterless constructor.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
            <param name="factory">The factory method used to instantiate values of type T.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateCulture(System.Globalization.CultureInfo@)">
            <summary>
            Translates a culture
            </summary>
            <param name="culture">The culture</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.Translate(System.Byte[]@)">
            <summary>
            Translates a byte array
            </summary>
            <param name="byteArray">The array to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateArray``1(``0[]@)">
            <summary>
            Translates an array of objects implementing INodePacketTranslatable.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="array">The array to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateArray``1(``0[]@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="array">The array to be translated.</param>
            <param name="factory">The factory method used to instantiate values of type T.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateDictionary(System.Collections.Generic.Dictionary{System.String,System.String}@,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Translates a dictionary of { string, string }.
            </summary>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="comparer">The comparer used to instantiate the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateDictionary``1(System.Collections.Generic.Dictionary{System.String,``0}@,System.Collections.Generic.IEqualityComparer{System.String},Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates a dictionary of { string, T }.  
            </summary>
            <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="comparer">The comparer used to instantiate the dictionary.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateDictionary``2(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``1})">
            <summary>
            Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
            </summary>
            <typeparam name="D">The reference type for the dictionary.</typeparam>
            <typeparam name="T">The reference type for values in the dictionary.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateDictionary``2(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``1},Microsoft.Build.BackEnd.NodePacketCollectionCreator{``0})">
            <summary>
            Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
            </summary>
            <typeparam name="D">The reference type for the dictionary.</typeparam>
            <typeparam name="T">The reference type for values in the dictionary.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
            <param name="collectionCreator">A factory used to create the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITranslator.TranslateNullable``1(``0)">
            <summary>
            Translates the boolean that says whether this value is null or not
            </summary>
            <param name="value">The object to test.</param>
            <typeparam name="T">The type of object to test.</typeparam>
            <returns>True if the object should be written, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BinaryTranslator">
            <summary>
            This class is responsible for serializing and deserializing simple types to and
            from the byte streams used to communicate INodePacket-implementing classes.
            Each class implements a Translate method on INodePacket which takes this class
            as a parameter, and uses it to store and retrieve fields to the stream.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.GetReadTranslator(System.IO.Stream,Microsoft.Build.SharedReadBuffer)">
            <summary>
            Returns a read-only serializer.
            </summary>
            <returns>The serializer.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.GetWriteTranslator(System.IO.Stream)">
            <summary>
            Returns a write-only serializer.
            </summary>
            <param name="stream">The stream containing data to serialize.</param>
            <returns>The serializer.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator">
            <summary>
            Implementation of ITranslator for reading from a stream.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator._packetStream">
            <summary>
            The stream used as a source or destination for data.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator._reader">
            <summary>
            The binary reader used in read mode.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.#ctor(System.IO.Stream,Microsoft.Build.SharedReadBuffer)">
            <summary>
            Constructs a serializer from the specified stream, operating in the designated mode.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Reader">
            <summary>
            Gets the reader, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Writer">
            <summary>
            Gets the writer, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Mode">
            <summary>
            Returns the current serialization mode.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Boolean@)">
            <summary>
            Translates a boolean.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Byte@)">
            <summary>
            Translates a byte.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Int16@)">
            <summary>
            Translates a short.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.UInt16@)">
            <summary>
            Translates an unsigned short.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Int32@)">
            <summary>
            Translates an integer.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Int64@)">
            <summary>
            Translates a long.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Double@)">
            <summary>
            Translates a double.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.String@)">
            <summary>
            Translates a string.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Byte[]@)">
            <summary>
            Translates a byte array
            </summary>
            <param name="byteArray">The array to be translated</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.String[]@)">
            <summary>
            Translates a string array.
            </summary>
            <param name="array">The array to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Collections.Generic.HashSet{System.String}@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.Collections.Generic.List{System.String}@)">
            <summary>
            Translates a list of strings
            </summary>
            <param name="list">The list to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate``1(System.Collections.Generic.List{``0}@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates a list of T where T implements INodePacketTranslateable
            </summary>
            <param name="list">The list to be translated.</param>
            <param name="factory">Factory to deserialize T</param>
            <typeparam name="T">TaskItem type</typeparam>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.DateTime@)">
            <summary>
            Translates a DateTime.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(System.TimeSpan@)">
            <summary>
            Translates a TimeSpan.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate(Microsoft.Build.Framework.BuildEventContext@)">
            <summary>
            Translates a BuildEventContext
            </summary>
            <remarks>
            This method exists only because there is no serialization method built into the BuildEventContext
            class, and it lives in Framework and we don't want to add a public method to it.
            </remarks>
            <param name="value">The context to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateCulture(System.Globalization.CultureInfo@)">
            <summary>
            Translates a CultureInfo
            </summary>
            <param name="value">The CultureInfo to translate</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateEnum``1(``0@,System.Int32)">
            <summary>
            Translates an enumeration.
            </summary>
            <typeparam name="T">The enumeration type.</typeparam>
            <param name="value">The enumeration instance to be translated.</param>
            <param name="numericValue">The enumeration value as an integer.</param>
            <remarks>This is a bit ugly, but it doesn't seem like a nice method signature is possible because
            you can't pass the enum type as a reference and constrain the generic parameter to Enum.  Nor
            can you simply pass as ref Enum, because an enum instance doesn't match that function signature.
            Finally, converting the enum to an int assumes that we always want to transport enums as ints.  This
            works in all of our current cases, but certainly isn't perfectly generic.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateDotNet``1(``0@)">
            <summary>
            Translates a value using the .Net binary formatter.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate``1(``0@)">
            <summary>
            Translates an object implementing INodePacketTranslatable.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.Translate``1(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates an object implementing INodePacketTranslatable which does not expose a
            public parameterless constructor.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
            <param name="factory">The factory method used to instantiate values of type T.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateArray``1(``0[]@)">
            <summary>
            Translates an array of objects implementing INodePacketTranslatable.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="array">The array to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateArray``1(``0[]@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="array">The array to be translated.</param>
            <param name="factory">The factory method used to instantiate values of type T.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateDictionary(System.Collections.Generic.Dictionary{System.String,System.String}@,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Translates a dictionary of { string, string }.
            </summary>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="comparer">The comparer used to instantiate the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateDictionary``1(System.Collections.Generic.Dictionary{System.String,``0}@,System.Collections.Generic.IEqualityComparer{System.String},Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates a dictionary of { string, T }.  
            </summary>
            <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="comparer">The comparer used to instantiate the dictionary.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateDictionary``2(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``1})">
            <summary>
            Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
            </summary>
            <typeparam name="D">The reference type for the dictionary.</typeparam>
            <typeparam name="T">The reference type for values in the dictionary.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateDictionary``2(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``1},Microsoft.Build.BackEnd.NodePacketCollectionCreator{``0})">
            <summary>
            Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
            </summary>
            <typeparam name="D">The reference type for the dictionary.</typeparam>
            <typeparam name="T">The reference type for values in the dictionary.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
            <param name="dictionaryCreator">The delegate used to instantiate the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryReadTranslator.TranslateNullable``1(``0)">
            <summary>
            Reads in the boolean which says if this object is null or not.
            </summary>
            <typeparam name="T">The type of object to test.</typeparam>
            <returns>True if the object should be read, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator">
            <summary>
            Implementation of ITranslator for writing to a stream.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator._packetStream">
            <summary>
            The stream used as a source or destination for data.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator._writer">
            <summary>
            The binary writer used in write mode.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.#ctor(System.IO.Stream)">
            <summary>
            Constructs a serializer from the specified stream, operating in the designated mode.
            </summary>
            <param name="packetStream">The stream serving as the source or destination of data.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Reader">
            <summary>
            Gets the reader, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Writer">
            <summary>
            Gets the writer, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Mode">
            <summary>
            Returns the current serialization mode.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Boolean@)">
            <summary>
            Translates a boolean.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Byte@)">
            <summary>
            Translates a byte.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Int16@)">
            <summary>
            Translates a short.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.UInt16@)">
            <summary>
            Translates an unsigned short.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Int32@)">
            <summary>
            Translates an integer.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Int64@)">
            <summary>
            Translates a long.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Double@)">
            <summary>
            Translates a double.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.String@)">
            <summary>
            Translates a string.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.String[]@)">
            <summary>
            Translates a string array.
            </summary>
            <param name="array">The array to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Collections.Generic.List{System.String}@)">
            <summary>
            Translates a list of strings
            </summary>
            <param name="list">The list to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Collections.Generic.HashSet{System.String}@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate``1(System.Collections.Generic.List{``0}@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates a list of T where T implements INodePacketTranslateable
            </summary>
            <param name="list">The list to be translated.</param>
            <param name="factory">factory to create type T</param>
            <typeparam name="T">A TaskItemType</typeparam>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate``2(System.Collections.Generic.IList{``0}@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0},Microsoft.Build.BackEnd.NodePacketCollectionCreator{``1})">
            <summary>
            Translates a list of T where T implements INodePacketTranslateable
            </summary>
            <param name="list">The list to be translated.</param>
            <param name="factory">factory to create type T</param>
            <param name="collectionFactory">factory to create the IList</param>
            <typeparam name="T">A TaskItemType</typeparam>
            <typeparam name="L">IList subtype</typeparam>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.DateTime@)">
            <summary>
            Translates a DateTime.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.TimeSpan@)">
            <summary>
            Translates a TimeSpan.
            </summary>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(Microsoft.Build.Framework.BuildEventContext@)">
            <summary>
            Translates a BuildEventContext
            </summary>
            <remarks>
            This method exists only because there is no serialization method built into the BuildEventContext
            class, and it lives in Framework and we don't want to add a public method to it.
            </remarks>
            <param name="value">The context to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateCulture(System.Globalization.CultureInfo@)">
            <summary>
            Translates a CultureInfo
            </summary>
            <param name="value">The CultureInfo</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateEnum``1(``0@,System.Int32)">
            <summary>
            Translates an enumeration.
            </summary>
            <typeparam name="T">The enumeration type.</typeparam>
            <param name="value">The enumeration instance to be translated.</param>
            <param name="numericValue">The enumeration value as an integer.</param>
            <remarks>This is a bit ugly, but it doesn't seem like a nice method signature is possible because
            you can't pass the enum type as a reference and constrain the generic parameter to Enum.  Nor
            can you simply pass as ref Enum, because an enum instance doesn't match that function signature.
            Finally, converting the enum to an int assumes that we always want to transport enums as ints.  This
            works in all of our current cases, but certainly isn't perfectly generic.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateDotNet``1(``0@)">
            <summary>
            Translates a value using the .Net binary formatter.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate``1(``0@)">
            <summary>
            Translates an object implementing INodePacketTranslatable.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate``1(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates an object implementing INodePacketTranslatable which does not expose a
            public parameterless constructor.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="value">The value to be translated.</param>
            <param name="factory">The factory method used to instantiate values of type T.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.Translate(System.Byte[]@)">
            <summary>
            Translates a byte array
            </summary>
            <param name="byteArray">The byte array to be translated</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateArray``1(``0[]@)">
            <summary>
            Translates an array of objects implementing INodePacketTranslatable.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="array">The array to be translated.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateArray``1(``0[]@,Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
            </summary>
            <typeparam name="T">The reference type.</typeparam>
            <param name="array">The array to be translated.</param>
            <param name="factory">The factory method used to instantiate values of type T.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateDictionary(System.Collections.Generic.Dictionary{System.String,System.String}@,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Translates a dictionary of { string, string }.
            </summary>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="comparer">The comparer used to instantiate the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateDictionary``1(System.Collections.Generic.Dictionary{System.String,``0}@,System.Collections.Generic.IEqualityComparer{System.String},Microsoft.Build.BackEnd.NodePacketValueFactory{``0})">
            <summary>
            Translates a dictionary of { string, T }.  
            </summary>
            <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="comparer">The comparer used to instantiate the dictionary.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateDictionary``2(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``1})">
            <summary>
            Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
            </summary>
            <typeparam name="D">The reference type for the dictionary.</typeparam>
            <typeparam name="T">The reference type for values in the dictionary.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateDictionary``2(``0@,Microsoft.Build.BackEnd.NodePacketValueFactory{``1},Microsoft.Build.BackEnd.NodePacketCollectionCreator{``0})">
            <summary>
            Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
            </summary>
            <typeparam name="D">The reference type for the dictionary.</typeparam>
            <typeparam name="T">The reference type for values in the dictionary.</typeparam>
            <param name="dictionary">The dictionary to be translated.</param>
            <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
            <param name="dictionaryCreator">The delegate used to instantiate the dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BinaryTranslator.BinaryWriteTranslator.TranslateNullable``1(``0)">
            <summary>
            Writes out the boolean which says if this object is null or not.
            </summary>
            <param name="value">The object to test.</param>
            <typeparam name="T">The type of object to test.</typeparam>
            <returns>True if the object should be written, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodePacketFactory">
            <summary>
            Implementation of INodePacketFactory as a helper class for classes which expose this interface publicly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketFactory._packetFactories">
            <summary>
            Mapping of packet types to factory information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers a packet handler
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Creates and routes a packet with data from a binary stream.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the specified packet.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord">
            <summary>
            A record for a packet factory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord._handler">
            <summary>
            The handler to invoke when the packet is deserialized.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord._factoryMethod">
            <summary>
            The method used to construct a packet from a translator stream.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord.#ctor(Microsoft.Build.BackEnd.INodePacketHandler,Microsoft.Build.BackEnd.NodePacketFactoryMethod)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Creates a packet from a binary stream and sends it to the registered handler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the packet to the correct destination.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeBuildComplete">
            <summary>
            The NodeBuildComplete packet is used to indicate to a node that it should clean up its current build and 
            possibly prepare for node reuse.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeBuildComplete._prepareForReuse">
            <summary>
            Flag indicating if the node should prepare for reuse after cleanup.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeBuildComplete.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeBuildComplete.#ctor">
            <summary>
            Private constructor for translation
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeBuildComplete.PrepareForReuse">
            <summary>
            Flag indicating if the node should prepare for reuse.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeBuildComplete.Type">
            <summary>
            The packet type
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeBuildComplete.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates the packet to/from binary form.
            </summary>
            <param name="translator">The translator to use.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeBuildComplete.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeShutdownReason">
            <summary>
            Reasons why the node shut down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeShutdownReason.Requested">
            <summary>
            The node shut down because it was requested to shut down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeShutdownReason.Error">
            <summary>
            The node shut down because of an error.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeShutdownReason.ConnectionFailed">
            <summary>
            The node shut down because the connection failed.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeShutdown">
            <summary>
            Implementation of INodePacket for the packet informing the build manager than a node has shut down.
            This is the last packet the BuildManager will receive from a Node, and as such can be used to trigger
            any appropriate cleanup behavior.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeShutdown._reason">
            <summary>
            The reason the node shut down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeShutdown._exception">
            <summary>
            The exception - if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeShutdown.#ctor(Microsoft.Build.BackEnd.NodeShutdownReason)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeShutdown.#ctor(Microsoft.Build.BackEnd.NodeShutdownReason,System.Exception)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeShutdown.#ctor">
            <summary>
            Constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeShutdown.Type">
            <summary>
            Returns the packet type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeShutdown.Reason">
            <summary>
            The reason for shutting down.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeShutdown.Exception">
            <summary>
            The exception, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeShutdown.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Serializes or deserializes a packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeShutdown.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory method for deserialization
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskLoggingHelper">
            <summary>
            Helper logging class - contains all the logging methods used by tasks.
            A TaskLoggingHelper object is passed to every task by MSBuild. For tasks that derive
            from the Task class, it is provided in the Log property.
            This class is thread safe: tasks can log from any threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.#ctor(Microsoft.Build.Framework.ITask)">
            <summary>
            public constructor
            </summary>
            <param name="taskInstance">task containing an instance of this class</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.#ctor(Microsoft.Build.Framework.IBuildEngine,System.String)">
            <summary>
            Public constructor which can be used by task factories to assist them in logging messages.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskLoggingHelper._sponsor">
            <summary>
            A client sponsor is a class
            which will respond to a lease renewal request and will
            increase the lease time allowing the object to stay in memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskLoggingHelper._locker">
            <summary>
            Object to make this class thread-safe.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskLoggingHelper.TaskName">
            <summary>
            Gets the name of the parent task.
            </summary>
            <value>Task name string.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskLoggingHelper.TaskNameUpperCase">
            <summary>
            Gets the upper-case version of the parent task's name.
            </summary>
            <value>Upper-case task name string.</value>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskLoggingHelper._buildEngine">
            <summary>
            The build engine we are going to log against
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskLoggingHelper.BuildEngine">
            <summary>
            Shortcut property for getting our build engine - we retrieve it from the task instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskLoggingHelper.TaskResources">
            <summary>
            Used to load culture-specific resources. Derived classes should register their resources either during construction, or
            via this property, if they have localized strings.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskLoggingHelper.HelpKeywordPrefix">
            <summary>
            Gets or sets the prefix used to compose help keywords from string resource names.
            </summary>
            <value>The help keyword prefix string.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskLoggingHelper.HasLoggedErrors">
            <summary>
            Has the task logged any errors through this logging helper object?
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.ExtractMessageCode(System.String,System.String@)">
            <summary>
            Extracts the message code (if any) prefixed to the given message string. Message code prefixes must match the
            following .NET regular expression in order to be recognized: <c>^\s*[A-Za-z]+\d+:\s*</c>
            Thread safe.
            </summary>
            <example>
            If this method is given the string "MYTASK1001: This is an error message.", it will return "MYTASK1001" for the
            message code, and "This is an error message." for the message.
            </example>
            <param name="message">The message to parse.</param>
            <param name="messageWithoutCodePrefix">The message with the code prefix removed (if any).</param>
            <returns>The message code extracted from the prefix, or null if there was no code.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.FormatResourceString(System.String,System.Object[])">
            <summary>
            Loads the specified resource string and optionally formats it using the given arguments. The current thread's culture
            is used for formatting.
            
            Requires the owner task to have registered its resources either via the Task (or TaskMarshalByRef) base
            class constructor, or the Task.TaskResources (or AppDomainIsolatedTask.TaskResources) property.
            
            Thread safe.
            </summary>
            <param name="resourceName">The name of the string resource to load.</param>
            <param name="args">Optional arguments for formatting the loaded string.</param>
            <returns>The formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>resourceName</c> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the string resource indicated by <c>resourceName</c> does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.FormatString(System.String,System.Object[])">
            <summary>
            Formats the given string using the variable arguments passed in. The current thread's culture is used for formatting.
            Thread safe.
            </summary>
            <param name="unformatted">The string to format.</param>
            <param name="args">Arguments for formatting.</param>
            <returns>The formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>unformatted</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.GetResourceMessage(System.String)">
            <summary>
            Get the message from resource in task library.
            Thread safe.
            </summary>
            <param name="resourceName">The resource name.</param>
            <returns>The message from resource.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessage(System.String,System.Object[])">
            <summary>
            Logs a message using the specified string.
            Thread safe.
            </summary>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Logs a message of the given importance using the specified string.
            Thread safe.
            </summary>
            <remarks>
            Take care to order the parameters correctly or the other overload will be called inadvertently.
            </remarks>
            <param name="importance">The importance level of the message.</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessage(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Logs a message using the specified string and other message details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the warning type (can be null).</param>
            <param name="code">Message code (can be null)</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the message (can be null).</param>
            <param name="lineNumber">The line in the file causing the message (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the message (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the message (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the message (set to zero if not available).</param>
            <param name="importance">Importance of the message.</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogCriticalMessage(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a critical message using the specified string and other message details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the warning type (can be null).</param>
            <param name="code">Message code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the message (can be null).</param>
            <param name="lineNumber">The line in the file causing the message (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the message (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the message (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the message (set to zero if not available).</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessageFromResources(System.String,System.Object[])">
            <summary>
            Logs a message using the specified resource string.
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Logs a message of the given importance using the specified resource string.
            Thread safe.
            </summary>
            <remarks>
            Take care to order the parameters correctly or the other overload will be called inadvertently.
            </remarks>
            <param name="importance">The importance level of the message.</param>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogExternalProjectStarted(System.String,System.String,System.String,System.String)">
            <summary>
            Small helper for logging the custom ExternalProjectStarted build event
            Thread safe.
            </summary>
            <param name="message">text message</param>
            <param name="helpKeyword">help keyword</param>
            <param name="projectFile">project name</param>
            <param name="targetNames">targets we are going to build (empty indicates default targets)</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogExternalProjectFinished(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Small helper for logging the custom ExternalProjectFinished build event.
            Thread safe.
            </summary>
            <param name="message">text message</param>
            <param name="helpKeyword">help keyword</param>
            <param name="projectFile">project name</param>
            <param name="succeeded">true indicates project built successfully</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogCommandLine(System.String)">
            <summary>
            Logs the command line for a task's underlying tool/executable/shell command.
            Thread safe.
            </summary>
            <param name="commandLine">The command line string.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance,System.String)">
            <summary>
            Logs the command line for a task's underlying tool/executable/shell
            command, using the given importance level.
            Thread safe.
            </summary>
            <param name="importance">The importance level of the command line.</param>
            <param name="commandLine">The command line string.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogError(System.String,System.Object[])">
            <summary>
            Logs an error using the specified string.
            Thread safe.
            </summary>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogError(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs an error using the specified string and other error details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the error type (can be null).</param>
            <param name="errorCode">The error code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file containing the error (can be null).</param>
            <param name="lineNumber">The line in the file where the error occurs (set to zero if not available).</param>
            <param name="columnNumber">The column in the file where the error occurs (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogErrorFromResources(System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string.
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogErrorFromResources(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string and other error details.
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the error type (can be null).</param>
            <param name="errorCode">The error code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file containing the error (can be null).</param>
            <param name="lineNumber">The line in the file where the error occurs (set to zero if not available).</param>
            <param name="columnNumber">The column in the file where the error occurs (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the error message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogErrorWithCodeFromResources(System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string. 
            If the message has an error code prefixed to it, the code is extracted and logged with the message. If a help keyword
            prefix has been provided, a help keyword for the host IDE is also logged with the message. The help keyword is
            composed by appending the string resource name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
               
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogErrorWithCodeFromResources(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs an error using the specified resource string and other error details. 
            If the message has an error code prefixed, the code is extracted and logged with the message. If a
            help keyword prefix has been provided, a help keyword for the host IDE is also logged with the message. The help
            keyword is composed by appending the error message resource string name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
               
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the error type (can be null).</param>
            <param name="file">The path to the file containing the error (can be null).</param>
            <param name="lineNumber">The line in the file where the error occurs (set to zero if not available).</param>
            <param name="columnNumber">The column in the file where the error occurs (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the error message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogErrorFromException(System.Exception)">
            <summary>
            Logs an error using the message from the given exception context.
            No callstack will be shown.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>e</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogErrorFromException(System.Exception,System.Boolean)">
            <summary>
            Logs an error using the message (and optionally the stack-trace) from the given exception context.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <param name="showStackTrace">If true, callstack will be appended to message.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogErrorFromException(System.Exception,System.Boolean,System.Boolean,System.String)">
            <summary>
            Logs an error using the message, and optionally the stack-trace from the given exception, and
            optionally inner exceptions too.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <param name="showStackTrace">If true, callstack will be appended to message.</param>
            <param name="showDetail">Whether to log exception types and any inner exceptions.</param>
            <param name="file">File related to the exception, or null if the project file should be logged</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarning(System.String,System.Object[])">
            <summary>
            Logs a warning using the specified string.
            Thread safe.
            </summary>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarning(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a warning using the specified string and other warning details.
            Thread safe.
            </summary>
            <param name="subcategory">Description of the warning type (can be null).</param>
            <param name="warningCode">The warning code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the warning (can be null).</param>
            <param name="lineNumber">The line in the file causing the warning (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the warning (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the warning (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the warning (set to zero if not available).</param>
            <param name="message">The message string.</param>
            <param name="messageArgs">Optional arguments for formatting the message string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>message</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarningFromResources(System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string.
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarningFromResources(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string and other warning details.
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the warning type (can be null).</param>
            <param name="warningCode">The warning code (can be null).</param>
            <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
            <param name="file">The path to the file causing the warning (can be null).</param>
            <param name="lineNumber">The line in the file causing the warning (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the warning (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the warning (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the warning (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the warning message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarningWithCodeFromResources(System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string. 
            If the message has a warning code prefixed to it, the code is extracted and logged with the message. If a help keyword
            prefix has been provided, a help keyword for the host IDE is also logged with the message. The help keyword is
            composed by appending the string resource name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
            
            Thread safe.
            </summary>
            <param name="messageResourceName">The name of the string resource to load.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarningWithCodeFromResources(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string and other warning details. 
            If the message has a warning code, the code is extracted and logged with the message.
            If a help keyword prefix has been provided, a help keyword for the host IDE is also logged with the message. The help
            keyword is composed by appending the warning message resource string name to the prefix.
            
            A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
            Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
            
            Thread safe.
            </summary>
            <param name="subcategoryResourceName">The name of the string resource that describes the warning type (can be null).</param>
            <param name="file">The path to the file causing the warning (can be null).</param>
            <param name="lineNumber">The line in the file causing the warning (set to zero if not available).</param>
            <param name="columnNumber">The column in the file causing the warning (set to zero if not available).</param>
            <param name="endLineNumber">The last line of a range of lines in the file causing the warning (set to zero if not available).</param>
            <param name="endColumnNumber">The last column of a range of columns in the file causing the warning (set to zero if not available).</param>
            <param name="messageResourceName">The name of the string resource containing the warning message.</param>
            <param name="messageArgs">Optional arguments for formatting the loaded string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>messageResourceName</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarningFromException(System.Exception)">
            <summary>
            Logs a warning using the message from the given exception context.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogWarningFromException(System.Exception,System.Boolean)">
            <summary>
            Logs a warning using the message (and optionally the stack-trace) from the given exception context.
            Thread safe.
            </summary>
            <param name="exception">Exception to log.</param>
            <param name="showStackTrace">If true, the exception callstack is appended to the message.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>exception</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessagesFromFile(System.String)">
            <summary>
            Logs errors/warnings/messages for each line of text in the given file. Errors/warnings are only logged for lines that
            fit a particular (canonical) format -- the remaining lines are treated as messages.
            Thread safe.
            </summary>
            <param name="fileName">The file to log from.</param>
            <returns>true, if any errors were logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>filename</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessagesFromFile(System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Logs errors/warnings/messages for each line of text in the given file. Errors/warnings are only logged for lines that
            fit a particular (canonical) format -- the remaining lines are treated as messages.
            Thread safe.
            </summary>
            <param name="fileName">The file to log from.</param>
            <param name="messageImportance">The importance level for messages that are neither errors nor warnings.</param>
            <returns>true, if any errors were logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>filename</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Logs errors/warnings/messages for each line of text in the given stream. Errors/warnings are only logged for lines
            that fit a particular (canonical) format -- the remaining lines are treated as messages.
            Thread safe.
            </summary>
            <param name="stream">The stream to log from.</param>
            <param name="messageImportance">The importance level for messages that are neither errors nor warnings.</param>
            <returns>true, if any errors were logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>stream</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogMessageFromText(System.String,Microsoft.Build.Framework.MessageImportance)">
            <summary>
            Logs an error/warning/message from the given line of text. Errors/warnings are only logged for lines that fit a
            particular (canonical) format -- all other lines are treated as messages.
            Thread safe.
            </summary>
            <param name="lineOfText">The line of text to log from.</param>
            <param name="messageImportance">The importance level for messages that are neither errors nor warnings.</param>
            <returns>true, if an error was logged</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>lineOfText</c> is null.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.LogTelemetry(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Logs telemetry with the specified event name and properties.
            </summary>
            <param name="eventName">The event name.</param>
            <param name="properties">The list of properties associated with the event.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.InitializeLifetimeService">
            <summary>
            InitializeLifetimeService is called when the remote object is activated. 
            This method will determine how long the lifetime for the object will be.
            Thread safe. However, InitializeLifetimeService and MarkAsInactive should
            only be called in that order, together or not at all, and no more than once.
            </summary>
            <returns>The lease object to control this object's lifetime.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelper.MarkAsInactive">
            <summary>
            Notifies this object that its work is done.
            Thread safe. However, InitializeLifetimeService and MarkAsInactive should
            only be called in that order, together or not at all, and no more than once.
            </summary>
            <remarks>
            Indicates to the TaskLoggingHelper that it is no longer needed.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskLoggingHelperExtension">
            <summary>
            Helper logging class for tasks, used for dealing with two resource streams.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelperExtension.#ctor(Microsoft.Build.Framework.ITask,System.Resources.ResourceManager,System.Resources.ResourceManager,System.String)">
            <summary>
            public constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskLoggingHelperExtension.TaskSharedResources">
            <summary>
            Used to load culture-specific resources. Derived classes should register their resources either during construction, or
            via this property, if they have localized strings.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskLoggingHelperExtension.FormatResourceString(System.String,System.Object[])">
            <summary>
            Loads the specified resource string and optionally formats it using the given arguments. The current thread's culture
            is used for formatting.
            </summary>
            <remarks>
            1) This method requires the owner task to have registered its resources either via the Task (or TaskMarshalByRef) base
               class constructor, or the "Task.TaskResources" (or "AppDomainIsolatedTask.TaskResources") property.
            2) This method is thread-safe.
            </remarks>
            <param name="resourceName">The name of the string resource to load.</param>
            <param name="args">Optional arguments for formatting the loaded string.</param>
            <returns>The formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>resourceName</c> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the string resource indicated by <c>resourceName</c> does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskParameterType">
            <summary>
            Type of parameter, used to figure out how to serialize it. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.Null">
            <summary>
            Parameter is null
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.String">
            <summary>
            Parameter is a string
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.StringArray">
            <summary>
            Parameter is an array of strings
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.ValueType">
            <summary>
            Parameter is a value type.  Note:  Must be serializable
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.ValueTypeArray">
            <summary>
            Parameter is an array of value types.  Note:  Must be serializable. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.ITaskItem">
            <summary>
            Parameter is an ITaskItem 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.ITaskItemArray">
            <summary>
            Parameter is an array of ITaskItems
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameterType.Invalid">
            <summary>
            An invalid parameter -- the value of this parameter contains the exception 
            that is thrown when trying to access it. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskParameter">
            <summary>
            Wrapper for task parameters, to allow proper serialization even 
            in cases where the parameter is not .NET serializable. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameter._parameterType">
            <summary>
            The TaskParameterType of the wrapped parameter
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameter._wrappedParameter">
            <summary>
            The actual task parameter that we're wrapping
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.#ctor(System.Object)">
            <summary>
            Create a new TaskParameter
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.#ctor">
            <summary>
            Constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskParameter.ParameterType">
            <summary>
            The TaskParameterType of the wrapped parameter
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskParameter.WrappedParameter">
            <summary>
            The actual task parameter that we're wrapping
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.ToString">
            <summary>
            TaskParameter's ToString should just pass through to whatever it's wrapping. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Serialize / deserialize this item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.InitializeLifetimeService">
            <summary>
            Overridden to give this class infinite lease time. Otherwise we end up with a limited
            lease (5 minutes I think) and instances can expire if they take long time processing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.CreateNewTaskItemFrom(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Creates a new ITaskItem with the contents of the old one. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TranslateITaskItemArray(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Serialize / deserialize this item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TranslateITaskItem(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Serialize / deserialize this item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.WriteITaskItem(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Write the given ITaskItem, using the given write translator
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.ReadITaskItem(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Framework.ITaskItem@)">
            <summary>
            Read an ITaskItem into the given parameter, using the given read translator
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TranslateNullable``1(Microsoft.Build.BackEnd.ITranslator,``0)">
            <summary>
            Writes out the boolean which says if this object is null or not.
            </summary>
            <typeparam name="T">The nullable type to translate.</typeparam>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem">
            <summary>
            Super simple ITaskItem derivative that we can use as a container for read items.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem._escapedItemSpec">
            <summary>
            The item spec 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem._escapedDefiningProject">
            <summary>
            The full path to the project that originally defined this item.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem._customEscapedMetadata">
            <summary>
            The custom metadata
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem._fullPath">
            <summary>
            Cache for fullpath metadata
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.#ctor(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructor for serialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.ItemSpec">
            <summary>
            Gets or sets the item "specification" e.g. for disk-based items this would be the file path.
            </summary>
            <remarks>
            This should be named "EvaluatedInclude" but that would be a breaking change to this interface.
            </remarks>
            <value>The item-spec string.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.MetadataNames">
            <summary>
            Gets the names of all the metadata on the item.
            Includes the built-in metadata like "FullPath".
            </summary>
            <value>The list of metadata names.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.MetadataCount">
            <summary>
            Gets the number of pieces of metadata on the item. Includes
            both custom and built-in metadata.  Used only for unit testing.
            </summary>
            <value>Count of pieces of metadata.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.Microsoft#Build#Framework#ITaskItem2#EvaluatedIncludeEscaped">
            <summary>
            Returns the escaped version of this item's ItemSpec
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.GetMetadata(System.String)">
            <summary>
            Allows the values of metadata on the item to be queried.
            </summary>
            <param name="metadataName">The name of the metadata to retrieve.</param>
            <returns>The value of the specified metadata.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.SetMetadata(System.String,System.String)">
            <summary>
            Allows a piece of custom metadata to be set on the item.
            </summary>
            <param name="metadataName">The name of the metadata to set.</param>
            <param name="metadataValue">The metadata value.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.RemoveMetadata(System.String)">
            <summary>
            Allows the removal of custom metadata set on the item.
            </summary>
            <param name="metadataName">The name of the metadata to remove.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Allows custom metadata on the item to be copied to another item.
            </summary>
            <remarks>
            RECOMMENDED GUIDELINES FOR METHOD IMPLEMENTATIONS:
            1) this method should NOT copy over the item-spec
            2) if a particular piece of metadata already exists on the destination item, it should NOT be overwritten
            3) if there are pieces of metadata on the item that make no semantic sense on the destination item, they should NOT be copied
            </remarks>
            <param name="destinationItem">The item to copy metadata to.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.CloneCustomMetadata">
            <summary>
            Get the collection of custom metadata. This does not include built-in metadata.
            </summary>
            <remarks>
            RECOMMENDED GUIDELINES FOR METHOD IMPLEMENTATIONS:
            1) this method should return a clone of the metadata
            2) writing to this dictionary should not be reflected in the underlying item.
            </remarks>
            <returns>Dictionary of cloned metadata</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.InitializeLifetimeService">
            <summary>
            Overridden to give this class infinite lease time. Otherwise we end up with a limited
            lease (5 minutes I think) and instances can expire if they take long time processing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.Microsoft#Build#Framework#ITaskItem2#GetMetadataValueEscaped(System.String)">
            <summary>
            Returns the escaped value of the requested metadata name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.Microsoft#Build#Framework#ITaskItem2#SetMetadataValueLiteral(System.String,System.String)">
            <summary>
            Sets the exact metadata value given to the metadata name requested. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameter.TaskParameterTaskItem.Microsoft#Build#Framework#ITaskItem2#CloneCustomMetadataEscaped">
            <summary>
            Returns a dictionary containing all metadata and their escaped forms.  
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskParameterTypeVerifier">
            <summary>
            Provide a class which can verify the correct type for both input and output parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameterTypeVerifier.IsValidScalarInputParameter(System.Type)">
            <summary>
            Is the parameter type a valid scalar input value
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameterTypeVerifier.IsValidVectorInputParameter(System.Type)">
            <summary>
            Is the passed in parameterType a valid vector input parameter
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameterTypeVerifier.IsAssignableToITask(System.Type)">
            <summary>
            Is the passed in value type assignable to an ITask or Itask[] object
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameterTypeVerifier.IsValueTypeOutputParameter(System.Type)">
            <summary>
            Is the passed parameter a valid value type output parameter
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameterTypeVerifier.IsValidInputParameter(System.Type)">
            <summary>
            Is the parameter type a valid scalar or value type input parameter
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskParameterTypeVerifier.IsValidOutputParameter(System.Type)">
            <summary>
            Is the parameter type a valid scalar or value type output parameter
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver">
            <summary>
            This is a helper class to install an AssemblyResolver event handler in whatever AppDomain this class is created in.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver.#ctor">
            <summary>
            This public default constructor is needed so that instances of this class can be created by NDP.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver.Initialize(System.String)">
            <summary>
            Initializes the instance.
            </summary>
            <param name="taskAssemblyFileToResolve"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver.InstallHandler">
            <summary>
            Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain, 
            so it's possible to create an AppDomain, create an instance of this class in it and use this method to install
            an event handler in that AppDomain. Since the event handler instance is stored internally, this method
            should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do 
            anything else).
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver.RemoveHandler">
            <summary>
            Removes the event handler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver.ResolveAssembly(System.Object,System.ResolveEventArgs)">
            <summary>
            This is an assembly resolution handler necessary for fixing up types instantiated in different
            AppDomains and loaded with a Assembly.LoadFrom equivalent call. See comments in TaskEngine.ExecuteTask
            for more details.
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver.InitializeLifetimeService">
            <summary>
            Overridden to give this class infinite lease time. Otherwise we end up with a limited
            lease (5 minutes I think) and instances can expire if they take long time processing.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.BuildLoggingContext">
            <summary>
            Intended to be used in the nodes, during a build, where a base LoggingContext is created when the node
            initializes for a build (this is the public constructor.)  When a new project, target batch
            or task batch is started, the appropriate method on the current LoggingContext is invoked
            and a new LoggingContext is returned.  This new LoggingContext should be used for all
            subsequent logging within the subcontext.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BuildLoggingContext._isInProcNode">
            <summary>
            True if this context comes from the in-proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.Boolean)">
            <summary>
            Constructs the logging context from a logging service and an event context.
            </summary>
            <param name="loggingService">The logging service to use</param>
            <param name="buildEventContext">The event context</param>
            <param name="inProc">Flag indicating if this context belongs to an in-proc node.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.BuildLoggingContext)">
            <inheritdoc cref="T:Microsoft.Build.BackEnd.Logging.LoggingContext"/>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildLoggingContext.IsInProcNode">
            <summary>
            Flag indicating if the context is being used for the in-proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildLoggingContext.LogFatalTaskError(System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log an error based on an exception during the execution of a task
            </summary>
            <param name="exception">The exception wich is to be logged</param>
            <param name="file">The file in which the error occurred</param>
            <param name="taskName">The task in which the error occurred</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.LoggingContext">
            <summary>
            This object encapsulates the logging service plus the current BuildEventContext and
            hides the requirement to pass BuildEventContexts to the logging service or query the
            host for the logging service all of the time.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingContext._loggingService">
            <summary>
            The logging service to which this context is attached
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingContext._eventContext">
            <summary>
            The build event context understood by the logging service.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingContext._isValid">
            <summary>
            True if this context is still valid (i.e. hasn't been "finished")
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Constructs the logging context from a logging service and an event context.
            </summary>
            <param name="loggingService">The logging service to use</param>
            <param name="eventContext">The event context</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.LoggingContext)">
            <summary>
            Constructs a logging context from another logging context.  This is used primarily in
            the constructors for other logging contexts to populate the logging service parameter,
            while the event context will come from a call into the logging service itself.
            </summary>
            <param name="baseContext">The context from which this context is being created.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingContext.LoggingService">
            <summary>
            Retrieves the logging service
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingContext.BuildEventContext">
            <summary>
            Retrieves the build event context
            UNDONE: (Refactor) We eventually want to remove this because all logging should go
            through a context object.  This exists only so we can make certain 
            logging calls in code which has not yet been fully refactored.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingContext.IsValid">
            <summary>
            Returns true if the context is still valid, false if the
            appropriate 'Finished' call has been invoked.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogComment(Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
             Helper method to create a message build event from a string resource and some parameters
            </summary>
            <param name="importance">Importance level of the message</param>
            <param name="messageResourceName">string within the resource which indicates the format string to use</param>
            <param name="messageArgs">string resource arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogCommentFromText(Microsoft.Build.Framework.MessageImportance,System.String)">
            <summary>
            Helper method to create a message build event from a string
            </summary>
            <param name="importance">Importance level of the message</param>
            <param name="message">message to log</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogError(Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log an error
            </summary>
            <param name="file">The file in which the error occurred</param>
            <param name="messageResourceName">The resource name for the error</param>
            <param name="messageArgs">Parameters for the resource string</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogErrorWithSubcategory(System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log an error
            </summary>
            <param name="subcategoryResourceName">The resource name which indicates the subCategory</param>
            <param name="file">The file in which the error occurred</param>
            <param name="messageResourceName">The resource name for the error</param>
            <param name="messageArgs">Parameters for the resource string</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogErrorFromText(System.String,System.String,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log an error
            </summary>
            <param name="subcategoryResourceName">The resource name which indicates the subCategory</param>
            <param name="errorCode"> Error code</param>
            <param name="helpKeyword">Help keyword</param>
            <param name="file">The file in which the error occurred</param>
            <param name="message">Error message</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogInvalidProjectFileError(Microsoft.Build.Exceptions.InvalidProjectFileException)">
            <summary>
            Log an invalid project file exception
            </summary>
            <param name="invalidProjectFileException">The invalid Project File Exception which is to be logged</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogFatalError(System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log an error based on an exception
            </summary>
            <param name="exception">The exception wich is to be logged</param>
            <param name="file">The file in which the error occurred</param>
            <param name="messageResourceName">The string resource which has the formatting string for the error</param>
            <param name="messageArgs">The arguments for the error message</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogWarning(System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log a warning
            </summary>
            <param name="subcategoryResourceName">The subcategory resource name</param>
            <param name="file">The file in which the warning occurred</param>
            <param name="messageResourceName">The string resource which contains the formatted warning string</param>
            <param name="messageArgs">parameters for the string resource</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogWarningFromText(System.String,System.String,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log a warning based on a text message
            </summary>
            <param name="subcategoryResourceName">The subcategory resource name</param>
            <param name="warningCode"> Warning code</param>
            <param name="helpKeyword"> Help keyword</param>
            <param name="file">The file in which the warning occurred</param>
            <param name="message">The message to be logged as a warning</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogBuildEvent(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Will Log a build Event. Will also take into account OnlyLogCriticalEvents when determining if to drop the event or to log it.
            </summary>
            <param name="buildEvent">The event to log</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingContext.LogFatalBuildError(System.Exception,Microsoft.Build.Shared.BuildEventFileInfo)">
            <summary>
            Log an error based on an exception
            </summary>
            <param name="exception">The exception to be logged</param>
            <param name="file">The file in which the error occurred</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.SendDataDelegate">
            <summary>
            Delegate to a method which will transport the packet accross the wire.
            </summary>
            <param name="packetToSend">A node packet to send accross the wire</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink">
            <summary>
            This class will consume the BuildEventArgs forwarded by the EventRedirectorToSink class.
            The sink will then create a packet and then pass this along to the transport layer to be
            sent back to the build manager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink._sendDataDelegate">
            <summary>
            Delegate to a method which accepts a INodePacket and send the packet to where it needs to go
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.#ctor(Microsoft.Build.BackEnd.Logging.SendDataDelegate)">
            <summary>
            Create the sink which will consume a buildEventArg
            Create a INodePacket and send it to the transport component
            </summary>
            <param name="sendData">A delegate which takes an INodePacket and sends the packet to where it needs to go</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Send data delegate is null</exception>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.Name">
            <summary>
            Provide a friendly name for the sink to make it easier to differentiate during 
            debugging and display
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.HaveLoggedBuildStartedEvent">
            <summary>
            Has the sink logged the BuildStartedEvent. This is important to know because we only want to log the build started event once
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.HaveLoggedBuildFinishedEvent">
            <summary>
            Has the sink logged the BuildFinishedEvent. This is important to know because we only want to log the build finished event once
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.WarningsAsErrors">
            <summary>
            This property is ignored by this event sink and relies on the receiver to treat warnings as errors.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.WarningsAsErrorsByProject">
            <summary>
            This property is ignored by this event sink and relies on the receiver to treat warnings as errors.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.WarningsAsMessages">
            <summary>
            This property is ignored by this event sink and relies on the receiver to treat warnings as low importance messages.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.WarningsAsMessagesByProject">
            <summary>
            This property is ignored by this event sink and relies on the receiver to treat warnings as low importance messages.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.BuildSubmissionIdsThatHaveLoggedErrors">
            <summary>
            This property is ignored by this event sink and relies on the receiver to keep track of whether or not any errors have been logged.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.Consume(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            This method should not be used since we need the sinkID
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.Consume(Microsoft.Build.Framework.BuildEventArgs,System.Int32)">
            <summary>
            Consumes the buildEventArg and creates a logMessagePacket
            </summary>
            <param name="buildEvent">Build event to package into a INodePacket</param>
            <param name="sinkId">The sink identifier.</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">buildEvent is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink.ShutDown">
            <summary>
            Dispose of any resources the sink is holding onto.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger">
            <summary>
            Logger that forwards events to loggers registered with the LoggingServices
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.BuildEventRedirector">
            <summary>
            An IEventRedirector which will redirect any events forwarded from the logger. The eventRedirector determines where the events will 
            be redirected.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.NodeId">
            <summary>
            The nodeId of the node on which the logger is currently running.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.Verbosity">
            <summary>
            Verbosity of the logger, in the central forwarding logger this is currently ignored
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.Parameters">
            <summary>
            Logging Parameters
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            Initialize the logger with an eventSource and a node count. 
            The logger will register and listen to anyEvents on the eventSource.
            The node count is for informational purposes. The logger may want to take different
            actions depending on how many nodes there are in the system.
            </summary>
            <param name="eventSource">Event source which the logger will register with to receive events</param>
            <param name="nodeCount">Number of nodes the system was started with</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Initialize the logger. The logger will register with AnyEventRaised on the eventSource
            </summary>
            <param name="eventSource">eventSource which the logger will register on to listen for events</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">EventSource is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.Shutdown">
            <summary>
            Shuts down the logger. This will null out the buildEventRedirector
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.EventSource_AnyEventRaised(System.Object,Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Forwards any event raised to the BuildEventRedirector, this redirector will send the event on a path which will 
            take it to a logger.
            </summary>
            <param name="sender">Who sent the message, this is not used</param>
            <param name="buildEvent">BuildEvent to forward</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.EventRedirectorToSink">
            <summary>
            Will redirect events from forwarding loggers to the a IBuildEventSink, many redirectors may redirect to one sink.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.EventRedirectorToSink._centralLoggerId">
            <summary>
            The Id of the central logger to which this event should be forwarded
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.EventRedirectorToSink._sink">
            <summary>
            The sink which will consume the messages
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventRedirectorToSink.#ctor(System.Int32,Microsoft.Build.BackEnd.Logging.IBuildEventSink)">
            <summary>
            Initalize this class with a central logger id identifying the central logger to which
            these events should consumed by. The redirector will send the messages to the registered sink to 
            be consumed
            </summary>
            <param name="loggerId">Id which will be attached to the build event arguments to indicate which logger the events came from</param>
            <param name="eventSink">sink which will initially consume the events</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Eventsink is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">LoggerId is less than 0</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventRedirectorToSink.Microsoft#Build#Framework#IEventRedirector#ForwardEvent(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            This method is called by the node loggers to forward the events to cenral logger
            </summary>
            <param name="buildEvent">Build event to forward</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEvent is null</exception>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.EventSourceSink">
            <summary>
            This class raises events on behalf of the build engine to all registered loggers.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.MessageRaised">
            <summary>
            This event is raised to log a message.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.ErrorRaised">
            <summary>
            This event is raised to log an error.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.WarningRaised">
            <summary>
            This event is raised to log a warning.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.BuildStarted">
            <summary>
            this event is raised to log the start of a build
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.BuildFinished">
            <summary>
            this event is raised to log the end of a build
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.ProjectStarted">
            <summary>
            this event is raised to log the start of a project build
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.ProjectFinished">
            <summary>
            this event is raised to log the end of a project build
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.TargetStarted">
            <summary>
            this event is raised to log the start of a target build
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.TargetFinished">
            <summary>
            this event is raised to log the end of a target build
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.TaskStarted">
            <summary>
            this event is raised to log the start of task execution
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.TaskFinished">
            <summary>
            this event is raised to log the end of task execution
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.CustomEventRaised">
            <summary>
            this event is raised to log a custom event
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.StatusEventRaised">
            <summary>
            this event is raised to log build status events, such as 
            build/project/target/task started/stopped 
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.AnyEventRaised">
            <summary>
            This event is raised to log that some event has
            occurred.  It is raised on every event.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.EventSourceSink.TelemetryLogged">
            <summary>
            This event is raised to log telemetry.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.EventSourceSink.Name">
            <summary>
            Provide a friendly name for the sink to make it easier to differentiate during 
            debugging and display
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.EventSourceSink.HaveLoggedBuildStartedEvent">
            <summary>
            Has the sink logged the BuildStartedEvent. This is important to know because we only want to log the build started event once
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.EventSourceSink.HaveLoggedBuildFinishedEvent">
            <summary>
            Has the sink logged the BuildFinishedEvent. This is important to know because we only want to log the build finished event once
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.EventSourceSink.IncludeEvaluationMetaprojects">
            <summary>
            Should evaluation events include generated metaprojects?
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.EventSourceSink.IncludeEvaluationProfiles">
            <summary>
            Should evaluation events include profiling information?
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.EventSourceSink.IncludeTaskInputs">
            <summary>
            Should task events include task inputs?
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.Consume(Microsoft.Build.Framework.BuildEventArgs,System.Int32)">
            <summary>
            Raises the given event to all registered loggers. This method up-cast the events
            extracted from the queue.
            </summary>
            <param name="buildEvent">BuildEventArgs</param>
            <param name="sinkId">Note this is not used in the eventsource sink</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.Consume(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Raises the given event to all registered loggers. This method up-cast the events
            extracted from the queue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.ShutDown">
            <summary>
            Shutdown and displose of any resource this object is holding onto.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.UnregisterAllEventHandlers">
            <summary>
            Clears out all events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseMessageEvent(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Raises a message event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildMessageEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception> 
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseErrorEvent(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Raises an error event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildErrorEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseWarningEvent(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Raises a warning event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildWarningEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseBuildStartedEvent(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Raises a "build started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildStartedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseBuildFinishedEvent(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Raises a "build finished" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildFinishedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseProjectStartedEvent(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Raises a "project build started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">ProjectStartedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseProjectFinishedEvent(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Raises a "project build finished" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">ProjectFinishedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseTargetStartedEvent(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs)">
            <summary>
            Raises a "target build started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TargetStartedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseTargetFinishedEvent(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Raises a "target build finished" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TargetFinishedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseTaskStartedEvent(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs)">
            <summary>
            Raises a "task execution started" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TaskStartedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseTaskFinishedEvent(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs)">
            <summary>
            Raises a "task finished executing" event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">TaskFinishedEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseCustomEvent(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Raises a custom event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">CustomBuildEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseStatusEvent(System.Object,Microsoft.Build.Framework.BuildStatusEventArgs)">
            <summary>
            Raises a catch-all build status event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">BuildStatusEventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseAnyEvent(System.Object,Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Raises a catch-all build event to all registered loggers.
            </summary>
            <param name="sender">sender of the event</param>
            <param name="buildEvent">Build EventArgs</param>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
            <exception cref="T:System.Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseTelemetryEvent(System.Object,Microsoft.Build.Framework.TelemetryEventArgs)">
            <summary>
            Raises the a telemetry event to all registered loggers.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.LoggingExceptionDelegate">
            <summary>
            Delegate for an event which will take an exception and raise it on the registered event handlers.
            </summary>
            <param name="e">Exception to be raised with registered event handlers</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ILoggingService">
            <summary>
            Interface representing logging services in the build system.
            Implementations should be thread-safe.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.ILoggingService.OnLoggingThreadException">
            <summary>
            When there is an exception on the logging thread, we do not want to throw the exception from there
            instead we would like the exception to be thrown on the engine thread as this is where hosts expect
            to see the exception. This event will transport the exception from the loggingService to the engine
            which will register on this event.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.ILoggingService.OnProjectStarted">
            <summary>
            Raised when a ProjectStarted event is about to be sent to the loggers.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.ILoggingService.OnProjectFinished">
            <summary>
            Raised when a ProjectFinished event has just been sent to the loggers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.ServiceState">
            <summary>
            Provide the current state of the loggingService.
            Is it Inistantiated
            Has it been Initialized
            Is it starting to shutdown
            Has it shutdown
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.LoggingMode">
            <summary>
            Returns the synchronous/asynchronous mode for the logging service.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.OnlyLogCriticalEvents">
            <summary>
            When true, only log critical events such as warnings and errors. Has to be in here for API compat
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.MaxCPUCount">
            <summary>
            Number of nodes in the system when it was initially started
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.Loggers">
            <summary>
            Enumerator over all registered loggers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.LoggerDescriptions">
            <summary>
            The list of descriptions which describe how to create forwarding loggers on a node.
            This is used by the node provider to get a list of registered descriptions so that 
            they can be transmitted to child nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.RegisteredLoggerTypeNames">
            <summary>
            Return an array which contains the logger type names
            this can be used to display which loggers are registered on the node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.RegisteredSinkNames">
            <summary>
            Return an array which contains the sink names
            this can be used to display which sinks are on the node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.PropertiesToSerialize">
            <summary>
            List of properties to serialize from the child node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.SerializeAllProperties">
            <summary>
            Should all properties be serialized from the child to the parent process
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.RunningOnRemoteNode">
            <summary>
            Is the logging running on a remote node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.WarningsAsErrors">
            <summary>
            Set of warnings to treat as errors.  An empty non-null set will treat all warnings as errors.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.WarningsAsMessages">
            <summary>
            A list of warnings to treat as low importance messages.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.IncludeEvaluationMetaprojects">
            <summary>
            Should evaluation events include generated metaprojects?
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.IncludeEvaluationProfile">
            <summary>
            Should evaluation events include profiling information?
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ILoggingService.IncludeTaskInputs">
            <summary>
            Should task events include task inputs?
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.AddWarningsAsMessages(Microsoft.Build.Framework.BuildEventContext,System.Collections.Generic.ISet{System.String})">
            <summary>
            Adds a set of warning codes to treat as low importance messages for the specified project instance ID.
            </summary>
            <param name="projectInstanceId">A <see cref="P:Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
            <param name="codes">The list of warning codes to treat as low importance messsages.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.AddWarningsAsErrors(Microsoft.Build.Framework.BuildEventContext,System.Collections.Generic.ISet{System.String})">
            <summary>
            Adds a set of warning codes to treat as errors for the specified project instance ID.
            </summary>
            <param name="projectInstanceId">A <see cref="P:Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
            <param name="codes">The list of warning codes to treat as errors.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.HasBuildSubmissionLoggedErrors(System.Int32)">
            <summary>
            Determines if the specified submission has logged an errors.
            </summary>
            <param name="submissionId">The ID of the build submission.  A value of "0" means that an error was logged outside of any build submission.</param>
            <returns><code>true</code> if the build submission logged an errors, otherwise <code>false</code>.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.RegisterDistributedLogger(Microsoft.Build.Framework.ILogger,Microsoft.Build.Logging.LoggerDescription)">
            <summary>
            Allows the registering of an ICentralLogger and a forwarding logger pair
            </summary>
            <param name="centralLogger">Central logger which is to receive the events created by the forwarding logger</param>
            <param name="forwardingLogger">A description of the forwarding logger</param>
            <returns value="bool">True if the central and forwarding loggers were registered. False if the central logger or the forwarding logger were already registered</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.RegisterLogger(Microsoft.Build.Framework.ILogger)">
             <summary>
             Register an logger which expects all logging events from the system
             </summary>
             <param name="logger">The logger to register.</param>
            <returns value="bool">True if the central was registered. False if the central logger was already registered</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.UnregisterAllLoggers">
            <summary>
            Clear out all registered loggers so that none are registered.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.InitializeNodeLoggers(System.Collections.Generic.ICollection{Microsoft.Build.Logging.LoggerDescription},Microsoft.Build.BackEnd.Logging.IBuildEventSink,System.Int32)">
            <summary>
            In order to setup the forwarding loggers on a node, we need to take in the logger descriptions and initialize them.
            The method will create a forwarding logger, an eventRedirector which will redirect all forwarded messages to the forwardingLoggerSink.
            All forwarding loggers will use the same forwardingLoggerSink.
            </summary>
            <param name="loggerDescriptions">Collection of logger descriptions which we would like to use to create a set of forwarding loggers on a node</param>
            <param name="forwardingLoggerSink">The buildEventSink which the fowarding loggers will forward their events to</param>
            <param name="nodeId">The id of the node the logging services is on</param>
            <exception cref="T:System.ArgumentNullException">When forwardingLoggerSink is null</exception>
            <exception cref="T:System.ArgumentNullException">When loggerDescriptions is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogComment(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
             Helper method to create a message build event from a string resource and some parameters
            </summary>
            <param name="buildEventContext">Event context which describes where in the build the message came from</param>
            <param name="importance">Importance level of the message</param>
            <param name="messageResourceName">string within the resource which indicates the format string to use</param>
            <param name="messageArgs">string resource arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogCommentFromText(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Framework.MessageImportance,System.String)">
            <summary>
            Helper method to create a message build event from a string
            </summary>
            <param name="buildEventContext">Event context which describes where in the build the message came from</param>
            <param name="importance">Importance level of the message</param>
            <param name="message">message to log</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogBuildEvent(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Will Log a build Event. Will also take into account OnlyLogCriticalEvents when determining if to drop the event or to log it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogError(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log an error
            </summary>
            <param name="buildEventContext">The event context information as to where the error occurred </param>
            <param name="file">The file in which the error occurred</param>
            <param name="messageResourceName">The resource name for the error</param>
            <param name="messageArgs">Parameters for the resource string</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogError(Microsoft.Build.Framework.BuildEventContext,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log an error
            </summary>
            <param name="buildEventContext">The event context for where the error occurred</param>
            <param name="subcategoryResourceName">The resource name which indicates the subCategory</param>
            <param name="file">The file in which the error occurred</param>
            <param name="messageResourceName">The resource name for the error</param>
            <param name="messageArgs">Parameters for the resource string</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogErrorFromText(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log an error
            </summary>
            <param name="buildEventContext">The event context for where the error occurred</param>
            <param name="subcategoryResourceName">The resource name which indicates the subCategory</param>
            <param name="errorCode"> Error code</param>
            <param name="helpKeyword">Help keyword</param>
            <param name="file">The file in which the error occurred</param>
            <param name="message">Error message</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogInvalidProjectFileError(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Exceptions.InvalidProjectFileException)">
            <summary>
            Log an invalid project file exception
            </summary>
            <param name="buildEventContext">The event context for where the error occurred</param>
            <param name="invalidProjectFileException">The invalid Project File Exception which is to be logged</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogFatalBuildError(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo)">
            <summary>
            Log an error based on an exception
            </summary>
            <param name="buildEventContext">The event context for where the error occurred</param>
            <param name="exception">The exception wich is to be logged</param>
            <param name="file">The file in which the error occurred</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogFatalTaskError(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log an error based on an exception during the execution of a task
            </summary>
            <param name="buildEventContext">The event context for where the error occurred</param>
            <param name="exception">The exception wich is to be logged</param>
            <param name="file">The file in which the error occurred</param>
            <param name="taskName">The task in which the error occurred</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogFatalError(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log an error based on an exception
            </summary>
            <param name="buildEventContext">The event context for where the error occurred</param>
            <param name="exception">The exception wich is to be logged</param>
            <param name="file">The file in which the error occurred</param>
            <param name="messageResourceName">The string resource which has the formatting string for the error</param>
            <param name="messageArgs">The arguments for the error message</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogTaskWarningFromException(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log a warning based on an exception
            </summary>
            <param name="buildEventContext">The event context for where the warning occurred</param>
            <param name="exception">The exception to be logged as a warning</param>
            <param name="file">The file in which the warning occurred</param>
            <param name="taskName">The task in which the warning occurred</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogWarning(Microsoft.Build.Framework.BuildEventContext,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Log a warning
            </summary>
            <param name="buildEventContext">The event context for where the warning occurred</param>
            <param name="subcategoryResourceName">The subcategory resource name</param>
            <param name="file">The file in which the warning occurred</param>
            <param name="messageResourceName">The string resource which contains the formatted warning string</param>
            <param name="messageArgs">parameters for the string resource</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogWarningFromText(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log a warning based on a text message
            </summary>
            <param name="buildEventContext">The event context for where the warning occurred</param>
            <param name="subcategoryResourceName">The subcategory resource name</param>
            <param name="warningCode"> Warning code</param>
            <param name="helpKeyword"> Help keyword</param>
            <param name="file">The file in which the warning occurred</param>
            <param name="message">The message to be logged as a warning</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogBuildStarted">
            <summary>
            Log the start of the build
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogBuildFinished(System.Boolean)">
            <summary>
            Log the completion of a build
            </summary>
            <param name="success">Did the build succeed or not</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.CreateEvaluationBuildEventContext(System.Int32,System.Int32)">
            <summary>
            Create an evaluation context, by generating a new evaluation id.
            </summary>
            <param name="nodeId">The node id</param>
            <param name="submissionId">The submission id</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogProjectEvaluationStarted(Microsoft.Build.Framework.BuildEventContext,System.String)">
            <summary>
            Logs that a project evaluation has started
            </summary>
            <param name="eventContext">The event context to use for logging</param>
            <param name="projectFile">Project file being built</param>
            <returns>The evaluation event context for the project.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogProjectEvaluationFinished(Microsoft.Build.Framework.BuildEventContext,System.String)">
            <summary>
            Logs that a project evaluation has finished
            </summary>
            <param name="projectEvaluationEventContext">Event context for the project.</param>
            <param name="projectFile">Project file being built</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogProjectStarted(Microsoft.Build.Framework.BuildEventContext,System.Int32,System.Int32,Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.DictionaryEntry},System.Collections.Generic.IEnumerable{System.Collections.DictionaryEntry})">
            <summary>
            Log that a project has started
            </summary>
            <param name="nodeBuildEventContext">The logging context of the node which is building this project.</param>
            <param name="submissionId">The id of the build submission.</param>
            <param name="projectId">The id of the project instance which is about to start</param>
            <param name="parentBuildEventContext">The build context of the parent project which asked this project to build</param>
            <param name="projectFile">The project file path of the project about to be built</param>
            <param name="targetNames">The entrypoint target names for this project</param>
            <param name="properties">The initial properties of the project</param>
            <param name="items">The initial items of the project</param>
            <returns>The BuildEventContext to use for this project.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogProjectFinished(Microsoft.Build.Framework.BuildEventContext,System.String,System.Boolean)">
            <summary>
            Log that the project has finished
            </summary>
            <param name="projectBuildEventContext">The build context of the project which has just finished</param>
            <param name="projectFile">The path to the projec file which was just built</param>
            <param name="success">Did the build succeede or not</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogTargetStarted(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,System.String,Microsoft.Build.Framework.TargetBuiltReason)">
            <summary>
            Log that a target has started
            </summary>
            <param name="projectBuildEventContext">The build event context of the project spawning this target.</param>
            <param name="targetName">The name of the target which is about to start</param>
            <param name="projectFile">The project file which is being built</param>
            <param name="projectFileOfTargetElement">The file in which the target is defined - typically a .targets file</param>
            <param name="parentTargetName">The name of the parent target.</param>
            <param name="buildReason">The reason the parent target built the target.</param>
            <returns>The target build event context</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogTargetFinished(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance.TaskItem})">
            <summary>
            Log that a target has finished
            </summary>
            <param name="targetBuildEventContext">The event context of the target which has just completed</param>
            <param name="targetName">The name of the target which has just completed</param>
            <param name="projectFile">The project file which the target was being run in</param>
            <param name="projectFileOfTargetElement">The file in which the target is defined - typically a .targets file</param>
            <param name="success">Did the target finish successfully or not</param>
            <param name="targetOutputs">List of target outputs for the target, right now this is for all batches and only is on the last target finished event</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogTaskStarted(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String)">
            <summary>
            Log that a task is about to start
            </summary>
            <param name="taskBuildEventContext">The event context of the task.</param>
            <param name="taskName">The name of the task</param>
            <param name="projectFile">The project file which is being built</param>
            <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogTaskStarted2(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String)">
            <summary>
            Log that a task is about to start
            </summary>
            <param name="targetBuildEventContext">The event context of the target which is spawning this task.</param>
            <param name="taskName">The name of the task</param>
            <param name="projectFile">The project file which is being built</param>
            <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
            <returns>The task build event context</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogTaskFinished(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Log that a task has just completed
            </summary>
            <param name="taskBuildEventContext">The event context of the task which has just finished</param>
            <param name="taskName">The name of the task</param>
            <param name="projectFile">The project file which is being built</param>
            <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
            <param name="success">True of the task finished successfully, false otherwise.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ILoggingService.LogTelemetry(Microsoft.Build.Framework.BuildEventContext,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Logs telemetry.
            </summary>
            <param name="buildEventContext">The event context of the task which sent the telemetry.</param>
            <param name="eventName">The event name.</param>
            <param name="properties">The list of properties associated with the event.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.IBuildEventSink">
            <summary>
            Acts as an endpoint for a buildEventArg. The objects which implement this interface are intended to consume the BuildEventArg. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.IBuildEventSink.Name">
            <summary>
            Provide a the sink a friendly name which can be used to distinguish sinks in memory 
            and for display
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.IBuildEventSink.HaveLoggedBuildStartedEvent">
            <summary>
            Has the sink logged the BuildStartedEvent. This is important to know because we only want to log the build started event once
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.IBuildEventSink.HaveLoggedBuildFinishedEvent">
            <summary>
            Has the sink logged the BuildFinishedEvent. This is important to know because we only want to log the build finished event once
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.IBuildEventSink.Consume(Microsoft.Build.Framework.BuildEventArgs,System.Int32)">
            <summary>
            Entry point for a sink to consume an event.
            </summary>
            <param name="buildEvent">The event to be consumed by the sink.</param>
            <param name="sinkId"> Sink where the message should go to, this is really only used for the transport sink</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.IBuildEventSink.Consume(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Entry point for a sink to consume an event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.IBuildEventSink.ShutDown">
            <summary>
            Shuts down the sink and any resources it may be holding
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.LoggerMode">
            <summary>
            What is the mode of the logger, should there be a thread
            processing the buildEvents and raising them on the filters and sinks
            or should they be done synchronously
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggerMode.Synchronous">
            <summary>
            Events are processed synchronously
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggerMode.Asynchronous">
            <summary>
            A thread is started which will process build events by raising them on a filter event source
            or on the correct sink.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.LoggingServiceState">
            <summary>
            What is the current state of the logging service
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingServiceState.Instantiated">
            <summary>
            When the logging service has been instantiated but not yet initialized through a call
            to initializecomponent
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingServiceState.Initialized">
            <summary>
            The logging service has been initialized through a call to initialize component
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingServiceState.ShuttingDown">
            <summary>
             The logging service is in the process of starting to shutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingServiceState.Shutdown">
            <summary>
            The logging service completly shutdown
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.LoggingService">
            <summary>
            Logging services is used as a helper class to assist logging messages in getting to the correct loggers.
            </summary>
            <summary>
            Partial class half of LoggingService which contains the Logging methods.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService.DefaultQueueCapacity">
            <summary>
            The default maximum size for the logging event queue.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._lockObject">
            <summary>
            Lock for the nextProjectId
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService.s_projectStartedEventArgsGlobalProperties">
            <summary>
            A cached reflection accessor for an internal member.
            </summary>
            <remarks>
            We use a BindingFlags.Public flag here because the getter is public, so although the setter is internal,
            it is only discoverable with Reflection using the Public flag (go figure!)
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService.s_projectStartedEventArgsToolsVersion">
            <summary>
            A cached reflection accessor for an internal member.
            </summary>
            <remarks>
            We use a BindingFlags.Public flag here because the getter is public, so although the setter is internal,
            it is only discoverable with Reflection using the Public flag (go figure!)
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._projectFileMap">
            <summary>
            The mapping of build request configuration ids to project file names.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._serviceState">
            <summary>
            The current state of the logging service
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._onlyLogCriticalEvents">
            <summary>
            Use to optimize away status messages. When this is set to true, only "critical"
            events like errors are logged. Default is false
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._eventSinkDictionary">
            <summary>
            Contains a dictionary of loggerId's and the sink which the logger (of the given Id) is expecting to consume its messages 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._loggers">
            <summary>
            A list of ILoggers registered with the LoggingService
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._loggerDescriptions">
            <summary>
            A list of LoggerDescriptions which describe how to create a forwarding logger on a node. These are
            passed to each node as they are created so that the forwarding loggers can be registered on them.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._filterEventSource">
            <summary>
            The event source to which filters will listen to to get the build events which are logged to the logging service through the 
            logging helper methods. Ie LogMessage and LogMessageEvent
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._centralForwardingLoggerSinkId">
            <summary>
            Index into the eventSinkDictionary which indicates which sink is the sink for any logger registered through RegisterLogger
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._nextSinkId">
            <summary>
            What is the Id for the next logger registered with the logging service.
            This Id is unique for this instance of the loggingService.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._maxCPUCount">
            <summary>
            The number of nodes in the system. Loggers may take different action depending on how many nodes are in the system.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._componentHost">
            <summary>
            Component host for this component which is used to get system parameters and other initialization information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._configCache">
            <summary>
            The IConfigCache instance obtained from componentHost (stored here to avoid repeated dictionary lookups).
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._nextEvaluationId">
            <summary>
            The next project ID to assign when a project evaluation started event is received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._nextProjectId">
            <summary>
            The next project ID to assign when a project started event is received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._nextTargetId">
            <summary>
            The next target ID to assign when a target started event is received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._nextTaskId">
            <summary>
            The next task ID to assign when a task started event is received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._nodeId">
            <summary>
            What node is this logging service running on
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._includeEvaluationMetaprojects">
            <summary>
            Whether to include evaluation metaprojects in events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._includeEvaluationProfile">
            <summary>
            Whether to include evaluation profiles in events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._includeTaskInputs">
            <summary>
            Whether to include task inputs in task events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._buildSubmissionIdsThatHaveLoggedErrors">
            <summary>
            A list of build submission IDs that have logged errors.  If an error is logged outside of a submission, the submission ID is <see cref="F:Microsoft.Build.Framework.BuildEventContext.InvalidSubmissionId"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._warningsAsErrorsByProject">
            <summary>
            A list of warnings to treat as errors for an associated <see cref="T:Microsoft.Build.Framework.BuildEventContext"/>.  If an empty set, all warnings are treated as errors.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._warningsAsMessagesByProject">
            <summary>
            A list of warnings to treat as messages for an associated <see cref="T:Microsoft.Build.Framework.BuildEventContext"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._loggingQueue">
            <summary>
            The data flow buffer for logging events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._loggingQueueProcessor">
            <summary>
            The data flow processor for logging events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._queueCapacity">
            <summary>
            The queue size above which the queue will close to messages from remote nodes.
            This value should be selected such that during normal builds it is never reached.
            It should also be low enough that we do not accumulate enough messages to cause
            virtual memory exhaustion in extremely large builds.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingService._logMode">
            <summary>
            By default our logMode is Asynchronous. We do this
            because we are hoping it will make the system 
            more responsive when there are a large number of logging messages
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.#ctor(Microsoft.Build.BackEnd.Logging.LoggerMode,System.Int32)">
            <summary>
            Initialize an instance of a loggingService.
            </summary>
            <param name="loggerMode">Should the events be processed synchronously or asynchronously</param>
            <param name="nodeId">The node identifier.</param>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.LoggingService.OnLoggingThreadException">
            <summary>
            When there is an exception on the logging thread, we do not want to throw the exception from there
            instead we would like the exception to be thrown on the engine thread as this is where hosts expect
            to see the exception. This event will transport the exception from the loggingService to the engine
            which will register on this event.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.LoggingService.OnProjectStarted">
            <summary>
            Raised when a ProjectStarted event is about to be sent to the loggers.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.Logging.LoggingService.OnProjectFinished">
            <summary>
            Raised when a ProjectFinished event has just been sent to the loggers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.PropertiesToSerialize">
            <summary>
            Properties we need to serialize from the child node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.SerializeAllProperties">
            <summary>
            Should all properties be serialized from the child to the parent node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.RunningOnRemoteNode">
            <summary>
            Is the logging running on a remote node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.NextEvaluationId">
            <summary>
            Gets the next project evaluation id.
            </summary>
            <remarks>This property is thread-safe</remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.NextProjectId">
            <summary>
            Gets the next project id.
            </summary>
            <remarks>This property is thread-safe</remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.NextTargetId">
            <summary>
            Gets the next target id.
            </summary>
            <remarks>This property is thread-safe</remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.NextTaskId">
            <summary>
            Gets the next task id.
            </summary>
            <remarks>This property is thread-safe</remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.ServiceState">
            <summary>
            Provide the current state of the loggingService.
            Is it Inistantiated
            Has it been Initialized
            Is it starting to shutdown
            Has it shutdown
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.OnlyLogCriticalEvents">
            <summary>
            Use to optimize away status messages. When this is set to true, only "critical"
            events like errors are logged.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.MaxCPUCount">
            <summary>
            Number of nodes in the system when the system is initially started
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.LoggerDescriptions">
            <summary>
            The list of descriptions which describe how to create forwarding loggers on a node.
            This is used by the node provider to get a list of registered descriptions so that 
            they can be transmitted to child nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.Loggers">
            <summary>
            Enumerator over all registered loggers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.LoggingMode">
            <summary>
            What type of logging mode is the logger running under. 
            Is it Synchronous or Asynchronous
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.WarningsAsErrors">
            <summary>
            Get of warnings to treat as errors.  An empty non-null set will treat all warnings as errors.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.WarningsAsMessages">
            <summary>
            A list of warnings to treat as low importance messages.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.IncludeEvaluationMetaprojects">
            <summary>
            Should evaluation events include generated metaprojects?
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.IncludeEvaluationProfile">
            <summary>
            Should evaluation events include profiling information?
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.IncludeTaskInputs">
            <summary>
            Should task events include task inputs?
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.HasBuildSubmissionLoggedErrors(System.Int32)">
            <summary>
            Determines if the specified submission has logged an errors.
            </summary>
            <param name="submissionId">The ID of the build submission.  A value of "0" means that an error was logged outside of any build submission.</param>
            <returns><code>true</code> if the build submission logged an errors, otherwise <code>false</code>.</returns>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.LoggingQueueHasEvents">
            <summary>
            Return whether or not the LoggingQueue has any events left in it
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.RegisteredLoggerTypeNames">
            <summary>
            Return an array which contains the logger type names
            this can be used to display which loggers are registered on the node
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.LoggingService.RegisteredSinkNames">
            <summary>
            Return an array which contains the sink names
            this can be used to display which sinks are on the node
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.CreateLoggingService(Microsoft.Build.BackEnd.Logging.LoggerMode,System.Int32)">
            <summary>
            Create an instance of a LoggingService using the specified mode.
            This method is used by the object factories to create instances of components.
            </summary>
            <param name="mode">Should the logger component created be synchronous or asynchronous</param>
            <param name="node">The identifier of the node.</param>
            <returns>An instantiated LoggingService as a IBuildComponent</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            NotThreadSafe, this method should only be called from the component host thread
            Called by the build component host when a component is first initialized.
            </summary>
            <param name="buildComponentHost">The component host for this object</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">When buildComponentHost is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Service has already shutdown</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.ShutdownComponent">
            <summary>
            NotThreadSafe, this method should only be called from the component host thread
            Called by the build component host when the component host is about to shutdown.
            1. Shutdown forwarding loggers so that any events they have left to forward can get into the queue
            2. Terminate the logging thread
            3. Null out sinks and the filter event source so that no more events can get to the central loggers
            4. Shutdown the central loggers
            </summary>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Service has already shutdown</exception>
            <exception cref="T:Microsoft.Build.Framework.LoggerException"> A logger may throw a logger exception when shutting down</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">A logger will wrap other exceptions (except ExceptionHandling.IsCriticalException exceptions) in a InternalLoggerException if it crashes during shutdown</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Will receive a logging packet and send it to the correct
            sink which is registered to the LoggingServices.
            PacketReceived should be called from a single thread.
            </summary>
            <param name="node">The node from which the packet was received.</param>
            <param name="packet">A LogMessagePacket</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Packet is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Packet is not a NodePacketType.LogMessage</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.RegisterLogger(Microsoft.Build.Framework.ILogger)">
            <summary>
            Register an instantiated logger which implements the ILogger interface. This logger will be registered to a specific event
            source (the central logger event source) which will receive all logging messages for a given build.
            This should not be used on a node, Loggers are not to be registered on a child node.
            </summary>
            <param name="logger">ILogger</param>
            <returns>True if the logger has been registered successfully. False if the logger was not registered due to it already being registered before</returns>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">If logger is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.UnregisterAllLoggers">
            <summary>
            Clear out all registered loggers so that none are registered.
            If no loggers are registered, does nothing.
            </summary>
            <remarks>
            UNDONE: (Logging) I don't like the semantics of this. Why should unregistering imply shutting down? VS actually calls it before registering any loggers.
            Also, why not just have ShutdownComponent? Or call this Shutdown or Dispose?
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.RegisterDistributedLogger(Microsoft.Build.Framework.ILogger,Microsoft.Build.Logging.LoggerDescription)">
            <summary>
            Register a distributed logger. This involves creating a new eventsource sink 
            and associating this with the central logger. In addition the sinkId needs 
            to be put in the loggerDescription so that nodes know what they need to 
            tag onto the event so that the message goes to the correct logger.
            
            The central logger is initialized before the distributed logger
            </summary>
            <param name="centralLogger">Central logger to receive messages from the forwarding logger, This logger cannot have been registered before</param>
            <param name="forwardingLogger">Logger description which describes how to create the forwarding logger, the logger description cannot have been used before</param>
            <returns value="bool">True if the distributed and central logger were registered, false if they either were already registered</returns>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">If forwardingLogger is null</exception>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">If a logger exception is thrown while creating or initializing the distributed or central logger</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">If any exception (other than a loggerException)is thrown while creating or initializing the distributed or central logger, we will wrap these exceptions in an InternalLoggerException</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.InitializeNodeLoggers(System.Collections.Generic.ICollection{Microsoft.Build.Logging.LoggerDescription},Microsoft.Build.BackEnd.Logging.IBuildEventSink,System.Int32)">
            <summary>
            In order to setup the forwarding loggers on a node, we need to take in the logger descriptions and initialize them.
            The method will create a forwarding logger, an eventRedirector which will redirect all forwarded messages to the forwardingLoggerSink.
            All forwarding loggers will use the same forwardingLoggerSink.
            </summary>
            <param name="descriptions">Collection of logger descriptions which we would like to use to create a set of forwarding loggers on a node</param>
            <param name="forwardingLoggerSink">The buildEventSink which the fowarding loggers will forward their events to</param>
            <param name="nodeId">The id of the node the logging services is on</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">When forwardingLoggerSink is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">When loggerDescriptions is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogBuildEvent(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Will Log a build Event. Will also take into account OnlyLogCriticalEvents when determining
            if to drop the event or to log it.
            
            Only the following events will be logged if OnlyLogCriticalEvents is true:
            CustomEventArgs
            BuildErrorEventArgs
            BuildWarningEventArgs
            </summary>
            <param name="buildEvent">BuildEvent to log</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">buildEvent is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.ProcessLoggingEvent(System.Object,System.Boolean)">
            <summary>
            This method will becalled from multiple threads in asynchronous mode.
            
            Determine where to send the buildevent either to the filters or to a specific sink.
            When in Asynchronous mode the event should to into the logging queue (as long as we are initialized).
            In Synchronous mode the event should be routed to the correct sink or logger right away
            </summary>
            <param name="buildEvent">BuildEventArgs to process</param>
            <param name="allowThrottling"><code>true</code> to allow throttling, otherwise <code>false</code>.</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">buildEvent is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.WaitForThreadToProcessEvents">
            <summary>
            Wait for the logging messages in the logging queue to be completly processed.
            This is required because for Logging build finished or when the component is to shutdown
            we need to make sure we process all of the events before the build finished event is raised
            and we need to make sure we process all of the logging events before we shutdown the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.InjectNonSerializedData(Microsoft.Build.BackEnd.LogMessagePacket)">
            <summary>
            Adds data to the EventArgs of the log packet that the main node is aware of, but doesn't
            get serialized for perf reasons.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.CreateLoggingEventQueue">
            <summary>
            Create a logging thread to process the logging queue
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.TerminateLoggingEventQueue">
            <summary>
            Wait for the logginQueue to empty and then terminate the logging thread
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.ShutdownLogger(Microsoft.Build.Framework.ILogger)">
            <summary>
            Shutdown an ILogger
            Rethrow LoggerExceptions
            Wrap all other exceptions in an InternalLoggerException
            </summary>
            <param name="logger">Logger to shutdown</param>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exception comming from a logger during shutdown that is not a LoggerException is wrapped in an InternalLoggerException and thrown</exception>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">Errors during logger shutdown may throw a LoggerException, in this case the exception is re-thrown</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.CreateFilterEventSource">
            <summary>
            Create an event source to which the distributed (filter loggers) can attach to and listen
            for logging events. This event source will consume events which are logged against
            the logging service and raise them on itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LoggingEventProcessor(System.Object)">
            <summary>
            The logging services thread loop. This loop will wait until the logging queue has build events.
            When this happens the thread will start to process the queue items by raising the build event
            on either a filter event source or a sink depending on where the message is supposed to go.
            </summary>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">WaitHandle returns something other than 0 or 1</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.RouteBuildEvent(System.Object)">
            <summary>
            Route the event to the correct location, this is mostly used by the logging thread since it may have a buildevent or a tuple.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.RouteBuildEvent(System.Collections.Generic.KeyValuePair{System.Int32,Microsoft.Build.Framework.BuildEventArgs})">
            <summary>
            Route the build event to the correct filter or sink depending on what the sinId is in the build event. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.RouteBuildEvent(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Route the build event to the filter
            </summary>
            <param name="eventArg">Build event that needs to be routed to the correct filter or sink.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.InitializeLogger(Microsoft.Build.Framework.ILogger,Microsoft.Build.Framework.IEventSource)">
            <summary>
            Initializes the logger and adds it to the list of loggers maintained by the engine.
            This method is not expected to be called from multiple threads
            </summary>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">A logger exception thrown by a logger when its initialize call is made</exception>
            <exception cref="T:Microsoft.Build.Exceptions.InternalLoggerException">Any exceptions from initializing the logger which are not loggerExceptions are caught and wrapped in a InternalLoggerException</exception>
            <exception cref="T:System.Exception">Any exception which is a ExceptionHandling.IsCriticalException will not be wrapped</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.RaiseLoggingExceptionEvent(System.Exception)">
            <summary>
            When an exception is raised in the logging thread, we do not want the application to terminate right away. 
            Whidbey and orcas msbuild have the logger exceptions occurring on the engine thread so that the host can
            catch and deal with these exceptions as they may occur somewhat frequently due to user generated loggers.
            This method will raise the exception on a delegate to which the engine is registered to. This delegate will 
            send the exception to the engine so that it can be raised on the engine thread.
            </summary>
            <param name="ex">Exception to raise to event handlers</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.TryRaiseProjectStartedEvent(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Raise the project started event, if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.TryRaiseProjectFinishedEvent(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Raise the project finished event, if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.GetAndVerifyProjectFileFromContext(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Get the project name from a context ID. Throw an exception if it's not found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.ShouldTreatWarningAsMessage(Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Determines if the specified warning should be treated as a low importance message.
            </summary>
            <param name="warningEvent">A <see cref="T:Microsoft.Build.Framework.BuildWarningEventArgs"/> that specifies the warning.</param>
            <returns><code>true</code> if the warning should be treated as a low importance message, otherwise <code>false</code>.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.ShouldTreatWarningAsError(Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Determines if the specified warning should be treated as an error.
            </summary>
            <param name="warningEvent">A <see cref="T:Microsoft.Build.Framework.BuildWarningEventArgs"/> that specifies the warning.</param>
            <returns><code>true</code> if the warning should be treated as an error, otherwise <code>false</code>.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogComment(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Logs a comment (BuildMessageEventArgs) with a certain MessageImportance level
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
            The higher the importance the lower the verbosity needs to be for the message to be seen</param>
            <param name="messageResourceName">String which identifies the message in the string resx</param>
            <param name="messageArgs">Arguments for the format string indexed by messageResourceName</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">MessageResourceName is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogCommentFromText(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Framework.MessageImportance,System.String)">
            <summary>
            Log a comment
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
            The higher the importance the lower the verbosity needs to be for the message to be seen</param>
            <param name="message">Message to log</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Message is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogCommentFromText(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Framework.MessageImportance,System.String,System.Object[])">
            <summary>
            Log a comment
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
            The higher the importance the lower the verbosity needs to be for the message to be seen</param>
            <param name="message">Message to log</param>
            <param name="messageArgs">Message formatting arguments</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Message is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogError(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Logs an error with all registered loggers using the specified resource string.
            </summary>
            <param name="location">Event context information which describes who is logging the event</param>
            <param name="file">File information where the error happened</param>
            <param name="messageResourceName">String key to find the correct string resource</param>
            <param name="messageArgs">Arguments for the string resource</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogError(Microsoft.Build.Framework.BuildEventContext,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Logs an error
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="subcategoryResourceName">Can be null.</param>
            <param name="file">File information about where the error happened</param>
            <param name="messageResourceName">String index into the string.resx file</param>
            <param name="messageArgs">Arguments for the format string in the resource file</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">MessageResourceName is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogErrorFromText(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Logs an error with a given message
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="subcategoryResourceName">Can be null.</param>
            <param name="errorCode">Can be null.</param>
            <param name="helpKeyword">Can be null.</param>
            <param name="file">File information about where the error happened</param>
            <param name="message">Error message which will be displayed</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">File is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">Message is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogInvalidProjectFileError(Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Exceptions.InvalidProjectFileException)">
            <summary>
            Logs an error regarding an invalid project file . Since this method may be multiple times for the same InvalidProjectException
            we do not want to log the error multiple times. Once the exception has been logged we set a flag on the exception to note that
            it has already been logged.
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="invalidProjectFileException">Exception which is causing the error</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">InvalidProjectFileException is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogFatalBuildError(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo)">
            <summary>
            Logs an error regarding an unexpected build failure
            This will include a stack dump.
            </summary>
            <param name="buildEventContext">BuildEventContext of the error</param>
            <param name="exception">Exception wihch caused the build error</param>
            <param name="file">Provides file information about where the build error happened</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogFatalTaskError(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Logs an error regarding an unexpected task failure.
            This will include a stack dump.
            </summary>
            <param name="buildEventContext">BuildEventContext of the error</param>
            <param name="exception">Exceptionm which caused the error</param>
            <param name="file">File information which indicates which file the error is happening in</param>
            <param name="taskName">Task which the error is happening in</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">TaskName is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogFatalError(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Logs an error regarding an unexpected failure using the specified resource string.
            This will include a stack dump.
            </summary>
            <param name="buildEventContext">BuildEventContext of the error</param>
            <param name="exception">Exception which will be used to generate the error message</param>
            <param name="file">File information which describes where the error happened</param>
            <param name="messageResourceName">String name for the resource string to be used</param>
            <param name="messageArgs">Arguments for messageResourceName</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">MessageResourceName is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogTaskWarningFromException(Microsoft.Build.Framework.BuildEventContext,System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Logs an warning regarding an unexpected task failure
            This will include a stack dump.
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="exception">The exception to be used to create the warning text</param>
            <param name="file">The file information which indicates where the warning happened</param>
            <param name="taskName">Name of the task which the warning is being raised from</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogWarning(Microsoft.Build.Framework.BuildEventContext,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String,System.Object[])">
            <summary>
            Logs a warning using the specified resource string.
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="subcategoryResourceName">Can be null.</param>
            <param name="file">File information which describes where the warning happened</param>
            <param name="messageResourceName">String name for the resource string to be used</param>
            <param name="messageArgs">Arguments for messageResourceName</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogWarningFromText(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Logs a warning
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="subcategoryResourceName">Subcategory resource Name. Can be null.</param>
            <param name="warningCode">The warning code of the message. Can be null.</param>
            <param name="helpKeyword">Help keyword for the message. Can be null.</param>
            <param name="file">The file information which will describe where the warning happened</param>
            <param name="message">Warning message to log</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogBuildStarted">
            <summary>
            Logs that the build has started 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogBuildFinished(System.Boolean)">
            <summary>
            Logs that the build has finished
            </summary>
            <param name="success">Did the build pass or fail</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.CreateEvaluationBuildEventContext(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogProjectEvaluationStarted(Microsoft.Build.Framework.BuildEventContext,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogProjectEvaluationFinished(Microsoft.Build.Framework.BuildEventContext,System.String)">
            <summary>
            Logs that a project evaluation has finished
            </summary>
            <param name="projectEvaluationEventContext">Event context for the project.</param>
            <param name="projectFile">Project file being built</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogProjectStarted(Microsoft.Build.Framework.BuildEventContext,System.Int32,System.Int32,Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.DictionaryEntry},System.Collections.Generic.IEnumerable{System.Collections.DictionaryEntry})">
            <summary>
            Logs that a project build has started
            </summary>
            <param name="nodeBuildEventContext">The event context of the node which is spawning this project.</param>
            <param name="submissionId">The id of the submission.</param>
            <param name="projectInstanceId">Id of the project instance which is being started</param>
            <param name="parentBuildEventContext">BuildEventContext of the project who is requesting "projectFile" to build</param>
            <param name="projectFile">Project file to build</param>
            <param name="targetNames">Target names to build</param>
            <param name="properties">Initial property list</param>
            <param name="items">Initial items list</param>
            <returns>The build event context for the project.</returns>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">parentBuildEventContext is null</exception>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">projectBuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogProjectFinished(Microsoft.Build.Framework.BuildEventContext,System.String,System.Boolean)">
            <summary>
            Logs that a project has finished
            </summary>
            <param name="projectBuildEventContext">Event context for the project.</param>
            <param name="projectFile">Project file being built</param>
            <param name="success">Did the project pass or fail</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogTargetStarted(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,System.String,Microsoft.Build.Framework.TargetBuiltReason)">
            <summary>
            Logs that a target started
            </summary>
            <param name="projectBuildEventContext">Event context for the project spawning this target</param>
            <param name="targetName">Name of target</param>
            <param name="projectFile">Project file being built</param>
            <param name="projectFileOfTargetElement">Project file which contains the target</param>
            <param name="parentTargetName">The name of the parent target.</param>
            <param name="buildReason">The reason the parent target built the target.</param>
            <returns>The build event context for the target.</returns>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogTargetFinished(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance.TaskItem})">
            <summary>
            Logs that a target has finished.
            </summary>
            <param name="targetBuildEventContext">Event context for the target</param>
            <param name="targetName">Target which has just finished</param>
            <param name="projectFile">Project file being built</param>
            <param name="projectFileOfTargetElement">Project file which contains the target</param>
            <param name="success">Did the target pass or fail</param>
            <param name="targetOutputs">Target outputs for the target.</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogTaskStarted(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String)">
            <summary>
            Logs that task execution has started.
            </summary>
            <param name="taskBuildEventContext">Event context for the task</param>
            <param name="taskName">Task Name</param>
            <param name="projectFile">Project file being built</param>
            <param name="projectFileOfTaskNode">Project file which contains the task</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogTaskStarted2(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String)">
            <summary>
            Logs that task execution has started.
            </summary>
            <param name="targetBuildEventContext">Event context for the target spawning this task.</param>
            <param name="taskName">Task Name</param>
            <param name="projectFile">Project file being built</param>
            <param name="projectFileOfTaskNode">Project file which contains the task</param>
            <returns>The build event context for the task.</returns>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogTaskFinished(Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Logs that a task has finished executing.
            </summary>
            <param name="taskBuildEventContext">Event context for the task</param>
            <param name="taskName">Name of the task</param>
            <param name="projectFile">Project which is being processed</param>
            <param name="projectFileOfTaskNode">Project file which contains the task</param>
            <param name="success">Did the task pass or fail</param>
            <exception cref="T:Microsoft.Build.Shared.InternalErrorException">BuildEventContext is null</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingService.LogTelemetry(Microsoft.Build.Framework.BuildEventContext,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Logs a telemetry event.
            </summary>
            <param name="buildEventContext">Event context information which describes who is logging the event</param>
            <param name="eventName">The event name.</param>
            <param name="properties">The list of properties assocated with the event.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.LoggingServiceFactory">
            <summary>
            Factory to create components of the type LoggingService
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingServiceFactory._logMode">
            <summary>
            What kind of LoggerMode are the logging services when created.
            They could be Synchronous or Asynchronous
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.LoggingServiceFactory._nodeId">
            <summary>
            What node is this logging service being created on.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingServiceFactory.#ctor(Microsoft.Build.BackEnd.Logging.LoggerMode,System.Int32)">
            <summary>
            Tell the factory what kind of logging services is should create
            </summary>
            <param name="mode">Synchronous or Asynchronous</param>
            <param name="nodeId">The node identifier.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LoggingServiceFactory.CreateInstance(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Create an instance of a LoggingService and returns is as an IBuildComponent
            </summary>
            <returns>An instance of a LoggingService as a IBuildComponent</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.NodeLoggingContext">
            <summary>
            The logging context for an entire node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.NodeLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.ILoggingService,System.Int32,System.Boolean)">
            <summary>
            Used to create the initial, base logging context for the node.
            </summary>
            <param name="loggingService">The logging service to use.</param>
            <param name="nodeId">The </param>
            <param name="inProcNode"><code>true</code> if this is an in-process node, otherwise <code>false</code>.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.NodeLoggingContext.LogBuildFinished(System.Boolean)">
            <summary>
            Log the completion of a build
            </summary>
            <param name="success">Did the build succeed or not</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.NodeLoggingContext.LogProjectStarted(Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Log that a project has started if it has no parent (the first project)
            </summary>
            <param name="requestEntry">The build request entry for this project.</param>
            <returns>The BuildEventContext to use for this project.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.NodeLoggingContext.LogProjectStarted(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Log that a project has started if it is serviced from the cache
            </summary>
            <param name="request">The build request.</param>
            <param name="configuration">The configuration used to build the request.</param>
            <returns>The BuildEventContext to use for this project.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.NodeLoggingContext.LogRequestHandledFromCache(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.BackEnd.BuildRequestConfiguration,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Logs the project started/finished pair for projects which are skipped entirely because all
            of their results are available in the cache.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext">
            <summary>
            A logging context for a project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext._projectFullPath">
            <summary>
            The project's full path
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext._nodeLoggingContext">
            <summary>
            The parent node logging context this context was derived from.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.NodeLoggingContext,Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Constructs a project logging context.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.NodeLoggingContext,Microsoft.Build.BackEnd.BuildRequest,System.String,System.String,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Constructs a project logging context.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.NodeLoggingContext,System.Int32,System.Int32,System.String,System.Collections.Generic.List{System.String},System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance},Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Constructs a project logging contexts.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.NodeLoggingContext">
            <summary>
            Retrieves the node logging context.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.LogProjectFinished(System.Boolean)">
            <summary>
            Log that the project has finished
            </summary>
            <param name="success">Did the build succeede or not</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.LogTargetBatchStarted(System.String,Microsoft.Build.Execution.ProjectTargetInstance,System.String,Microsoft.Build.Framework.TargetBuiltReason)">
            <summary>
            Log that a target has started
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectItemInstanceEnumeratorProxy">
            <summary>
            An enumerable wrapper for items that clones items as they are requested,
            so that writes have no effect on the items.
            </summary>
            <remarks>
            This class is designed to be passed to loggers.
            The expense of copying items is only incurred if and when 
            a logger chooses to enumerate over it.
            The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectItemInstanceEnumeratorProxy._backingItems">
            <summary>
            Enumerable that this proxies
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectItemInstanceEnumeratorProxy.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Constructor
            </summary>
            <param name="backingItems">Enumerator this class should proxy</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectItemInstanceEnumeratorProxy.GetEnumerator">
            <summary>
            Returns an enumerator that provides copies of the items
            in the backing store.
            Each dictionary entry has key of the item type and value of an ITaskItem.
            Type of the enumerator is imposed by backwards compatibility for ProjectStartedEvent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectItemInstanceEnumeratorProxy.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that provides copies of the items
            in the backing store.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectPropertyInstanceEnumeratorProxy">
            <summary>
            An enumerable wrapper for properties that clones properties as they are requested,
            so that writes have no effect on the properties.
            </summary>
            <remarks>
            This class is designed to be passed to loggers.
            The expense of copying items is only incurred if and when 
            a logger chooses to enumerate over it.
            The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectPropertyInstanceEnumeratorProxy._backingProperties">
            <summary>
            Enumerable that this proxies
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectPropertyInstanceEnumeratorProxy.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Constructor
            </summary>
            <param name="backingProperties">Enumerator this class should proxy</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectPropertyInstanceEnumeratorProxy.GetEnumerator">
            <summary>
            Returns an enumerator that provides copies of the properties
            in the backing store.
            Each DictionaryEntry has key of the property name and value of the property value.
            Type of the enumerator is imposed by backwards compatibility for ProjectStartedEvent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectLoggingContext.ProjectPropertyInstanceEnumeratorProxy.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that provides copies of the properties
            in the backing store.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.TargetLoggingContext">
            <summary>
            A logging context for building a specific target within a project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.s_enableTargetOutputLogging">
            <summary>
            Should target outputs be logged also.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.TargetLoggingContext._projectLoggingContext">
            <summary>
            The project to which this target is attached.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.TargetLoggingContext._target">
            <summary>
            The target being built.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.ProjectLoggingContext,System.String,Microsoft.Build.Execution.ProjectTargetInstance,System.String,Microsoft.Build.Framework.TargetBuiltReason)">
            <summary>
            Creates a new target logging context from an existing project context and target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Constructor used to support out-of-proc task host (proxy for in-proc logging service.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.EnableTargetOutputLogging">
            <summary>
            Should target outputs be logged also.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.ProjectLoggingContext">
            <summary>
            Retrieves the project logging context.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.Target">
            <summary>
            Retrieves the target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.LogTargetBatchFinished(System.String,System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance.TaskItem})">
            <summary>
            Log that a target has finished
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.LogTaskBatchStarted(System.String,Microsoft.Build.Execution.ProjectTargetInstanceChild)">
            <summary>
            Log that a task is about to start
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy">
            <summary>
            An enumerable wrapper for items that clones items as they are requested,
            so that writes have no effect on the items.
            </summary>
            <remarks>
            This class is designed to be passed to loggers.
            The expense of copying items is only incurred if and when 
            a logger chooses to enumerate over it.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy._backingItems">
            <summary>
            Enumerable that this proxies
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance.TaskItem})">
            <summary>
            Constructor
            </summary>
            <param name="backingItems">Enumerator this class should proxy</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy.GetEnumerator">
            <summary>
            Returns an enumerator that provides copies of the items
            in the backing store.
            Each dictionary entry has key of the item type and value of an ITaskItem.
            Type of the enumerator is imposed by backwards compatibility for ProjectStartedEvent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that provides copies of the items
            in the backing store.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.TaskLoggingContext">
            <summary>
            A logging context representing a task being built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.TaskLoggingContext._targetLoggingContext">
            <summary>
            The target context in which this task is being built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.TaskLoggingContext._task">
            <summary>
            The task instance
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.TaskLoggingContext._taskName">
            <summary>
            The name of the task
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.TargetLoggingContext,System.String,Microsoft.Build.Execution.ProjectTargetInstanceChild)">
            <summary>
            Constructs a task logging context from a parent target context and a task node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskLoggingContext.#ctor(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Constructor used to support out-of-proc task host (proxy for in-proc logging service.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.TaskLoggingContext.TargetLoggingContext">
            <summary>
            Retrieves the target logging context.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.TaskLoggingContext.Task">
            <summary>
            Retrieves the task node.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.TaskLoggingContext.TaskName">
            <summary>
            Retrieves the task node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskLoggingContext.LogTaskBatchFinished(System.String,System.Boolean)">
            <summary>
            Log that a task has just completed
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.TaskLoggingContext.LogTaskWarningFromException(System.Exception,Microsoft.Build.Shared.BuildEventFileInfo,System.String)">
            <summary>
            Log a warning based on an exception
            </summary>
            <param name="exception">The exception to be logged as a warning</param>
            <param name="file">The file in which the warning occurred</param>
            <param name="taskName">The task in which the warning occurred</param>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger._supportReadingBackgroundColor">
            <summary>
            When set, we'll try reading background color.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.BackgroundColor">
            <summary>
            Some platforms do not allow getting current background color. There
            is not way to check, but not-supported exception is thrown. Assume
            black, but don't crash.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.Verbosity">
            <summary>
            Gets or sets the level of detail to show in the event log.
            </summary>
            <value>Verbosity level.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.NumberOfProcessors">
            <summary>
            Gets or sets the number of MSBuild processes participating in the build. If greater than 1,
            include the node ID 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.Parameters">
            <summary>
            The console logger takes a single parameter to suppress the output of the errors
            and warnings summary at the end of a build.
            </summary>
            <value>null</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.SkipProjectStartedText">
            <summary>
            Suppresses the display of project headers. Project headers are
            displayed by default unless this property is set.
            </summary>
            <remarks>This is only needed by the IDE logger.</remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ShowSummary">
            <summary>
            Suppresses the display of error and warnings summary.
            If null, user has made no indication.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteHandler">
            <summary>
            Provide access to the write hander delegate so that it can be redirected
            if necessary (e.g. to a file)
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ParseParameters">
            <summary>
            Parses out the logger parameters from the Parameters string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.DictionaryEntryKeyComparer">
            <summary>
            An implementation of IComparer useful for comparing the keys 
            on DictionaryEntry's
            </summary>
            <remarks>Uses CurrentCulture for display purposes</remarks>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ITaskItemItemSpecComparer">
            <summary>
            An implementation of IComparer useful for comparing the ItemSpecs 
            on ITaskItem's
            </summary>
            <remarks>Uses CurrentCulture for display purposes</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.IndentString(System.String,System.Int32)">
            <summary>
            Indents the given string by the specified number of spaces.
            </summary>
            <param name="s">String to indent.</param>
            <param name="indent">Depth to indent.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.SplitStringOnNewLines(System.String)">
            <summary>
            Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
            </summary>
            <param name="s">String to split.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteNewLine">
            <summary>
            Writes a newline to the log.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteLinePrettyFromResource(System.String,System.Object[])">
            <summary>
            Writes a line from a resource string to the log, using the default indentation.
            </summary>
            <param name="resourceString"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteLinePrettyFromResource(System.Int32,System.String,System.Object[])">
            <summary>
            Writes a line from a resource string to the log, using the specified indentation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WritePretty(System.String)">
            <summary>
            Writes to the log, using the default indentation. Does not 
            terminate with a newline.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ShowPerfSummary">
            <summary>
            If requested, display a performance summary at the end of the build.  This
            shows how much time (and # hits) were spent inside of each project, target,
            and task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WritePretty(System.Int32,System.String)">
            <summary>
            Writes to the log, using the specified indentation. Does not 
            terminate with a newline.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteLinePretty(System.String)">
            <summary>
            Writes a line to the log, using the default indentation.
            </summary>
            <param name="formattedString"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteLinePretty(System.Int32,System.String)">
            <summary>
            Writes a line to the log, using the specified indentation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.IsRunningWithCharacterFileType">
            <summary>
            Check to see what kind of device we are outputting the log to, is it a character device, a file, or something else
            this can be used by loggers to modify their outputs based on the device they are writing to
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Determines whether the current verbosity setting is at least the value
            passed in.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.SetColor(System.ConsoleColor)">
            <summary>
            Sets foreground color to color specified
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ResetColor">
            <summary>
            Resets the color
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.SetColorAnsi(System.ConsoleColor)">
            <summary>
            Sets foreground color to color specified using ANSI escape codes
            </summary>
            <param name="c">foreground color</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ResetColorAnsi">
            <summary>
            Resets the color using ANSI escape codes
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.TransformColor(System.ConsoleColor,System.ConsoleColor)">
            <summary>
            Changes the foreground color to black if the foreground is the
            same as the background. Changes the foreground to white if the
            background is black.
            </summary>
            <param name="foreground">foreground color for black</param>
            <param name="background">current background</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.DontSetColor(System.ConsoleColor)">
            <summary>
            Does nothing, meets the ColorSetter delegate type
            </summary>
            <param name="c">foreground color (is ignored)</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.DontResetColor">
            <summary>
            Does nothing, meets the ColorResetter delegate type
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteProperties(System.Collections.Generic.List{System.Collections.DictionaryEntry})">
            <summary>
            Writes out the list of property names and their values.
            This could be done at any time during the build to show the latest
            property values, using the cached reference to the list from the 
            appropriate ProjectStarted event.
            </summary>
            <param name="properties">List of properties</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteEnvironment(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes out the environment as seen on build started.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ExtractPropertyList(System.Collections.IEnumerable)">
            <summary>
            Generate a list which contains the properties referenced by the properties 
            enumerable object
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.OutputEnvironment(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Write the environment of the build as was captured on the build started event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.WriteItems(System.Collections.SortedList)">
            <summary>
            Writes out the list of item specs and their metadata.
            This could be done at any time during the build to show the latest
            items, using the cached reference to the list from the 
            appropriate ProjectStarted event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ExtractItemList(System.Collections.IEnumerable)">
            <summary>
            Extract the Items from the enumerable object and return a sorted list containing these items
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.OutputItems(System.String,System.Collections.ArrayList)">
            <summary>
            Dump the initial items provided.
            Overridden in ParallelConsoleLogger.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.GetPerformanceCounter(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter}@)">
            <summary>
            Returns a performance counter for a given scope (either task name or target name)
            from the given table.
            </summary>
            <param name="scopeName">Task name or target name.</param>
            <param name="table">Table that has tasks or targets.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.DisplayCounters(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter})">
            <summary>
            Display the timings for each counter in the dictionary.
            </summary>
            <param name="counters"></param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter">
            <summary>
            Records performance information consumed by a task or target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.#ctor(System.String)">
            <summary>
            Construct.
            </summary>
            <param name="scopeName"></param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.ScopeName">
            <summary>
            Name of the scope.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.Calls">
            <summary>
            Total number of calls so far.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.ElapsedTime">
            <summary>
            Total accumulated time so far.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.ReenteredScope">
            <summary>
            Whether or not this scope was reentered. Timing information is not recorded in these cases.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.InScope">
            <summary>
            Whether or not this task or target is executing right now.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.DescendingByElapsedTimeComparer">
            <summary>
            Returns an IComparer that will put performance counters 
            in descending order by elapsed time.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.DescendingByElapsedTime">
            <summary>
            Private IComparer class for sorting performance counters 
            in descending order by elapsed time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter.DescendingByElapsedTime.Compare(System.Object,System.Object)">
            <summary>
            Compare two PerformanceCounters.
            </summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Signs up the console logger for all build events.
            </summary>
            <param name="eventSource">Available events.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ApplyParameter(System.String,System.String)">
            <summary>
            Apply a logger parameter.
            parameterValue may be null, if there is no parameter value.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.ApplyVerbosityParameter(System.String)">
            <summary>
            Apply the verbosity value
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.buildStarted">
            <summary>
            Time the build started
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.setColor">
            <summary>
            Delegate used to change text color.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.resetColor">
            <summary>
            Delegate used to reset text color
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.tabWidth">
            <summary>
            Number of spaces that each level of indentation is worth
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.currentIndentLevel">
            <summary>
            Keeps track of the current indentation level.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.newLines">
            <summary>
            The kinds of newline breaks we expect.
            </summary>
            <remarks>Currently we're not supporting "\r".</remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.projectSeparatorLine">
            <summary>
            Visual separator for projects. Line length was picked arbitrarily.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.parameterDelimiters">
            <summary>
            Console logger parameters delimiters.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.s_parameterValueSplitCharacter">
            <summary>
            Console logger parameter value split character.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.showPerfSummary">
            <summary>
            When true, accumulate performance numbers.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.showItemAndPropertyList">
            <summary>
            When true, show the list of item and property values at the start of each project
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.showTargetOutputs">
            <summary>
            Should the target output items be displayed
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.showOnlyWarnings">
            <summary>
            When true, suppresses all messages except for warnings. (And possibly errors, if showOnlyErrors is true.)
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.showOnlyErrors">
            <summary>
            When true, suppresses all messages except for errors. (And possibly warnings, if showOnlyWarnings is true.)
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.showEnvironment">
            <summary>
            When true the environment block supplied by the build started event should be printed out at the start of the build
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.showProjectFile">
            <summary>
            When true, indicates that the logger should tack the project file onto the end of errors and warnings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.errorCount">
            <summary>
            Number of errors encountered in this build
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.warningCount">
            <summary>
            Number of warnings encountered in this build
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.errorList">
            <summary>
            A list of the errors that have occurred during this build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.warningList">
            <summary>
            A list of the warnings that have occurred during this build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.projectPerformanceCounters">
            <summary>
            Accumulated project performance information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.targetPerformanceCounters">
            <summary>
            Accumulated target performance information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.taskPerformanceCounters">
            <summary>
            Accumulated task performance information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.projectEvaluationPerformanceCounters">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.NullCentralLogger">
            <summary>
            This class will throw an exception when it receives any event except for the build started or build finished event
            this logger is good to use if a distributed logger is attached but does not want to forward any events
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.BuildEventManager">
            <summary>
            Stores and manages projects and targets events for logging purposes
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.AddProjectStartedEvent(Microsoft.Build.Framework.ProjectStartedEventArgs,System.Boolean)">
            <summary>
             Adds a new project to the list of project started events which have been fired
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.AddTargetStartedEvent(Microsoft.Build.Framework.TargetStartedEventArgs,System.Boolean)">
            <summary>
             Adds a new target to the list of project started events which have been fired
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.GetProjectCallStack(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Get a call stack of event contexts for a starting point event context
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.SetErrorWarningFlagOnCallStack(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Set an error flag on all projects in the call stack of a given event context
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.ProjectCallStackFromProject(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Retrieve the project call stack based on the starting point of buildEventContext e
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.GetProjectStartedEvent(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Get a deferred project started event based on a given event context
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.GetTargetStartedEvent(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
             Get a deferred target started event based on a given event context
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.RemoveProjectStartedEvent(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Will remove a project started event from the list of deferred project started events
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.BuildEventManager.RemoveTargetStartedEvent(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Will remove a project started event from the list of deferred project started events
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ComparerContextNodeId`1">
            <summary>
            Compares two event contexts on ProjectContextId and NodeId only
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ComparerContextNodeIdTargetId`1">
            <summary>
            Compares two event contexts based on the ProjectContextId, NodeId, and TargetId only
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ProjectStartedEventMinimumFields">
            <summary>
            This class stands in for a full project started event because it contains only the 
            minimum amount of inforomation needed for the logger
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.TargetStartedEventMinimumFields">
            <summary>
            This class stands in for a full target started event because it contains only the 
            minimum amount of inforomation needed for the logger
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ErrorWarningSummaryDictionaryKey">
            <summary>
            This class is used as a key to group warnings and errors by the project entry point and the target they 
            error or warning was in
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ProjectFullKey">
            <summary>
            Structure that holds both project and entrypoint keys
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectFullKey.ToString(Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Output the projectKey or the projectKey and the entrypointKey depending on the verbosity level of the logger
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ProjectFullKey.ToString">
            <summary>
            The default of he ToString method should  be to output the projectKey or the projectKey and the entrypointKey depending if a
            entry point key exists or not
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger">
            <summary>
            This class implements the default logger that outputs event data
            to the console (stdout).
            </summary>
            <remarks>This class is not thread safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.#ctor(Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Create a logger instance with a specific verbosity.  This logs to
            the default console.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.#ctor(Microsoft.Build.Framework.LoggerVerbosity,Microsoft.Build.Logging.WriteHandler,Microsoft.Build.Logging.ColorSetter,Microsoft.Build.Logging.ColorResetter)">
            <summary>
            Initializes the logger, with alternate output handlers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.CheckIfOutputSupportsAlignment">
            <summary>
            Check to see if the console is going to a char output such as a console,printer or com port, or if it going to a file
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ApplyParameter(System.String,System.String)">
            <summary>
            Allows the logger to take action based on a parameter passed on when initializing the logger
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ShownBuildEventContext(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Keep track of the last event displayed so target names can be displayed at the correct time
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ResetConsoleLoggerState">
            <summary>
            Reset the states of per-build member variables
            VSW#516376 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Handler for build started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Handler for build finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ShowFlatErrorWarningSummary">
            <summary>
            At the end of the build, repeats the errors and warnings that occurred 
            during the build, and displays the error count and warning count.
            Does this in a "flat" style, without context.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ShowNestedErrorWarningSummary">
            <summary>
            At the end of the build, repeats the errors and warnings that occurred 
            during the build, and displays the error count and warning count.
            Does this in a "nested" style.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Handler for project started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Handler for project finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.WriteProperties(Microsoft.Build.Framework.BuildEventArgs,System.Collections.IEnumerable)">
            <summary>
            Writes out the list of property names and their values.
            This could be done at any time during the build to show the latest
            property values, using the cached reference to the list from the 
            appropriate ProjectStarted event.
            </summary>
            <param name="e">A <see cref="T:Microsoft.Build.Framework.BuildEventArgs"/> object containing information about the build event.</param>
            <param name="properties">List of properties</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.OutputEnvironment(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
             Write the environment strings to the console.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.WriteItems(Microsoft.Build.Framework.BuildEventArgs,System.Collections.IEnumerable)">
            <summary>
            Writes out the list of item specs and their metadata.
            This could be done at any time during the build to show the latest
            items, using the cached reference to the list from the 
            appropriate ProjectStarted event.
            </summary>
            <param name="e">A <see cref="T:Microsoft.Build.Framework.BuildEventArgs"/> object containing information about the build event.</param>
            <param name="items">List of items</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs)">
            <summary>
            Handler for target started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Handler for target finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs)">
            <summary>
            Handler for task started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs)">
            <summary>
            Handler for task finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.ErrorHandler(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Prints an error event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.WarningHandler(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Prints a warning event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.MessageHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Prints a message event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.PrintMessage(Microsoft.Build.Framework.BuildMessageEventArgs,System.Boolean)">
            <summary>
            Prints out a message event to the console
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.WriteMessageAligned(System.String,System.Boolean)">
            <summary>
            Writes a message to the console, aligned and formatted to fit within the console width
            </summary>
            <param name="message">Message to be formatted to fit on the console</param>
            <param name="prefixAlreadyWritten">Has the prefix(timestamp or key been written)</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.WriteMessageAligned(System.String,System.Boolean,System.Int32)">
            <summary>
            Writes a message to the console, aligned and formatted to fit within the console width
            </summary>
            <param name="message">Message to be formatted to fit on the console</param>
            <param name="prefixAlreadyWritten">Has the prefix(timestamp or key been written)</param>
            <param name="prefixAdjustment">An amount to adjust the prefix by.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.WriteBasedOnPrefix(System.String,System.Boolean,System.Int32)">
            <summary>
            Write message taking into account whether or not the prefix (timestamp and key) have already been written on the line
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.DisplayDeferredTargetStartedEvent(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Will display the target started event which was deferred until the first visible message for the target is ready to be displayed
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.DisplayDeferredProjectStartedEvent(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Will display the project started event which was deferred until the first visible message for the project is ready to be displayed
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Prints a custom event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.WriteLinePrefix(Microsoft.Build.Framework.BuildEventContext,System.DateTime,System.Boolean)">
            <summary>
            Writes message contextual information for each message displayed on the console
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.GetFullProjectKey(Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Extract the full project key from the BuildEventContext
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.GetPerformanceCounter(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.Build.BackEnd.Logging.BaseConsoleLogger.PerformanceCounter}@)">
            <summary>
            Returns a performance counter for a given scope (either task name or target name)
            from the given table.
            </summary>
            <param name="scopeName">Task name or target name.</param>
            <param name="table">Table that has tasks or targets.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.MPPerformanceCounter">
            <summary>
            Stores and calculates the performance numbers for the different events
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.MPPerformanceCounter.AddEventStarted(System.String,Microsoft.Build.Framework.BuildEventContext,System.DateTime,System.Collections.Generic.IEqualityComparer{Microsoft.Build.Framework.BuildEventContext})">
            <summary>
            Add a started event to the performance counter, by adding the event this sets the start time of the performance counter
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.MPPerformanceCounter.AddEventFinished(System.String,Microsoft.Build.Framework.BuildEventContext,System.DateTime)">
            <summary>
             Add a finished event to the performance counter, so perf numbers can be calculated
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger.MPPerformanceCounter.PrintCounterMessage(Microsoft.Build.BackEnd.Logging.WriteLinePrettyFromResourceDelegate,Microsoft.Build.Logging.ColorSetter,Microsoft.Build.Logging.ColorResetter)">
            <summary>
            Print out the performance counter message
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.LogFormatter">
            <summary>
            Utility helper functions for formatting logger output.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LogFormatter.FormatLogTimeStamp(System.DateTime)">
            <summary>
            Formats the timestamp in the log as  Hours:Minutes:Seconds.Milliseconds
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.LogFormatter.FormatTimeSpan(System.TimeSpan)">
            <summary>
            Formats a timespan for logger output.
            </summary>
            <param name="t"></param>
            <returns>String representation of time-span.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.#ctor(Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Create a logger instance with a specific verbosity.  This logs to
            the default console.
            </summary>
            <param name="verbosity">Verbosity level.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.#ctor(Microsoft.Build.Framework.LoggerVerbosity,Microsoft.Build.Logging.WriteHandler,Microsoft.Build.Logging.ColorSetter,Microsoft.Build.Logging.ColorResetter)">
            <summary>
            Initializes the logger, with alternate output handlers.
            </summary>
            <param name="verbosity"></param>
            <param name="write"></param>
            <param name="colorSet"></param>
            <param name="colorReset"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.ResetConsoleLoggerState">
            <summary>
            Reset the states of per-build member variables
            VSW#516376 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Handler for build started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Handler for build finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.ShowErrorWarningSummary">
            <summary>
            At the end of the build, repeats the errors and warnings that occurred 
            during the build, and displays the error count and warning count.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Handler for project started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Handler for project finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs)">
            <summary>
            Handler for target started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Handler for target finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs)">
            <summary>
            Handler for task started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs)">
            <summary>
            Handler for task finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.ErrorHandler(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Prints an error event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.WarningHandler(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Prints a warning event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.MessageHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Prints a message event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Prints a custom event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.WriteProjectStarted">
            <summary>
            Writes project started messages.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.WriteProjectStartedText(System.String,System.String,System.String,System.Int32)">
            <summary>
            Displays the text for a project started message.
            </summary>
            <param name ="current">current project file</param>
            <param name ="previous">previous project file</param>
            <param name="targetNames">targets that are being invoked</param>
            <param name="indentLevel">indentation level</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.WriteTargetStarted">
            <summary>
            Writes target started messages.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.GetCurrentlyBuildingProjectFile">
            <summary>
            Determines the currently building project file.
            </summary>
            <returns>name of project file currently being built</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.ShowDeferredMessages">
            <summary>
            Displays project started and target started messages that
            are shown only when the associated project or target produces
            output.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.SetErrorsOrWarningsOnCurrentFrame">
            <summary>
            Marks the current frame to indicate that an error or warning
            occurred during it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.VerifyStack(System.Boolean,System.String,System.Object[])">
            <summary>
            Checks the condition passed in.  If it's false, it emits an error message to the console
            indicating that there's a problem with the console logger.  These "problems" should
            never occur in the real world after we ship, unless there's a bug in the MSBuild
            engine such that events aren't getting paired up properly.  So the messages don't
            really need to be localized here, since they're only for our own benefit, and have
            zero value to a customer.
            </summary>
            <param name="condition"></param>
            <param name="unformattedMessage"></param>
            <param name="args"></param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameType">
            <summary>
            This enumeration represents the kinds of context that can be
            stored in the context stack.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame">
            <summary>
            This struct represents context information about a single
            target or project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.#ctor(Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameType,System.Boolean,System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of frame with all fields specified.
            </summary>
            <param name="t">the type of the this frame</param>
            <param name="d">display state. true indicates this frame has been displayed to the user</param>
            <param name="indent">indentation level for this frame</param>
            <param name="s">frame id</param>
            <param name="targets">targets to execute, in the case of a project frame</param>
            <param name="fileOfTarget">the file name where the target is defined</param>
            <param name="parent">parent project file</param>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.type">
            <summary>
            Indicates if project or target frame.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.displayed">
            <summary>
            Set to true to indicate the user has seen a message about this frame.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.indentLevel">
            <summary>
            The number of tabstops to indent this event when it is eventually displayed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.ID">
            <summary>
            A string associated with this frame -- should be a target name
            or a project file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.parentProjectFile">
            <summary>
            For a TargetStarted or a ProjectStarted event, this field tells us
            the name of the *parent* project file that was responsible.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.targetNames">
            <summary>
            Stores the TargetNames from the ProjectStarted event. Null for Target frames.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.file">
            <summary>
            For TargetStarted events, this stores the filename where the Target is defined
            (e.g., Microsoft.Common.targets).  This is different than the project that is 
            being built.  
            For ProjectStarted events, this is null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame.hasErrorsOrWarnings">
            <summary>
            True if there were errors/warnings during the project or target frame.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack">
            <summary>
            The FrameStack class represents a (lifo) stack of Frames.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack._frames">
            <summary>
            The frames member is contained by FrameStack and does
            all the heavy lifting for FrameStack.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack.#ctor">
            <summary>
            Create a new, empty, FrameStack.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack.Pop">
            <summary>
            Remove and return the top element in the stack.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when stack is empty.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack.Peek">
            <summary>
            Returns, but does not remove, the top of the stack.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack.Push(Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.Frame)">
            <summary>
            Push(f) adds f to the top of the stack.
            </summary>
            <param name="f">a frame to push</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack.Count">
            <summary>
            Constant property that indicates the number of elements
            in the stack.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.FrameStack.IsEmpty">
            <summary>
            s.IsEmpty() is true iff s.Count == 0
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Logging.SerialConsoleLogger.contextStack">
            <summary>
            contextStack is the only interesting state in the console
            logger.  The context stack contains a sequence of frames
            denoting current and previous containing projects and targets
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildComponentFactoryCollection">
            <summary>
            Helper class for maintaining the component collection
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentFactoryCollection._componentEntriesByType">
            <summary>
            The build component factories.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentFactoryCollection._host">
            <summary>
            The host used to initialize components.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.#ctor(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.CreationPattern">
            <summary>
            The creation pattern to use for this component.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.CreationPattern.Singleton">
            <summary>
            The component should be created as a singleton.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.CreationPattern.CreateAlways">
            <summary>
            A new instance of the component should be created with every request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.RegisterDefaultFactories">
            <summary>
            Registers the default factories.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.ShutdownComponents">
            <summary>
            Shuts down all factories registered to this component factory collection. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.ShutdownComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Shuts down a specific singleton component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.ReplaceFactory(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.BuildComponentFactoryDelegate)">
            <summary>
            Registers a factory to replace one of the defaults.  Creation pattern is inherited from the original.
            </summary>
            <param name="componentType">The type which is created by this factory.</param>
            <param name="factory">The factory to be registered.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.ReplaceFactory(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.IBuildComponent)">
            <summary>
            Registers a factory to replace one of the defaults.  Creation pattern is inherited from the original.
            </summary>
            <param name="componentType">The type which is created by this factory.</param>
            <param name="instance">The instance to be registered.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.AddFactory(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.BuildComponentFactoryDelegate,Microsoft.Build.BackEnd.BuildComponentFactoryCollection.CreationPattern)">
            <summary>
            Adds a factory.
            </summary>
            <param name="componentType">The type which is created by this factory.</param>
            <param name="factory">Delegate which is responsible for creating the Component.</param>
            <param name="creationPattern">Creation pattern.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.GetComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Gets an instance of the specified component type from the host.
            </summary>
            <param name="type">The component type to be retrieved</param>
            <returns>The component</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry">
            <summary>
            A helper class wrapping build components.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry._factory">
            <summary>
            The factory used to construct instances of the component.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry._singleton">
            <summary>
            The singleton instance for components which adhere to the singleton pattern.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry.#ctor(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.BuildComponentFactoryDelegate,Microsoft.Build.BackEnd.BuildComponentFactoryCollection.CreationPattern)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry.#ctor(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.IBuildComponent)">
            <summary>
            Constructor for existing singleton.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry.ComponentType">
            <summary>
            Retrieves the component type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry.Pattern">
            <summary>
            Retrieves the creation pattern.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry.GetInstance(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Gets an instance of the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.BuildComponentEntry.ShutdownSingletonInstance">
            <summary>
            Shuts down the single instance for this component type.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache">
            <summary>
            Defines a cache for registered task objects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache.DisposeCacheObjects(Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Disposes of all of the objects with the specified lifetime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache.RegisterTaskObject(System.Object,System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime,System.Boolean)">
            <summary>
            Registers a task object with the specified key and lifetime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache.GetRegisteredTaskObject(System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Gets a previously registered task object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache.UnregisterTaskObject(System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Unregisters a task object.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase">
            <summary>
            This is a cache of objects which are registered to be disposed of at a specified time.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.s_appDomainLifetimeObjects">
            <summary>
            The cache for AppDomain lifetime objects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase._buildLifetimeObjects">
            <summary>
            The cache for Build lifetime objects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.#cctor">
            <summary>
            Static constructor which registers a callback to dispose of AppDomain-lifetime cache objects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.DisposeCacheObjects(Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary> 
            Disposes of all of the cached objects registered with the specified lifetime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.RegisterTaskObject(System.Object,System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime,System.Boolean)">
            <summary>
            Registers a task object with the specified key and lifetime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.GetRegisteredTaskObject(System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Gets a previously registered task object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.UnregisterTaskObject(System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Unregisters a previously registered task object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.IsCollectionEmptyOrUncreated(Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Returns true if a collection is not yet created or if it has no content.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.GetCollectionForLifetime(Microsoft.Build.Framework.RegisteredTaskObjectLifetime,System.Boolean)">
            <summary>
            Returns the collection associated with a particular lifetime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.GetLazyCollectionForLifetime(Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Gets the lazy cache for the specified lifetime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase.DisposeObjects(System.Lazy{System.Collections.Concurrent.ConcurrentDictionary{System.Object,System.Object}})">
            <summary>
            Cleans up a cache collection.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache">
            <summary>
            This is a cache of objects which are registered to be disposed of at a specified time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Initialize the build component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache.ShutdownComponent">
            <summary>
            Shuts down the build component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache.Dispose">
            <summary>
            Implementation of Dispose pattern.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Component factory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache.Dispose(System.Boolean)">
            <summary>
            Implementation of Dispose pattern.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Components.Logging.EvaluationLoggingContext">
            <summary>
                Logging context and helpers for evaluation logging
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Components.Logging.EvaluationLoggingContext.LogProjectEvaluationFinished">
            <summary>
            Log that the project has finished
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.CallTarget">
            <remarks>
            This class implements the "CallTarget" task, which invokes other targets within the same
            project file.  Marked RunInMTA because we do not want this task to ever be invoked explicitly
            on the STA if the RequestBuilder is running on another thread, as this will cause thread
            id validation checks to fail.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.CallTarget._logHelper">
            <summary>
            The task logging helper
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.CallTarget.Targets">
            <summary>
            A list of targets to build.  This is a required parameter.  If you want to build the 
            default targets, use the <see cref="T:Microsoft.Build.BackEnd.MSBuild"/> task and pass in Projects=$(MSBuildProjectFile).
            </summary>
            <value>Array of target names.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.CallTarget.TargetOutputs">
            <summary>
            Outputs of the targets built in each project.
            </summary>
            <value>Array of output items.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.CallTarget.RunEachTargetSeparately">
            <summary>
            When this is true, instead of calling the engine once to build all the targets (for each project),
            we would call the engine once per target (for each project).  The benefit of this is that
            if one target fails, you can still continue with the remaining targets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.CallTarget.UseResultsCache">
            <summary>
            Deprecated. Does nothing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.CallTarget.HostObject">
            <summary>
            The host object, from ITask
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.CallTarget.ExecuteInternal">
            <summary>
            Instructs the MSBuild engine to build one or more targets in the current project.
            </summary>
            <returns>true if all targets built successfully; false if any target fails</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IntrinsicTaskFactory">
            <summary>
            The factory
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTaskFactory.#ctor(System.Type)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IntrinsicTaskFactory.FactoryName">
            <summary>
            Returns the factory name
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IntrinsicTaskFactory.TaskType">
            <summary>
            Returns the task type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTaskFactory.Initialize(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Initialize the factory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTaskFactory.GetTaskParameters">
            <summary>
            Gets all of the parameters on the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Creates an instance of the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask)">
            <summary>
            Cleanup for the task.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ItemGroupLoggingHelper">
            <summary>
            Helper class to convert ItemGroup parameters to a string value for logging.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemGroupLoggingHelper.parameterCharacterLimit">
            <summary>
            The default character limit for logging parameters. 10k is somewhat arbitrary, see https://github.com/microsoft/msbuild/issues/4907.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemGroupLoggingHelper.parameterLimit">
            <summary>
            The default parameter limit for logging. 200 is somewhat arbitrary, see https://github.com/microsoft/msbuild/pull/5210.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupLoggingHelper.GetParameterText(System.String,System.String,System.Object[])">
            <summary>
            Gets a text serialized value of a parameter for logging.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupLoggingHelper.GetParameterText(System.String,System.String,System.Collections.IList)">
            <summary>
            Gets a text serialized value of a parameter for logging.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupLoggingHelper.GetStringFromParameterValue(System.Object)">
            <summary>
            Given an object wrapping a scalar value that will be set on a task,
            returns a suitable string to log its value, with a trailing newline.
            First line is already indented.
            Indent of any subsequent line should be 12 spaces.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.MSBuild">
            <remarks>
            This class implements the "MSBuild" task, which hands off child project files to the MSBuild engine to be built.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.BackEnd.MSBuild.SkipNonexistentProjectsBehavior">
            <summary>
            Enum describing the behavior when a project doesn't exist on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.MSBuild.SkipNonexistentProjectsBehavior.Skip">
            <summary>
            Skip the project if there is no file on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.MSBuild.SkipNonexistentProjectsBehavior.Error">
            <summary>
            Error if the project does not exist on disk.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.MSBuild.SkipNonexistentProjectsBehavior.Build">
            <summary>
            Build even if the project does not exist on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.BuildEngine">
            <inheritdoc />
            <summary>
            The build engine, from ITask
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.HostObject">
            <inheritdoc />
            <summary>
            The host object, from ITask
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.Properties">
            <summary>
            A list of property name/value pairs to apply as global properties to 
            the child project.  
            A typical input: "propname1=propvalue1", "propname2=propvalue2", "propname3=propvalue3".
            </summary>
            <remarks>
            The fact that this is a string[] makes the following illegal:
                <MSBuild
                    Properties="TargetPath=@(OutputPathItem)" />
            The engine fails on this because it doesn't like item lists being concatenated with string
            constants when the data is being passed into an array parameter.  So the workaround is to 
            write this in the project file:
                <MSBuild
                    Properties="@(OutputPathItem->'TargetPath=%(Identity)')" />
            </remarks>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.RemoveProperties">
            <summary>
            Gets or sets a semicolon-delimited list of global properties to remove.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.Targets">
            <summary>
            The targets to build in each project specified by the <see cref="P:Microsoft.Build.BackEnd.MSBuild.Projects"/> property.
            </summary>
            <value>Array of target names.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.Projects">
            <summary>
            The projects to build.
            </summary>
            <value>Array of project items.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.TargetOutputs">
            <summary>
            Outputs of the targets built in each project.
            </summary>
            <value>Array of output items.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.RebaseOutputs">
            <summary>
            Indicates if the paths of target output items should be rebased relative to the calling project.
            </summary>
            <value>true, if target output item paths should be rebased</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.StopOnFirstFailure">
            <summary>
            Forces the task to stop building the remaining projects as soon as any of
            them fail.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.RunEachTargetSeparately">
            <summary>
            When this is true, instead of calling the engine once to build all the targets (for each project),
            we would call the engine once per target (for each project).  The benefit of this is that
            if one target fails, you can still continue with the remaining targets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.ToolsVersion">
            <summary>
            Value of ToolsVersion to use when building projects passed to this task.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.BuildInParallel">
            <summary>
            When this is true we call the engine with all the projects at once instead of 
            calling the engine once per project
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.UnloadProjectsOnCompletion">
            <summary>
            If true the project will be unloaded once the operation is completed
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.UseResultsCache">
            <summary>
            Deprecated. Does nothing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.SkipNonexistentProjects">
            <summary>
            When this is true, project files that do not exist on the disk will be skipped. By default,
            such projects will cause an error.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.TargetAndPropertyListSeparators">
            <summary>
            Un-escape Targets, Properties (including Properties and AdditionalProperties as Project item metadata)
            will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will 
            be treated as if it were an un-escaped ';'
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.MSBuild.SkipNonexistentTargets">
            <summary>
            If set, MSBuild will skip the targets specified in this build request if they are not defined in the
            <see cref="P:Microsoft.Build.BackEnd.MSBuild.Projects"/> to build. This only applies to this build request (if another target calls the
            "missing target" later this will still result in an error).
            <remarks>
            This could be useful when implementing a breaking protocol change between projects or stubbing behavior 
            which may not make sense in all project types (e.g. Restore).
            </remarks>
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.MSBuild.ExecuteInternal">
            <summary>
            Instructs the MSBuild engine to build one or more project files whose locations are specified by the
            <see cref="P:Microsoft.Build.BackEnd.MSBuild.Projects"/> property.
            </summary>
            <returns>true if all projects build successfully; false if any project fails</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.MSBuild.BuildProjectsInParallel(System.Collections.Generic.Dictionary{System.String,System.String},System.String[],System.Collections.Generic.List{System.String[]},System.Boolean,System.Boolean[])">
            <summary>
            Build projects which have not been skipped. This will be done in parallel
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.MSBuild.ExpandAllTargetsAndProperties">
            <summary>
            Expand and re-construct arrays of all targets and properties
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulableRequestState">
            <summary>
            The state enumeration for SchedulableRequests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequestState.Unscheduled">
            <summary>
            This request has been submitted but has never been scheduled so it has executed no tasks and does not currently have an
            entry residing on any node.  There may be multiple requests with the same global request id in this state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequestState.Ready">
            <summary>
            This request may continue executing.  It already has an entry on a node.  There may only ever be one request with a given
            global request id in this state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequestState.Executing">
            <summary>
            This request is currently executing tasks on its node.  In this case it will be the only task executing on the node -
            all other tasks are either Ready or Blocked.  There may only ever be one request with a given global request id in this state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequestState.Blocked">
            <summary>
            This request is currently blocked on one or more requests which must complete before it may continue.  There may only ever be one
            request with a given global request id in this state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequestState.Yielding">
            <summary>
            This request has yielded control of the node while it is running a long-running out-of-process program.  Any number of tasks on a 
            node may be in the yielding state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequestState.Completed">
            <summary>
            This request has completed and removed from the system.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulableRequest">
            <summary>
            A representation of a BuildRequest and associated data used by the Scheduler to track work being done by the build system.
            SchedulableRequests implicitly form a directed acyclic graph showing the blocking/blocked relationship between the requests
            known to the system at any given time.  These associations are updated by the BlockByRequest, UnblockWithResult and ResumeExecution
            methods.  These methods, along with Complete, cause state changes which the SchedulingData object will record.  That data can be
            queried to determine the state of any request or node in the system.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._schedulingData">
            <summary>
            The request collection to which this belongs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._assignedNodeId">
            <summary>
            The node to which this request is assigned.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._request">
            <summary>
            The BuildRequest this class represents.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._parent">
            <summary>
            The schedulable request which issued this request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._activeTargetsWhenBlocked">
            <summary>
            The list of targets which were actively building at the time we were blocked.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._requestsWeAreBlockedBy">
            <summary>
            The requests which must complete before we can continue executing.  Indexed by global request id and node request id.
            Each global request id may have multiple requests which map to it, but they will have separate node request ids.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._requestsWeAreBlocking">
            <summary>
            The requests which cannot continue until we have finished executing.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._creationTime">
            <summary>
            The time this request was created.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._startTime">
            <summary>
            The time this request started building.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._endTime">
            <summary>
            The time this request was completed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest._timeRecords">
            <summary>
            Records of the amount of time spent in each of the states.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.#ctor(Microsoft.Build.BackEnd.SchedulingData,Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.State">
            <summary>
            The current state of the request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.BuildRequest">
            <summary>
            The underlying BuildRequest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.Parent">
            <summary>
            The request which issued this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.AssignedNode">
            <summary>
            Returns the node to which this request is assigned.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.ActiveTargets">
            <summary>
            The set of active targets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.BlockingTarget">
            <summary>
            The target we are blocked on
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.RequestsWeAreBlockedByCount">
            <summary>
            Gets a count of the requests we are blocked by.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.RequestsWeAreBlockedBy">
            <summary>
            Gets the set of requests for which we require results before we may proceed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.RequestsWeAreBlockingCount">
            <summary>
            Gets a count of the requests we are blocking.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.RequestsWeAreBlocking">
            <summary>
            Gets the set of requests which cannot proceed because they are waiting for results from us.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.CreationTime">
            <summary>
            The time this request was created.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.StartTime">
            <summary>
            The time this request started building.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulableRequest.EndTime">
            <summary>
            The time this request was completed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.GetTimeSpentInState(Microsoft.Build.BackEnd.SchedulableRequestState)">
            <summary>
            Gets the amount of time we spent in the specified state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.Yield(System.String[])">
            <summary>
            Inticates the request is yielding the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.Reacquire">
            <summary>
            Indicates the request is ready to reacquire the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.BlockByRequest(Microsoft.Build.BackEnd.SchedulableRequest,System.String[],System.String)">
            <summary>
            Marks this request as being blocked by the specified request.  Establishes the correct relationships between the requests.
            </summary>
            <param name="blockingRequest">The request which is blocking this one.</param>
            <param name="activeTargets">The list of targets this request was currently building at the time it became blocked.</param>
            <param name="blockerBlockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.UnblockWithPartialResultForBlockingTarget(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Indicates that there are partial results (project producing the result is still running) which can be used to unblock this request.  Updates the relationships between requests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.UnblockWithResult(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Indicates that there are results which can be used to unblock this request.  Updates the relationships between requests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.ResumeExecution(System.Int32)">
            <summary>
            Resumes execution of the request on the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.Complete(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Completes this request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.Delete">
            <summary>
            Removes an unscheduled request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.VerifyState(Microsoft.Build.BackEnd.SchedulableRequestState)">
            <summary>
            Verifies that the current state is as expected.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.VerifyOneOfStates(Microsoft.Build.BackEnd.SchedulableRequestState[])">
            <summary>
            Verifies that the current state is as expected.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.ChangeToState(Microsoft.Build.BackEnd.SchedulableRequestState)">
            <summary>
            Change to the specified state.  Update internal counters.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.DetectCircularDependency(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Detects a circular dependency.  Throws a CircularDependencyException if one exists.  Circular dependencies can occur
            under the following conditions:
            1. If the blocking request's global request ID appears in the ancestor chain (Direct).
            2. If a request appears in the ancestor chain and has a different global request ID but has an active target that
               matches one of the targets specified in the blocking request (Direct).
            3. If the blocking request exists elsewhere as a blocked request with the same global request ID, and one of its children
               (recursively) matches this request's global request ID (Indirect).
            4. If the blocking request's configuration is part of another request elsewhere which is also blocked, and that request
               is building targets this blocking request is building, and one of that blocked request's children (recursively)
               matches this request's global request ID (Indirect).
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.DetectIndirectCircularDependency(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Detects a circular dependency where the request which is about to block us is already blocked by us, usually as a result
            of it having been previously scheduled in a multiproc scenario, but before this request was able to execute.
            </summary>
            <remarks>
            Let A be 'this' project and B be 'blockingRequest' (the request which is going to block A.)  
            An indirect circular dependency exists if there is a dependency path from B to A.  If there is no 
            existing blocked request B' with the same global request id as B, then there can be no path from B to A because B is a brand new 
            request with no other dependencies.  If there is an existing blocked request B' with the same global request ID as B, then we 
            walk the set of dependencies recursively searching for A.  If A is found, we have a circular dependency.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.ThrowIndirectCircularDependency(Microsoft.Build.BackEnd.SchedulableRequest,Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Build our ancestor list then throw the circular dependency error.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.DetectDirectCircularDependency(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Detects a circular dependency where the blocking request is in our direct ancestor chain.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.CleanupForCircularDependencyAndThrow(Microsoft.Build.BackEnd.SchedulableRequest,System.Collections.Generic.List{Microsoft.Build.BackEnd.SchedulableRequest})">
            <summary>
            Removes associations with all blocking requests and throws an exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.DisconnectRequestWeAreBlockedBy(Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey)">
            <summary>
            Removes the association between this request and the one we are blocked by.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey">
            <summary>
            A key for blocking requests combining the global request and node request ids.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey._globalRequestId">
            <summary>
            The global request id.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey._nodeRequestId">
            <summary>
            The request id known to the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey.#ctor(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Constructor over a request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey.#ctor(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Constructor over a result.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey.Equals(System.Object)">
            <summary>
            Equals override.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulableRequest.BlockingRequestKey.GetHashCode">
            <summary>
            GetHashCode override.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulingData">
            <summary>
            This class manages the set of schedulable requests.  In concert with SchedulableRequest, it tracks all relationships
            between requests in the system, verifies state change validity and provides efficient methods for querying request relationships.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._executingRequests">
            <summary>
            Maps global request Id to an executing request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._blockedRequests">
            <summary>
            Maps global request Id to a blocked request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._yieldingRequests">
            <summary>
            Maps global request Id to a blocked request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._readyRequests">
            <summary>
            Maps global request Id to a ready request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._unscheduledRequests">
            <summary>
            Holds all of the unscheduled requests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._unscheduledRequestNodesByRequest">
            <summary>
            Maps a schedulable request directly to the node holding it in the linked list.  This allows us to perform an O(1) operation to
            remove the node from the linked list without exposing the list directly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._scheduledRequestsByNode">
            <summary>
            Maps node id to the requests scheduled on it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._executingRequestByNode">
            <summary>
            Maps a node id to the currently executing request, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._readyRequestsByNode">
            <summary>
            Maps a node id to those requests which are ready to execute, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._configurationsByNode">
            <summary>
            Maps a node id to the set of configurations assigned to it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._configurationToNode">
            <summary>
            Maps a configuration id to the node to which it is assigned.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._configurationToRequests">
            <summary>
            Maps a configuration id to the requests which apply to it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._buildHierarchy">
            <summary>
            This is the hierarchy of build requests as they were created.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._buildEvents">
            <summary>
            The sequence of events which have taken place during this build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData._currentEventTime">
            <summary>
            The current time for events.  This is set by the scheduler when it does a scheduling cycle in response to an event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.BuildEvents">
            <summary>
            Retrieves all of the build events.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.ExecutingRequests">
            <summary>
            Retrieves all of the executing requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.ExecutingRequestsCount">
            <summary>
            Gets a count of all executing requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.ReadyRequests">
            <summary>
            Retrieves all of the ready requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.ReadyRequestsCount">
            <summary>
            Gets a count of all the ready requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.BlockedRequests">
            <summary>
            Retrieves all of the blocked requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.BlockedRequestsCount">
            <summary>
            Gets a count of all of the blocked requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.YieldingRequests">
            <summary>
            Retrieves all of the yielded requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.YieldingRequestsCount">
            <summary>
            Gets a count of all of the yielded requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.UnscheduledRequests">
            <summary>
            Retrieves all of the unscheduled requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.UnscheduledRequestsCount">
            <summary>
            Gets a count of all the unscheduled requests.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.UnscheduledRequestsWhichCanBeScheduled">
            <summary>
            Enumerates the unscheduled requests which don't have other instances scheduled already.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.Configurations">
            <summary>
            Gets all of the configurations for this build.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.EventTime">
            <summary>
            Gets or sets the current event time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.CreateRequest(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Creates a new request and adds it to the system
            </summary>
            <remarks>
            New requests always go on the front of the queue, because we prefer to build the projects we just received first (depth first, absent
            any particular scheduling algorithm such as in the single-proc case.)
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.UpdateFromState(Microsoft.Build.BackEnd.SchedulableRequest,Microsoft.Build.BackEnd.SchedulableRequestState)">
            <summary>
            Updates the state of the specified request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetRequestsAssignedToConfiguration(System.Int32)">
            <summary>
            Gets the requests assigned to a particular configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetRequestsAssignedToConfigurationCount(System.Int32)">
            <summary>
            Retrieves the number of requests which exist in the system that are attributed to the specified configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetExecutingRequest(System.Int32)">
            <summary>
            Retrieves a request which is currently executing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetBlockedRequest(System.Int32)">
            <summary>
            Retrieves a request which is currently blocked.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetBlockedRequestIfAny(System.Int32)">
            <summary>
            Retrieves a request which is currently blocked, or null if there is none.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetYieldingRequest(System.Int32)">
            <summary>
            Retrieves a request which is currently yielding.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetReadyRequest(System.Int32)">
            <summary>
            Retrieves a request which is ready to continue executing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetScheduledRequest(System.Int32)">
            <summary>
            Retrieves a request which has been assigned to a node and is in the executing, blocked or ready states.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.IsNodeWorking(System.Int32)">
            <summary>
            Returns true if the specified node has an executing request, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetConfigurationsCountByNode(System.Int32,System.Boolean,Microsoft.Build.BackEnd.IConfigCache)">
            <summary>
            Returns the number of configurations assigned to the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetExecutingRequestByNode(System.Int32)">
            <summary>
            Gets the request currently executing on the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.IsRequestScheduled(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Determines if the specified request is currently scheduled.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetScheduledRequestsCountByNode(System.Int32)">
            <summary>
            Retrieves the count all of the requests scheduled to the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetScheduledRequestsByNode(System.Int32)">
            <summary>
            Retrieves all of the requests scheduled to the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetReadyRequestsByNode(System.Int32)">
            <summary>
            Retrieves all of the ready requests on the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetRequestsByHierarchy(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Retrieves a set of build requests which have the specified parent.  If root is null, this will retrieve all of the 
            top-level requests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.GetAssignedNodeForRequestConfiguration(System.Int32)">
            <summary>
            Returns the node id to which this request should be assigned based on its configuration.
            </summary>
            <returns>The node if one has been assigned for this configuration, otherwise -1.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.CanScheduleRequestToNode(Microsoft.Build.BackEnd.SchedulableRequest,System.Int32)">
            <summary>
            Returns true if the request can be scheduled to the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.UnassignNodeForRequestConfiguration(System.Int32)">
            <summary>
            Unassigns the node associated with a particular configuration.
            </summary>
            <remarks>
            The operation is only valid when there are no scheduled requests for this configuration.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.InternalGetScheduledRequestByGlobalRequestId(System.Int32)">
            <summary>
            Gets a schedulable request with the specified global request id if it is currently scheduled.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.ExpectScheduledRequestState(System.Int32,Microsoft.Build.BackEnd.SchedulableRequestState)">
            <summary>
            Verifies that the request is scheduled and in the expected state.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent">
            <summary>
            A scheduling event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent._eventTime">
            <summary>
            The time the event took place.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent._request">
            <summary>
            The request involved in the event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent._oldState">
            <summary>
            The state of the request before the event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent._newState">
            <summary>
            The state of the request as a result of the event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent.#ctor(System.DateTime,Microsoft.Build.BackEnd.SchedulableRequest,Microsoft.Build.BackEnd.SchedulableRequestState,Microsoft.Build.BackEnd.SchedulableRequestState)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent.EventTime">
            <summary>
            The time the event took place.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent.Request">
            <summary>
            The request involved in the event.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent.OldState">
            <summary>
            The state of the request before the event.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingData.SchedulingEvent.NewState">
            <summary>
            The state of the request as a result of the event.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Scheduler">
            <summary>
            The MSBuild Scheduler
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler.InvalidNodeId">
            <summary>
            The invalid node id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler.ResultsTransferredId">
            <summary>
            ID used to indicate that the results for a particular configuration may at one point 
            have resided on this node, but currently do not and will need to be transferred back 
            in order to be used.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler.InProcNodeId">
            <summary>
            The in-proc node id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler.VirtualNode">
            <summary>
            The virtual node, used when a request is initially given to the scheduler.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler.DefaultCustomSchedulerForSQLConfigurationLimitMultiplier">
            <summary>
            If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the default multiplier for the amount by which 
            the count of configurations on any one node can exceed the average configuration count is 1.1 -- 
            + 10%.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._schedulingUnlimitedVariable">
            <summary>
            Content of the environment variable  MSBUILDSCHEDULINGUNLIMITED
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._schedulingUnlimited">
            <summary>
            If MSBUILDSCHEDULINGUNLIMITED is set, this flag will make AtSchedulingLimit() always return false
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._nodeLimitOffset">
            <summary>
            If MSBUILDNODELIMITOFFSET is set, this will add an offset to the limit used in AtSchedulingLimit()
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._availableNodes">
            <summary>
            { nodeId -> NodeInfo }
            A list of nodes we know about.  For the non-distributed case, there will be no more nodes than the
            maximum specified on the command-line.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._currentInProcNodeCount">
            <summary>
            The number of inproc nodes that can be created without hitting the 
            node limit.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._currentOutOfProcNodeCount">
            <summary>
            The number of out-of-proc nodes that can be created without hitting the 
            node limit.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._schedulingData">
            <summary>
            The collection of all requests currently known to the system.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._componentHost">
            <summary>
            The component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._configCache">
            <summary>
            The configuration cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._resultsCache">
            <summary>
            The results cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._nextGlobalRequestId">
            <summary>
             The next ID to assign for a global request id.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._debugDumpState">
            <summary>
            Flag indicating that we are supposed to dump the scheduler state to the disk periodically.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._forceAffinityOutOfProc">
            <summary>
            Flag used for debugging by forcing all scheduling to go out-of-proc.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._debugDumpPath">
            <summary>
            The path into which debug files will be written.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._customSchedulerForSQLConfigurationLimitMultiplier">
            <summary>
            If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the user may also choose to set 
            MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER to the value by which they want 
            the max configuration count for any one node to exceed the average configuration count.  
            If that env var is not set, or is set to an invalid value (negative, less than 1, non-numeric)
            then we use the default value instead.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._schedulingPlan">
            <summary>
            The plan.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Scheduler._customRequestSchedulingAlgorithm">
            <summary>
            If MSBUILDCUSTOMSCHEDULER is set, contains the requested scheduling algorithm
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsDelegate">
            <summary>
            In the circumstance where we want to specify the scheduling algorithm via the secret environment variable 
            MSBUILDCUSTOMSCHEDULING, the scheduling algorithm used will be assigned to a delegate of this type. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Scheduler.MinimumAssignableConfigurationId">
            <summary>
            Retrieves the minimum configuration id which can be assigned that won't conflict with those in the scheduling plan.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.IsCurrentlyBuildingConfiguration(System.Int32)">
            <summary>
            Returns true if the specified configuration is currently in the scheduler.
            </summary>
            <param name="configurationId">The configuration id</param>
            <returns>True if the specified configuration is already building.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.GetConfigurationIdFromPlan(System.String)">
            <summary>
            Gets a configuration id from the plan which matches the specified path.
            </summary>
            <param name="configPath">The path.</param>
            <returns>The configuration id which has been assigned to this path.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ReportRequestBlocked(System.Int32,Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Reports that the specified request has become blocked and cannot proceed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ReportResult(System.Int32,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Informs the scheduler of a specific result.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ReportNodesCreated(System.Collections.Generic.IEnumerable{Microsoft.Build.BackEnd.NodeInfo})">
            <summary>
            Signals that a node has been created.
            </summary>
            <param name="nodeInfos">Information about the nodes which were created.</param>
            <returns>A new set of scheduling actions to take.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ReportBuildAborted(System.Int32)">
            <summary>
            Signals that the build has been aborted by the specified node.
            </summary>
            <param name="nodeId">The node which reported the failure.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.Reset">
            <summary>
            Resets the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.WriteDetailedSummary(System.Int32)">
            <summary>
            Writes out the detailed summary of the build.
            </summary>
            <param name="submissionId">The id of the submission which is at the root of the build.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Initializes the component with the specified component host.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ShutdownComponent">
            <summary>
            Shuts down the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Factory for component construction.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.HandleYieldAction(Microsoft.Build.BackEnd.SchedulableRequest,Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Updates the state of a request based on its desire to yield or reacquire control of its node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ScheduleUnassignedRequests(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Attempts to schedule unassigned requests to free nodes.
            </summary>
            <param name="responses">The list which should be populated with responses from the scheduling.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsToNodes(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Determines which requests to assign to available nodes.
            </summary>
            <remarks>
            This is where all the real scheduling decisions take place.  It should not be necessary to edit functions outside of this
            to alter how scheduling occurs.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.GetSchedulingPlanAndAlgorithm">
            <summary>
            Reads in the scheduling plan if one exists and has not previously been read; returns true if the scheduling plan 
            both exists and is valid, or false otherwise. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsWithPlanByMostImmediateReferences(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests to nodes based on those which refer to the most other projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsWithPlanByGreatestPlanTime(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests to nodes based on those which have the most plan time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsByTraversalsFirst(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests preferring those which are traversal projects as determined by filename.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.IsTraversalRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Returns true if the request is for a traversal project.  Traversals are used to find more work.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsWithConfigurationCountLevelling(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests to nodes attempting to ensure each node has the same number of configurations assigned to it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsWithSmallestFileSize(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests with the smallest file sizes first.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsWithLargestFileSize(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests with the largest file sizes first.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsWithMaxWaitingRequests(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests preferring the ones which have the most other requests waiting on them using the transitive closure.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsWithMaxWaitingRequests2(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests preferring those with the most requests waiting on them, but only counting those requests which are
            directly waiting, as opposed to the transitive closure.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsFIFO(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Assigns requests on a first-come, first-serve basis.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestsUsingCustomSchedulerForSQL(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Custom scheduler for the SQL folks to solve a performance problem with their builds where they end up with a few long-running 
            requests on all but one node, and then a very large number of short-running requests on that one node -- which is by design for 
            our current scheduler, but makes it so that later in the build, when these configurations are re-entered with new requests, the 
            build becomes essentially serial because so many of the configurations are tied to that one node.  
            
            Fixes that problem by intentionally choosing to refrain from assigning new configurations to idle nodes if those idle nodes already 
            have more than their fair share of the existing configurations assigned to them. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignUnscheduledRequestToNode(Microsoft.Build.BackEnd.SchedulableRequest,System.Int32,System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Assigns the specified request to the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AtSchedulingLimit">
            <summary>
            Returns true if we are at the limit of work we can schedule.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.CanScheduleRequestToNode(Microsoft.Build.BackEnd.SchedulableRequest,System.Int32)">
            <summary>
            Returns true if a request can be scheduled to a node, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.CreateNewNodeIfPossible(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Collections.Generic.IEnumerable{Microsoft.Build.BackEnd.SchedulableRequest})">
            <summary>
            Adds CreateNode responses to satisfy all the affinities in the list of requests, with the following constraints:
            
            a) Issue no more than one response to create an inproc node, and aggressively issues as many requests for an out-of-proc node
               as there are requests to assign to them. 
               
            b) Don't exceed the max node count, *unless* there isn't even one node of the necessary affinity yet. (That means that even if there's a max
               node count of e.g., 3, and we have already created 3 out of proc nodes, we will still create an inproc node if affinity requires it; if 
               we didn't, the build would jam.)
               
            Returns true if there is a pending response to create a new node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.MarkRequestAborted(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Marks the specified request and all of its ancestors as having aborted.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.HandleRequestBlockedOnInProgressTarget(Microsoft.Build.BackEnd.SchedulableRequest,Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Marks the request as being blocked by another request which is currently building a target whose results we need to proceed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.HandleRequestBlockedOnResultsTransfer(Microsoft.Build.BackEnd.SchedulableRequest,System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Marks the parent as blocked waiting for results from a results transfer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.HandleRequestBlockedByNewRequests(Microsoft.Build.BackEnd.SchedulableRequest,Microsoft.Build.BackEnd.BuildRequestBlocker,System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Marks the request as being blocked by new requests whose results we must get before we can proceed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ResumeReadyRequestIfAny(System.Int32,System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Resumes executing a request which was in the Ready state for the specified node, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ResolveRequestFromCacheAndResumeIfPossible(Microsoft.Build.BackEnd.SchedulableRequest,System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Attempts to get results from the cache for this request.  If results are available, reports them to the 
            correct node.  If that action causes the parent to become ready and its node is idle, the parent is
            resumed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ResumeRequiredWork(System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Determines which work is available which must be assigned to the nodes.  This includes:
            1. Ready requests - those requests which can immediately resume executing.
            2. Requests which can continue because results are now available but we haven't distributed them.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.TrySatisfyRequestFromCache(System.Int32,Microsoft.Build.BackEnd.BuildRequest,System.Boolean)">
            <summary>
            Attempts to get a result from the cache to satisfy the request, and returns the appropriate response if possible.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(System.Int32,Microsoft.Build.BackEnd.BuildRequest,System.Collections.Generic.List{Microsoft.Build.BackEnd.ScheduleResponse},System.Action{Microsoft.Build.BackEnd.Logging.ILoggingService}@)">
            <returns>True if caches misses are allowed, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.GetResponseForResult(System.Int32,Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Gets the appropriate ScheduleResponse for a result, either to complete a submission or to report to a node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.LogRequestHandledFromCache(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Logs the project started/finished pair for projects which are skipped entirely because all
            of their results are available in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ComputeClosureOfWaitingRequests(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            This method determines how many requests are waiting for this request, taking into account the full tree of all requests
            in all dependency chains which are waiting.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.GetNodeAffinityForRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Gets the node affinity for the specified request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.RequestOrAnyItIsBlockedByCanBeServiced(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Iterates through the set of available nodes and checks whether any of them is 
            capable of servicing this request or any of the requests that it is blocked 
            by (regardless of whether they are currently available to do so).
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.AssignGlobalRequestId(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Determines if we have a matching request somewhere, and if so, assigns the same request ID.  Otherwise
            assigns a new request id.
            </summary>
            <remarks>
            UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the 
            requests to find a matching one.  A HashSet with proper equality semantics and a good hash code for the BuildRequest
            would speed this considerably, especially for large numbers of projects in a build.
            </remarks>
            <param name="request">The request whose ID should be assigned</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.WriteNodeUtilizationGraph(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.Boolean)">
            <summary>
            Writes the graph representation of how the nodes were utilized.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.WriteNodeUtilizationGraphLine(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.Int32[],System.Int32[],System.DateTime,System.DateTime,System.Int32,System.Double@)">
            <summary>
            Writes a single line of node utilization information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.WriteRecursiveSummary(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.Int32,Microsoft.Build.BackEnd.SchedulableRequest,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Recursively dumps the build information for the specified hierarchy
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.TraceScheduler(System.String,System.Object[])">
            <summary>
            Method used for debugging purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.DumpSchedulerState">
            <summary>
            Dumps the current state of the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.DumpConfigurations">
            <summary>
            Dumps all of the configurations.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.DumpRequests">
            <summary>
            Dumps all of the requests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.DumpRequestHierarchy(System.IO.StreamWriter,Microsoft.Build.BackEnd.SchedulableRequest,System.Int32)">
            <summary>
            Dumps the hierarchy of requests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.DumpRequestState(System.IO.StreamWriter,Microsoft.Build.BackEnd.SchedulableRequest,System.Int32)">
            <summary>
            Dumps the state of a request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.DumpRequestSpec(System.IO.StreamWriter,Microsoft.Build.BackEnd.SchedulableRequest,System.Int32,System.String)">
            <summary>
            Dumps detailed information about a request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.WriteSchedulingPlan(System.Int32)">
            <summary>
            Write out the scheduling information so the next time we can read the plan back in and use it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Scheduler.ReadSchedulingPlan(System.Int32)">
            <summary>
            Retrieves the scheduling plan from the previous run.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulerCircularDependencyException">
            <summary>
            Exception thrown when a circular dependency is detected in the Scheduler.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulerCircularDependencyException._ancestors">
            <summary>
            The ancestors which led to this circular dependency.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulerCircularDependencyException._request">
            <summary>
            The request which caused the circular dependency.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulerCircularDependencyException.#ctor(Microsoft.Build.BackEnd.BuildRequest,System.Collections.Generic.IList{Microsoft.Build.BackEnd.SchedulableRequest})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulerCircularDependencyException.Ancestors">
            <summary>
            Gets an enumeration of the ancestors which led to this circular dependency.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulerCircularDependencyException.Request">
            <summary>
            Gets the request which caused the circular dependency.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ScheduleTimeRecord">
            <summary>
            Class used to track time accumulated during scheduling.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleTimeRecord._startTimeForCurrentState">
            <summary>
            The time the current counter started.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleTimeRecord._accumulatedTime">
            <summary>
            The accumulated time for this counter.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleTimeRecord.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ScheduleTimeRecord.AccumulatedTime">
            <summary>
            Retrieve the accumulated time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleTimeRecord.StartState(System.DateTime)">
            <summary>
            Start the timer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleTimeRecord.EndState(System.DateTime)">
            <summary>
            End the timer and update the accumulated time.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulingPlan">
            <summary>
            A SchedulingPlan contains timing and relationship information for a build which has already occurred.  This data can then be
            used by subsequent builds to determine how best to distribute work among several nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan._configCache">
            <summary>
            The configuration cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan._schedulingData">
            <summary>
            The active scheduling data.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan._configPathToData">
            <summary>
            Mapping of project full paths to plan configuration data.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan._configIdToData">
            <summary>
            Mapping of configuration ids to plan configuration data.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan._configIdToPaths">
            <summary>
            Mapping of configuration ids to the set of configurations which were traversed to get to this configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.#ctor(Microsoft.Build.BackEnd.IConfigCache,Microsoft.Build.BackEnd.SchedulingData)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.IsPlanValid">
            <summary>
            Returns true if a valid plan was read, false otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.MaximumConfigurationId">
            <summary>
            Returns the largest configuration id known to the plan.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.WritePlan(System.Int32,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Writes a plan for the specified submission id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.ReadPlan(System.Int32,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Reads a plan for the specified submission Id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.GetConfigIdForPath(System.String)">
            <summary>
            Returns the config id for the config specified by the path, if any.
            </summary>
            <returns>The config id if one exists, otherwise BuildRequestConfiguration.InvalidConfigurationId</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.GetConfigWithGreatestNumberOfReferences(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Given a list of configuration IDs, returns the id of the config with the greatest number of immediate references.
            </summary>
            <param name="configsToSchedule">The set of configurations to consider.</param>
            <returns>The id of the configuration with the most immediate references.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.GetConfigWithGreatestPlanTime(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Given a list of real configuration IDs, returns the id of the config with the largest plan time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.GetReferencesCountForConfigByPath(System.String)">
            <summary>
            Determines how many references a config with a particular path has.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.VisitConfig(System.String)">
            <summary>
            Advances the state of the plan by removing the specified config from all paths
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.CompleteConfig(System.String)">
            <summary>
            Advances the state of the plan by zeroing out the time spend on the config.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.GetPlanName(Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Gets the name of the plan file for a specified submission.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.GetConfigWithComparison(System.Collections.Generic.IEnumerable{System.Int32},System.Comparison{Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData})">
            <summary>
            Returns the config id with the greatest value according to the comparer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.AnalyzeData">
            <summary>
            Analyzes the plan data which has been read.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.DetermineConfigsWithGreatestPlanTime">
            <summary>
            Writes out configuration in order of the greatest total plan time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.DetermineConfigsWithTheMostImmediateReferences">
            <summary>
            Writes out configs in order of most immediate references.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.DetermineConfigsByNumberOfOccurrences">
            <summary>
            Writes out configs in order of how often they are seen in the hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.DoRecursiveAnalysis">
            <summary>
            This method finds all of the paths which lead to any given project
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.RecursiveVisitNodes(Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData,System.Collections.Generic.Stack{Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData})">
            <summary>
            Recursively visits all nodes in the hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.DetermineExpensiveConfigs">
            <summary>
            Finds projects in order of expense and displays the paths leading to them.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.ReadHierarchy(System.IO.StreamReader)">
            <summary>
            Reads the hierarchy from a plan file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.ReadTimes(System.IO.StreamReader)">
            <summary>
            Reads the accumulated time and path information for each configuration from the plan file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.GetRootRequest(System.Int32)">
            <summary>
            Retrieves the root request for the specified submission id.
            </summary>
            <returns>The request if one exists, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.RecursiveWriteDependencies(System.IO.StreamWriter,Microsoft.Build.BackEnd.SchedulableRequest)">
            <summary>
            Writes out all of the dependencies for a specified request, recursively.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.RecursiveAccumulateConfigurationTimes(Microsoft.Build.BackEnd.SchedulableRequest,System.Collections.Generic.Dictionary{System.Int32,System.Double})">
            <summary>
            Recursively accumulates the amount of time spent in each configuration.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData">
            <summary>
            The data associated with a config as read from a build plan.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData._configId">
            <summary>
            The configuration id.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData._configFullPath">
            <summary>
            The full path to the project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData._accumulatedTime">
            <summary>
            The amount of time spent in the configuration.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData._accumulatedTimeOfReferences">
            <summary>
            The total time of all of the references.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData._references">
            <summary>
            The set of references.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData._referrers">
            <summary>
            The set of referrers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.#ctor(System.Int32,System.String,System.Double)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.ConfigId">
            <summary>
            Gets the configuration id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.ConfigFullPath">
            <summary>
            Gets the configuration's full path.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.AccumulatedTime">
            <summary>
            Gets the configuration's accumulated time.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.AccumulatedTimeOfReferences">
            <summary>
            Gets the configuration's accumulated time for all of its references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.TotalPlanTime">
            <summary>
            Retrieves the total time for this configuration, which includes the time spent on its references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.ReferencesCount">
            <summary>
            Retrieves the number of references this configuration has.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.References">
            <summary>
            Retrieves the references from this configuration.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.ReferrerCount">
            <summary>
            Retrieves the number of configurations which refer to this one.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.Referrers">
            <summary>
            Retrieves the configurations which refer to this one.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.AddReference(Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData)">
            <summary>
            Adds the specified configuration as a reference.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SchedulingPlan.PlanConfigData.RecursivelyApplyReferenceTimeToReferrers(System.Double)">
            <summary>
            Applies the specified duration offset to the configurations which refer to this one.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.DefaultSdkResolver">
            <summary>
                Default SDK resolver for compatibility with VS2017 RTM.
            <remarks>
                Default Sdk folder will to:
                    1) MSBuildSDKsPath environment variable if defined
                    2) When in Visual Studio, (VSRoot)\MSBuild\Sdks\
                    3) Outside of Visual Studio (MSBuild Root)\Sdks\
            </remarks>
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService">
            <summary>
            An interface for services which resolve SDKs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.SendPacket">
            <summary>
            A method to use when sending packets to a remote host.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ClearCache(System.Int32)">
            <summary>
            Clears the cache for the specified build submission ID.
            </summary>
            <param name="submissionId">The build submission ID to clear from the cache.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ClearCaches">
            <summary>
            Clear the entire cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)">
            <summary>
             Resolves the full path to the specified SDK.
            </summary>
            <param name="submissionId">The build submission ID that the resolution request is for.</param>
            <param name="sdk">The <see cref="T:Microsoft.Build.Framework.SdkReference"/> containing information about the referenced SDK.</param>
            <param name="loggingContext">The <see cref="T:Microsoft.Build.BackEnd.Logging.LoggingContext"/> to use when logging messages during resolution.</param>
            <param name="sdkReferenceLocation">The <see cref="T:Microsoft.Build.Construction.ElementLocation"/> of the element which referenced the SDK.</param>
            <param name="solutionPath">The full path to the solution file, if any, that is resolving the SDK.</param>
            <param name="projectPath">The full path to the project file that is resolving the SDK.</param>
            <param name="interactive">Indicates whether or not the resolver is allowed to be interactive.</param>
            <returns>An <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResult"/> containing information about the resolved SDK. If no resolver was able to resolve it, then <see cref="P:Microsoft.Build.Framework.SdkResult.Success"/> == false. </returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService">
            <summary>
            An implementation of <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> that is hosted in an out-of-proc node for multi-proc builds.  This instance of the service
            sends requests to the main node that SDK resolution is handled in a central location.  This instance is registered in <see cref="T:Microsoft.Build.Execution.OutOfProcNode"/>
            using a factory so that parameters can be passed to the constructor.  This service caches responses for a given build so that it can avoid sending
            a packet where possible.  The cache is always in effect here because the out-of-proc node is only used for builds.
            
            Since this object is a registered <see cref="T:Microsoft.Build.BackEnd.IBuildComponent"/>, it is a singleton for the main process.  To get an instance of it, you
            must have access to an <see cref="T:Microsoft.Build.BackEnd.IBuildComponentHost"/> and call <see cref="M:Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(Microsoft.Build.BackEnd.BuildComponentType)"/> and pass <see cref="F:Microsoft.Build.BackEnd.BuildComponentType.SdkResolverService"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService._responseCache">
            <summary>
            The cache of responses which is cleared between builds.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService._responseReceivedEvent">
            <summary>
            An event to signal when a response has been received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService._lastResponse">
            <summary>
            An object used to store the last response from a remote node.  Since evaluation is single threaded, this object is only set one at a time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService.#ctor(System.Action{Microsoft.Build.BackEnd.INodePacket})">
            <summary>
            Initializes a new instance of the OutOfProcNodeSdkResolverService class.
            </summary>
            <param name="sendPacket">A <see cref="T:System.Action`1"/> to use when sending packets to the main node.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService.ShutdownComponent">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.IBuildComponent.ShutdownComponent"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService.HandleResponse(Microsoft.Build.BackEnd.SdkResolution.SdkResult)">
            <summary>
            Handles a response from the main node.
            </summary>
            <param name="response"></param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverServiceFactory">
            <summary>
            A factory used when creating a <see cref="T:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService"/> which can pass parameters to its constructor.  Our 
            dependency inject cannot pass parameters to constructors so this factory is used as a middle man.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverServiceFactory._sendPacket">
            <summary>
            Stores the SendPacket delegate to use.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.SdkLogger">
            <summary>
            An internal implementation of <see cref="T:Microsoft.Build.Framework.SdkLogger"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.CachingSdkResolverService._cache">
            <summary>
            Stores the cache in a set of concurrent dictionaries.  The main dictionary is by build submission ID and the inner dictionary contains a case-insensitive SDK name and the cached <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResult"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverContext">
            <summary>
            An internal implementation of <see cref="T:Microsoft.Build.Framework.SdkResolverContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader.FindPotentialSdkResolvers(System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
                Find all files that are to be considered SDK Resolvers. Pattern will match
                Root\SdkResolver\(ResolverName)\(ResolverName).dll.
            </summary>
            <param name="rootFolder"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverManifest">
            <summary>
            Serialization contract for an SDK Resolver manifest
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.SdkResolverManifest.Load(System.String)">
            <summary>
            Deserialize the file into an SdkResolverManifest.
            </summary>
            <param name="filePath">Path to the manifest xml file.</param>
            <returns>New deserialized collection instance.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverRequest">
            <summary>
            Represents an SDK resolver request which is serialized and sent between nodes.  This is mostly a wrapper around <see cref="T:Microsoft.Build.Framework.SdkReference"/>
            with an additional <see cref="T:Microsoft.Build.BackEnd.INodePacket"/> implementation.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService">
             <summary>
             An implementation of <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> that is hosted in the main node for multi-proc builds.  This instance of the service
             listens for requests from out-of-proc nodes so that SDK resolution is handled in a central location.  This instance is registered in <see cref="M:Microsoft.Build.BackEnd.BuildComponentFactoryCollection.RegisterDefaultFactories"/>
             and can be overridden for different contexts.  This service calls the <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService"/> to do any actual SDK resolution
             because the <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService"/> is used for stand-alone evaluations where there is no build context available so caching
             is not an option.
            
             Since this object is a registered <see cref="T:Microsoft.Build.BackEnd.IBuildComponent"/>, it is a singleton for the main process.  To get an instance of it, you
             must have access to an <see cref="T:Microsoft.Build.BackEnd.IBuildComponentHost"/> and call <see cref="M:Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(Microsoft.Build.BackEnd.BuildComponentType)"/> and pass <see cref="F:Microsoft.Build.BackEnd.BuildComponentType.SdkResolverService"/>.
             </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService._lockObject">
            <summary>
            An object used for locking in this class instance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService._requestHandler">
            <summary>
            A <see cref="T:System.Threading.Tasks.Task"/> running in the background which handles requests from remote nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService._requestReceivedEvent">
            <summary>
            An event which is signaled when a request is received from a remote host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService._requests">
            <summary>
            A list of requests from remote hosts which need to be processed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            A factory which is registered to create an instance of this class.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.ClearCache(System.Int32)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ClearCache(System.Int32)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.HandleRequest(System.Int32,Microsoft.Build.BackEnd.SdkResolution.SdkResolverRequest)">
            <summary>
            Handles a request from a remote node.
            </summary>
            <param name="node">The ID of the remote node.</param>
            <param name="request">The <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverRequest"/> containing information about the SDK to resolve.</param>
            <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply
            adds requests to a queue which are processed by a background thread.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.ProcessRequests">
            <summary>
            Processes all requests that are currently in the queue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.RequestHandlerPumpProc">
            <summary>
            A background thread that waits for requests to be received.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService">
            <summary>
            The main implementation of <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> which resolves SDKs.  This class is the central location for all SDK resolution and is used
            directly by the main node and non-build evaluations and is used indirectly by the out-of-proc node when it sends requests to the main node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.InstanceLazy">
            <summary>
            Stores the singleton instance for a particular process.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService._lockObject">
            <summary>
            A lock object used for this class.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService._resolverStateBySubmission">
            <summary>
            Stores resolver state by build submission ID.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService._resolvers">
            <summary>
            Stores the list of SDK resolvers which were loaded.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService._sdkResolverLoader">
            <summary>
            Stores an <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader"/> which can load registered SDK resolvers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.Instance">
            <summary>
            Gets the current instance of <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService"/> for this process.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.SendPacket">
            <inheritdoc cref="P:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.SendPacket"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.IsReferenceSameVersion(Microsoft.Build.Framework.SdkReference,System.String)">
            <summary>
            Determines if the <see cref="T:Microsoft.Build.Framework.SdkReference"/> is the same as the specified version.  If the <paramref name="sdk"/> object has <code>null</code> for the version,
            this method will always return true since <code>null</code> can match any version.
            </summary>
            <param name="sdk">An <see cref="T:Microsoft.Build.Framework.SdkReference"/> object.</param>
            <param name="version">The version to compare.</param>
            <returns><code>true</code> if the specified SDK reference has the same version as the specified result, otherwise <code>false</code>.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.ClearCache(System.Int32)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ClearCache(System.Int32)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.InitializeForTests(Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader,System.Collections.Generic.IList{Microsoft.Build.Framework.SdkResolver})">
            <summary>
            Used for unit tests only.  This is currently only called through reflection in Microsoft.Build.Engine.UnitTests.TransientSdkResolution.CallResetForTests
            </summary>
            <param name="resolverLoader">An <see cref="T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader"/> to use for loading SDK resolvers.</param>
            <param name="resolvers">Explicit set of SdkResolvers to use for all SDK resolution.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase">
            <summary>
            A base class for "hosted" ISdkResolverService implementations which are registered by an <see cref="T:Microsoft.Build.BackEnd.IBuildComponentHost"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.ShutdownEvent">
            <summary>
            An event to signal for waiting threads when the <see cref="T:Microsoft.Build.BackEnd.IBuildComponent"/> is being shut down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.Host">
            <summary>
            The current <see cref="T:Microsoft.Build.BackEnd.IBuildComponentHost"/> which is hosting this component.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.SendPacket">
            <inheritdoc cref="P:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.SendPacket"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.ClearCache(System.Int32)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ClearCache(System.Int32)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.IBuildComponent.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
             <inheritdoc cref="M:Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)"/>
            
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService.ResolveSdk(System.Int32,Microsoft.Build.Framework.SdkReference,Microsoft.Build.BackEnd.Logging.LoggingContext,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase.ShutdownComponent">
            <inheritdoc cref="M:Microsoft.Build.BackEnd.IBuildComponent.ShutdownComponent"/>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.SdkResult">
            <summary>
            An internal implementation of <see cref="T:Microsoft.Build.Framework.SdkResult"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.SdkResolution.SdkResultFactory">
            <summary>
            An internal implementation of <see cref="T:Microsoft.Build.Framework.SdkResultFactory"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ConfigurationMetadata">
            <summary>
            A struct representing the uniquely-identifying portion of a BuildRequestConfiguration.  Used for lookups.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigurationMetadata.#ctor(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Constructor over a BuildRequestConfiguration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigurationMetadata.#ctor(Microsoft.Build.Evaluation.Project)">
            <summary>
            Constructor over a Project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigurationMetadata.#ctor(System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Constructor taking individual arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ConfigurationMetadata.ProjectFullPath">
            <summary>
            The full path to the project to build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ConfigurationMetadata.ToolsVersion">
            <summary>
            The tools version specified for the configuration.
            Always specified.
            May have originated from a /tv switch, or an MSBuild task,
            or a Project tag, or the default.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ConfigurationMetadata.GlobalProperties">
            <summary>
            The set of global properties which should be used when building this project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigurationMetadata.GetHashCode">
            <summary>
            This override is used to provide a hash code for storage in dictionaries and the like.
            </summary>
            <remarks>
            If two objects are Equal, they must have the same hash code, for dictionaries to work correctly.
            Two configurations are Equal if their global properties are equivalent, not necessary reference equals.
            So only include filename and tools version in the hashcode.
            </remarks>
            <returns>A hash code</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigurationMetadata.Equals(System.Object)">
            <summary>
            Determines object equality
            </summary>
            <param name="obj">The object to compare with</param>
            <returns>True if they contain the same data, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigurationMetadata.Equals(Microsoft.Build.BackEnd.ConfigurationMetadata)">
            <summary>
            Equality of the configuration is the product of the equality of its members.
            </summary>
            <param name="other">The other configuration to which we will compare ourselves.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigurationMetadata.InternalEquals(Microsoft.Build.BackEnd.ConfigurationMetadata)">
            <summary>
            Compares this object with another for equality
            </summary>
            <param name="other">The object with which to compare this one.</param>
            <returns>True if the objects contain the same data, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ResultsCacheResponseType">
            <summary>
            The type of response.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ResultsCacheResponseType.NotSatisfied">
            <summary>
            There were no matching results, or some implicit targets need to be built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ResultsCacheResponseType.Satisfied">
            <summary>
            All explicit and implicit targets have results.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ResultsCacheResponse">
            <summary>
            Container for results of IResultsCache.SatisfyRequest
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ResultsCacheResponse.Type">
            <summary>
            The results type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ResultsCacheResponse.Results">
            <summary>
            The actual results, if the request was satisfied.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ResultsCacheResponse.ExplicitTargetsToBuild">
            <summary>
            The subset of explicit targets which must be built because there are no results for them in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCacheResponse.#ctor(Microsoft.Build.BackEnd.ResultsCacheResponseType)">
            <summary>
            Constructor.
            </summary>
            <param name="type">The response type.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeEndpointOutOfProc">
            <summary>
            This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProc._componentHost">
            <summary>
            The build component host
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProc.#ctor(System.String,Microsoft.Build.BackEnd.IBuildComponentHost,System.Boolean,System.Boolean)">
            <summary>
            Instantiates an endpoint to act as a client
            </summary>
            <param name="pipeName">The name of the pipe to which we should connect.</param>
            <param name="host">The component host.</param>
            <param name="enableReuse">Whether this node may be reused for a later build.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProc.GetHostHandshake">
            <summary>
            Returns the host handshake for this node endpoint
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProc.GetClientHandshake">
            <summary>
            Returns the client handshake for this node endpoint
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeEndpointOutOfProc.EndpointPair">
            <summary>
            Used to return a matched pair of endpoints for in-proc nodes to use with the Build Manager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProc.EndpointPair.NodeEndpoint">
            <summary>
            The endpoint destined for use by a node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointOutOfProc.EndpointPair.ManagerEndpoint">
            <summary>
            The endpoint destined for use by the Build Manager
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointOutOfProc.EndpointPair.#ctor(Microsoft.Build.BackEnd.NodeEndpointInProc,Microsoft.Build.BackEnd.NodeEndpointInProc)">
            <summary>
            Creates an endpoint pair
            </summary>
            <param name="node">The node-side endpoint.</param>
            <param name="manager">The manager-side endpoint.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeManager">
            <summary>
            The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the 
            creation of new nodes on request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager.InvalidNodeId">
            <summary>
            The invalid node id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._inProcNodeProvider">
            <summary>
            The node provider for the in-proc node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._outOfProcNodeProvider">
            <summary>
            The node provider for out-of-proc nodes.
            </summary> 
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._componentHost">
            <summary>
            The build component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._nodeIdToProvider">
            <summary>
            Mapping of manager-produced node IDs to the provider hosting the node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._packetFactory">
            <summary>
            The packet factory used to translate and route packets
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._nextNodeId">
            <summary>
            The next node id to assign to a node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._inprocNodeId">
            <summary>
            The nodeID for the inproc node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._nodesShutdown">
            <summary>
            Flag indicating when the nodes have been shut down.
            BUGBUG: This is a fix which corrects an RI blocking BVT failure.  The real fix must be determined before RTM.
            This must be investigated and resolved before RTM.  The apparent issue is that a design-time build has already called EndBuild
            through the BuildManagerAccessor, and the nodes are shut down.  Shortly thereafter, the solution build manager comes through and calls EndBuild, which throws
            another Shutdown packet in the queue, and causes the following build to stop prematurely.  This is all timing related - not every sequence of builds seems to 
            cause the problem, probably due to the order in which the packet queue gets serviced relative to other threads.
            
            It appears that the problem is that the BuildRequestEngine is being invoked in a way that causes a shutdown packet to appear to overlap with a build request packet.
            Interactions between the in-proc node communication thread and the shutdown mechanism must be investigated to determine how BuildManager.EndBuild is allowing itself
            to return before the node has indicated it is actually finished.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeManager._componentShutdown">
            <summary>
            Tracks whether ShutdownComponent has been called.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.CreateNode(Microsoft.Build.BackEnd.NodeConfiguration,Microsoft.Build.Execution.NodeAffinity)">
            <summary>
            Creates a node on an available NodeProvider, if any..
            </summary>
            <param name="configuration">The configuration to use for the remote node.</param>
            <param name="nodeAffinity">The <see cref="T:Microsoft.Build.Execution.NodeAffinity"/> to use.</param>
            <returns>A NodeInfo describing the node created, or null if none could be created.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.SendData(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the specified node.
            </summary>
            <param name="node">The node.</param>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.ShutdownConnectedNodes(System.Boolean)">
            <summary>
            Shuts down all of the connected managed nodes.
            </summary>
            <param name="enableReuse">Flag indicating if nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.ShutdownAllNodes">
            <summary>
            Shuts down all of managed nodes permanently.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Initializes the component
            </summary>
            <param name="host">The component host</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.ShutdownComponent">
            <summary>
            Shuts down the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.ClearPerBuildState">
            <summary>
            Reset the state of objects in the node manager which need to be reset between builds.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers the specified handler for a particular packet type.
            </summary>
            <param name="packetType">The packet type.</param>
            <param name="factory">The factory for packets of the specified type.</param>
            <param name="handler">The handler to be called when packets of the specified type are received.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.
            </summary>
            <param name="packetType">The packet type.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Takes a serializer, deserializes the packet and routes it to the appropriate handler.
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packetType">The packet type.</param>
            <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the specified packet. This is called by the Inproc node directly since it does not have to do any deserialization
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packet">The packet to route.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.RemoveNodeFromMapping(System.Int32)">
            <summary>
            We have received the node shutdown packet for this node, we should remove it from our list of providers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeManager.AttemptCreateNode(Microsoft.Build.BackEnd.INodeProvider,Microsoft.Build.BackEnd.NodeConfiguration)">
            <summary>
            Attempts to create a node on the specified machine using the specified provider.
            </summary>
            <param name="nodeProvider">The provider used to create the node.</param>
            <param name="nodeConfiguration">The <see cref="T:Microsoft.Build.BackEnd.NodeConfiguration"/> to use.</param>
            <returns>The id of the node created.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskHostNodeManager">
            <summary>
            The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the 
            creation of new nodes on request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostNodeManager._outOfProcTaskHostNodeProvider">
            <summary>
            The node provider for task hosts. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostNodeManager._componentHost">
            <summary>
            The build component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostNodeManager._componentShutdown">
            <summary>
            Tracks whether ShutdownComponent has been called.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.CreateNode(Microsoft.Build.BackEnd.NodeConfiguration,Microsoft.Build.Execution.NodeAffinity)">
            <summary>
            Creates a node on an available NodeProvider, if any..
            </summary>
            <param name="configuration">The configuration to use for the remote node.</param>
            <param name="nodeAffinity">The <see cref="T:Microsoft.Build.Execution.NodeAffinity"/> to use.</param>
            <returns>A NodeInfo describing the node created, or null if none could be created.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.SendData(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the specified node.
            </summary>
            <param name="node">The node.</param>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.ShutdownConnectedNodes(System.Boolean)">
            <summary>
            Shuts down all of the connected managed nodes.
            </summary>
            <param name="enableReuse">Flag indicating if nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.ShutdownAllNodes">
            <summary>
            Shuts down all of the managed nodes permanently.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Initializes the component
            </summary>
            <param name="host">The component host</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.ShutdownComponent">
            <summary>
            Shuts down the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.ClearPerBuildState">
            <summary>
            Reset the state of objects in the node manager which need to be reset between builds.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers the specified handler for a particular packet type.
            </summary>
            <param name="packetType">The packet type.</param>
            <param name="factory">The factory for packets of the specified type.</param>
            <param name="handler">The handler to be called when packets of the specified type are received.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.
            </summary>
            <param name="packetType">The packet type.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Takes a serializer, deserializes the packet and routes it to the appropriate handler.
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packetType">The packet type.</param>
            <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the specified packet. This is called by the Inproc node directly since it does not have to do any deserialization
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packet">The packet to route.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostNodeManager.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Factory for component creation.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.LogMessagePacket">
            <summary>
            A packet to encapsulate a BuildEventArg logging message.
            Contents:
            Build Event Type
            Build Event Args
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.LogMessagePacket.#ctor(System.Nullable{System.Collections.Generic.KeyValuePair{System.Int32,Microsoft.Build.Framework.BuildEventArgs}})">
            <summary>
            Encapsulates the buildEventArg in this packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.LogMessagePacket.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for deserialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.LogMessagePacket.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.LogMessagePacket.TranslateTargetFinishedEvent(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Translate the TargetOutputs for the target finished event.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeFailedToLaunchException">
            <summary>
            An exception representing the case where a TaskHost node failed to launch.
            This may happen for example when the TaskHost binary is corrupted.
            </summary>
            <remarks>
            If you add fields to this class, add a custom serialization constructor and override GetObjectData().
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeFailedToLaunchException.#ctor">
            <summary>
            Constructs a standard NodeFailedToLaunchException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeFailedToLaunchException.#ctor(System.String,System.String)">
            <summary>
            Constructs a standard NodeFailedToLaunchException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeFailedToLaunchException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor for deserialization.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeFailedToLaunchException.ErrorCode">
            <summary>
            Gets the error code (if any) associated with the exception message.
            </summary>
            <value>Error code string, or null.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeFailedToLaunchException.ErrorDescription">
            <summary>
            Gets the error code (if any) associated with the exception message.
            </summary>
            <value>Error code string, or null.</value>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeFailedToLaunchException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            ISerializable method which we must override since Exception implements this interface
            If we ever add new members to this class, we'll need to update this.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse">
            <summary>
            This is the packet which is sent in response to a build configuration ID request.  When the node generates a new configuration which it has
            never seen before, it gives that configuration a temporary, "unresolved" configuration id.  The node then asks the Build Request Manager
            for the "resolved" configuration id, which is global to all nodes in the system.  This packet maps the unresolved to the resolved
            configuration id.  Once this packet is received, the node engine can then continue processing requests associated with the configuration.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse._nodeConfigId">
            <summary>
            The configuration ID assigned by the node
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse._globalConfigId">
            <summary>
            The configuration ID assigned by the build manager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse._resultsNodeId">
            <summary>
            The results node assigned to this configuration
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor for non-deserialization initialization.
            </summary>
            <param name="nodeConfigId">The node-assigned configuration id</param>
            <param name="globalConfigId">The build manager-assigned configuration id</param>
            <param name="resultsNodeId">The result node identifier.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.NodeConfigurationId">
            <summary>
            Returns the node-assigned configuration id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.GlobalConfigurationId">
            <summary>
            Returns the build manager assigned configuration id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.ResultsNodeId">
            <summary>
            Returns the results node for the global configuration.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.Type">
            <summary>
            INodePacket property.  Returns the packet type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads/writes this packet
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestEngine">
            <summary>
            The BuildRequestEngine is responsible for managing the building of projects on a given node.  It
            receives build requests, reports results and deals with BuildRequestConfiguration transactions.
            As it runs on its own thread, all BuildRequestEngine operations are asynchronous.
            </summary>
            <remarks>
            Internally, the BuildRequestEngine manages the requests in the form of BuildRequestEntry objects.
            Each of these maintains the complete state of a build request, accumulating results until completion.
            The EngineLoop method is the separate thread proc which handles state changes for BuildRequestEntries
            and shutting down.  However, each RequestBuilder can call back into the BuildRequestEngine (via events)
            to cause new requests to be submitted.  See <seealso cref="M:Microsoft.Build.BackEnd.BuildRequestEngine.IssueBuildRequest(Microsoft.Build.BackEnd.BuildRequestBlocker)"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine.StartingUnresolvedConfigId">
            <summary>
            The starting unresolved configuration id assigned by the engine.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine.StartingBuildRequestId">
            <summary>
            The starting build request id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._status">
            <summary>
            The current engine status
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._componentHost">
            <summary>
            Ths component host
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._workQueue">
            <summary>
            The work queue.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._requests">
            <summary>
            The list of current requests the engine is working on.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._requestsByGlobalRequestId">
            <summary>
            Mapping of global request ids to the request entries.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._unsubmittedRequests">
            <summary>
            The list of requests currently waiting to be submitted from RequestBuilders.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._nextUnresolvedConfigurationId">
            <summary>
            The next available local unresolved configuration Id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._nextBuildRequestId">
            <summary>
            The next available build request Id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._configCache">
            <summary>
            The global configuration cache
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._unresolvedConfigurations">
            <summary>
            The list of unresolved configurations
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._nodeLoggingContext">
            <summary>
            The logging context for the node
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._debugDumpState">
            <summary>
            Flag indicating if we should trace.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._debugDumpPath">
            <summary>
            The path where we will store debug files
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine._debugForceCaching">
            <summary>
            Forces caching of all configurations and results.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.BuildRequestEngine.OnRequestComplete">
            <summary>
            Raised when a request has completed.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.BuildRequestEngine.OnRequestResumed">
            <summary>
            Raised when a request is resumed by the engine itself.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.BuildRequestEngine.OnRequestBlocked">
            <summary>
            Raised when a new request is generated.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.BuildRequestEngine.OnStatusChanged">
            <summary>
            Raised when the engine's status has changed.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.BuildRequestEngine.OnNewConfigurationRequest">
            <summary>
            Raised when a configuration needs its ID resolved.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.BuildRequestEngine.OnEngineException">
            <summary>
            Raised when an unexpected exception occurs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEngine.Status">
            <summary>
            Returns the current engine status.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.InitializeForBuild(Microsoft.Build.BackEnd.Logging.NodeLoggingContext)">
            <summary>
            Prepares the build request engine to run a build.
            </summary>
            <param name="loggingContext">The logging context to use.</param>
            <remarks>
            Called by the Node.  Non-overlapping with other calls from the Node.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.CleanupForBuild">
            <summary>
            Cleans up after a build but leaves the engine thread running.  Aborts
            any outstanding requests.  Blocks until the engine has cleaned up
            everything.  After this method is called, InitializeForBuild may be
            called to start a new build, or the component may be shut down.        
            </summary>
            <remarks>
            Called by the Node.  Non-overlapping with other calls from the Node.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.SubmitBuildRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Adds a new build request to the request queue.
            </summary>
            <param name="request">The request to be added.</param>
            <remarks>
            Called by the Node.  Non-overlapping with other calls from the Node.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.UnblockBuildRequest(Microsoft.Build.BackEnd.BuildRequestUnblocker)">
            <summary>
            Reports a build result to the engine, allowing it to satisfy outstanding requests.  This result
            is reported to each entry, allowing it the opportunity to determine for itself if the
            result applies.
            </summary>
            <param name="unblocker">Information needed to unblock the engine.</param>
            <remarks>
            Called by the Node.  Non-overlapping with other calls from the Node.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.ReportConfigurationResponse(Microsoft.Build.BackEnd.BuildRequestConfigurationResponse)">
            <summary>
            Reports a configuration response to the request, allowing it to satisfy outstanding requests.
            <seealso cref="T:Microsoft.Build.BackEnd.BuildRequestConfigurationResponse"/>
            </summary>
            <param name="response">The configuration response.</param>
            <remarks>
            Called by the Node.  Non-overlapping with other calls from the Node.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Sets the build component host for this object.
            </summary>
            <param name="host">The host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.ShutdownComponent">
            <summary>
            Called to terminate the functions of this component
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Class factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.BuildRequestEntry_StateChanged(Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.BuildRequestEntryState)">
            <summary>
            Called when a build request entry has a state change.  We should re-evaluate our requests when this happens.
            </summary>
            <param name="entry">The entry raising the event.</param>
            <param name="newState">The event's new state.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.RaiseRequestComplete(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Raises the OnRequestComplete event.
            </summary>
            <param name="request">The request which completed.</param>
            <param name="result">The result for the request</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.RaiseRequestResumed(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Raises the OnRequestResumed event.
            </summary>
            <param name="request">The request being resumed.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.RaiseEngineException(System.Exception)">
            <summary>
            Raises the OnEngineException event.
            </summary>
            <param name="e">The exception being thrown.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.RaiseRequestBlocked(Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Raises the OnNewRequest event.
            </summary>
            <param name="blocker">Information about what is blocking the current request.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.RaiseEngineStatusChanged(Microsoft.Build.BackEnd.BuildRequestEngineStatus)">
            <summary>
            Raises the OnStatusChanged event.
            </summary>
            <param name="newStatus">The new engine status.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.RaiseNewConfigurationRequest(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Raises the OnNewConfigurationRequest event.
            </summary>
            <param name="config">The configuration which needs resolving.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.ChangeStatus(Microsoft.Build.BackEnd.BuildRequestEngineStatus)">
            <summary>
            Changes the engine's status and raises the OnStatsChanged event.
            </summary>
            <param name="newStatus">The new engine status.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.EvaluateRequestStates">
            <summary>
            This method examines the current list of requests to determine if any requests should change
            state, possibly reactivating a previously inactive request or removing a now-completed
            request from the list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.CheckMemoryUsage">
            <summary>
            Check the amount of memory we are using and, if we exceed the threshold, unload cacheable items.
            </summary>
            <remarks>
            Since this causes synchronous I/O and a stop-the-world GC, it can be very expensive. If
            something other than build results is taking up the bulk of the memory space, it may not
            free any space. That's caused customer reports of VS hangs resulting from build requests
            that are very slow because something in VS is taking all of the memory, but every
            project build is slowed down by this codepath. To mitigate this, don't perform these
            checks in devenv.exe. On the command line, 32-bit MSBuild may still need to cache build
            results on very large builds, but build results are much more likely to be the bulk of
            memory usage there.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.ActivateBuildRequest(Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Makes the specified build request entry the active one, loading the project if necessary.
            </summary>
            <param name="entry">The entry to activate.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.GetRequestBuilder">
            <summary>
            Returns an unused request builder if there are any, or creates a new one.
            </summary>
            <returns>An IRequestBuilder to use.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.BeginDeactivateBuildRequest(Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Starts to terminate any builder associated with the entry and clean it up in preparation for removal.
            </summary>
            <param name="entry">The entry to be deactivated</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.WaitForDeactivateCompletion(Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Waits for the builders until they are terminated.
            </summary>
            <param name="entry">The entry to be deactivated</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.Builder_OnNewBuildRequests(Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.FullyQualifiedBuildRequest[])">
            <summary>
            Raised when the active request needs to build new requests.
            </summary>
            <param name="issuingEntry">The request issuing the requests.</param>
            <param name="newRequests">The requests being issued.</param>
            <remarks>Called by the RequestBuilder (implicitly through an event).  Non-overlapping with other RequestBuilders.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.Builder_OnBlockedRequest(Microsoft.Build.BackEnd.BuildRequestEntry,System.Int32,System.String,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Called when the request builder needs to block on another request.
            </summary>
            <remarks>
            Called by the RequestBuilder (implicitly through an event).  Non-overlapping with other RequestBuilders.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.IssueUnsubmittedRequests">
            <summary>
            Dequeue some requests from the unsubmitted request queue and submit them.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.IssueBuildRequests(Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.FullyQualifiedBuildRequest[])">
            <summary>
            This method is responsible for evaluating whether we have enough information to make the request of the Build Manager,
            or if we need to obtain additional configuration information.  It then issues either configuration
            requests or build requests, or both as needed.
            </summary>
            <param name="issuingEntry">The BuildRequestEntry which is making the request</param>
            <param name="newRequests">The array of "child" build requests to be issued.</param>
            <remarks>
            When we receive a build request, we first have to determine if we already have a configuration which matches the
            one used by the request.  We do this because everywhere we deal with requests and results beyond this function, we
            use configuration ids, which are assigned once by the Build Manager and are global to the system.  If we do
            not have a global configuration id, we can't check to see if we already have build results for the request, so we 
            cannot send the request out.  Thus, first we determine the configuration id.
            
            Assuming we don't have the global configuration id locally, we will send the configuration to the Build Manager.
            It will look up or assign the global configuration id and send it back to us.
            
            Once we have the global configuration id, we can then look up results locally.  If we have enough results to fulfill
            the request, we give them back to the request, otherwise we have to forward the request to the Build Mangager
            for scheduling.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.GetNextUnresolvedConfigurationId">
            <summary>
            Retrieves a new configuration ID
            </summary>
            <returns>The next unused local configuration ID.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.GetNextBuildRequestId">
            <summary>
            Retrieves a new build request ID
            </summary>
            <returns>The next build request ID.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.IssueConfigurationRequest(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            This method forms a configuration request from an unresolved configuration and posts it to the
            Build Manager.
            </summary>
            <param name="config">The configuration to be mapped.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.IssueBuildRequest(Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Sends a build request to the Build Manager for scheduling
            </summary>
            <param name="blocker">The information about why the request is blocked.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.QueueAction(System.Action,System.Boolean)">
            <summary>
            Queue an action to be run in the engine.
            </summary>
            <param name="action">The action to execute.</param>
            <param name="isLastTask"><code>true</code> if this is the last task for this queue, otherwise <code>false</code>.</param>
            <remarks>This method will return false if an attempt is made to schedule an action after the queue has been shut down.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.TraceEngine(System.String,System.Object[])">
            <summary>
            Method used for debugging purposes.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestEngine.PendingUnsubmittedBuildRequests">
            <summary>
            Struct used to contain information about requests submitted by the RequestBuilder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine.PendingUnsubmittedBuildRequests.BlockingGlobalRequestId">
            <summary>
            The global request id on which we are blocking
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine.PendingUnsubmittedBuildRequests.BlockingTarget">
            <summary>
            The target on which we are blocking
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine.PendingUnsubmittedBuildRequests.IssuingEntry">
            <summary>
            The issuing request
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngine.PendingUnsubmittedBuildRequests.NewRequests">
            <summary>
            The new requests to issue
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.PendingUnsubmittedBuildRequests.#ctor(Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.FullyQualifiedBuildRequest[])">
            <summary>
            Create a new unsubmitted request entry
            </summary>
            <param name="issuingEntry">The build request originating these requests.</param>
            <param name="newRequests">The new requests to be issued.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEngine.PendingUnsubmittedBuildRequests.#ctor(Microsoft.Build.BackEnd.BuildRequestEntry,System.Int32,System.String)">
            <summary>
            Create a new unsubmitted request entry
            </summary>
            <param name="issuingEntry">The build request originating these requests.</param>
            <param name="blockingGlobalRequestId">The request on which we are blocked.</param>
            <param name="blockingTarget">The target on which we are blocked.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestEntryStateChangedDelegate">
            <summary>
            Delegate is called when the state for a build request entry has changed.
            </summary>
            <param name="entry">The entry whose state has changed.</param>
            <param name="newState">The new state value.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestEntryState">
            <summary>
            The set of states in which a build request entry can be.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntryState.Active">
            <summary>
            There should only ever be one entry in the Active state.  This is the request which is
            being actively built by the engine - i.e. it has a running task thread.  All other requests
            must be in one of the other states.  When in this state, the outstandingRequest and
            receivedResult members must be null.
            
            Transitions: 
                Waiting:  When an msbuild callback is made the active build request needs to wait
                          for the results in order to continue to process.
                Complete: The build request has generated all of the required results.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntryState.Ready">
            <summary>
            This state means the node has received all of the results needed to continue processing this
            request.  When this state is set, the receivedResult member of this entry must be non-null.  
            The request engine can continue it at some later point when it is no longer busy.
            Any number of entries may be in this state.
            
            Transitions:
                    Active: The build request engine picks this ready request to process.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntryState.Waiting">
            <summary>
            This state means the node is waiting for results from outstanding build requests.  When this 
            state is set, the outstandingRequest or outstandingConfiguration members of the entry 
            must be non-null.
            
            Transitions: 
                      Ready: All of the results which caused the build request to wait have been received
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntryState.Complete">
            <summary>
            This state means the request has completed and results are available.  The engine will remove
            the request from the list and the results will be returned to the node for processing.
            
            Transitions: None, this is the final state of the build request
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestEntry">
            <summary>
            BuildRequestEntry holds a build request and associated state data.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._unresolvedConfigurations">
            <summary>
            Mapping of Build Request Configurations to Build Requests waiting for configuration resolution.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._requestsToIssue">
            <summary>
            The set of requests to issue.  This holds all of the requests as we prepare them.  Once their configurations
            have all been resolved, we will issue them to the Scheduler in the order received.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._unresolvedConfigurationsToIssue">
            <summary>
            The list of unresolved configurations we need to issue.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._outstandingRequests">
            <summary>
            Mapping of nodeRequestIDs to Build Requests waiting for results.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._outstandingResults">
            <summary>
            Mapping of nodeRequestIDs to Build Results.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._blockingGlobalRequestId">
            <summary>
            The ID of the request we are blocked waiting for.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._requestBuilder">
            <summary>
            The object used to build this request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEntry._projectRootDirectory">
            <summary>
            The project's root directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.#ctor(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Creates a build request entry from a build request.
            </summary>
            <param name="request">The originating build request.</param>
            <param name="requestConfiguration">The build request configuration.</param>
        </member>
        <member name="E:Microsoft.Build.BackEnd.BuildRequestEntry.OnStateChanged">
            <summary>
            Raised when the state changes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEntry.GlobalLock">
            <summary>
            Returns the object used to lock for synchronization of long-running operations.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEntry.ProjectRootDirectory">
            <summary>
            Returns the root directory for the project being built by this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEntry.State">
            <summary>
            Returns the current state of the build request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEntry.Request">
            <summary>
            Returns the request which originated this entry.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEntry.RequestConfiguration">
            <summary>
            Returns the build request configuration
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEntry.Result">
            <summary>
            Returns the overall result for this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestEntry.Builder">
            <summary>
            Returns the request builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.WaitForConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Informs the entry that it has configurations which need to be resolved.
            </summary>
            <param name="configuration">The configuration to be resolved.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.WaitForResult(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Waits for a result from a request.
            </summary>
            <param name="newRequest">The build request</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.WaitForBlockingRequest(System.Int32)">
            <summary>
            Signals that we are waiting for a specific blocking request to finish.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.ResolveConfigurationRequest(System.Int32,System.Int32)">
            <summary>
            Waits for a result from a request which previously had an unresolved configuration.
            </summary>
            <param name="unresolvedConfigId">The id of the unresolved configuration.</param>
            <param name="configId">The id of the resolved configuration.</param>
            <returns>True if all unresolved configurations have been resolved, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.GetRequestsToIssueIfReady">
            <summary>
            Returns the set of build requests which should be issued to the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.GetUnresolvedConfigurationsToIssue">
            <summary>
            Returns the list of unresolved configurations to issue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.GetActiveTargets">
            <summary>
            Returns the list of currently active targets.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.ReportResult(Microsoft.Build.Execution.BuildResult)">
            <summary>
            This reports a result for a request on which this entry was waiting.
            PERF: Once we have fixed up all the result reporting, we can probably
            optimize this.  See the comment in BuildRequestEngine.ReportBuildResult.
            </summary>
            <param name="result">The result for the request.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.Unblock">
            <summary>
            Unblocks an entry which was waiting for a specific global request id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.Continue">
            <summary>
            Marks the entry as active and returns all of the results needed to continue.
            Results are returned as { nodeRequestId -> BuildResult }
            </summary>
            <returns>The results for all previously pending requests, or null if there were none.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.BeginCancel">
            <summary>
            Starts to cancel the current request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.WaitForCancelCompletion">
            <summary>
            Waits for the current request until it's canceled.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.Complete(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Marks this entry as complete and sets the final results.
            </summary>
            <param name="result">The result of the build.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.WaitForResult(Microsoft.Build.BackEnd.BuildRequest,System.Boolean)">
            <summary>
            Adds a request to the set of waiting requests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestEntry.ChangeState(Microsoft.Build.BackEnd.BuildRequestEntryState)">
            <summary>
            Updates the state of this entry.
            </summary>
            <param name="newState">The new state for this entry.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest">
            <summary>
            This class represents a build request as it would be received from an MSBuild callback.  Such requests have
            configurations which have not yet been assigned a global configuration ID, and therefore must be resolved
            with the build manager before a formal request can be sent.
            </summary>
            <remarks>
            This class is called "Fully Qualified" because it completely and directly specifies all of the configuration information.
            A standard Build Request only specifies the configuration id, so to get the configuration requires an additional lookup
            in a configuration cache.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.#ctor(Microsoft.Build.BackEnd.BuildRequestConfiguration,System.String[],System.Boolean,System.Boolean,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Initializes a build request.
            </summary>
            <param name="config">The configuration to use for the request.</param>
            <param name="targets">The set of targets to build.</param>
            <param name="resultsNeeded">Whether or not to wait for the results of this request.</param>
            <param name="flags">Flags specified for the build request.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.Config">
            <summary>
            Returns the configuration for this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.Targets">
            <summary>
            Returns the set of targets to be satisfied for this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.ResultsNeeded">
            <summary>
            Returns true if this request must wait for its results in order to complete.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.BuildRequestDataFlags">
            <summary>
            The set of flags specified in the BuildRequestData for this request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.op_Equality(Microsoft.Build.BackEnd.FullyQualifiedBuildRequest,Microsoft.Build.BackEnd.FullyQualifiedBuildRequest)">
            <summary>
            Implementation of the equality operator.
            </summary>
            <param name="left">The left hand argument</param>
            <param name="right">The right hand argument</param>
            <returns>True if the objects are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.op_Inequality(Microsoft.Build.BackEnd.FullyQualifiedBuildRequest,Microsoft.Build.BackEnd.FullyQualifiedBuildRequest)">
            <summary>
            Implementation of the inequality operator.
            </summary>
            <param name="left">The left-hand argument</param>
            <param name="right">The right-hand argument</param>
            <returns>True if the objects are not equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.GetHashCode">
            <summary>
            Returns the hash code for this object.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.Equals(System.Object)">
            <summary>
            Determines equivalence between this object and another.
            </summary>
            <param name="obj">The object to which this one should be compared.</param>
            <returns>True if the objects are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.FullyQualifiedBuildRequest.InternalEquals(Microsoft.Build.BackEnd.FullyQualifiedBuildRequest)">
            <summary>
            Determines equivalence with another object of the same type.
            </summary>
            <param name="other">The other object with which to compare this one.</param>
            <returns>True if the objects are equivalent, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ConfigCreateCallback">
            <summary>
            Delegate invoked to create a configuration
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IConfigCache">
            <summary>
            An interfacing representing a build request configuration cache.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IConfigCache.Item(System.Int32)">
            <summary>
            Returns the configuration with the specified id.
            </summary>
            <param name="configId">The configuration id.</param>
            <returns>The configuration with the specified id.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.AddConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Adds the configuration to the cache.
            </summary>
            <param name="config">The configuration to add.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.RemoveConfiguration(System.Int32)">
            <summary>
            Removes the specified configuration from the cache.
            </summary>
            <param name="configId">The id of the configuration to remove.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.GetMatchingConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Gets the cached configuration which matches the specified configuration
            </summary>
            <param name="config">The configuration to match.</param>
            <returns>The matching configuration if any, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.GetMatchingConfiguration(Microsoft.Build.BackEnd.ConfigurationMetadata)">
            <summary>
            Gets the cached configuration which matches the specified configuration
            </summary>
            <param name="configMetadata">The configuration metadata to match.</param>
            <returns>The matching configuration if any, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.GetMatchingConfiguration(Microsoft.Build.BackEnd.ConfigurationMetadata,Microsoft.Build.BackEnd.ConfigCreateCallback,System.Boolean)">
            <summary>
            Gets a matching configuration.  If no such configration exists, one is created and optionally loaded.
            </summary>
            <param name="configMetadata">The configuration metadata to match.</param>
            <param name="callback">Callback to be invoked if the configuration does not exist.</param>
            <param name="loadProject">True if the configuration should also be loaded.</param>
            <returns>The matching configuration if any, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.HasConfiguration(System.Int32)">
            <summary>
            Returns true if a configuration with the specified id exists in the cache.
            </summary>
            <param name="configId">The configuration id to check.</param>
            <returns>
            True if there is a configuration with the specified id, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.ClearConfigurations">
            <summary>
            Clears out the configurations
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.ClearNonExplicitlyLoadedConfigurations">
            <summary>
            Clear non explicltly loaded configurations. 
            </summary>
            <returns>The configuration ids which have been cleared.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.IsConfigCacheSizeLargerThanThreshold">
            <summary>
            Check whether the config cache has more items that the predefined threshold
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IConfigCache.WriteConfigurationsToDisk">
            <summary>
            Unloads any configurations not in use.
            </summary>
            <returns>True if any configurations were cached, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ResultsCache">
            <summary>
            Implementation of the results cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ResultsCache._resultsByConfiguration">
            <summary>
            The table of all build results.  This table is indexed by configuration id and
            contains BuildResult objects which have all of the target information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.#ctor">
            <summary>
            Creates an empty results cache.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ResultsCache.ResultsDictionary">
            <summary>
            Returns the internal cache for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.AddResult(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Adds the specified build result to the cache
            </summary>
            <param name="result">The result to add.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.ClearResults">
            <summary>
            Clears the results for the specified build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.GetResultForRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Retrieves the results for the specified build request.
            </summary>
            <param name="request">The request for which results should be retrieved.</param>
            <returns>The build results for the specified request.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.GetResultsForConfiguration(System.Int32)">
            <summary>
            Retrieves the results for the specified configuration
            </summary>
            <param name="configurationId">The configuration for which results should be returned.</param>
            <returns>The results, if any</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.SatisfyRequest(Microsoft.Build.BackEnd.BuildRequest,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Attempts to satisfy the request from the cache.  The request can be satisfied only if:
            1. All specified targets in the request have successful results in the cache or if the sequence of target results
               includes 0 or more successful targets followed by at least one failed target.
            2. All initial targets in the configuration for the request have non-skipped results in the cache.
            3. If there are no specified targets, then all default targets in the request must have non-skipped results
               in the cache.
            </summary>
            <param name="request">The request whose results we should return</param>
            <param name="configInitialTargets">The initial targets for the request's configuration.</param>
            <param name="configDefaultTargets">The default targets for the request's configuration.</param>
            <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".  
            If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method 
            will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no 
            chance of re-execution (which is the usual response to missing / skipped targets), and the caller just needs the data.</param>
            <returns>A response indicating the results, if any, and the targets needing to be built, if any.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.ClearResultsForConfiguration(System.Int32)">
            <summary>
            Removes the results for a particular configuration.
            </summary>
            <param name="configurationId">The configuration</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.WriteResultsToDisk">
            <summary>
            Cache as many results as we can.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Sets the build component host.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.ShutdownComponent">
            <summary>
            Shuts down this component
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ResultsCache.CheckResults(Microsoft.Build.Execution.BuildResult,System.Collections.Generic.List{System.String},System.Collections.Generic.HashSet{System.String},System.Boolean)">
            <summary>
            Looks for results for the specified targets.
            </summary>
            <param name="result">The result to examine</param>
            <param name="targets">The targets to search for</param>
            <param name="targetsMissingResults">An optional list to be populated with missing targets</param>
            <param name="skippedResultsAreOK">If true, a status of "skipped" counts as having valid results 
            for that target.  Otherwise, a skipped target is treated as equivalent to a missing target.</param>
            <returns>False if there were missing results, true otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ConfigCache">
            <summary>
            Implements a build request configuration cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ConfigCache._configurations">
            <summary>
            The configurations
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ConfigCache._lockObject">
            <summary>
            Object used for locking.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ConfigCache._configurationIdsByMetadata">
            <summary>
            Lookup which can be used to find a configuration with the specified metadata.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ConfigCache._sweepThreshhold">
            <summary>
            The maximum cache entries allowed before a sweep can occur.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.#ctor">
            <summary>
            Creates a new build configuration cache.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ConfigCache.Item(System.Int32)">
            <summary>
            Returns the configuration cached under the specified configuration id.
            </summary>
            <param name="configId">The id of the configuration to return.</param>
            <returns>The cached configuration.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Returned if a configuration with the specified id is not in the cache.</exception>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.AddConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Adds the specified configuration to the cache.
            </summary>
            <param name="config">The configuration to add.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.RemoveConfiguration(System.Int32)">
            <summary>
            Removes the specified configuration from the cache.
            </summary>
            <param name="configId">The id of the configuration to remove.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.GetMatchingConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Returns the entry in the cache which matches the specified config.
            </summary>
            <param name="config">The configuration to match</param>
            <returns>A matching configuration if one exists, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.GetMatchingConfiguration(Microsoft.Build.BackEnd.ConfigurationMetadata)">
            <summary>
            Returns the entry in the cache which matches the specified config.
            </summary>
            <param name="configMetadata">The configuration metadata to match</param>
            <returns>A matching configuration if one exists, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.GetMatchingConfiguration(Microsoft.Build.BackEnd.ConfigurationMetadata,Microsoft.Build.BackEnd.ConfigCreateCallback,System.Boolean)">
            <summary>
            Gets a matching configuration.  If no such configuration exists, one is created and optionally loaded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.HasConfiguration(System.Int32)">
            <summary>
            Returns true if the cache contains a configuration with the specified id, false otherwise.
            </summary>
            <param name="configId">The configuration id to check.</param>
            <returns>True if the cache contains a configuration with this id, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.ClearConfigurations">
            <summary>
            Clear all configurations
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.ClearNonExplicitlyLoadedConfigurations">
            <summary>
            Clears configurations from the configuration cache which have not been explicitly loaded.
            </summary>
            <returns>Set if configurations which have been cleared.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.IsConfigCacheSizeLargerThanThreshold">
            <summary>
            Check whether the config cache has more items that the predefined threshold
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.WriteConfigurationsToDisk">
            <summary>
            Writes out as many configurations to disk as we can, under the assumption that inactive configurations
            probably aren't going to be accessed again (the exception is re-entrant builds) and we want to make as much
            space as possible now for future projects to load.
            </summary>
            <returns>True if any configurations were cached, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.GetEnumerator">
            <summary>
            Gets the enumerator over the configurations in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumerator over the configurations in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Sets the component host.
            </summary>
            <param name="host">The build component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.ShutdownComponent">
            <summary>
            Shuts down this component
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ConfigCache.GetKeyForConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Override which determines the key for entry into the collection from the specified build request configuration.
            </summary>
            <param name="config">The build request configuration.</param>
            <returns>The configuration id.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IPropertyCache">
            <summary>
            Represents a cache for build properties
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IResultsCache">
            <summary>
            This interface represents an object which holds build results.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IResultsCache.AddResult(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Adds a result to the cache
            </summary>
            <param name="result">The result to add.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IResultsCache.ClearResults">
            <summary>
            Deletes all results from the cache for the specified build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IResultsCache.GetResultForRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Retrieves a BuildResult for the specified matching BuildRequest.
            </summary>
            <param name="request">The request for which the result should be returned.</param>
            <returns>A BuildResult if there is a matching one in the cache, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IResultsCache.GetResultsForConfiguration(System.Int32)">
            <summary>
            Retrieves a BuildResult for the specified configuration.
            </summary>
            <param name="configurationId">The configuration for which results should be returned.</param>
            <returns>A BuildResult if there is a matching one in the cache, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IResultsCache.SatisfyRequest(Microsoft.Build.BackEnd.BuildRequest,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Attempts to satisfy the request from the cache.  The request can be satisfied only if:
            1. All specified targets in the request have non-skipped results in the cache.
            2. All initial targets in the configuration for the request have non-skipped results in the cache.
            3. If there are no specified targets, then all default targets in the request must have non-skipped results
               in the cache.
            </summary>
            <param name="request">The request whose results we should return</param>
            <param name="configInitialTargets">The initial targets for the request's configuration.</param>
            <param name="configDefaultTargets">The default targets for the request's configuration.</param>
            <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".  
            If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method 
            will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no 
            chance of re-execution (which is the usual response to missing / skipped targets), and the caller just needs the data.</param>
            <returns>A response indicating the results, if any, and the targets needing to be built, if any.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IResultsCache.ClearResultsForConfiguration(System.Int32)">
            <summary>
            Clears the results for a specific configuration.
            </summary>
            <param name="configurationId">The configuration id.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IResultsCache.WriteResultsToDisk">
            <summary>
            Caches results to disk if possible.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TranslatorExtensions">
            <summary>
            This class is responsible for serializing and deserializing anything that is not 
            officially supported by ITranslator, but that we still want to do 
            custom translation of.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TranslatorExtensions.TranslateProjectPropertyInstanceDictionary(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance}@)">
            <summary>
            Translates a PropertyDictionary of ProjectPropertyInstances.
            </summary>
            <param name="translator">The tranlator doing the translating</param>
            <param name="value">The dictionary to translate.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TranslatorExtensions.FactoryForDeserializingTypeWithName``1(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Deserialize a type or a subtype by its full name. The type must implement ITranslateable
            </summary>
            <typeparam name="T">Top level type. Serialized types can be of this type, or subtypes</typeparam>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeProviderOutOfProc">
            <summary>
            The provider for out-of-proc nodes.  This manages the lifetime of external MSBuild.exe processes
            which act as child nodes for the build system.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProc._nodeContexts">
            <summary>
            A mapping of all the nodes managed by this provider.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderOutOfProc.ProviderType">
            <summary>
            Returns the node provider type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderOutOfProc.AvailableNodes">
            <summary>
            Returns the number of available nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.GetHostHandshake(System.Boolean,System.Boolean)">
            <summary>
            Magic number sent by the host to the client during the handshake.
            Derived from the binary timestamp to avoid mixing binary versions,
            Is64BitProcess to avoid mixing bitness, and enableNodeReuse to
            ensure that a /nr:false build doesn't reuse clients left over from
            a prior /nr:true build. The enableLowPriority flag is to ensure that
            a build with /low:false doesn't reuse clients left over for a prior
            /low:true build.
            </summary>
            <param name="enableNodeReuse">Is reuse of build nodes allowed?</param>
            <param name="enableLowPriority">Is the build running at low priority?</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.GetClientHandshake">
            <summary>
            Magic number sent by the client to the host during the handshake.
            Munged version of the host handshake.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.CreateNode(System.Int32,Microsoft.Build.BackEnd.INodePacketFactory,Microsoft.Build.BackEnd.NodeConfiguration)">
            <summary>
            Instantiates a new MSBuild process acting as a child node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.SendData(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the specified node.
            </summary>
            <param name="nodeId">The node to which data shall be sent.</param>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.ShutdownConnectedNodes(System.Boolean)">
            <summary>
            Shuts down all of the connected managed nodes.
            </summary>
            <param name="enableReuse">Flag indicating if nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.ShutdownAllNodes">
            <summary>
            Shuts down all of the managed nodes permanently.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Initializes the component.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.ShutdownComponent">
            <summary>
            Shuts down the component
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Static factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProc.NodeContextTerminated(System.Int32)">
            <summary>
            Method called when a context terminates.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase">
            <summary>
            Contains the shared pieces of code from NodeProviderOutOfProc
            and NodeProviderOutOfProcTaskHost.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.MaxPacketWriteSize">
            <summary>
            The maximum number of bytes to write
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeCreationRetries">
            <summary>
            The number of times to retry creating an out-of-proc node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.TimeoutForNewNodeCreation">
            <summary>
            The amount of time to wait for an out-of-proc node to spool up before we give up.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase._componentHost">
            <summary>
            The build component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase._processesToIgnore">
            <summary>
            Keeps track of the processes we've already checked for nodes so we don't check them again.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContextTerminateDelegate">
            <summary>
            Delegate used to tell the node provider that a context has terminated.
            </summary>
            <param name="nodeId">The id of the node which terminated.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.ComponentHost">
            <summary>
            The build component host.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.SendData(Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the specified node.
            </summary>
            <param name="context">The node to which data shall be sent.</param>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.ShutdownConnectedNodes(System.Collections.Generic.List{Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext},System.Boolean)">
            <summary>
            Shuts down all of the connected managed nodes.
            </summary>
            <param name="contextsToShutDown">List of the contexts to be shut down</param>
            <param name="enableReuse">Flag indicating if nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.ShutdownAllNodes(System.Int64,System.Int64,System.Int64,Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContextTerminateDelegate)">
            <summary>
            Shuts down all of the managed nodes permanently.
            </summary>
            <param name="hostHandshake">host handshake key</param>
            <param name="hostHandshakeWithLowPriority">host handshake key with low priority added</param>
            <param name="clientHandshake">client handshake key</param>
            <param name="terminateNode">Delegate used to tell the node provider that a context has terminated</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.GetNode(System.String,System.String,System.Int32,Microsoft.Build.BackEnd.INodePacketFactory,System.Int64,System.Int64,Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContextTerminateDelegate)">
            <summary>
            Finds or creates a child process which can act as a node.
            </summary>
            <returns>The pipe stream representing the node.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.GetPossibleRunningNodes(System.String)">
            <summary>
            Finds processes named after either msbuild or msbuildtaskhost.
            </summary>
            <param name="msbuildLocation"></param>
            <returns>
            Item 1 is the name of the process being searched for.
            Item 2 is the list of processes themselves.
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.GetProcessesToIgnoreKey(System.Int64,System.Int64,System.Int32)">
            <summary>
            Generate a string from task host context and the remote process to be used as key to lookup processes we have already
            attempted to connect to or are already connected to
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.TryConnectToProcess(System.Int32,System.Int32,System.Int64,System.Int64)">
            <summary>
            Attempts to connect to the specified process.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.LaunchNode(System.String,System.String)">
            <summary>
            Creates a new MSBuild process
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.GetCurrentHost">
            <summary>
            Identify the .NET host of the current process.
            </summary>
            <returns>The full path to the executable hosting the current process, or null if running on Full Framework on Windows.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext">
            <summary>
            Class which wraps up the communications infrastructure for a given node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._packetFactory">
            <summary>
            The factory used to create packets from data read off the pipe.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._nodeId">
            <summary>
            The node id assigned by the node provider.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._processId">
            <summary>
            The process id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._headerByte">
            <summary>
            An array used to store the header byte for each packet when read.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._smallReadBuffer">
            <summary>
            A buffer typically big enough to handle a packet body.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._nodeTerminated">
            <summary>
            Event indicating the node has terminated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._terminateDelegate">
            <summary>
            Delegate called when the context terminates.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext._sharedReadBuffer">
            <summary>
            Per node read buffers
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext.#ctor(System.Int32,System.Int32,System.IO.Stream,Microsoft.Build.BackEnd.INodePacketFactory,Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContextTerminateDelegate)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext.BeginAsyncPacketRead">
            <summary>
            Starts a new asynchronous read operation for this node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext.SendData(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends the specified packet to this node.
            </summary>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext.Close">
            <summary>
            Closes the node's context, disconnecting it from the node.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost">
            <summary>
            The provider for out-of-proc nodes.  This manages the lifetime of external MSBuild.exe processes
            which act as child nodes for the build system.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.MaxNodeCount">
            <summary>
            The maximum number of nodes that this provider supports. Should
            always be equivalent to the number of different TaskHostContexts
            that exist.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_baseTaskHostPath">
            <summary>
            Store the path for MSBuild / MSBuildTaskHost so that we don't have to keep recalculating it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_baseTaskHostPath64">
            <summary>
            Store the 64-bit path for MSBuild / MSBuildTaskHost so that we don't have to keep recalculating it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_pathToX32Clr2">
            <summary>
            Store the path for the 32-bit MSBuildTaskHost so that we don't have to keep re-calculating it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_pathToX64Clr2">
            <summary>
            Store the path for the 64-bit MSBuildTaskHost so that we don't have to keep re-calculating it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_pathToX32Clr4">
            <summary>
            Store the path for the 32-bit MSBuild so that we don't have to keep re-calculating it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_pathToX64Clr4">
            <summary>
            Store the path for the 64-bit MSBuild so that we don't have to keep re-calculating it.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_msbuildName">
            <summary>
            Name for MSBuild.exe
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.s_msbuildTaskHostName">
            <summary>
            Name for MSBuildTaskHost.exe
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost._noNodesActiveEvent">
            <summary>
            Are there any active nodes?
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost._nodeContexts">
            <summary>
            A mapping of all the nodes managed by this provider.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost._nodeIdToPacketFactory">
            <summary>
            A mapping of all of the INodePacketFactories wrapped by this provider.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost._nodeIdToPacketHandler">
            <summary>
            A mapping of all of the INodePacketHandlers wrapped by this provider.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost._activeNodes">
            <summary>
            Keeps track of the set of nodes for which we have not yet received shutdown notification.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost._localPacketFactory">
            <summary>
            Packet factory we use if there's not already one associated with a particular context.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.ProviderType">
            <summary>
            Returns the node provider type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.AvailableNodes">
            <summary>
            Returns the number of available nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost">
            <summary>
            Returns the name of the CLR2 Task Host executable
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.CreateNode(System.Int32,Microsoft.Build.BackEnd.INodePacketFactory,Microsoft.Build.BackEnd.NodeConfiguration)">
            <summary>
            Instantiates a new MSBuild process acting as a child node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.SendData(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the specified node.
            </summary>
            <param name="nodeId">The node to which data shall be sent.</param>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.SendData(Microsoft.Build.Internal.TaskHostContext,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the specified node.
            </summary>
            <param name="hostContext">The node to which data shall be sent.</param>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.ShutdownConnectedNodes(System.Boolean)">
            <summary>
            Shuts down all of the connected managed nodes.
            </summary>
            <param name="enableReuse">Flag indicating if nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.ShutdownAllNodes">
            <summary>
            Shuts down all of the managed nodes permanently.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Initializes the component.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.ShutdownComponent">
            <summary>
            Shuts down the component
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers the specified handler for a particular packet type.
            </summary>
            <param name="packetType">The packet type.</param>
            <param name="factory">The factory for packets of the specified type.</param>
            <param name="handler">The handler to be called when packets of the specified type are received.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.
            </summary>
            <param name="packetType">The packet type.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Takes a serializer, deserializes the packet and routes it to the appropriate handler.
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packetType">The packet type.</param>
            <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the specified packet
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packet">The packet to route.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            This method is invoked by the NodePacketRouter when a packet is received and is intended for
            this recipient.
            </summary>
            <param name="node">The node from which the packet was received.</param>
            <param name="packet">The packet.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Static factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.ClearCachedTaskHostPaths">
            <summary>
            Clears out our cached values for the various task host names and paths.
            FOR UNIT TESTING ONLY
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.GetTaskHostNameFromHostContext(Microsoft.Build.Internal.TaskHostContext)">
            <summary>
            Given a TaskHostContext, returns the name of the executable we should be searching for.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(Microsoft.Build.Internal.TaskHostContext)">
            <summary>
            Given a TaskHostContext, return the appropriate location of the
            executable (MSBuild or MSBuildTaskHost) that we wish to use, or null
            if that location cannot be resolved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.AcquireAndSetUpHost(Microsoft.Build.Internal.TaskHostContext,Microsoft.Build.BackEnd.INodePacketFactory,Microsoft.Build.BackEnd.INodePacketHandler,Microsoft.Build.BackEnd.TaskHostConfiguration)">
            <summary>
            Make sure a node in the requested context exists.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.DisconnectFromHost(Microsoft.Build.Internal.TaskHostContext)">
            <summary>
            Expected to be called when TaskHostTask is done with host of the given context.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.CreateNode(Microsoft.Build.Internal.TaskHostContext,Microsoft.Build.BackEnd.INodePacketFactory,Microsoft.Build.BackEnd.INodePacketHandler,Microsoft.Build.BackEnd.TaskHostConfiguration)">
            <summary>
            Instantiates a new MSBuild or MSBuildTaskHost process acting as a child node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost.NodeContextTerminated(System.Int32)">
            <summary>
            Method called when a context terminates.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BatchingEngine">
            <summary>
            This class is used by objects in the build engine that have the ability to execute themselves in batches, to partition the
            items they consume into "buckets", based on the values of select item metadata.
            </summary>
            <remarks>
            What batching does
            
            Batching partitions the items consumed by the batchable object into buckets, where each bucket 
            contains a set of items that have the same value set on all item metadata consumed by the object. 
            Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it 
            refers, for example %(a.m).
            
            If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the 
            same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type ‘b’ 
            are considered to always have a blank value for %(a.m). This means items of type ‘b’ will only be 
            placed in buckets where %(a.m) is blank. However %(a.m) is equivalent to %(m) on items of type ‘a’.
            
            There is an extra ambiguity rule: every items consumed by the object must have an explicit value for 
            every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item 
            of type ‘a’ must have a value for the metadata ‘m’ but need not all necessarily have a value for the 
            metadata ‘n’. This rule eliminates ambiguity about whether items that do not define values for an 
            unqualified metadata should go in all buckets, or just into buckets with a blank value for 
            that metadata.
            
            For example 
            
            <ItemGroup>
            <a Include='a1;a2'>
              <n>m0</n>
            </a>
            <a Include='a3'>
              <n>m1</n>
            </a>
            <b Include='b1'>
              <n>n0</n>
            </b>
            <b Include='b2;b3'>
              <n>n1</n>
            </b>
            <b Include='b4'/>
            </ItemGroup>
            
            <Target Name="t" >
              <Message Text="a={@(a).%(a.n)} b={@(b).%(b.n)}" />
            </Target>
            
            Will produce 5 buckets: 
            
            a={a1;a2.m0} b={.}
            a={a3.m1} b={.}
            a={.} b={b1.n0}
            a={.} b={b2;b3.n1}
            a={.} b={b4.}
            
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BatchingEngine.PrepareBatchingBuckets(System.Collections.Generic.List{System.String},Microsoft.Build.BackEnd.Lookup,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Determines how many times the batchable object needs to be executed (each execution is termed a "batch"), and prepares
            buckets of items to pass to the object in each batch.
            </summary>
            <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BatchingEngine.PrepareBatchingBuckets(System.Collections.Generic.List{System.String},Microsoft.Build.BackEnd.Lookup,System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Determines how many times the batchable object needs to be executed (each execution is termed a "batch"), and prepares
            buckets of items to pass to the object in each batch.
            </summary>
            <param name="elementLocation"></param>
            <param name="batchableObjectParameters"></param>
            <param name="lookup"></param>
            <param name="implicitBatchableItemType">Any item type that can be considered an implicit input to this batchable object.
            This is useful for items inside targets, where the item name is plainly an item type that's an "input" to the object.</param>
            <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BatchingEngine.GetItemListsToBeBatched(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.MetadataReference},System.Collections.Generic.HashSet{System.String},Microsoft.Build.BackEnd.Lookup,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Of all the item lists that are referenced in this batchable object, which ones should we
            batch on, and which ones should we just pass in wholesale to every invocation of the 
            target/task?
            
            Rule #1.  If the user has referenced any *qualified* item metadata such as %(EmbeddedResource.Culture),
            then that item list "EmbeddedResource" will definitely get batched.
            
            Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that 
            every single item in every single item list being passed into the task contains a value
            for that metadata.  If not, it's an error.  If so, we batch all of those item lists.
            
            All other item lists will not be batched, and instead will be passed in wholesale to all buckets.
            </summary>
            <returns>Dictionary containing the item names that should be batched.  If the items match unqualified metadata,
            the entire list of items will be returned in the Value.  Otherwise, the Value will be empty, indicating only the
            qualified item set (in the Key) should be batched.
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BatchingEngine.BucketConsumedItems(Microsoft.Build.BackEnd.Lookup,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.ICollection{Microsoft.Build.Execution.ProjectItemInstance}},System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.MetadataReference},Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Partitions the items consumed by the batchable object into buckets, where each bucket contains a set of items that
            have the same value set on all item metadata consumed by the object.
            </summary>
            <remarks>
            PERF NOTE: Given n items and m batching metadata that produce l buckets, it is usually the case that n > l > m,
            because a batchable object typically uses one or two item metadata to control batching, and only has a handful of
            buckets. The number of buckets is typically only large if a batchable object is using single-item batching
            (where l == n). Any algorithm devised for bucketing therefore, should try to minimize n and l in its complexity
            equation. The algorithm below has a complexity of O(n*lg(l)*m/2) in its comparisons, and is effectively O(n) when
            l is small, and O(n*lg(n)) in the worst case as l -> n. However, note that the comparison complexity is not the
            same as the operational complexity for this algorithm. The operational complexity of this algorithm is actually
            O(n*m + n*lg(l)*m/2 + n*l/2 + n + l), which is effectively O(n^2) in the worst case. The additional complexity comes
            from the array and metadata operations that are performed. However, those operations are extremely cheap compared
            to the comparison operations, which dominate the time spent in this method.
            </remarks>
            <returns>List containing ItemBucket objects (can be empty), each one representing an execution batch.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BatchingEngine.GetItemMetadataValues(Microsoft.Build.Execution.ProjectItemInstance,System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.MetadataReference},Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Gets the values of the specified metadata for the given item.
            The keys in the dictionary returned may be qualified and/or unqualified, exactly
            as they are found in the metadata reference. 
            For example if %(x) is found, the key is "x", if %(z.x) is found, the key is "z.x".
            This dictionary in each bucket is used by Expander to expand exactly the same metadata references, so
            %(x) is expanded using the key "x", and %(z.x) is expanded using the key "z.x".
            </summary>
            <returns>the metadata values</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IntrinsicTask">
            <summary>
            A class that evaluates an ItemGroup or PropertyGroup that is within a target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTask.#ctor(Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Execution.ProjectInstance,System.Boolean)">
            <summary>
            Initializes this base class.
            </summary>
            <param name="loggingContext">The logging context</param>
            <param name="projectInstance">The project instance</param>
            <param name="logTaskInputs">Flag to determine whether or not to log task inputs.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IntrinsicTask.LoggingContext">
            <summary>
            Gets or sets the logging context.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IntrinsicTask.Project">
            <summary>
            Gets or sets the project instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IntrinsicTask.LogTaskInputs">
            <summary>
            Flag to determine whether or not to log task inputs.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTask.InstantiateTask(Microsoft.Build.Execution.ProjectTargetInstanceChild,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Execution.ProjectInstance,System.Boolean)">
            <summary>
            Factory for intrinsic tasks.
            </summary>
            <param name="taskInstance">The task instance object.</param>
            <param name="loggingContext">The logging context.</param>
            <param name="projectInstance">The project instance.</param>
            <param name="logTaskInputs"><code>true</code> to log task inputs, otherwise <code>false</code>.</param>
            <returns>An instantiated intrinsic task.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTask.ExecuteTask(Microsoft.Build.BackEnd.Lookup)">
            <summary>
            Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
            </summary>
            <param name="lookup">The lookup used for expansion and to receive created items and properties.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IntrinsicTask.AddIfNotEmptyString(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            If value is not an empty string, adds it to list.
            </summary>
            <param name="list">The list of strings to which this should be added, if it is not empty.</param>
            <param name="value">The string to add.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask">
            <summary>
            Implementation of the ItemGroup intrinsic task
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask._taskInstance">
            <summary>
            The task instance data
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.#ctor(Microsoft.Build.Execution.ProjectItemGroupTaskInstance,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Execution.ProjectInstance,System.Boolean)">
            <summary>
            Instantiates an ItemGroup task
            </summary>
            <param name="taskInstance">The original task instance data</param>
            <param name="loggingContext">The logging context</param>
            <param name="projectInstance">The project instance</param>
            <param name="logTaskInputs">Flag to determine whether or not to log task inputs.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.ExecuteTask(Microsoft.Build.BackEnd.Lookup)">
            <summary>
            Execute an ItemGroup element, including each child item expression
            </summary>
            <param name="lookup">The lookup used for evaluation and as a destination for these items.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.ExecuteAdd(Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance,Microsoft.Build.BackEnd.ItemBucket,System.Collections.Generic.ISet{System.String},System.Collections.Generic.ISet{System.String})">
            <summary>
            Add items to the world. This is the in-target equivalent of an item include expression outside of a target.
            </summary>
            <param name="child">The item specification to evaluate and add.</param>
            <param name="bucket">The batching bucket.</param>
            <param name="keepMetadata">An <see cref="T:System.Collections.Generic.ISet`1"/> of metadata names to keep.</param>
            <param name="removeMetadata">An <see cref="T:System.Collections.Generic.ISet`1"/> of metadata names to remove.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.ExecuteRemove(Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance,Microsoft.Build.BackEnd.ItemBucket)">
            <summary>
            Remove items from the world. Removes to items that are part of the project manifest are backed up, so 
            they can be reverted when the project is reset after the end of the build.
            </summary>
            <param name="child">The item specification to evaluate and remove.</param>
            <param name="bucket">The batching bucket.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.ExecuteModify(Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance,Microsoft.Build.BackEnd.ItemBucket,System.Collections.Generic.ISet{System.String},System.Collections.Generic.ISet{System.String})">
            <summary>
            Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so 
            they can be reverted when the project is reset after the end of the build.
            </summary>
            <param name="child">The item specification to evaluate and modify.</param>
            <param name="bucket">The batching bucket.</param>
            <param name="keepMetadata">An <see cref="T:System.Collections.Generic.ISet`1"/> of metadata names to keep.</param>
            <param name="removeMetadata">An <see cref="T:System.Collections.Generic.ISet`1"/> of metadata names to remove.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.GetBatchableValuesFromBuildItemGroupChild(System.Collections.Generic.List{System.String},Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance)">
            <summary>
            Adds batchable parameters from an item element into the list. If the item element was a task, these
            would be its raw parameter values.
            </summary>
            <param name="parameterValues">The list of batchable values</param>
            <param name="child">The item from which to find batchable values</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.ExpandItemIntoItems(Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance,Microsoft.Build.Evaluation.Expander{Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance},System.Collections.Generic.ISet{System.String},System.Collections.Generic.ISet{System.String})">
            <summary>
            Takes an item specification, evaluates it and expands it into a list of items
            </summary>
            <param name="originalItem">The original item data</param>
            <param name="expander">The expander to use.</param>
            <param name="keepMetadata">An <see cref="T:System.Collections.Generic.ISet`1"/> of metadata names to keep.</param>
            <param name="removeMetadata">An <see cref="T:System.Collections.Generic.ISet`1"/> of metadata names to remove.</param>
            <remarks>
            This code is very close to that which exists in the Evaluator.EvaluateItemXml method.  However, because
            it invokes type constructors, and those constructors take arguments of fundamentally different types, it has not
            been refactored.
            </remarks>
            <returns>A list of items.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.FindItemsMatchingSpecification(System.Collections.Generic.ICollection{Microsoft.Build.Execution.ProjectItemInstance},System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Evaluation.Expander{Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Returns a list of all items in the provided item group whose itemspecs match the specification, after it is split and any wildcards are expanded.
            If no items match, returns null.
            </summary>
            <param name="items">The items to match</param>
            <param name="specification">The specification to match against the items.</param>
            <param name="specificationLocation">The specification to match against the provided items</param>
            <param name="expander">The expander to use</param>
            <returns>A list of matching items</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable">
            <summary>
            This class is used during ItemGroup intrinsic tasks to resolve metadata references.  It consists of three tables:
            1. The metadata added during evaluation.
            1. The metadata table created for the bucket, may be null.
            2. The metadata table derived from the item definition group, may be null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable._addTable">
            <summary>
            The table for all metadata added during expansion
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable._bucketTable">
            <summary>
            The table for metadata which was generated for this batch bucket.
            May be null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable._itemDefinitionTable">
            <summary>
            The table for metadata from the item definition
            May be null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable._itemType">
            <summary>
            The item type to which this metadata applies.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable.#ctor(System.String,Microsoft.Build.Evaluation.IMetadataTable,Microsoft.Build.Evaluation.IMetadataTable)">
            <summary>
            Creates a new metadata table aggregating the bucket and item definition tables.
            </summary>
            <param name="itemType">The type of item for which we are doing evaluation.</param>
            <param name="bucketTable">The metadata table created for this batch bucket.  May be null.</param>
            <param name="itemDefinitionTable">The metadata table for the item definition representing this item.  May be null.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable.AddedMetadata">
            <summary>
            Retrieves the metadata table used to collect additions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable.GetEscapedValue(System.String)">
            <summary>
            Gets the specified metadata value.  Returns an empty string if none is set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable.GetEscapedValue(System.String,System.String)">
            <summary>
            Gets the specified metadata value for the qualified item type.  Returns an empty string if none is set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable.GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Gets the specified metadata value for the qualified item type.  Returns null if none is set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemGroupIntrinsicTask.NestedMetadataTable.SetValue(System.String,System.String)">
            <summary>
            Sets the metadata value.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask">
            <summary>
            This class represents a PropertyGroup intrinsic task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask._taskInstance">
            <summary>
            The original task instance data.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask.#ctor(Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Execution.ProjectInstance,System.Boolean)">
            <summary>
            Create a new PropertyGroup task.
            </summary>
            <param name="taskInstance">The task instance data</param>
            <param name="loggingContext">The logging context</param>
            <param name="projectInstance">The project instance</param>
            <param name="logTaskInputs">Flag to determine whether or not to log task inputs.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask.ExecuteTask(Microsoft.Build.BackEnd.Lookup)">
            <summary>
            Execute a PropertyGroup element, including each child property
            </summary>
            <param name="lookup">The lookup use for evaluation and as a destination for these properties.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask.GetBatchableValuesFromProperty(System.Collections.Generic.List{System.String},Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance)">
            <summary>
            Adds batchable parameters from a property element into the list. If the property element was
            a task, these would be its raw parameter values.
            </summary>
            <param name="parameterValues">The list which will contain the batchable values.</param>
            <param name="property">The property from which to take the values.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ITargetBuilderCallback">
            <summary>
            Interface implemented by the Target Builder which allows tasks to invoke targets and build projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITargetBuilderCallback.LegacyCallTarget(System.String[],System.Boolean,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Invokes the specified targets using Dev9 behavior.  
            </summary>
            <param name="targets">The targets to build.</param>
            <param name="continueOnError">True to continue building the remaining targets if one fails.</param>
            <param name="referenceLocation">The <see cref="T:Microsoft.Build.Construction.ElementLocation"/> of the reference.</param>
            <returns>The results for each target.</returns>
            <remarks>
            The target is run using the data context of the Project, rather than the data context 
            of the current target.  This has the following effects:
            1. Data visible to the CALLING target at the time it was first invoked is the only
               data which the CALLED target can see.  No changes made between the time the CALLING
               target starts and the CALLED target starts are visible to the CALLED target.
            2. Items and Properties modified by the CALLED target are not visible to the CALLING
               target, even after the CALLED target returns.  However, any changes made to
               items and properties by the CALLING target will override any changes made by the
               CALLED target.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TargetSpecification">
            <summary>
            Contains information about a target name and reference location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetSpecification.#ctor(System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Construct a target specification.
            </summary>
            <param name="targetName">The name of the target</param>
            <param name="referenceLocation">The location from which it was referred.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetSpecification.TargetName">
            <summary>
            Gets or sets the target name            
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetSpecification.ReferenceLocation">
            <summary>
            Gets or sets the reference location
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.InProcNode">
            <summary>
            This class represents an implementation of INode for out-of-proc nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._componentHost">
            <summary>
            The build component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._savedEnvironment">
            <summary>
            The environment at the time the build is started.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._savedCurrentDirectory">
            <summary>
            The current directory at the time the build is started.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._loggingContext">
            <summary>
            The node logging context.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._buildRequestEngine">
            <summary>
            The build request engine.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._receivedPackets">
            <summary>
            The queue of packets we have received but which have not yet been processed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._packetReceivedEvent">
            <summary>
            The event which is set when we receive packets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._shutdownEvent">
            <summary>
            The event which is set when we should shut down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._shutdownReason">
            <summary>
            The reason we are shutting down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._shutdownException">
            <summary>
            The exception, if any, which caused shutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._nodeEndpoint">
            <summary>
            The node endpoint
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._engineExceptionEventHandler">
            <summary>
            Handler for engine exceptions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._newConfigurationRequestEventHandler">
            <summary>
            Handler for new configuration requests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._requestBlockedEventHandler">
            <summary>
            Handler for blocked request events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.InProcNode._requestCompleteEventHandler">
            <summary>
            Handler for request completed events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.#ctor(Microsoft.Build.BackEnd.IBuildComponentHost,Microsoft.Build.BackEnd.INodeEndpoint)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.Run(System.Exception@)">
            <summary>
            Starts up the node and processes messages until the node is requested to shut down.
            </summary>
            <param name="shutdownException">The exception which caused shutdown, if any.</param>
            <returns>The reason for shutting down.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Not necessary for in-proc node - we don't serialize.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Not necessary for in-proc node - we don't serialize.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Not necessary for in-proc node - we don't serialize.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the packet to the appropriate handler.
            </summary>
            <param name="nodeId">The node id.</param>
            <param name="packet">The packet.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.OnRequestComplete(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Event handler for the BuildEngine's OnRequestComplete event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.OnNewRequest(Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Event handler for the BuildEngine's OnNewRequest event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.OnNewConfigurationRequest(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Event handler for the BuildEngine's OnNewConfigurationRequest event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.OnLoggingThreadException(System.Exception)">
            <summary>
            Event handler for the LoggingService's OnLoggingThreadException event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.OnEngineException(System.Exception)">
            <summary>
            Event handler for the BuildEngine's OnEngineException event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandleShutdown(System.Exception@)">
            <summary>
            Perform necessary actions to shut down the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandlePacket(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Dispatches the packet to the correct handler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.OnLinkStatusChanged(Microsoft.Build.BackEnd.INodeEndpoint,Microsoft.Build.BackEnd.LinkStatus)">
            <summary>
            Event handler for the node endpoint's LinkStatusChanged event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandleBuildRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Handles the BuildRequest packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandleBuildRequestConfiguration">
            <summary>
            Handles the BuildRequestConfiguration packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandleBuildRequestConfigurationResponse(Microsoft.Build.BackEnd.BuildRequestConfigurationResponse)">
            <summary>
            Handles the BuildRequestConfigurationResponse packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandleBuildResult(Microsoft.Build.BackEnd.BuildRequestUnblocker)">
            <summary>
            Handles the BuildResult packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandleNodeConfiguration(Microsoft.Build.BackEnd.NodeConfiguration)">
            <summary>
            Handles the NodeConfiguration packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.InProcNode.HandleNodeBuildComplete(Microsoft.Build.BackEnd.NodeBuildComplete)">
            <summary>
            Handles the NodeBuildComplete packet.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeConfiguration">
            <summary>
            NodeConfiguration contains all of the information necessary for a node to configure itself for building.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeConfiguration._nodeId">
            <summary>
            The node id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeConfiguration._buildParameters">
            <summary>
            The system parameters which were defined on the host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeConfiguration._appDomainSetup">
            <summary>
            The app domain information needed for setting up AppDomain-isolated tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeConfiguration._forwardingLoggers">
            <summary>
            The forwarding loggers to use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeConfiguration._loggingNodeConfiguration">
            <summary>
            The logging configuration for the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeConfiguration.#ctor(System.Int32,Microsoft.Build.Execution.BuildParameters,Microsoft.Build.Logging.LoggerDescription[],System.AppDomainSetup,Microsoft.Build.BackEnd.LoggingNodeConfiguration)">
            <summary>
            Constructor
            </summary>
            <param name="nodeId">The node id.</param>
            <param name="buildParameters">The build parameters</param>
            <param name="forwardingLoggers">The forwarding loggers.</param>
            <param name="appDomainSetup">The AppDomain setup information.</param>
            <param name="loggingNodeConfiguration">The logging configuration for the node.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeConfiguration.#ctor">
            <summary>
            Private constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeConfiguration.NodeId">
            <summary>
            Gets or sets the node id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeConfiguration.BuildParameters">
            <summary>
            Retrieves the system parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeConfiguration.LoggerDescriptions">
            <summary>
            Retrieves the logger descriptions.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeConfiguration.AppDomainSetup">
            <summary>
            Retrieves the app domain setup information.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeConfiguration.LoggingNodeConfiguration">
            <summary>
            The logging configuration for the node.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeConfiguration.Type">
            <summary>
            Retrieves the packet type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeConfiguration.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates the packet to/from binary form.
            </summary>
            <param name="translator">The translator to use.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeConfiguration.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeConfiguration.Clone">
            <summary>
            We need to clone this object since it gets modified for each node which is launched.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NativeMethods">
            <summary>
            Native methods used by the backend. This was copied from the oldOM so we can make it stylecop compliant and allow
            easier deletion of the native code in the old OM
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.NullPtr">
            <summary>
            Null Pointer
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.InvalidHandle">
            <summary>
            Invalid Handle
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.NORMALPRIORITYCLASS">
            <summary>
            Start the process with a normal priority class
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.CREATENOWINDOW">
            <summary>
            Do not create a window
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTFUSESTDHANDLES">
            <summary>
            Use the standard handles
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.CREATE_NEW_CONSOLE">
            <summary>
            Create a new console.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NativeMethods.CreateProcess(System.String,System.String,Microsoft.Build.BackEnd.NativeMethods.SECURITY_ATTRIBUTES@,Microsoft.Build.BackEnd.NativeMethods.SECURITY_ATTRIBUTES@,System.Boolean,System.UInt32,System.IntPtr,System.String,Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO@,Microsoft.Build.BackEnd.NativeMethods.PROCESS_INFORMATION@)">
            <summary>
            Create a new process
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO">
            <summary>
            Structure that contains the startupinfo
            Represents STARTUP_INFO in win32
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.cb">
            <summary>
            The size of the structure, in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.lpReserved">
            <summary>
            Reserved; must be NULL
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.lpDesktop">
            <summary>
            The name of the desktop, or the name of both the desktop and window station for this process.
            A backslash in the string indicates that the string includes both the desktop and window station names
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.lpTitle">
            <summary>
            For console processes, this is the title displayed in the title bar if a new console window is created. 
            If NULL, the name of the executable file is used as the window title instead. 
            This parameter must be NULL for GUI or console processes that do not create a new console window
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwX">
            <summary>
            If dwFlags specifies STARTF_USEPOSITION, this member is the x offset of the upper left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwY">
            <summary>
            If dwFlags specifies STARTF_USEPOSITION, this member is the y offset of the upper left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwXSize">
            <summary>
            If dwFlags specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwYSize">
            <summary>
            If dwFlags specifies STARTF_USESIZE, this member is the height of the window if a new window is created, in pixels. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwXCountChars">
            <summary>
            If dwFlags specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer width, in character columns. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwYCountChars">
            <summary>
            If dwFlags specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.dwFillAttribute 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwFillAttribute">
            <summary>
            If dwFlags specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.dwFlags">
            <summary>
            A bit field that determines whether certain STARTUPINFO members are used when the process creates a window
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.wShowWindow">
            <summary>
            If dwFlags specifies STARTF_USESHOWWINDOW, this member can be any of the SW_ constants defined in Winuser.h. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.cbReserved2">
            <summary>
            Reserved for use by the C Run-time; must be zero.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.lpReserved2">
            <summary>
            Reserved for use by the C Run-time; must be NULL.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.hStdInput">
            <summary>
            If dwFlags specifies STARTF_USESTDHANDLES, this member is the standard input handle for the process. Otherwise, this member is ignored and the default for standard input is the keyboard buffer.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.hStdOutput">
            <summary>
            If dwFlags specifies STARTF_USESTDHANDLES, this member is the standard output handle for the process. Otherwise, this member is ignored and the default for standard output is the console window's buffer.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.STARTUP_INFO.hStdError">
            <summary>
            If dwFlags specifies STARTF_USESTDHANDLES, this member is the standard error handle for the process. Otherwise, this member is ignored and the default for standard error is the console window's buffer.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NativeMethods.SECURITY_ATTRIBUTES">
            <summary>
            Structure to contain security attributes from the create process call represents
            SECURITY_ATTRIBUTE in win32
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure. Set this value to the size of the SECURITY_ATTRIBUTES structure
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a security descriptor for the object that controls the sharing of it.
            If NULL is specified for this member, the object is assigned the default security descriptor of the calling process. 
            This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). 
            The default security descriptor is based on the default DACL of the access token belonging to the calling process.
            By default, the default DACL in the access token of a process allows access only to the user represented by the access token. 
            If other users must access the object, you can either create a security descriptor with the appropriate access, 
            or add ACEs to the DACL that grants access to a group of users. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created.
            If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NativeMethods.PROCESS_INFORMATION">
            <summary>
            Process information from the create process call
            Represents PROCESS_INFORMATION in win32
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.PROCESS_INFORMATION.hProcess">
            <summary>
            A handle to the newly created process. The handle is used to specify the process in all functions that perform operations on the process object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.PROCESS_INFORMATION.hThread">
            <summary>
            A handle to the primary thread of the newly created process. The handle is used to specify the thread in all functions that perform operations on the thread object
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.PROCESS_INFORMATION.dwProcessId">
            <summary>
            A value that can be used to identify a process.
            The value is valid from the time the process is created until all handles to the process are closed and 
            the process object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NativeMethods.PROCESS_INFORMATION.dwThreadId">
            <summary>
            A value that can be used to identify a thread. The value is valid from the time the thread is created until all handles to the thread are closed and the thread object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NewBuildRequestsDelegate">
            <summary>
            Delegate for event raised when a new build request needs to be issued.
            </summary>
            <param name="issuingEntry">The entry issuing the request.</param>
            <param name="requests">The request to be issued.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestCompletedDelegate">
            <summary>
            Delegate for event raised when a build request has completed.
            </summary>
            <param name="completedEntry">The entry which completed.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestBlockedDelegate">
            <summary>
            Delegate for event raised when a build request is blocked on another request which is in progress.
            </summary>
            <param name="issuingEntry">The build request entry which is being blocked.</param>
            <param name="blockingGlobalRequestId">The request on which we are blocked.</param>
            <param name="blockingTarget">The target on which we are blocked.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IRequestBuilder">
            <summary>
            Represents a class which is capable of building BuildRequestEntries.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IRequestBuilder.OnNewBuildRequests">
            <summary>
            Raised when a new build request is to be issued.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IRequestBuilder.OnBuildRequestCompleted">
            <summary>
            Raised when the build request is complete.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IRequestBuilder.OnBuildRequestBlocked">
            <summary>
            Raised when a build request is blocked on another one in progress.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilder.BuildRequest(Microsoft.Build.BackEnd.Logging.NodeLoggingContext,Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Builds the request contained in the specified entry.
            </summary>
            <param name="nodeLoggingContext">The logging context for the node.</param>
            <param name="entry">The entry to be built.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilder.ContinueRequest">
            <summary>
            Continues building a request which was previously waiting for results.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilder.CancelRequest">
            <summary>
            Cancels an existing request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilder.BeginCancel">
            <summary>
            Starts to cancel an existing request.
            </summary>
            <remarks>
            This method should return immediately after signal the cancel event.
            "CancelRequest()" is equal to call "BeginCancel()" and "WaitForCancelCompletion()".
            We break "CancelRequest()" to 2 phases, so that we could signal cancel event
            to a bunch of requests without waiting, in order to optimize the "cancel build" scenario.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilder.WaitForCancelCompletion">
            <summary>
            Waits for the cancellation until it's completed, and cleans up the internal states.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IRequestBuilderCallback">
            <summary>
            This interface is passed to objects which might need to call back into the request builder, such as the Target and Task builders
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilderCallback.BuildProjects(System.String[],Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance}[],System.String[],System.String[],System.Boolean,System.Boolean)">
            <summary>
            This method instructs the request builder to build the specified projects using the specified parameters.  This is
            what is ultimately used by something like an MSBuild task which needs to invoke a project-to-project reference.  IBuildEngine
            and IBuildEngine2 have BuildProjectFile methods which boil down to an invocation of this method as well.
            </summary>
            <param name="projectFiles">An array of projects to be built.</param>
            <param name="properties">The property groups to use for each project.  Must be the same number as there are project files.</param>
            <param name="toolsVersions">The tools version to use for each project.  Must be the same number as there are project files.</param>
            <param name="targets">The targets to be built.  Each project will be built with the same targets.</param>
            <param name="waitForResults">True to wait for the results </param>
            <param name="skipNonexistentTargets">If set, skip targets that are not defined in the projects to be built.</param>
            <returns>An Task representing the work which will be done.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilderCallback.BlockOnTargetInProgress(System.Int32,System.String,Microsoft.Build.Execution.BuildResult)">
            <summary>
            This method instructs the request builder that the target builder is blocked on a target which is already in progress on the
            configuration due to another request.
            </summary>
            <param name="blockingRequestId">The request on which we are blocked.</param>
            <param name="blockingTarget">The target on which we are blocked.</param>
            <param name="partialBuildResult">Results so far from the target builder that's blocking</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilderCallback.Yield">
            <summary>
            Instructs the RequestBuilder that it may yield its control of the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilderCallback.Reacquire">
            <summary>
            Instructs the RequestBuilder to suspend until the node is reacquired.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilderCallback.EnterMSBuildCallbackState">
            <summary>
            Instructs the RequestBuilder that next Build request from a task should post its request
            and immediately return so that the thread may be freed up.  May not be nested.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IRequestBuilderCallback.ExitMSBuildCallbackState">
            <summary>
            Exits the previous MSBuild callback state.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ITargetBuilder">
            <summary>
            Represents an object which can build targets for a project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITargetBuilder.BuildTargets(Microsoft.Build.BackEnd.Logging.ProjectLoggingContext,Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.IRequestBuilderCallback,System.String[],Microsoft.Build.BackEnd.Lookup,System.Threading.CancellationToken)">
            <summary>
            Builds the specified targets.
            </summary>
            <param name="projectLoggingContext">The logging context for the project.</param>
            <param name="entry">The BuildRequestEntry for which we are building targets.</param>
            <param name="callback">The callback to be used to handle new project build requests.</param>
            <param name="targets">The targets to build.</param>
            <param name="baseLookup">The Lookup containing all current items and properties for this target.</param>
            <param name="cancellationToken">The cancellation token used to cancel processing of targets.</param>
            <returns>A Task representing the work to be done.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskExecutionMode">
            <summary>
            Flags indicating the mode in which the task builder should operate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionMode.Invalid">
            <summary>
            This entry is necessary to use the enum with binary math. It is never used outside 
            intermediate calculations.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionMode.ExecuteTaskAndGatherOutputs">
            <summary>
            In this mode, the task engine actually runs the task and retrieves its outputs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionMode.InferOutputsOnly">
            <summary>
            In this mode, the task engine only infers the task's outputs from its &lt;Output&gt; tags.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ITaskBuilder">
            <summary>
            Interface representing an object which can build tasks.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.ITargetBuilderCallback,Microsoft.Build.Execution.ProjectTargetInstanceChild,Microsoft.Build.BackEnd.TaskExecutionMode,Microsoft.Build.BackEnd.Lookup,Microsoft.Build.BackEnd.Lookup,System.Threading.CancellationToken)">
            <summary>
            Executes the specified task, batching it is necessary.
            </summary>
            <param name="targetLoggingContext">The logging context for the target</param>
            <param name="requestEntry">The build request entry</param>
            <param name="targetBuilderCallback">The callback to use for handling new build requests.</param>
            <param name="task">The node for the task</param>
            <param name="mode">The mode to use when executing the task.</param>
            <param name="lookupForInference">The lookup used when we are inferring outputs from inputs.</param>
            <param name="lookupForExecution">The lookup used when executing the task to get its outputs.</param>
            <param name="cancellationToken">The cancellation token used to cancel processing of the task.</param>
            <returns>A Task representing the work to be done.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ItemBucket">
            <summary>
            This class represents a collection of items that are homogeneous w.r.t.
            a certain set of metadata.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemBucket._expander">
            <summary>
            This single object contains all of the data necessary to perform expansion of metadata, properties,
            and items.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemBucket._metadata">
            <summary>
            Metadata in this bucket
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemBucket._lookup">
            <summary>
            The items for this bucket.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemBucket._bucketSequenceNumber">
            <summary>
            When buckets are being created for batching purposes, this indicates which order the 
            buckets were created in, so that the target/task being batched gets called with the items
            in the same order as they were declared in the project file.  For example, the first
            bucket created gets bucketSequenceNumber=0, the second bucket created gets 
            bucketSequenceNumber=1, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ItemBucket._lookupEntry">
            <summary>
            The entry we enter when we create the bucket.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemBucket.#ctor">
            <summary>
            Private default constructor disallows parameterless instantiation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemBucket.#ctor(System.Collections.Generic.ICollection{System.String},System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.Build.BackEnd.Lookup,System.Int32)">
            <summary>
            Creates an instance of this class using the given bucket data.
            </summary>
            <param name="itemNames">Item types being batched on: null indicates no batching is occurring</param>
            <param name="metadata">Hashtable of item metadata values: null indicates no batching is occurring</param>
            <param name="lookup">The <see cref="P:Microsoft.Build.BackEnd.ItemBucket.Lookup"/> to use for the items in the bucket.</param>
            <param name="bucketSequenceNumber">A sequence number indication what order the buckets were created in.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemBucket.CompareTo(System.Object)">
            <summary>
            Compares this item bucket against the given one. The comparison is
            solely based on the values of the item metadata in the buckets.
            </summary>
            <param name="obj"></param>
            <returns>
            -1, if this bucket is "less than" the second one
             0, if this bucket is equivalent to the second one
            +1, if this bucket is "greater than" the second one
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemBucket.GetDummyBucketForComparisons(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs a token bucket object that can be compared against other
            buckets. This dummy bucket is a patently invalid bucket, and cannot
            be used for any other operations besides comparison.
            </summary>
            <remarks>
            PERF NOTE: A dummy bucket is intentionally very light-weight, and it
            allocates a minimum of memory compared to a real bucket.
            </remarks>
            <returns>An item bucket that is invalid for everything except comparisons.</returns>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ItemBucket.Expander">
            <summary>
            Returns the object that knows how to handle all kinds of expansion for this bucket.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ItemBucket.BucketSequenceNumber">
            <summary>
            When buckets are being created for batching purposes, this indicates which order the 
            buckets were created in, so that the target/task being batched gets called with the items
            in the same order as they were declared in the project file.  For example, the first
            bucket created gets bucketSequenceNumber=0, the second bucket created gets 
            bucketSequenceNumber=1, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ItemBucket.Lookup">
            <summary>
            The items for this bucket.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemBucket.AddItem(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Adds a new item to this bucket.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ItemBucket.LeaveScope">
            <summary>
            Leaves the lookup scope created for this bucket.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Lookup">
            <summary>
            Contains a list of item and property collections, optimized to allow
                - very fast "cloning"
                - quick lookups
                - scoping down of item subsets in nested scopes (useful for batches)
                - isolation of adds, removes, modifies, and property sets inside nested scopes
                
            When retrieving the item group for an item type, each table is consulted in turn,
            starting with the primary table (the "top" or "innermost" table), until a table is found that has an entry for that type.
            When an entry is found, it is returned without looking deeper.
            This makes it possible to let callers see only a subset of items without affecting or cloning the original item groups,
            by populating a scope with item groups that are empty or contain subsets of items in lower scopes.
            
            Instances of this class can be cloned with Clone() to share between batches.
            
            When EnterScope() is called, a fresh primary table is inserted, and all adds and removes will be invisible to
            any clones made before the scope was entered and anyone who has access to item groups in lower tables.
            
            When LeaveScope() is called, the primary tables are merged into the secondary tables, and the primary tables are discarded.
            This makes the adds and removes in the primary tables visible to clones made during the previous scope.
            
            Scopes can be populated (before Adds, Removes, and Lookups) using PopulateWithItem(). This reduces the set of items of a particular
            type that are visible in a scope, because lookups of items of this type will stop at this level and see the subset, rather than the
            larger set in a scope below.
            
            Items can be added or removed by calling AddNewItem() and RemoveItem(). Only the primary level is modified.
            When items are added or removed they enter into a primary table exclusively for adds or removes, instead of the main primary table.
            This allows the adds and removes to be applied to the scope below on LeaveScope(). Even when LeaveScope() is called, the adds and removes
            stay in their separate add and remove tables: if they were applied to a main table, they could truncate the downward traversal performed by lookups
            and hide items in a lower main table. Only on the final call of LeaveScope() can all adds and removes be applied to the outermost table, i.e., the project.
            
            Much the same applies to properties.
            
            For sensible semantics, only the current primary scope can be modified at any point.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup._lookupScopes">
            <summary>
            Ordered list of scope used for lookup.
            Each scope contains multiple tables:
             - the main item table (populated with subsets of lists, in order to create batches)
             - the add table (items that have been added during execution)
             - the remove table (items that have been removed during execution)
             - the modify table (item metadata modifications)
             - the main property table (populated with properties that are visible in this scope)
             - the property set table (changes made to properties)
            All have to be consulted to find the items and properties available in the current scope.
            We have to keep them separate, because the adds and removes etc need to be applied to the table
            below when we leave a scope.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup._cloneTable">
            <summary>
            When we are asked for all the items of a certain type using the GetItems() method, we may have to handle items
            that have been modified earlier with ModifyItems(). These pending modifications can't be applied immediately to
            the item because that would affect other batches. Instead we clone the item, apply the modification, and hand that over.
            The problem is that later we might get asked to remove or modify that item. We want to make sure that we record that as
            a remove or modify of the real item, not the clone we handed over. So we keep a lookup of (clone, original) to consult.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.#ctor(Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Construct a lookup over specified items and properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.#ctor(Microsoft.Build.BackEnd.Lookup)">
            <summary>
            Copy constructor (called via Clone() - clearer semantics)
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.GetPropertyOverrideMessages(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Compares the primary property sets of the passed in lookups to determine if there are properties which are shared between
            the lookups. We find these shared property names because this indicates that the current Lookup is overriding the property value of another Lookup
            When an override is detected a messages is generated to inform the users that the property is being changed between batches
            </summary>
            <returns>array or error messages to log </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.Clone">
            <summary>
            Clones this object, to create another one with its own list, but the same contents.
            Then the clone can enter scope and have its own fresh primary list without affecting the other object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.EnterScope(System.String)">
            <summary>
            Enters the scope using the specified description.
            Callers keep the scope in order to pass it to <see cref="M:Microsoft.Build.BackEnd.Lookup.LeaveScope(Microsoft.Build.BackEnd.Lookup.Scope)">LeaveScope</see>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.LeaveScope(Microsoft.Build.BackEnd.Lookup.Scope)">
            <summary>
            Leaves the specified scope, which must be the active one.
            Moves all tables up one: the tertiary table becomes the secondary table, and so on. The primary
            and secondary table are merged. This has the effect of "applying" the adds applied to the primary
            table into the secondary table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MergeScopeIntoNotLastScope">
            <summary>
            Leaving an arbitrary scope, just merging all the adds, removes, modifies, and sets into the scope below.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MergeScopeIntoLastScope">
            <summary>
            Merge the current scope down into the base scope. This means applying the adds, removes, modifies, and sets
            directly into the item and property tables in this scope.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.GetProperty(System.String,System.Int32,System.Int32)">
            <summary>
            Gets the effective property for the current scope.
            taking the name from the provided string within the specified start and end indexes.
            If no match is found, returns null.
            Caller must not modify the property returned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.GetProperty(System.String)">
            <summary>
            Gets the effective property for the current scope.
            If no match is found, returns null.
            Caller must not modify the property returned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.GetItems(System.String)">
            <summary>
            Gets the items of the specified type that are visible in the current scope.
            If no match is found, returns an empty list.
            Caller must not modify the group returned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.PopulateWithItems(System.String,System.Collections.Generic.ICollection{Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Populates with an item group. This is done before the item lookup is used in this scope.
            Assumes all the items in the group have the same, provided, type.
            Assumes there is no item group of this type in the primary table already.
            Should be used only by batching buckets, and if no items are passed,
            explicitly stores a marker for this item type indicating this.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.PopulateWithItem(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Populates with an item. This is done before the item lookup is used in this scope.
            There may or may not already be a group for it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.SetProperty(Microsoft.Build.Execution.ProjectPropertyInstance)">
            <summary>
            Apply a property to this scope.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.AddNewItemsOfItemType(System.String,System.Collections.Generic.ICollection{Microsoft.Build.Execution.ProjectItemInstance},System.Boolean)">
            <summary>
            Implements a true add, an item that has been created in a batch.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.AddNewItem(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Implements a true add, an item that has been created in a batch.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Remove a bunch of items from this scope
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Remove an item from this scope
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.ModifyItems(System.String,System.Collections.Generic.ICollection{Microsoft.Build.Execution.ProjectItemInstance},Microsoft.Build.BackEnd.Lookup.MetadataModifications)">
            <summary>
            Modifies items in this scope with the same set of metadata modifications.
            Assumes all the items in the group have the same, provided, type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.ApplyModifies(Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance},System.Collections.Generic.Dictionary{Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.BackEnd.Lookup.MetadataModifications})">
            <summary>
            Apply modifies to a temporary result group.
            Items to be modified are virtual-cloned so the original isn't changed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.ApplyMetadataModificationsToItem(Microsoft.Build.BackEnd.Lookup.MetadataModifications,Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Applies the specified modifications to the supplied item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.RetrieveOriginalFromCloneTable(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Look up the "real" item by using its clone, and return the real item.
            See <see cref="F:Microsoft.Build.BackEnd.Lookup._cloneTable"/> for explanation of the clone table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.ApplyModificationsToTable(Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance},System.String,System.Collections.Generic.Dictionary{Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.BackEnd.Lookup.MetadataModifications})">
            <summary>
            Applies a list of modifications to the appropriate <see cref="T:Microsoft.Build.Collections.ItemDictionary`1" /> in a main table.
            If any modifications conflict, these modifications win.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MergeModificationsIntoModificationTable(System.Collections.Generic.Dictionary{Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.BackEnd.Lookup.MetadataModifications},System.Collections.Generic.KeyValuePair{Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.BackEnd.Lookup.MetadataModifications},Microsoft.Build.BackEnd.Lookup.ModifyMergeType)">
            <summary>
            Applies a modification to an item in a table of modifications.
            If the item already exists in the table, merges in the modifications; if there is a conflict
            the mergeType indicates which should win.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MustNotBeOuterScope">
            <summary>
            Add/remove/modify/set directly on an outer scope would need to be handled separately - it would apply
            directly to the main tables. Our code isn't expected to do this.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Lookup.ModifyMergeType">
            <summary>
            When merging metadata, we can deal with a conflict two different ways:
            FirstWins = any previous metadata with the name takes precedence
            SecondWins = the new metadata with the name takes precedence
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Lookup.MetadataModifications">
            <summary>
            A class representing a set of additions, modifications or removal of metadata from items.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.MetadataModifications._keepOnlySpecified">
            <summary>
            Flag indicating if the modifications should be interpreted such that the lack of an explicit entry for a metadata name
            means that that metadata should be removed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.MetadataModifications._modifications">
            <summary>
            A set of explicitly-specified modifications.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModifications.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="keepOnlySpecified">When true, metadata which is not explicitly-specified here but which is present on the target
            item should be removed.  When false, only explicitly-specified modifications apply.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModifications.#ctor(Microsoft.Build.BackEnd.Lookup.MetadataModifications)">
            <summary>
            Cloning constructor.
            </summary>
            <param name="other">The metadata modifications to clone.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModifications.Clone">
            <summary>
            Clones this modification set.
            </summary>
            <returns>A copy of the modifications.</returns>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.MetadataModifications.HasChanges">
            <summary>
            A flag indicating whether or not there are any changes which might apply.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.MetadataModifications.KeepOnlySpecified">
            <summary>
            A flag indicating whether only those metadata explicitly-specified should be retained on a target item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModifications.ApplyModifications(Microsoft.Build.BackEnd.Lookup.MetadataModifications)">
            <summary>
            Applies the modifications from the specified modifications to this one, performing a proper merge.
            </summary>
            <param name="other">The set of metadata modifications to merge into this one.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModifications.ContainsExplicitModification(System.String)">
            <summary>
            Returns true if this block contains an explicitly-specified modification for the provided metadata name.
            </summary>
            <param name="metadataName">The name of the metadata.</param>
            <returns>True if there is an explicit modification for this metadata, false otherwise.</returns>
            <remarks>The return value of this method is unaffected by the <see cref="P:Microsoft.Build.BackEnd.Lookup.MetadataModifications.KeepOnlySpecified"/> property.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModifications.Add(System.String,System.String)">
            <summary>
            Adds metadata to the modification table.
            </summary>
            <param name="metadataName">The name of the metadata to add (or change) in the target item.</param>
            <param name="metadataValue">The metadata value.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.MetadataModifications.ExplicitModifications">
            <summary>
            Provides an enumeration of the explicit metadata modifications.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.MetadataModifications.Item(System.String)">
            <summary>
            Sets or retrieves a modification from the modifications table.
            </summary>
            <param name="metadataName">The metadata name.</param>
            <returns>If <see cref="P:Microsoft.Build.BackEnd.Lookup.MetadataModifications.KeepOnlySpecified"/> is true, this will return a modification with <see cref="P:Microsoft.Build.BackEnd.Lookup.MetadataModification.Remove"/>
            set to true if the metadata has no other explicitly-specified modification.  Otherwise it will return only the explicitly-specified
            modification if one exists.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">When <see cref="P:Microsoft.Build.BackEnd.Lookup.MetadataModifications.KeepOnlySpecified"/> if false, this is thrown if the metadata
            specified does not exist when attempting to retrieve a metadata modification.</exception>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Lookup.ModificationType">
            <summary>
            A type of metadata modification.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.ModificationType.Keep">
            <summary>
            Indicates the metadata value should be kept unchanged.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.ModificationType.Update">
            <summary>
            Indicates the metadata value should be changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.ModificationType.Remove">
            <summary>
            Indicates the metadata value should be removed.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Lookup.MetadataModification">
            <summary>
            Represents a modification for a single metadata.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.MetadataModification._remove">
            <summary>
            When true, indicates the metadata should be removed from the target item.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.MetadataModification._newValue">
            <summary>
            The value to which the metadata should be set.  If null, the metadata value should be retained unmodified.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.MetadataModification.s_keepModification">
            <summary>
            A modification which indicates the metadata value should be retained without modification.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.MetadataModification.s_removeModification">
            <summary>
            A modification which indicates the metadata should be removed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModification.#ctor(Microsoft.Build.BackEnd.Lookup.ModificationType)">
            <summary>
            Constructor for metadata modifications of type Keep or Remove.
            </summary>
            <param name="modificationType">The type of modification to make.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModification.#ctor(System.String)">
            <summary>
            Constructor for metadata modifications of type Update.
            </summary>
            <param name="value">The new value for the metadata.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModification.CreateFromNoChange">
            <summary>
            Creates a metadata modification of type Keep.
            </summary>
            <returns>The metadata modification.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModification.CreateFromNewValue(System.String)">
            <summary>
            Creates a metadata modification of type Update with the specified metadata value.
            </summary>
            <param name="newValue">The new metadata value.</param>
            <returns>The metadata modification.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.MetadataModification.CreateFromRemove">
            <summary>
            Creates a metadata modification of type Remove.
            </summary>
            <returns>The metadata modification.</returns>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.MetadataModification.Remove">
            <summary>
            When true, this modification indicates the associated metadata should be removed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.MetadataModification.KeepValue">
            <summary>
            When true, this modification indicates the associated metadata should retain its existing value.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.MetadataModification.NewValue">
            <summary>
            The new value of the metadata.  Only valid when <see cref="P:Microsoft.Build.BackEnd.Lookup.MetadataModification.Remove"/> is false.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.Lookup.Scope">
            <summary>
            Represents an entry in the lookup list.
            Class rather than a struct so that it can be modified in the list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._items">
            <summary>
            Contains all of the original items at this level in the Lookup
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._adds">
            <summary>
            Contains all of the items which have been added at this level in the Lookup
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._removes">
            <summary>
            Contails all of the items which have been removed at this level in the Lookup
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._modifies">
            <summary>
            Contains all of the metadata which has been changed for items at this level in the Lookup.
            Schema: { K=type, V= { K=item, V=table of { K=metadata name, V=metadata value }}}
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._properties">
            <summary>
            Contains all of the original properties at this level in the Lookup
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._propertySets">
            <summary>
            Contains all of the properties which have been set at this level or above in the Lookup
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._threadIdThatEnteredScope">
            <summary>
            The managed thread id which entered this scope.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._description">
            <summary>
            A description of this scope, for error checking
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._owningLookup">
            <summary>
            The lookup which owns this scope, for error checking.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.Lookup.Scope._truncateLookupsAtThisScope">
            <summary>
            Indicates whether or not further levels in the Lookup should be consulted beyond this one
            to find the actual value for the desired item or property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.Items">
            <summary>
            The main table, populated with items that
            are initially visible in this scope. Does not 
            include adds or removes unless it's the table in 
            the outermost scope.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.Adds">
            <summary>
            Adds made in this scope or above.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.Removes">
            <summary>
            Removes made in this scope or above.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.Modifies">
            <summary>
            Modifications made in this scope or above.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.Properties">
            <summary>
            The main property table, populated with properties
            that are initially visible in this scope. Does not
            include sets unless it's the table in the outermost scope.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.PropertySets">
            <summary>
            Properties set in this scope or above.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.ThreadIdThatEnteredScope">
            <summary>
            ID of thread owning this scope
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.TruncateLookupsAtThisScope">
            <summary>
            Whether to stop lookups going beyond this scope downwards
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.Lookup.Scope.Description">
            <summary>
            The description assigned to this scope.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.Lookup.Scope.LeaveScope">
            <summary>
            Leaves the current lookup scope.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.RequestBuilder">
            <summary>
            Implementation of IRequestBuilder
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder.s_dedicatedScheduler">
            <summary>
            The dedicated scheduler object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._terminateEvent">
            <summary>
            The event used to signal that this request should immediately terminate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._continueEvent">
            <summary>
            The event used to signal that this request should wake up from its wait state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._continueResults">
            <summary>
            The results used when a build request entry continues.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._requestTask">
            <summary>
            The task representing the currently-executing build request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._cancellationTokenSource">
            <summary>
            The cancellation token source for the currently-executing build request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._requestEntry">
            <summary>
            The build request entry being built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._componentHost">
            <summary>
            The component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._nodeLoggingContext">
            <summary>
            The node logging context
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._projectLoggingContext">
            <summary>
            The project logging context
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._targetBuilder">
            <summary>
            The target builder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._blockType">
            <summary>
            Block type
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._inMSBuildCallback">
            <summary>
            Flag indicating we are in an MSBuild callback
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder._isZombie">
            <summary>
            Flag indicating whether this request builder has been zombied by a cancellation request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.#ctor">
            <summary>
            Creates a new request builder.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.RequestBuilder.OnNewBuildRequests">
            <summary>
            The event raised when a new build request should be issued.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.RequestBuilder.OnBuildRequestCompleted">
            <summary>
            The event raised when the build request has completed.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.RequestBuilder.OnBuildRequestBlocked">
            <summary>
            The event raised when the build request has completed.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.RequestBuilder.BlockType">
            <summary>
            The current block type
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder.BlockType.BlockedOnTargetInProgress">
            <summary>
            We are blocked waiting on a target in progress.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder.BlockType.BlockedOnChildRequests">
            <summary>
            We are blocked waiting for results from child requests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder.BlockType.Yielded">
            <summary>
            We are blocked because we have yielded control
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.RequestBuilder.BlockType.Unblocked">
            <summary>
            We are not blocked at all.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.RequestBuilder.RequestEntry">
            <summary>
            Retrieves the request entry associated with this RequestBuilder.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.RequestBuilder.HasActiveBuildRequest">
            <summary>
            Returns true if this RequestBuilder has an active build request
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.BuildRequest(Microsoft.Build.BackEnd.Logging.NodeLoggingContext,Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Starts a build request
            </summary>
            <param name="loggingContext">The logging context for the node.</param>
            <param name="entry">The entry to build.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.ContinueRequest">
            <summary>
            Continues a build request
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.CancelRequest">
            <summary>
            Terminates the build request
            </summary>
            <remarks>
            Once we have entered this method, no more methods will be invoked on this class (save ShutdownComponent)
            as we should no longer be receiving any messages from the BuildManager.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.BeginCancel">
            <summary>
            Starts to cancel an existing request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.WaitForCancelCompletion">
            <summary>
            Waits for the cancellation until it's completed, and cleans up the internal states.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.BuildProjects(System.String[],Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance}[],System.String[],System.String[],System.Boolean,System.Boolean)">
            <summary>
            This method instructs the request builder to build the specified projects using the specified parameters.  This is
            what is ultimately used by something like an MSBuild task which needs to invoke a project-to-project reference.  IBuildEngine
            and IBuildEngine2 have BuildProjectFile methods which boil down to an invocation of this method as well.
            </summary>
            <param name="projectFiles">An array of projects to be built.</param>
            <param name="properties">The property groups to use for each project.  Must be the same number as there are project files.</param>
            <param name="toolsVersions">The tools version to use for each project.  Must be the same number as there are project files.</param>
            <param name="targets">The targets to be built.  Each project will be built with the same targets.</param>
            <param name="waitForResults">True to wait for the results </param>
            <param name="skipNonexistentTargets">If set, skip targets that are not defined in the projects to be built.</param>
            <returns>True if the requests were satisfied, false if they were aborted.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.BlockOnTargetInProgress(System.Int32,System.String,Microsoft.Build.Execution.BuildResult)">
            <summary>
            This method is called when the current request needs to build a target which is already in progress on this configuration, but which
            is being built by another request.
            </summary>
            <param name="blockingGlobalRequestId">The id of the request on which we are blocked.</param>
            <param name="blockingTarget">The target on which we are blocked.</param>
            <param name="partialBuildResult">A BuildResult with results from an incomplete build request.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.Yield">
            <summary>
            Yields the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.Reacquire">
            <summary>
            Waits for the node to be reacquired.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.EnterMSBuildCallbackState">
            <summary>
            Enters the state where we are going to perform a build request callback.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.ExitMSBuildCallbackState">
            <summary>
            Exits the build request callback state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Sets the component host.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.ShutdownComponent">
            <summary>
            Shuts down this component
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.IsBuilderUsingLegacyThreadingSemantics(Microsoft.Build.BackEnd.IBuildComponentHost,Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Returns true if this builder is using legacy threading semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.WaitWithBuilderThreadStart(System.Threading.WaitHandle[],System.Boolean,Microsoft.Build.Execution.LegacyThreadingData,System.Int32)">
            <summary>
            This method waits for the specified handles, but will also spawn a request builder "thread" if that event is set.
            This mechanism is used to implement running RequestBuilder threads on the main UI thread in VS.
            </summary>
            <returns>The index of the handle which was signaled.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Class factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.StartBuilderThread">
            <summary>
            Starts the thread used to build
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.SetCommonWorkerThreadParameters">
            <summary>
            Set some parameters common to all worker threads we use
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.VerifyEntryInReadyState">
            <summary>
            Asserts that the entry is in the ready state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.VerifyEntryInActiveState">
            <summary>
            Asserts that the entry is in the active state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.RequestThreadProc(System.Boolean)">
            <summary>
            The entry point for the request builder thread.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.BuildAndReport">
            <summary>
            Launch the project and gather the results, reporting them back to the BuildRequestEngine.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.ReportResultAndCleanUp(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Reports this result to the engine and cleans up.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.StartNewBuildRequests(Microsoft.Build.BackEnd.FullyQualifiedBuildRequest[])">
            <summary>
            This is called back when this request needs to issue new requests and possible wait on them.  This method will
            block the builder's thread if any of the requests require us to wait for their results.
            </summary>
            <param name="requests">The list of build requests to be built.</param>
            <returns>The results, or null if the build should terminate.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.GetResultsForContinuation(Microsoft.Build.BackEnd.FullyQualifiedBuildRequest[],System.Boolean)">
            <summary>
            Gets the results uses to continue the current build request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.RaiseOnNewBuildRequests(Microsoft.Build.BackEnd.FullyQualifiedBuildRequest[])">
            <summary>
            Invokes the OnNewBuildRequests event
            </summary>
            <param name="requests">The requests to be fulfilled.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.RaiseBuildRequestCompleted(Microsoft.Build.BackEnd.BuildRequestEntry)">
            <summary>
            Invokes the OnBuildRequestCompleted event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.RaiseOnBlockedRequest(System.Int32,System.String,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Invokes the OnBlockedRequest event
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.SetProjectCurrentDirectory">
            <summary>
            This method is called to reset the current directory to the one appropriate for this project.  It should be called any time
            the project is resumed.
            If the directory does not exist, does nothing.
            This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project. 
            No errors are masked by doing this: errors loading the project from disk are reported at load time, if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.BuildProject">
            <summary>
            Kicks off the build of the project file.  Doesn't return until the build is complete (or aborted.)
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.LoadProjectIntoConfiguration">
            <summary>
            Loads the project specified by the configuration's parameters into the configuration block.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.SaveOperatingEnvironment">
            <summary>
            Saves the current operating environment.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.InitializeOperatingEnvironment">
            <summary>
            Sets the operationg environment to the initial build environment.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.RestoreOperatingEnvironment">
            <summary>
            Restores a previously saved operating environment.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.SetEnvironmentVariableBlock(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sets the environment block to the set of saved variables.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.ClearVariablesNotInEnvironment(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Clears from the current environment any variables which do not exist in the saved environment
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.UpdateEnvironmentVariables(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Updates the current environment with values in the saved environment which differ or are not yet set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.VerifyIsNotZombie">
            <summary>
            Throws if the RequestBuilder has been zombied.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.RequestBuilder.ConfigureWarningsAsErrorsAndMessages">
            <summary>
            Configure warnings as messages and errors based on properties defined in the project.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TargetBuilder">
            <summary>
            The Target Builder is responsible for building a single target within a given project.
            </summary>
            <remarks>
            The Target Builder is a stack machine which builds project targets.  Each time a target needs to be built, it is
            pushed onto the stack.  The main loop for the Target Builder simply evaluates the top item on the stack to determine
            which action to take.  These actions comprise the target state machine, as represented by the states of the
            TargetEntry object.
            
            When a target completes, all of its outputs are available in the Lookup contained in the TargetEntry.  In fact, everything that it changed
            in the global state is available by virtue of its Lookup being merged with the current Target's lookup.
            
            For CallTarget tasks, this behavior is not the same.  Rather the Lookup from a CallTarget call does not get merged until the calling 
            Target has completed.  This is considered erroneous behavior and 'normal' version of CallTarget will be implemented which does not exhibit
            this.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._cancellationToken">
            <summary>
            The cancellation token.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._targetsToBuild">
            <summary>
            The current stack of targets and dependents.  The top-most entry on the stack is the target
            currently being built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._componentHost">
            <summary>
            The component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._requestEntry">
            <summary>
            The BuildRequestEntry for which we are building targets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._baseLookup">
            <summary>
            The lookup representing the project's state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._requestBuilderCallback">
            <summary>
            The callback interface used to invoke new project builds.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._projectLoggingContext">
            <summary>
            The project logging context
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._buildResult">
            <summary>
            The aggregate build result from running the targets
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._projectInstance">
            <summary>
            The project instance we are building
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetBuilder._legacyCallTargetContinueOnError">
            <summary>
            Flag indicating whether we are under the influence of the legacy CallTarget's ContinueOnError behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.BuildTargets(Microsoft.Build.BackEnd.Logging.ProjectLoggingContext,Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.IRequestBuilderCallback,System.String[],Microsoft.Build.BackEnd.Lookup,System.Threading.CancellationToken)">
            <summary>
            Builds the specified targets.
            </summary>
            <param name="loggingContext">The logging context for the project.</param>
            <param name="entry">The BuildRequestEntry for which we are building targets.</param>
            <param name="callback">The callback to be used to handle new project build requests.</param>
            <param name="targetNames">The names of the targets to build.</param>
            <param name="baseLookup">The Lookup containing all current items and properties for this target.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to use when building the targets.</param>
            <returns>The target's outputs and result codes</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Sets the component host.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.ShutdownComponent">
            <summary>
            Shuts down the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.Microsoft#Build#BackEnd#ITargetBuilderCallback#LegacyCallTarget(System.String[],System.Boolean,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Invokes the specified targets using Dev9 behavior.
            </summary>
            <param name="targets">The targets to build.</param>
            <param name="continueOnError">True to continue building the remaining targets if one fails.</param>
            <param name="taskLocation">The <see cref="T:Microsoft.Build.Construction.ElementLocation"/> of the task.</param>
            <returns>The results for each target.</returns>
            <remarks>
            Dev9 behavior refers to the following:
            1. The changes made during the calling target up to this point are NOT visible to this target.
            2. The changes made by this target are NOT visible to the calling target.
            3. Changes made by the calling target OVERRIDE changes made by this target.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.Microsoft#Build#BackEnd#IRequestBuilderCallback#BuildProjects(System.String[],Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance}[],System.String[],System.String[],System.Boolean,System.Boolean)">
            <summary>
            Forwarding implementation of BuildProjects
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.Microsoft#Build#BackEnd#IRequestBuilderCallback#BlockOnTargetInProgress(System.Int32,System.String,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Required for interface - this should never be called.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.Microsoft#Build#BackEnd#IRequestBuilderCallback#Yield">
            <summary>
            Yields the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.Microsoft#Build#BackEnd#IRequestBuilderCallback#Reacquire">
            <summary>
            Reacquires the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.Microsoft#Build#BackEnd#IRequestBuilderCallback#EnterMSBuildCallbackState">
            <summary>
            Enters the MSBuild callback state for asynchronous processing of referenced projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.Microsoft#Build#BackEnd#IRequestBuilderCallback#ExitMSBuildCallbackState">
            <summary>
            Exits the MSBuild callback state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Class factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.ProcessTargetStack(Microsoft.Build.BackEnd.ITaskBuilder)">
            <summary>
            Processes the target stack until its empty or we hit a recursive break (due to CallTarget etc.)
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.CheckSkipTarget(System.Boolean@,Microsoft.Build.BackEnd.TargetEntry)">
            <summary>
            Determines if the current target should be skipped, and logs the appropriate message.
            </summary>
            <returns>True to skip the target, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.PopDependencyTargetsOnTargetFailure(Microsoft.Build.BackEnd.TargetEntry,Microsoft.Build.Execution.TargetResult,System.Boolean@)">
            <summary>
            When a target build fails, we don't just stop building that target; we also pop all of the other dependency targets of its 
            parent target off the stack. Extract that logic into a standalone method so that it can be used when dealing with targets that 
            are skipped-unsuccessful as well as first-time failures. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetBuilder.PushTargets(System.Collections.Generic.IList{Microsoft.Build.BackEnd.TargetSpecification},Microsoft.Build.BackEnd.TargetEntry,Microsoft.Build.BackEnd.Lookup,System.Boolean,System.Boolean,Microsoft.Build.Framework.TargetBuiltReason)">
            <summary>
            Pushes the list of targets specified onto the target stack in reverse order specified, so that
            they will be built in the order specified.
            </summary>
            <param name="targets">List of targets to build.</param>
            <param name="parentTargetEntry">The target which should be considered the parent of these targets.</param>
            <param name="baseLookup">The lookup to be used to build these targets.</param>
            <param name="addAsErrorTarget">True if this should be considered an error target.</param>
            <param name="stopProcessingOnCompletion">True if target stack processing should terminate when the last target in the list is processed.</param>
            <param name="buildReason">The reason the target is being built by the parent.</param>
            <returns>True if we actually pushed any targets, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TargetEntryState">
            <summary>
            Represents which state the target entry is currently in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntryState.Dependencies">
            <summary>
            The target's dependencies need to be evaluated and pushed onto the target stack.
            
            Transitions:
            Execution, ErrorExecution
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntryState.Execution">
            <summary>
            The target is ready to execute its tasks, batched as needed.
            
            Transitions:
            ErrorExecution, Completed
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntryState.ErrorExecution">
            <summary>
            The target is ready to provide error tasks.
            
            Transitions:
            None
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntryState.Completed">
            <summary>
            The target has finished building.  All of the results are in the Lookup.
            
            Transitions:
            None
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TargetEntry">
            <summary>
            This class represents a single target in the TargetBuilder.  It maintains the state machine for a particular target as well as
            relevant information on outputs generated while a target is running.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._requestEntry">
            <summary>
            The BuildRequestEntry to which this target invocation belongs
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._targetSpecification">
            <summary>
            The specification of the target being built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._target">
            <summary>
            The Target being built.  This will be null until the GetTargetInstance() is called, which
            will cause us to attempt to resolve the actual project instance.  At that point
            if the target doesn't exist, we will throw an InvalidProjectFileException.  We do this lazy
            evaluation because the 'target doesn't exist' message is not supposed to be emitted until
            the target is actually needed, as opposed to when it is specified, such as in an OnError
            clause, DependsOnTargets or on the command-line.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._state">
            <summary>
            The current state of this entry
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._targetResult">
            <summary>
            The completion state of the target.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._parentTarget">
            <summary>
            The parent entry, which is waiting for us to complete before proceeding.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._buildReason">
            <summary>
            Why the parent target built this target.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._expander">
            <summary>
            The expander used to expand item and property markup to evaluated values.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._baseLookup">
            <summary>
            The lookup containing our environment.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._host">
            <summary>
            The build component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._targetBuilderCallback">
            <summary>
            The target builder callback
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._legacyCallTargetScopes">
            <summary>
            A queue of legacy CallTarget lookup scopes to leave when this target is finished.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._cancellationToken">
            <summary>
            The cancellation token.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._isExecuting">
            <summary>
            Flag indicating whether we are currently executing this target.  Used for assertions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetEntry._currentTaskBuilder">
            <summary>
            The current task builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.#ctor(Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.ITargetBuilderCallback,Microsoft.Build.BackEnd.TargetSpecification,Microsoft.Build.BackEnd.Lookup,Microsoft.Build.BackEnd.TargetEntry,Microsoft.Build.Framework.TargetBuiltReason,Microsoft.Build.BackEnd.IBuildComponentHost,System.Boolean)">
            <summary>
            The constructor.
            </summary>
            <param name="requestEntry">The build request entry for the target.</param>
            <param name="targetBuilderCallback">The target builder callback.</param>
            <param name="targetSpecification">The specification for the target to build.</param>
            <param name="baseLookup">The lookup to use.</param>
            <param name="parentTarget">The parent of this entry, if any.</param>
            <param name="buildReason">The reason the parent built this target.</param>
            <param name="host">The Build Component Host to use.</param>
            <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.ErrorTarget">
            <summary>
            Gets or sets a flag indicating if this entry is the result of being listed as an error target in
            an OnError clause.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.ReferenceLocation">
            <summary>
            Sets or sets the location from which this target was referred.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.StopProcessingOnCompletion">
            <summary>
            Gets or sets a flag indicating that the target builder should stop processing the target
            stack when this target completes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.Name">
            <summary>
            Retrieves the name of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.State">
            <summary>
            Gets the current state of the target
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.Result">
            <summary>
            The result of this target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.Lookup">
            <summary>
            Retrieves the Lookup this target was initialized with, including any modifications which have 
            been made to it while running.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.Target">
            <summary>
            The target contained by the entry.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.RequestEntry">
            <summary>
            The build request entry to which this target belongs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.ParentEntry">
            <summary>
            The target entry for which we are a dependency.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetEntry.BuildReason">
            <summary>
            Why the parent target built this target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.Equals(Microsoft.Build.BackEnd.TargetEntry)">
            <summary>
            Determines equivalence of two target entries.  They are considered the same
            if their names are the same.
            </summary>
            <param name="other">The entry to which we compare this one.</param>
            <returns>True if they are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.GetDependencies(Microsoft.Build.BackEnd.Logging.ProjectLoggingContext)">
            <summary>
            Retrieves the list of dependencies this target needs to have built and moves the target to the next state.
            Never returns null.
            </summary>
            <returns>A collection of targets on which this target depends.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.ExecuteTarget(Microsoft.Build.BackEnd.ITaskBuilder,Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.Logging.ProjectLoggingContext,System.Threading.CancellationToken)">
            <summary>
            Runs all of the tasks for this target, batched as necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.GetErrorTargets(Microsoft.Build.BackEnd.Logging.ProjectLoggingContext)">
            <summary>
            Retrieves the error targets for this target.
            </summary>
            <param name="projectLoggingContext">The project logging context.</param>
            <returns>A list of error targets.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.GatherResults">
            <summary>
            Gathers the results from the target into the base lookup of the target.
            </summary>
            <returns>The base lookup for this target.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.EnterLegacyCallTargetScope(Microsoft.Build.BackEnd.Lookup)">
            <summary>
            Enters a legacy calltarget scope.
            </summary>
            <param name="lookup">The lookup to enter with.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.MarkForError">
            <summary>
            This method is used by the Target Builder to indicate that the target should run in error mode rather than normal mode.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.MarkForStop">
            <summary>
            This method is used by the Target Builder to indicate that a child of this target has failed and that work should not
            continue in Completed / Skipped mode. We do not want to mark the state to run in ErrorExecution mode so that the
            OnError targets do not run (the target was skipped due to condition so OnError targets should not run).
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.LeaveLegacyCallTargetScopes">
            <summary>
            Leaves all the call target scopes in the order they were entered.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.ProcessBucket(Microsoft.Build.BackEnd.ITaskBuilder,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.BackEnd.TaskExecutionMode,Microsoft.Build.BackEnd.Lookup,Microsoft.Build.BackEnd.Lookup)">
            <summary>
            Walks through the set of tasks for this target and processes them by handing them off to the TaskBuilder.
            </summary>
            <returns>
            The result of the tasks, based on the last task which ran.
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.GetTaskExecutionMode(Microsoft.Build.BackEnd.DependencyAnalysisResult)">
            <summary>
            Gets the task execution mode based 
            </summary>
            <param name="analysis">The result of the up-to-date check.</param>
            <returns>The mode to be used to execute tasks.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.VerifyState(Microsoft.Build.BackEnd.TargetEntryState,Microsoft.Build.BackEnd.TargetEntryState)">
            <summary>
            Verifies that the target's state is as expected.
            </summary>
            <param name="actual">The actual value</param>
            <param name="expected">The expected value</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.GetBatchableParametersForTarget">
            <summary>
            Gets the list of parameters which are batchable for a target
            PERF: (Refactor) This used to be a method on the target, and it would 
            cache its values so this would only be computed once for each
            target.  We should consider doing something similar for perf reasons.
            </summary>
            <returns>A list of batchable parameters</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetEntry.GetTargetInstance">
            <summary>
            Resolves the target.  If it doesn't exist in the project, throws an InvalidProjectFileException.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.DependencyAnalysisResult">
            <summary>
            Enumeration of the results of target dependency analysis.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TargetUpToDateChecker">
            <summary>
            This class is used for performing dependency analysis on targets to determine if they should be built/rebuilt/skipped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.#ctor(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectTargetInstance,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Creates an instance of this class for the given target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetUpToDateChecker.TargetToAnalyze">
            <summary>
            Gets the target to perform dependency analysis on.
            </summary>
            <value>Target object.</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetUpToDateChecker.TargetInputSpecification">
            <summary>
            Gets the value of the target's "Inputs" attribute.
            </summary>
            <value>Input specification string (can be empty).</value>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TargetUpToDateChecker.TargetOutputSpecification">
            <summary>
            Gets the value of the target's "Outputs" attribute.
            </summary>
            <value>Output specification string (can be empty).</value>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.PerformDependencyAnalysis(Microsoft.Build.BackEnd.ItemBucket,Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance}@,Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance}@)">
            <summary>
            Compares the target's inputs against its outputs to determine if the target needs to be built/rebuilt/skipped.
            </summary>
            <remarks>
            The collections of changed and up-to-date inputs returned from this method are valid IFF this method decides an
            incremental build is needed.
            </remarks>
            <param name="bucket"></param>
            <param name="changedTargetInputs"></param>
            <param name="upToDateTargetInputs"></param>
            <returns>
            DependencyAnalysisResult.SkipUpToDate, if target is up-to-date;
            DependencyAnalysisResult.SkipNoInputs, if target has no inputs;
            DependencyAnalysisResult.SkipNoOutputs, if target has no outputs;
            DependencyAnalysisResult.IncrementalBuild, if only some target outputs are out-of-date;
            DependencyAnalysisResult.FullBuild, if target is out-of-date
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.LogReasonForBuildingTarget(Microsoft.Build.BackEnd.DependencyAnalysisResult)">
            <summary>
            Does appropriate logging to indicate why this target is being built fully or partially.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.GetFullBuildReason(Microsoft.Build.BackEnd.DependencyAnalysisLogDetail)">
            <summary>
            Returns a string indicating why a full build is occurring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.GetIncrementalBuildReason(Microsoft.Build.BackEnd.DependencyAnalysisLogDetail)">
            <summary>
            Returns a string indicating why an incremental build is occurring.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.LogUniqueInputsAndOutputs">
            <summary>
            Extract only the unique inputs and outputs from all the inputs and outputs gathered
            during depedency analysis
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.ParseTargetInputOutputSpecifications(Microsoft.Build.BackEnd.ItemBucket,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}}@,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}}@,System.Collections.Generic.Dictionary{System.String,System.String}@,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}}@,System.Collections.Generic.Dictionary{System.String,System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Parses the target's "Inputs" and "Outputs" attributes and gathers up referenced items.
            </summary>
            <param name="bucket"></param>
            <param name="itemVectorsInTargetInputs"></param>
            <param name="itemVectorTransformsInTargetInputs"></param>
            <param name="discreteItemsInTargetInputs"></param>
            <param name="itemVectorsInTargetOutputs"></param>
            <param name="discreteItemsInTargetOutputs"></param>
            <param name="targetOutputItemSpecs"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.PerformDependencyAnalysisIfNoInputs">
            <summary>
            Determines if the target needs to be built/rebuilt/skipped if it has no inputs (because they evaluated to empty).
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.PerformDependencyAnalysisIfNoOutputs">
            <summary>
            Determines if the target needs to be built/rebuilt/skipped if it has no outputs (because they evaluated to empty).
            </summary>
            <returns>Indication of how to build the target.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.PerformDependencyAnalysisIfDiscreteInputs(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Determines if the target needs to be built/rebuilt/skipped if it has discrete inputs.
            </summary>
            <param name="itemVectorsInTargetInputs"></param>
            <param name="itemVectorTransformsInTargetInputs"></param>
            <param name="discreteItemsInTargetInputs"></param>
            <param name="itemVectorsReferencedOnlyInTargetInputs"></param>
            <param name="targetOutputItemSpecs"></param>
            <returns>Indication of how to build the target.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.PerformDependencyAnalysisIfCorrelatedInputsOutputs(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.Collections.Generic.List{System.String},Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance}@,Microsoft.Build.Collections.ItemDictionary{Microsoft.Build.Execution.ProjectItemInstance}@)">
            <summary>
            Determines if the target needs to be built/rebuilt/skipped if its inputs and outputs can be correlated.
            </summary>
            <param name="itemVectorsInTargetInputs">The set of items which are in the inputs</param>
            <param name="itemVectorsInTargetOutputs">The set of items which are in the outputs.</param>
            <param name="itemVectorsReferencedInBothTargetInputsAndOutputs">A list of item types referenced in both the inputs and the outputs</param>
            <param name="changedTargetInputs">The inputs which are "changed" and require a build</param>
            <param name="upToDateTargetInputs">The inpurt which are "up to date" and do not require a build</param>
            <returns>Indication of how to build the target.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.PerformDependencyAnalysisIfDiscreteOutputs(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Determines if the target needs to be built/rebuilt/skipped if it has discrete outputs.
            </summary>
            <param name="itemVectorsInTargetInputs"></param>
            <param name="itemVectorTransformsInTargetInputs"></param>
            <param name="discreteItemsInTargetInputs"></param>
            <param name="targetOutputItemSpecs"></param>
            <returns>Indication of how to build the target.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.SeparateItemVectorsFromDiscreteItems(Microsoft.Build.Evaluation.SemiColonTokenizer,Microsoft.Build.BackEnd.ItemBucket,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}}@,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.Collections.Generic.Dictionary{System.String,System.String}@,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Separates item vectors from discrete items, and discards duplicates. If requested, item vector transforms are also
            separated out. The item vectors (and the transforms) are partitioned by type, since there can be more than one item
            vector of the same type.
            </summary>
            <remarks>
            The item vector collection is a table of tables, where the top-level table is indexed by item type, and
            each "partition" table is indexed by the item vector itself.
            </remarks>
            <param name="items"></param>
            <param name="bucket"></param>
            <param name="itemVectors">Collection for item vectors</param>
            <param name="itemVectorTransforms">Collection for transforms if they should be collected separately, else null</param>
            <param name="discreteItems"></param>
            <param name="elementLocation"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.GetItemSpecsFromItemVectors(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}})">
            <summary>
            Retrieves the item-specs of all items in the given item vector collection.
            </summary>
            <param name="itemVectors"></param>
            <returns>list of item-specs</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.GetItemSpecsFromItemVectors(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance}}},System.String)">
            <summary>
            Retrieves the item-specs of all items of the specified type in the given item vector collection.
            </summary>
            <param name="itemVectors"></param>
            <param name="itemType"></param>
            <returns>list of item-specs</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.DiffHashtables``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.List{``0}@,System.Collections.Generic.List{``0}@,System.Collections.Generic.List{``0}@)">
            <summary>
            Finds the differences in the keys between the two given hashtables.
            </summary>
            <param name="h1"></param>
            <param name="h2"></param>
            <param name="commonKeys"></param>
            <param name="uniqueKeysInH1"></param>
            <param name="uniqueKeysInH2"></param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.IsAnyOutOfDate``1(Microsoft.Build.BackEnd.DependencyAnalysisLogDetail@,System.String,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Compares the set of files/directories designated as "inputs" against the set of files/directories designated as
            "outputs", and indicates if any "output" file/directory is out-of-date w.r.t. any "input" file/directory.
            </summary>
            <remarks>
            NOTE: Internal for unit test purposes only.
            </remarks>
            <returns>true, if any "input" is newer than any "output", or if any input or output does not exist.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.RecordUniqueInputsAndOutputs``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Record the unique input and output files so that the "up to date" message
            can list them in the log later.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.IsOutOfDate(System.String,System.String,System.String,System.String)">
            <summary>
            Compares the file/directory designated as "input" against the file/directory designated as "output", and indicates if
            the "output" file/directory is out-of-date w.r.t. the "input" file/directory.
            </summary>
            <remarks>
            If the "input" does not exist on disk, we treat its disappearance as a change, and consider the "input" to be newer
            than the "output", regardless of whether the "output" itself exists.
            </remarks>
            <param name="input"></param>
            <param name="output"></param>
            <param name="inputItemName"></param>
            <param name="outputItemName"></param>
            <returns>true, if "input" is newer than "output"</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.RecordComparisonResults(System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Add timestamp comparison results to a list, to log them together later.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TargetUpToDateChecker.CompareLastWriteTimes(System.String,System.String,System.Boolean@,System.Boolean@)">
            <summary>
            Compares the last-write times of the given files/directories.
            </summary>
            <remarks>
            Existing files/directories are always considered newer than non-existent ones, and two non-existent files/directories
            are considered to have the same last-write time.
            </remarks>
            <param name="path1"></param>
            <param name="path2"></param>
            <param name="path1DoesNotExist">[out] indicates if the first file/directory does not exist on disk</param>
            <param name="path2DoesNotExist">[out] indicates if the second file/directory does not exist on disk</param>
            <returns>
            -1  if the first file/directory is older than the second;
             0  if the files/directories were both last written to at the same time;
            +1  if the first file/directory is newer than the second
            </returns>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetUpToDateChecker.s_sortInputsOutputs">
            <summary>
            By default we do not sort target inputs and outputs as it has significant perf impact.
            But allow suites to enable this so they get consistent results.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetUpToDateChecker._uniqueTargetInputs">
            <summary>
            The unique target inputs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TargetUpToDateChecker._uniqueTargetOutputs">
            <summary>
            The unique target outputs.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.OutofdateReason">
            <summary>
            Why TLDA decided this entry was out of date
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.DependencyAnalysisLogDetail">
            <summary>
            A logging detail entry. Describes what TLDA decided about inputs / outputs
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.DependencyAnalysisLogDetail.Reason">
            <summary>
            The reason that we are logging this entry
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.DependencyAnalysisLogDetail.InputItemName">
            <summary>
            The input item name (can be null)
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.DependencyAnalysisLogDetail.OutputItemName">
            <summary>
            The output item name (can be null)
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.DependencyAnalysisLogDetail.Input">
            <summary>
            The input file
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.DependencyAnalysisLogDetail.Output">
            <summary>
            The output file
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.DependencyAnalysisLogDetail.#ctor(System.String,System.String,System.String,System.String,Microsoft.Build.BackEnd.OutofdateReason)">
            <summary>
            Construct a log detail element
            </summary>
            <param name="input">Input file</param>
            <param name="output">Output file</param>
            <param name="inputItemName">Input item name (can be null)</param>
            <param name="outputItemName">Output item name (can be null)</param>
            <param name="reason">The reason we are logging</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ContinueOnError">
            <summary>
            The possible values for a task's ContinueOnError attribute.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ContinueOnError.ErrorAndStop">
            <summary>
            If the task fails, error and stop.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ContinueOnError.ErrorAndContinue">
            <summary>
            If the task fails, error and continue.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ContinueOnError.WarnAndContinue">
            <summary>
            If the task fails, warn and continue.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskBuilder">
            <summary>
            The TaskBuilder is one of two components related to building tasks, the other being the TaskExecutionHost.  The TaskBuilder is
            responsible for all parts dealing with the XML/task declaration.  It determines if the task is intrinsic or extrinsic, 
            looks up the task in the task registry, determines the task parameters and requests them to be set, and requests outputs
            when task execution has been completed.  It is not responsible for reflection over the task instance or anything which
            requires dealing with the task instance directly - those actions are handled by the TaskExecutionHost.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._buildRequestEntry">
            <summary>
            The Build Request Entry for which this task is executing.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._cancellationToken">
            <summary>
            The cancellation token
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._componentHost">
            <summary>
            The build component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._targetChildInstance">
            <summary>
            The original target child instance
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._taskNode">
            <summary>
            The task instance for extrinsic tasks
            </summary> 
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._taskHostObject">
            <summary>
            Host callback for host-aware tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._continueOnError">
            <summary>
            indicates whether to ignore task execution failures
            </summary> 
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._targetLoggingContext">
            <summary>
            The logging context for the target in which we are executing.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._projectFullPath">
            <summary>
            Full path to the project, for errors
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._targetBuilderCallback">
            <summary>
            The target builder callback.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._taskExecutionHost">
            <summary>
            The task execution host for in-proc tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskBuilder._taskExecutionHostSync">
            <summary>
            The object used to synchronize access to the task execution host.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.BackEnd.ITargetBuilderCallback,Microsoft.Build.Execution.ProjectTargetInstanceChild,Microsoft.Build.BackEnd.TaskExecutionMode,Microsoft.Build.BackEnd.Lookup,Microsoft.Build.BackEnd.Lookup,System.Threading.CancellationToken)">
            <summary>
            Builds the task specified by the XML.
            </summary>
            <param name="loggingContext">The logging context of the target</param>
            <param name="requestEntry">The build request entry being built</param>
            <param name="targetBuilderCallback">The target builder callback.</param>
            <param name="taskInstance">The task instance.</param>
            <param name="mode">The mode in which to execute tasks.</param>
            <param name="inferLookup">The lookup to be used for inference.</param>
            <param name="executeLookup">The lookup to be used during execution.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to use when executing the task.</param>
            <returns>The result of running the task batch.</returns>
            <remarks>
            The ExecuteTask method takes a task as specified by XML and executes it.  This procedure is comprised 
            of the following steps:
            1. Loading the Task from its containing assembly by looking it up in the task registry
            2. Determining if the task is batched.  If it is, create the batches and execute each as if it were a non-batched task
            3. If the task is not batched, execute it.
            4. If the task was batched, hold on to its Lookup until all of the natches are done, then merge them.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Sets the build component host.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.ShutdownComponent">
            <summary>
            Shuts down the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Class factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.CreateListOfParameterValues">
            <summary>
            Build up a list of all parameters on the task, including those in any Output tags,
            in order to find batchable metadata references
            </summary>
            <returns>The list of parameter values</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.TaskExecutionMode,Microsoft.Build.BackEnd.Lookup)">
            <summary>
            Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
            </summary>
            <returns>true, if successful</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.ExecuteBucket(Microsoft.Build.BackEnd.TaskHost,Microsoft.Build.BackEnd.ItemBucket,Microsoft.Build.BackEnd.TaskExecutionMode,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Execute a single bucket
            </summary>
            <returns>true if execution succeeded</returns>        
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.GatherTaskIdentityParameters(Microsoft.Build.Evaluation.Expander{Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Returns the set of parameters that can contribute to a task's identity, and their values for this particular task.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.ExecuteTaskInSTAThread(Microsoft.Build.BackEnd.ItemBucket,Microsoft.Build.BackEnd.Logging.TaskLoggingContext,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.BackEnd.TaskHost,Microsoft.Build.BackEnd.TaskExecutionMode)">
            <summary>
            Executes the task using an STA thread.
            </summary>
            <comment>
            STA thread launching also being used in XMakeCommandLine\OutOfProcTaskAppDomainWrapperBase.cs, InstantiateAndExecuteTaskInSTAThread method.  
            Any bug fixes made to this code, please ensure that you also fix that code.  
            </comment>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.LogSkippedTask(Microsoft.Build.BackEnd.ItemBucket,Microsoft.Build.BackEnd.TaskExecutionMode)">
            <summary>
            Logs a task skipped message if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.ExecuteIntrinsicTask(Microsoft.Build.BackEnd.ItemBucket)">
            <summary>
            Runs an intrinsic task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.InitializeAndExecuteTask(Microsoft.Build.BackEnd.Logging.TaskLoggingContext,Microsoft.Build.BackEnd.ItemBucket,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.BackEnd.TaskHost,Microsoft.Build.BackEnd.TaskExecutionMode)">
            <summary>
            Initializes and executes the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.UpdateContinueOnError(Microsoft.Build.BackEnd.ItemBucket,Microsoft.Build.BackEnd.TaskHost)">
            <summary>
            Recomputes the task's "ContinueOnError" setting.
            </summary>
            <param name="bucket">The bucket being executed.</param>
            <param name="taskHost">The task host to use.</param>
            <remarks>
            There are four possible values:
            false - Error and stop if the task fails.
            true - Warn and continue if the task fails.
            ErrorAndContinue - Error and continue if the task fails.
            WarnAndContinue - Same as true.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(Microsoft.Build.BackEnd.ITaskExecutionHost,Microsoft.Build.BackEnd.Logging.TaskLoggingContext,Microsoft.Build.BackEnd.TaskHost,Microsoft.Build.BackEnd.ItemBucket,Microsoft.Build.BackEnd.TaskExecutionMode)">
            <summary>
            Execute a task object for a given bucket.
            </summary>
            <param name="taskExecutionHost">The host used to execute the task.</param>
            <param name="taskLoggingContext">The logging context.</param>
            <param name="taskHost">The task host for the task.</param>
            <param name="bucket">The batching bucket</param>
            <param name="howToExecuteTask">The task execution mode</param>
            <returns>The result of running the task.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.GatherTaskOutputs(Microsoft.Build.BackEnd.ITaskExecutionHost,Microsoft.Build.BackEnd.TaskExecutionMode,Microsoft.Build.BackEnd.ItemBucket)">
            <summary>
            Gathers task outputs in two ways:
            1) Given an instantiated task that has finished executing, it extracts the outputs using .NET reflection.
            2) Otherwise, it parses the task's output specifications and (statically) infers the outputs.
            </summary>
            <param name="taskExecutionHost">The task execution host.</param>
            <param name="howToExecuteTask">The task execution mode</param>
            <param name="bucket">The bucket to which the task execution belongs.</param>
            <returns>true, if successful</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskBuilder.InferTaskOutputs(Microsoft.Build.BackEnd.Lookup,Microsoft.Build.Execution.ProjectTaskInstanceChild,System.String,System.String,System.String,Microsoft.Build.BackEnd.ItemBucket)">
            <summary>
            Uses the given task output specification to (statically) infer the task's outputs.
            </summary>
            <param name="lookup">The lookup</param>
            <param name="taskOutputSpecification">The task output specification</param>
            <param name="taskParameterName">The task parameter name</param>
            <param name="itemName">can be null</param>
            <param name="propertyName">can be null</param>
            <param name="bucket">The bucket for the batch.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskHost">
            <summary>
            The task host object which allows tasks to interface with the rest of the build system.
            Implementation of IBuildEngineX is thread-safe, so, for example, tasks can log concurrently on multiple threads.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost.s_onlyUseOutOfProcNodes">
            <summary>
            True if the "secret" environment variable MSBUILDNOINPROCNODE is set. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost.s_breakOnLogAfterTaskReturns">
            <summary>
            Help diagnose tasks that log after they return.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._host">
            <summary>
            The build component host
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._requestEntry">
            <summary>
            The build request entry
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._taskLocation">
            <summary>
            Location of the task node in the original file
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._taskLoggingContext">
            <summary>
            The task logging context
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._activeProxy">
            <summary>
            True if the task connected to this proxy is alive
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._targetBuilderCallback">
            <summary>
            The callback used to invoke the target builder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._callbackMonitor">
            <summary>
            This reference type is used to block access to a single entry methods of the interface
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._sponsor">
            <summary>
            A client sponsor is a class
            which will respond to a lease renewal request and will
            increase the lease time allowing the object to stay in memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._continueOnError">
            <summary>
            Legacy continue on error value per batch exposed via IBuildEngine
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._convertErrorsToWarnings">
            <summary>
            Flag indicating if errors should be converted to warnings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHost._yieldThreadId">
            <summary>
            The thread on which we yielded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.#ctor(Microsoft.Build.BackEnd.IBuildComponentHost,Microsoft.Build.BackEnd.BuildRequestEntry,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.BackEnd.ITargetBuilderCallback)">
            <summary>
            Constructor
            </summary>
            <param name="host">The component host</param>
            <param name="requestEntry">The build request entry</param>
            <param name="taskLocation">The <see cref="T:Microsoft.Build.Construction.ElementLocation"/> of the task.</param>
            <param name="targetBuilderCallback">An <see cref="T:Microsoft.Build.BackEnd.ITargetBuilderCallback"/> to use to invoke targets and build projects.</param>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.IsRunningMultipleNodes">
            <summary>
            Returns true in the multiproc case
            </summary>
            <comment>
            If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.  
            </comment>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.ContinueOnError">
            <summary>
            Reflects the value of the ContinueOnError attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.LineNumberOfTaskNode">
            <summary>
            The line number this task is on
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.ColumnNumberOfTaskNode">
            <summary>
            The column number this task is on
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.ProjectFileOfTaskNode">
            <summary>
            The project file this task is in.
            Typically this is an imported .targets file.
            Unfortunately the interface has shipped with a poor name, so we cannot change it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.ConvertErrorsToWarnings">
            <summary>
            Indicates whether or not errors should be converted to warnings.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.LoggingContext">
            <summary>
            Sets or retrieves the logging context
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.AppDomainSetup">
            <summary>
            For configuring child AppDomains.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHost.IsOutOfProc">
            <summary>
            Whether or not this is out of proc.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.BuildProjectFile(System.String,System.String[],System.Collections.IDictionary,System.Collections.IDictionary,System.String)">
            <summary>
            Builds a single project file
            Thread safe.
            </summary>
            <param name="projectFileName">The project file</param>
            <param name="targetNames">The list of targets to build</param>
            <param name="globalProperties">The global properties to use</param>
            <param name="targetOutputs">The outputs from the targets</param>
            <param name="toolsVersion">The tools version to use</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.BuildProjectFilesInParallel(System.String[],System.String[],System.Collections.IDictionary[],System.Collections.IDictionary[],System.String[],System.Boolean,System.Boolean)">
            <summary>
            Builds multiple project files in parallel.  This is the method the old MSBuild task invokes.
            Thread safe.
            </summary>
            <param name="projectFileNames">The list of projects to build</param>
            <param name="targetNames">The set of targets to build</param>
            <param name="globalProperties">The global properties to use for each project</param>
            <param name="targetOutputsPerProject">The outputs for each target on each project</param>
            <param name="toolsVersion">The tools versions to use</param>
            <param name="useResultsCache">Whether to use the results cache</param>
            <param name="unloadProjectsOnCompletion">Whether to unload projects when we are done.</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.BuildProjectFilesInParallel(System.String[],System.String[],System.Collections.IDictionary[],System.Collections.Generic.IList{System.String}[],System.String[],System.Boolean)">
            <summary>
            Builds multiple project files in parallel. 
            Thread safe.
            </summary>
            <param name="projectFileNames">The list of projects to build</param>
            <param name="targetNames">The set of targets to build</param>
            <param name="globalProperties">The global properties to use for each project</param>
            <param name="undefineProperties">The list of global properties to undefine</param>
            <param name="toolsVersion">The tools versions to use</param>
            <param name="returnTargetOutputs">Should the target outputs be returned in teh BuildEngineResult</param>
            <returns>A structure containing the result of the build, success or failure and the list of target outputs per project</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.Yield">
            <summary>
            Requests to yield the node.
            Thread safe, however Yield cannot be called unless the
            last call to Yield or Reacquire was Reacquire.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.Reacquire">
            <summary>
            Requests to reacquire the node.
            Thread safe, however Reacquire cannot be called unless the
            last call to Yield or Reacquire was Yield.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Logs an error event for the current task
            Thread safe.
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Logs a warning event for the current task
            Thread safe.
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Logs a message event for the current task
            Thread safe.
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Logs a custom event for the current task
            Thread safe.
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.BuildProjectFile(System.String,System.String[],System.Collections.IDictionary,System.Collections.IDictionary)">
            <summary>
            Builds a single project file
            Thread safe.
            </summary>
            <param name="projectFileName">The project file name</param>
            <param name="targetNames">The set of targets to build.</param>
            <param name="globalProperties">The global properties to use</param>
            <param name="targetOutputs">The outputs from the targets</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.RegisterTaskObject(System.Object,System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime,System.Boolean)">
            <summary>
            Disposes of all of the objects with the specified lifetime.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.GetRegisteredTaskObject(System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Gets a previously registered task object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.UnregisterTaskObject(System.Object,Microsoft.Build.Framework.RegisteredTaskObjectLifetime)">
            <summary>
            Unregisters a task object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.LogTelemetry(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Logs a telemetry event for the current task.
            </summary>
            <param name="eventName">The event name.</param>
            <param name="properties">The list of properties associated with the event.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.GetGlobalProperties">
            <summary>
            Gets the global properties for the current project.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" /> containing the global properties of the current project.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.InternalBuildProjects(System.String[],System.String[],System.Collections.IDictionary[],System.Collections.Generic.IList{System.String}[],System.String[],System.Boolean,System.Boolean)">
            <summary>
            Called by the internal MSBuild task.
            Does not take the lock because it is called by another request builder thread.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.InitializeLifetimeService">
            <inheritdoc />
            <summary>
            InitializeLifetimeService is called when the remote object is activated. 
            This method will determine how long the lifetime for the object will be.
            </summary>
            <returns>The lease object to control this object's lifetime.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.MarkAsInactive">
            <summary>
            Indicates to the TaskHost that it is no longer needed.
            Called by TaskBuilder when the task using the EngineProxy is done.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.IsEventSerializable(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Determine if the event is serializable. If we are running with multiple nodes we need to make sure the logging events are serializable. If not
            we need to log a warning.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.BuildProjectFilesInParallelAsync(System.String[],System.String[],System.Collections.IDictionary[],System.Collections.Generic.IList{System.String}[],System.String[],System.Boolean,System.Boolean)">
            <summary>
            Async version of BuildProjectFilesInParallel.
            </summary>
            <param name="projectFileNames">The list of projects to build</param>
            <param name="targetNames">The set of targets to build</param>
            <param name="globalProperties">The global properties to use for each project</param>
            <param name="undefineProperties">The list of global properties to undefine</param>
            <param name="toolsVersion">The tools versions to use</param>
            <param name="returnTargetOutputs">Should the target outputs be returned in teh BuildEngineResult</param>
            <param name="skipNonexistentTargets">If set, skip targets that are not defined in the projects to be built.</param>
            <returns>A Task returning a structure containing the result of the build, success or failure and the list of target outputs per project</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHost.VerifyActiveProxy">
            <summary>
            Verify the task host is active or not
            Thread safe.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequest">
            <summary>
            A build request contains information about the configuration used to build as well
            as which targets need to be built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId">
            <summary>
            The invalid global request id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest.InvalidNodeRequestId">
            <summary>
            The invalid node request id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest.ResultsTransferNodeRequestId">
            <summary>
            The results transfer request id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._submissionId">
            <summary>
            The submission with which this request is associated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._configurationId">
            <summary>
            The configuration id.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._globalRequestId">
            <summary>
            The global build request id, assigned by the Build Manager
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._parentGlobalRequestId">
            <summary>
            The global request id of the request which spawned this one.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._nodeRequestId">
            <summary>
            The build request id assigned by the node originating this request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._targets">
            <summary>
            The targets specified when the request was made.  Doesn't include default or initial targets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._parentBuildEventContext">
            <summary>
            The build event context of the parent
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._buildEventContext">
            <summary>
            The build event context of this request
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._buildRequestDataFlags">
            <summary>
            Whether or not the <see cref="T:Microsoft.Build.Execution.BuildResult"/> issued in response to this request should include <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequest._requestedProjectState">
            <summary>
            Filter describing properties, items, and metadata of interest for this request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequest.#ctor">
            <summary>
            Constructor for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequest.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildRequestDataFlags,Microsoft.Build.Execution.RequestedProjectState,System.Boolean)">
            <summary>
            Initializes a build request with a parent context.
            </summary>
            <param name="submissionId">The id of the build submission.</param>
            <param name="nodeRequestId">The id of the node issuing the request</param>
            <param name="configurationId">The configuration id to use.</param>
            <param name="escapedTargets">The targets to be built</param>
            <param name="hostServices">Host services if any. May be null.</param>
            <param name="parentBuildEventContext">The build event context of the parent project.</param>
            <param name="parentRequest">The parent build request, if any.</param>
            <param name="skipStaticGraphIsolationConstraints"></param>
            <param name="buildRequestDataFlags">Additional flags for the request.</param>
            <param name="requestedProjectState">Filter for desired build results.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequest.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.IsConfigurationResolved">
            <summary>
            Returns true if the configuration has been resolved, false otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.SubmissionId">
            <summary>
            Returns the submission id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.ConfigurationId">
            <summary>
            Returns the configuration id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.GlobalRequestId">
            <summary>
            Gets the global request id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.ParentGlobalRequestId">
            <summary>
            Gets the global request id of the parent request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.NodeRequestId">
            <summary>
            Gets the node request id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.Targets">
            <summary>
            Returns the set of unescaped targets to be built
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.Type">
            <summary>
            Returns the type of packet.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.ParentBuildEventContext">
            <summary>
            Returns the build event context of the parent, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.BuildEventContext">
            <summary>
            Returns the build event context for this request, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.CurrentTaskContext">
            <summary>
            The <see cref="P:Microsoft.Build.BackEnd.BuildRequest.BuildEventContext" /> of the currently executing task, if any.
            Used to correlate a project's build with the parent task that spawned it
            (usually the MSBuild task).
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.BuildRequestDataFlags">
            <summary>
            The set of flags specified in the BuildRequestData for this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.RequestedProjectState">
            <summary>
            Filter describing properties, items, and metadata of interest for this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.HostServices">
            <summary>
            The route for host-aware tasks back to the host
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.IsRootRequest">
            <summary>
            Returns true if this is a root request (one which has no parent.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequest.SkipStaticGraphIsolationConstraints">
            <summary>
            Whether static graph isolation constraints should be skipped for this request
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequest.ResolveConfiguration(System.Int32)">
            <summary>
            Sets the configuration id to a resolved id.
            </summary>
            <param name="newConfigId">The new configuration id for this request.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequest.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads/writes this packet
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequest.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.YieldAction">
            <summary>
            Indicates what the action is for requests which are yielding.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.YieldAction.Yield">
            <summary>
            The request is yielding its control of the node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.YieldAction.Reacquire">
            <summary>
            The request is ready to reacquire control of the node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.YieldAction.None">
            <summary>
            There is no yield action
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestBlocker">
            <summary>
            This class is used to inform the Scheduler that a request on a node is being blocked from further progress.  There
            are two cases for this:
            1) The request may be blocked waiting for a target to complete in the same project but which is assigned to
               another request.
            2) The request may be blocked because it has child requests which need to be satisfied to proceed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestBlocker._yieldAction">
            <summary>
            The yield action, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestBlocker._blockedGlobalRequestId">
            <summary>
            The global request id of the request which is being blocked from continuing.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestBlocker._targetsInProgress">
            <summary>
            The set of targets which are currently in progress for the blocked global request ID.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestBlocker._blockingGlobalRequestId">
            <summary>
            The request on which we are blocked, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestBlocker._blockingTarget">
            <summary>
            The name of the blocking target, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestBlocker._buildRequests">
            <summary>
            The requests which need to be built to unblock the request, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.#ctor(System.Int32,System.String[],System.Int32,System.String)">
            <summary>
            Constructor for the blocker where we are blocked waiting for a target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.#ctor(System.Int32,System.String[],Microsoft.Build.BackEnd.BuildRequest[])">
            <summary>
            Constructor for the blocker where we are blocked waiting for requests to be satisfied.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.#ctor(System.Int32,System.String[],Microsoft.Build.BackEnd.YieldAction)">
            <summary>
            Constructor for a blocker used by yielding requests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.#ctor(System.Int32)">
            <summary>
            Constructor for a blocker used by results-transfer requests
            </summary>
            <param name="blockedGlobalRequestId">The request needing results transferred</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.#ctor(System.Int32,System.String[])">
            <summary>
            Constructor for common values.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestBlocker.Type">
            <summary>
            Returns the type of packet.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestBlocker.BlockedRequestId">
            <summary>
            Accessor for the blocked request id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestBlocker.TargetsInProgress">
            <summary>
            Accessor for the set of targets currently in progress.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestBlocker.BlockingRequestId">
            <summary>
            Accessor for the blocking request id, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestBlocker.BlockingTarget">
            <summary>
            Accessor for the blocking request id, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestBlocker.BuildRequests">
            <summary>
            Accessor for the blocking build requests, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestBlocker.YieldAction">
            <summary>
            Accessor for the yield action.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Serialization method.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestBlocker.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestConfiguration">
            <summary>
            A build request configuration represents all of the data necessary to know which project to build
            and the environment in which it should be built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration.InvalidConfigurationId">
            <summary>
            The invalid configuration id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._configId">
            <summary>
            This is the ID of the configuration as set by the generator of the configuration.  When
            a node generates a configuration, this is set to a negative number.  The Build Manager will
            generate positive IDs
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._projectFullPath">
            <summary>
            The full path to the project to build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._toolsVersion">
            <summary>
            The tools version specified for the configuration.
            Always specified.
            May have originated from a /tv switch, or an MSBuild task,
            or a Project tag, or the default.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._explicitToolsVersionSpecified">
            <summary>
            Whether the tools version was set by the /tv switch or passed in through an msbuild callback
            directly or indirectly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._globalProperties">
            <summary>
            The set of global properties which should be used when building this project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._isTraversalProject">
            <summary>
            Flag indicating if the project in this configuration is a traversal
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._syncLock">
            <summary>
            Synchronization object.  Currently this just prevents us from caching and uncaching at the
            same time, causing a race condition.  This class is not made 100% threadsafe by the presence
            and current usage of this lock.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._project">
            <summary>
            The project object, representing the project to be built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._transferredState">
            <summary>
            The state of a project instance which has been transferred from one node to another.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._transferredProperties">
            <summary>
            The project instance properties we should transfer.
            <see cref="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._transferredState"/> and <see cref="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._transferredProperties"/> are mutually exclud
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._projectInitialTargets">
            <summary>
            The initial targets for the project
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._projectDefaultTargets">
            <summary>
            The default targets for the project
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._baseLookup">
            <summary>
            This is the lookup representing the current project items and properties 'state'.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._activelyBuildingTargets">
            <summary>
            This is the set of targets which are currently building but which have not yet completed.
            { targetName -> globalRequestId }
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._resultsNodeId">
            <summary>
            The node where this configuration's master results are stored.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._savedEnvironmentVariables">
            <summary>
             Holds a snapshot of the environment at the time we blocked.
             </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestConfiguration._savedCurrentDirectory">
            <summary>
            Holds a snapshot of the current working directory at the time we blocked.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.TargetNames">
            <summary>
            The target names that were requested to execute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.#ctor(Microsoft.Build.Execution.BuildRequestData,System.String)">
            <summary>
            Initializes a configuration from a BuildRequestData structure.  Used by the BuildManager.
            Figures out the correct tools version to use, falling back to the provided default if necessary.
            May throw InvalidProjectFileException.
            </summary>
            <param name="data">The data containing the configuration information.</param>
            <param name="defaultToolsVersion">The default ToolsVersion to use as a fallback</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.#ctor(System.Int32,Microsoft.Build.Execution.BuildRequestData,System.String)">
            <summary>
            Initializes a configuration from a BuildRequestData structure.  Used by the BuildManager.
            Figures out the correct tools version to use, falling back to the provided default if necessary.
            May throw InvalidProjectFileException.
            </summary>
            <param name="configId">The configuration ID to assign to this new configuration.</param>
            <param name="data">The data containing the configuration information.</param>
            <param name="defaultToolsVersion">The default ToolsVersion to use as a fallback</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.#ctor(System.Int32,Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Creates a new BuildRequestConfiguration based on an existing project instance.
            Used by the BuildManager to populate configurations from a solution.
            </summary>
            <param name="configId">The configuration id</param>
            <param name="instance">The project instance.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.#ctor(System.Int32,Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Creates a new configuration which is a clone of the old one but with a new id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.IsCacheable">
            <summary>
            Flag indicating whether the configuration is allowed to cache.  This does not mean that the configuration will
            actually cache - there are several criteria which must for that.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ExplicitlyLoaded">
            <summary>
            When reset caches is false we need to only keep around the configurations which are being asked for during the design time build.
            Other configurations need to be cleared. If this configuration is marked as ExplicitlyLoadedConfiguration then it should not be cleared when 
            Reset Caches is false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.IsActivelyBuilding">
            <summary>
            Flag indicating whether or not the configuration is actually building.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.IsLoaded">
            <summary>
            Flag indicating whether or not the configuration has been loaded before.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.IsCached">
            <summary>
            Flag indicating if the configuration is cached or not.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.IsTraversal">
            <summary>
            Flag indicating if this configuration represents a traversal project.  Traversal projects
            are projects which typically do little or no work themselves, but have references to other
            projects (and thus are used to find more work.)  The scheduler can treat these differently
            in order to fill its work queue with other options for scheduling.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.WasGeneratedByNode">
            <summary>
            Returns true if this configuration was generated on a node and has not yet been resolved.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ConfigurationId">
            <summary>
            Sets or returns the configuration id
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ProjectFullPath">
            <summary>
            Returns the filename of the project to build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ToolsVersion">
            <summary>
            The tools version specified for the configuration.
            Always specified.
            May have originated from a /tv switch, or an MSBuild task,
            or a Project tag, or the default.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.GlobalProperties">
            <summary>
            Returns the global properties to use to build this project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.Project">
            <summary>
            Sets or returns the project to build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.HasTargetsResolved">
            <summary>
            Returns true if the default and initial targets have been resolved.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ProjectInitialTargets">
            <summary>
            Gets the initial targets for the project
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ProjectDefaultTargets">
            <summary>
            Gets the default targets for the project
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.Type">
            <summary>
            Returns the node packet type
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.BaseLookup">
            <summary>
            Returns the lookup which collects all items and properties during the run of this project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ActivelyBuildingTargets">
            <summary>
            Retrieves the set of targets currently building, mapped to the request id building them.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.SavedEnvironmentVariables">
            <summary>
            Holds a snapshot of the environment at the time we blocked.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.SavedCurrentDirectory">
            <summary>
            Holds a snapshot of the current working directory at the time we blocked.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ExplicitToolsVersionSpecified">
            <summary>
            Whether the tools version was set by the /tv switch or passed in through an msbuild callback
            directly or indirectly.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestConfiguration.ResultsNodeId">
            <summary>
            Gets or sets the node on which this configuration's results are stored.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.op_Equality(Microsoft.Build.BackEnd.BuildRequestConfiguration,Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Implementation of the equality operator.
            </summary>
            <param name="left">The left hand argument</param>
            <param name="right">The right hand argument</param>
            <returns>True if the objects are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.op_Inequality(Microsoft.Build.BackEnd.BuildRequestConfiguration,Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Implementation of the inequality operator.
            </summary>
            <param name="left">The left-hand argument</param>
            <param name="right">The right-hand argument</param>
            <returns>True if the objects are not equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.CacheIfPossible">
            <summary>
            Requests that the configuration be cached to disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.RetrieveFromCache">
            <summary>
            Retrieves the configuration data from the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.GetTargetsUsedToBuildRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Gets the list of targets which are used to build the specified request, including all initial and applicable default targets
            </summary>
            <param name="request">The request </param>
            <returns>An array of t</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.GetHashCode">
            <summary>
            This override is used to provide a hash code for storage in dictionaries and the like.
            </summary>
            <remarks>
            If two objects are Equal, they must have the same hash code, for dictionaries to work correctly.
            Two configurations are Equal if their global properties are equivalent, not necessary reference equals.
            So only include filename and tools version in the hashcode.
            </remarks>
            <returns>A hash code</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.ToString">
            <summary>
            Returns a string representation of the object
            </summary>
            <returns>String representation of the object</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.Equals(System.Object)">
            <summary>
            Determines object equality
            </summary>
            <param name="obj">The object to compare with</param>
            <returns>True if they contain the same data, false otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.Equals(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Equality of the configuration is the product of the equality of its members.
            </summary>
            <param name="other">The other configuration to which we will compare ourselves.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.ApplyTransferredState(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Applies the state from the specified instance to the loaded instance.  This overwrites the items and properties.
            </summary>
            <remarks>
            Used when we transfer results and state from a previous node to the current one.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.GetCacheFile">
            <summary>
            Gets the name of the cache file for this configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.ClearCacheFile">
            <summary>
            Deletes the cache file
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.ShallowCloneWithNewId(System.Int32)">
            <summary>
            Clones this BuildRequestConfiguration but sets a new configuration id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.InternalEquals(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Compares this object with another for equality
            </summary>
            <param name="other">The object with which to compare this one.</param>
            <returns>True if the objects contain the same data, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.ResolveToolsVersion(Microsoft.Build.Execution.BuildRequestData,System.String)">
            <summary>
            Determines what the real tools version is.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestConfiguration.GetConfigurationTranslator(Microsoft.Build.BackEnd.TranslationDirection)">
            <summary>
            Gets the translator for this configuration.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.CircularDependencyException">
            <summary>
            An exception representing the case where a BuildRequest has caused a circular project dependency.  This is used to
            terminate the request builder which initiated the failure path.
            </summary>
            <remarks>
            If you add fields to this class, add a custom serialization constructor and override GetObjectData().
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.CircularDependencyException.#ctor">
            <summary>
            Constructs a standard BuildAbortedException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.CircularDependencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestUnblocker">
            <summary>
            This class is used by the Scheduler to unblock a blocked build request on the BuildRequestEngine.
            There are two cases:
            1. The request was blocked waiting on a target in the same project.  In this case this class will contain
               no information other than the request id.
            2. The request was blocked on some set of build requests.  This class will then contain the build results 
               needed to satisfy those requests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestUnblocker._blockedGlobalRequestId">
            <summary>
            The node request id of the request which is blocked and now will either result or have results reported.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestUnblocker._buildResult">
            <summary>
            The build result which we wish to report.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestUnblocker.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestUnblocker.#ctor(System.Int32)">
            <summary>
            Constructor for the unblocker where we are blocked waiting for a target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestUnblocker.#ctor(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Constructor for the unblocker where we are blocked waiting for results.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestUnblocker.#ctor(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Constructor for the unblocker for circular dependencies
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestUnblocker.Type">
            <summary>
            Returns the type of packet.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestUnblocker.BlockedRequestId">
            <summary>
            Accessor for the blocked node request id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.BuildRequestUnblocker.Result">
            <summary>
            Accessor for the build results, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestUnblocker.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Serialization method.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.BuildRequestUnblocker.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IBuildResults">
            <summary>
            An interface representing results for a build request
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildResults.Exception">
            <summary>
            The exception, if any, generated while the build ran.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildResults.OverallResult">
            <summary>
            The overall build result code.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildResults.ResultsByTarget">
            <summary>
            Returns an enumerator for all target results in this build result
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildResults.SavedEnvironmentVariables">
            <summary>
            Set of environment variables for the configuration this result came from
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildResults.SavedCurrentDirectory">
            <summary>
            The current directory for the configuration this result came from
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildResults.Item(System.String)">
            <summary>
            Gets the results for a target in the build request
            </summary>
            <param name="target">The target name</param>
            <returns>The target results</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildResults.HasResultsForTarget(System.String)">
            <summary>
            Returns true if there are results for the specified target
            </summary>
            <param name="target">The target name</param>
            <returns>True if results exist, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.WorkUnitResultCode">
            <summary>
            The result of executing the task or target.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitResultCode.Skipped">
            <summary>
            The work unit was skipped.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitResultCode.Success">
            <summary>
            The work unit succeeded.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitResultCode.Failed">
            <summary>
            The work unit failed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitResultCode.Canceled">
            <summary>
            The work unit was cancelled.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.WorkUnitActionCode">
            <summary>
            Indicates whether further work should be done.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitActionCode.Continue">
            <summary>
            Work should proceed with the next work unit.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitActionCode.Stop">
            <summary>
            No further work units should be executed.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.WorkUnitResult">
            <summary>
            A result of executing a target or task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitResult._resultCode">
            <summary>
            The result.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitResult._actionCode">
            <summary>
            The next action to take.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.WorkUnitResult._exception">
            <summary>
            The exception from the failure, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.WorkUnitResult.#ctor">
            <summary>
            Creates a new work result ready for aggregation during batches.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.WorkUnitResult.#ctor(Microsoft.Build.BackEnd.WorkUnitResultCode,Microsoft.Build.BackEnd.WorkUnitActionCode,System.Exception)">
            <summary>
            Creates a work result with the specified result codes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.WorkUnitResult.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translator constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.WorkUnitResult.ResultCode">
            <summary>
            Get the result code.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.WorkUnitResult.ActionCode">
            <summary>
            Get the action code.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.WorkUnitResult.Exception">
            <summary>
            Get the exception
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.WorkUnitResult.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.WorkUnitResult.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.WorkUnitResult.AggregateResult(Microsoft.Build.BackEnd.WorkUnitResult)">
            <summary>
            Aggregates the specified result with this result and returns the aggregation.
            </summary>
            <remarks>
            The rules are:
            1. Errors take precedence over success.
            2. Success takes precedence over skipped.
            3. Stop takes precedence over continue.
            4. The first exception in the result wins.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.BackEnd.RequestCompleteDelegate">
            <summary>
            Callback for event raised when a build request is completed
            </summary>
            <param name="request">The request which completed</param>
            <param name="result">The result for the request</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.RequestResumedDelegate">
            <summary>
            Callback for event raised when a request is resumed
            </summary>
            <param name="request">The request being resumed</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.RequestBlockedDelegate">
            <summary>
            Callback for event raised when a new build request is generated by an MSBuild callback
            </summary>
            <param name="blocker">Information about what is blocking the engine.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.EngineStatusChangedDelegate">
            <summary>
            Callback for event raised when the build request engine's status changes.
            </summary>
            <param name="newStatus">The new status for the engine</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NewConfigurationRequestDelegate">
            <summary>
            Callback for event raised when a new configuration needs an ID resolved.
            </summary>
            <param name="config">The configuration needing an ID</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.EngineExceptionDelegate">
            <summary>
            Callback for event raised when there is an unhandled exception in the engine.
            </summary>
            <param name="e">The exception.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildRequestEngineStatus">
            <summary>
            Status types for the build request engine
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngineStatus.Uninitialized">
            <summary>
            The engine has not yet been initialized, and cannot accept requests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngineStatus.Idle">
            <summary>
            The engine has no active or waiting build requests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngineStatus.Active">
            <summary>
            The engine is presently working on a build request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngineStatus.Waiting">
            <summary>
            The engine has only build requests which are waiting for build results to continue.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildRequestEngineStatus.Shutdown">
            <summary>
            The engine has shut down.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IBuildRequestEngine">
            <summary>
            Objects implementing this interface may be used by a Node to process build requests
            and generate build results.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IBuildRequestEngine.OnRequestComplete">
            <summary>
            Raised when a build request is completed and results are available.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IBuildRequestEngine.OnRequestResumed">
            <summary>
            Raised when a build request is resumed from a previously waiting state.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IBuildRequestEngine.OnRequestBlocked">
            <summary>
            Raised when a new build request is generated by an MSBuild callback.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IBuildRequestEngine.OnStatusChanged">
            <summary>
            Raised when the engine status changes.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IBuildRequestEngine.OnNewConfigurationRequest">
            <summary>
            Raised when a configuration needs an id.
            </summary>
        </member>
        <member name="E:Microsoft.Build.BackEnd.IBuildRequestEngine.OnEngineException">
            <summary>
            Raised when an unhandled exception occurs in the engine.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildRequestEngine.Status">
            <summary>
            Gets the current engine status.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildRequestEngine.InitializeForBuild(Microsoft.Build.BackEnd.Logging.NodeLoggingContext)">
            <summary>
            Prepares the engine for a new build and spins up the engine thread.  
            The engine must be in the Idle state, and not already be initialized.
            </summary>
            <param name="loggingContext">The logging context for the node.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildRequestEngine.CleanupForBuild">
            <summary>
            Cleans up after a build but leaves the engine thread running.  Aborts
            any outstanding requests.  Blocks until the engine has cleaned up
            everything.  After this method is called, InitializeForBuild may be
            called to start a new build, or the component may be shut down.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildRequestEngine.SubmitBuildRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Submits the specified request to the build queue. 
            </summary>
            <param name="request">The request to build.</param>
            <remarks>It is only valid to call this method when the engine is in the Idle or
            Waiting state because the engine can only service one active request at a time.</remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildRequestEngine.UnblockBuildRequest(Microsoft.Build.BackEnd.BuildRequestUnblocker)">
            <summary>
            Notifies the engine of a build result for a waiting build request.
            </summary>
            <param name="unblocker">The unblocking information</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildRequestEngine.ReportConfigurationResponse(Microsoft.Build.BackEnd.BuildRequestConfigurationResponse)">
            <summary>
            Notifies the engine of a configuration response packet, typically generated by the Build Request Manager.  This packet is used to set
            the global configuration ID for a specific configuration.
            </summary>
            <param name="response">The build configuration response.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.INodeManager">
            <summary>
            Represents a collection of all node providers in the system.  Reports events concerning
            the topology of the system and provides a means to send and receive data to nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeManager.CreateNode(Microsoft.Build.BackEnd.NodeConfiguration,Microsoft.Build.Execution.NodeAffinity)">
            <summary>
            Requests that a new node be created.
            </summary>
            <param name="configuration">The configuration to use to create the node.</param>
            <param name="affinity">The <see cref="T:Microsoft.Build.Execution.NodeAffinity"/> to use.</param>
            <returns>Information about the node created</returns>
            <remarks>
            Throws an exception if the node could not be created.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeManager.SendData(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends a data packet to a specific node
            </summary>
            <param name="node">The node to which the data packet should be sent.</param>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeManager.ShutdownConnectedNodes(System.Boolean)">
            <summary>
            Shuts down all of the managed nodes.  This is an asynchronous method - the nodes are
            not considered shut down until a NodeShutdown packet has been received.
            </summary>
            <param name="enableReuse">Flag indicating if nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeManager.ShutdownAllNodes">
            <summary>
            Shuts down all of the managed nodes permanently.  This is an asynchronous method - the nodes are
            not considered shut down until a NodeShutdown packet has been received.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeManager.ClearPerBuildState">
            <summary>
            The node manager contains state which is not supposed to persist between builds, make sure this is cleared.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeProviderType">
            <summary>
            The type of nodes provided by the node provider.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderType.InProc">
            <summary>
            The provider provides the in-proc node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderType.OutOfProc">
            <summary>
            The provider provides out-of-proc nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderType.Remote">
            <summary>
            The provider provides remote nodes.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.INodeProvider">
            <summary>
            This interface represents a collection of nodes in the system.  It provides methods to 
            enumerate active nodes as well as send data and receive events from those nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.INodeProvider.ProviderType">
            <summary>
            The type of nodes provided by this node provider.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.INodeProvider.AvailableNodes">
            <summary>
            The number of nodes this provider can create.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeProvider.CreateNode(System.Int32,Microsoft.Build.BackEnd.INodePacketFactory,Microsoft.Build.BackEnd.NodeConfiguration)">
            <summary>
            Requests that a new node be created on the specified machine.
            </summary>
            <param name="nodeId">The id to assign to the node.</param>
            <param name="packetFactory">
            The packet factory used to create packets when data is
            received on this node.
            </param>
            <param name="configuration">The configuration to use to create the remote node.</param>
            <returns>True if the node was created, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeProvider.SendData(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to a specific node.
            </summary>
            <param name="node">The node to which data should be sent.</param>
            <param name="packet">The packet to be sent.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeProvider.ShutdownConnectedNodes(System.Boolean)">
            <summary>
            Shuts down all of the connected, managed nodes.  This call will not return until all nodes are shut down.
            </summary>
            <param name="enableReuse">Flag indicating if nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INodeProvider.ShutdownAllNodes">
            <summary>
            Shuts down all of the managed nodes.  This call will not return until all nodes are shut down.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeEndpointInProc">
            <summary>
            This is an implementation of INodeEndpoint for in-proc nodes.  This endpoint can use either
            synchronous or asynchronous packet processing methods.  When synchronous processing methods are
            used, the SendData method will cause the OnDataReceived event on the receiving endpoint to be called
            on the same thread, blocking until the handler returns.  The asynchronous method more closely emulates
            the way other kinds of endpoints work, as the recipient processes the packet on a different thread
            than that from which the packet originated, but with the cost of the extra thread.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc.s_locker">
            <summary>
            An object for the two inproc endpoints to synchronize on.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._status">
            <summary>
            The current communication status of the node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._mode">
            <summary>
            The communications mode
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._peerEndpoint">
            <summary>
            The peer endpoint
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._componentHost">
            <summary>
            The build component host
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._packetFactory">
            <summary>
            The packet factory used to route packets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._asyncDataMonitor">
            <summary>
            Object used as a lock source for the async data
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._packetAvailable">
            <summary>
            Set when a packet is available in the packet queue
            </summary>      
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._terminatePacketPump">
            <summary>
            Set when the asynchronous packet pump should terminate
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._packetPump">
            <summary>
            The thread which runs the asynchronous packet pump
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._peerConnected">
            <summary>
            Set to true if our peer is connected to us.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc._packetQueue">
            <summary>
            The asynchronous packet queue.  
            </summary>
            <remarks>
            Operations on this queue must be synchronized since it is accessible by multiple threads.
            Use a lock on the packetQueue itself.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.#ctor(Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointMode,Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Instantiates a Node and initializes it to unconnected.
            </summary>
            <param name="commMode">The communications mode for this endpoint.</param>
            <param name="host">The component host.</param>
        </member>
        <member name="E:Microsoft.Build.BackEnd.NodeEndpointInProc.OnLinkStatusChanged">
            <summary>
            Raised when the link status has changed.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointMode">
            <summary>
            Represents the style of communications used by the in-proc endpoint.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointMode.Synchronous">
            <summary>
            The DataReceived event is raised on the same thread as that which called SendData.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointMode.Asynchronous">
            <summary>
            The DataReceived event is raised on a separate thread from that which called SendData
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeEndpointInProc.LinkStatus">
            <summary>
            Returns the link status of this node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.Listen(Microsoft.Build.BackEnd.INodePacketFactory)">
            <summary>
            Causes this endpoint to wait for the remote endpoint to connect
            </summary>
            <param name="factory">Unused</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.Connect(Microsoft.Build.BackEnd.INodePacketFactory)">
            <summary>
            Causes this node to connect to the matched endpoint.  
            </summary>
            <param name="factory">Unused</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.Disconnect">
            <summary>
            Shuts down the link
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.SendData(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the peer endpoint.
            </summary>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.CreateInProcEndpoints(Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointMode,Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            This method is used to create a matched pair of endpoints used by the Node Provider and
            the Node.  The inputs and outputs for each node are automatically configured.
            </summary>
            <param name="mode">The communications mode for the endpoints.</param>
            <param name="host">The component host.</param>
            <returns>A matched pair of endpoints.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.RaiseLinkStatusChanged(Microsoft.Build.BackEnd.LinkStatus)">
            <summary>
            Invokes the OnLinkStatusChanged event in a thread-safe manner.
            </summary>
            <param name="newStatus">The new status of the endpoint link.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.SetPeerNodeConnected">
            <summary>
            This method is called by the other endpoint when it is ready to establish the connection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.SetPeerNodeDisconnected">
            <summary>
            This method is called by either side to notify this endpoint that the link is inactive.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.InternalDisconnect">
            <summary>
            This does the actual work of changing the status and shutting down any threads we may have for
            disconnection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.ChangeLinkStatus(Microsoft.Build.BackEnd.LinkStatus)">
            <summary>
            Updates the current link status if it has changed and notifies any registered delegates.
            </summary>
            <param name="newStatus">The status the node should now be in.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.EnqueuePacket(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Adds a packet to the packet queue when asynchronous mode is enabled.
            </summary>
            <param name="packet">The packet to be transmitted.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.InitializeAsyncPacketThread">
            <summary>
            Initializes the packet pump thread and the supporting events as well as the packet queue.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.TerminateAsyncPacketThread">
            <summary>
            Shuts down the packet pump thread and cleans up associated data.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.PacketPumpProc">
            <summary>
            This method handles the asynchronous message pump.  It waits for messages to show up on the queue
            and calls FireDataAvailable for each such packet.  It will terminate when the terminate event is
            set.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointPair">
            <summary>
            Used to return a matched pair of endpoints for in-proc nodes to use with the Build Manager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointPair.NodeEndpoint">
            <summary>
            The endpoint destined for use by a node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointPair.ManagerEndpoint">
            <summary>
            The endpoint destined for use by the Build Manager
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeEndpointInProc.EndpointPair.#ctor(Microsoft.Build.BackEnd.NodeEndpointInProc,Microsoft.Build.BackEnd.NodeEndpointInProc)">
            <summary>
            Creates an endpoint pair
            </summary>
            <param name="node">The node-side endpoint.</param>
            <param name="manager">The manager-side endpoint.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeInfo">
            <summary>
            Contains information about the state of a node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeInfo._nodeId">
            <summary>
            The node ID
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeInfo._providerType">
            <summary>
            The provider type
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeInfo._configurationIDs">
            <summary>
            The configuration IDs the node knows about.  These are not necessarily the ones
            currently assigned to the node, as that can change.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeInfo.#ctor(System.Int32,Microsoft.Build.BackEnd.NodeProviderType)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeInfo.NodeId">
            <summary>
            The ID of the node.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeInfo.ProviderType">
            <summary>
            The type of provider which manages this node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeInfo.AssignConfiguration(System.Int32)">
            <summary>
            Assigns the specific configuration ID to the node.
            </summary>
            <returns>
            True if the configuration is not already known to the node and must be sent to it, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeInfo.HasConfiguration(System.Int32)">
            <summary>
            Determines whether the specified configuration if is known to the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeInfo.CanServiceRequestWithAffinity(Microsoft.Build.Execution.NodeAffinity)">
            <summary>
            Returns true if this node can service requests with the specified affinity.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeProviderInProc">
            <summary>
            An implementation of a node provider for in-proc nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc.InvalidInProcNodeId">
            <summary>
            The invalid in-proc node id
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._disposed">
            <summary>
            Flag indicating we have disposed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc.InProcNodeOwningOperatingEnvironment">
            <summary>
            Value used to ensure multiple in-proc nodes which save the operating environment are not created.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._componentHost">
            <summary>
            The component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._inProcNode">
            <summary>
            The in-proc node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._inProcNodeEndpoint">
            <summary>
            The in-proc node endpoint.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._packetFactory">
            <summary>
            The packet factory used to route packets from the node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._inProcNodeThread">
            <summary>
            The in-proc node thread.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._endpointConnectedEvent">
            <summary>
            Event which is raised when the in-proc endpoint is connected.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._inProcNodeId">
            <summary>
            The ID of the in-proc node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.NodeProviderInProc._exclusiveOperatingEnvironment">
            <summary>
            Check to allow the inproc node to have exclusive ownership of the operating environment
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.#ctor">
            <summary>
            Initializes the node provider.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderInProc.ProviderType">
            <summary>
            Returns the type of nodes managed by this provider.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.NodeProviderInProc.AvailableNodes">
            <summary>
            Returns the number of nodes available to create on this provider.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Sets the build component host.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.ShutdownComponent">
            <summary>
            Shuts down this component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.SendData(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Sends data to the specified node.
            </summary>
            <param name="nodeId">The node to which data should be sent.</param>
            <param name="packet">The data to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.ShutdownConnectedNodes(System.Boolean)">
            <summary>
            Causes all connected nodes to be shut down.
            </summary>
            <param name="enableReuse">Flag indicating if the nodes should prepare for reuse.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.ShutdownAllNodes">
            <summary>
            Causes all nodes to be shut down permanently - for InProc nodes it is the same as ShutdownConnectedNodes
            with enableReuse = false
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.CreateNode(System.Int32,Microsoft.Build.BackEnd.INodePacketFactory,Microsoft.Build.BackEnd.NodeConfiguration)">
            <summary>
            Requests that a node be created on the specified machine.
            </summary>
            <param name="nodeId">The id of the node to create.</param>
            <param name="factory">The factory to use to create packets from this node.</param>
            <param name="configuration">The configuration for the node.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers a packet handler.  Not used in the in-proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.  Not used in the in-proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Deserializes and routes a packet.  Not used in the in-proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes a packet.
            </summary>
            <param name="nodeId">The id of the node from which the packet is being routed.</param>
            <param name="packet">The packet to route.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.Dispose">
            <summary>
            IDisposable implementation
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.CreateComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Factory for component creation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.InstantiateNode(Microsoft.Build.BackEnd.INodePacketFactory)">
            <summary>
            Creates a new in-proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.InProcNodeThreadProc">
            <summary>
            Thread proc which runs the in-proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.InProcNodeEndpoint_OnLinkStatusChanged(Microsoft.Build.BackEnd.INodeEndpoint,Microsoft.Build.BackEnd.LinkStatus)">
            <summary>
            Callback invoked when the link status of the endpoint has changed.
            </summary>
            <param name="endpoint">The endpoint whose status has changed.</param>
            <param name="status">The new link status.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.InProcNodeShutdown(Microsoft.Build.Execution.NodeEngineShutdownReason,System.Exception)">
            <summary>
            Callback invoked when the endpoint shuts down.
            </summary>
            <param name="reason">The reason the endpoint is shutting down.</param>
            <param name="e">Any exception which was raised that caused the endpoint to shut down.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.NodeProviderInProc.Dispose(System.Boolean)">
            <summary>
            Dispose implementation.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IBuildComponent">
            <summary>
            Each component in the build system which is registered with the Build Manager or a Node must
            implement this interface.
            
            REFACTOR: Maybe these could all implement IDisposable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildComponent.InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Called by the build component host when a component is first initialized
            </summary>
            <param name="host">The host for the component.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildComponent.ShutdownComponent">
            <summary>
            Called by the build component host when the component host is about to shutdown
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildComponentFactoryDelegate">
            <summary>
            Factory delegate which instantiates a component of the type specified.
            </summary>
            <param name="type">The type of component to be instantiated.</param>
            <returns>An instance of the component.</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.BuildComponentType">
            <summary>
            An enumeration of all component types recognized by the system    
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.RequestManager">
            <summary>
            Request Manager
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.Scheduler">
            <summary>
            Scheduler
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.ResultsCache">
            <summary>
            Results Cache
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.PropertyCache">
            <summary>
            Property Cache
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.ConfigCache">
            <summary>
            The Build Request Configuration Cache
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.NodeManager">
            <summary>
            Node Manager
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.InProcNodeProvider">
            <summary>
            InProcNodeProvider
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.OutOfProcNodeProvider">
            <summary>
            OutOfProcNodeProvider
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.RemoteNodeProvider">
            <summary>
            RemoteNodeProvider
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.NodePacketFactory">
            <summary>
            Node packet factory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.RequestEngine">
            <summary>
            Request engine
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.FileMonitor">
            <summary>
            File monitor
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.NodeEndpoint">
            <summary>
            The endpoint on a Node
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.LoggingService">
            <summary>
            The logging service
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.RequestBuilder">
            <summary>
            The component responsible for building requests.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.TargetBuilder">
            <summary>
            The component responsible for building targets.        
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.TaskBuilder">
            <summary>
            The component responsible for building tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.TestDataProvider">
            <summary>
            The component which is responsible for providing test data to the variour components
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.OutOfProcTaskHostNodeProvider">
            <summary>
            OutOfProcTaskHostNodeProvider
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.TaskHostNodeManager">
            <summary>
            Node manager for task host nodes
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.RegisteredTaskObjectCache">
            <summary>
            The cache of registered disposable objects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.BuildComponentType.SdkResolverService">
            <summary>
            The SDK resolution service.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IBuildComponentHost">
            <summary>
            This interface is implemented by objects which host build components.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildComponentHost.Name">
            <summary>
            Retrieves the name of the host.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildComponentHost.BuildParameters">
            <summary>
            Retrieves the BuildParameters used during the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildComponentHost.LegacyThreadingData">
            <summary>
            The data structure which holds the data for the use of legacy threading semantics
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IBuildComponentHost.LoggingService">
            <summary>
            Retrieves the logging service associated with a particular build
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildComponentHost.RegisterFactory(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.BuildComponentFactoryDelegate)">
            <summary>
            Registers a factory which will be used to create the necessary components of the build
            system.
            </summary>
            <param name="factoryType">The type which is created by this factory.</param>
            <param name="factory">The factory to be registered.</param>
            <remarks>
            It is not necessary to register any factories.  If no factory is registered for a specific kind
            of object, the system will use the default factory.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Gets an instance of the specified component type from the host.
            </summary>
            <param name="type">The component type to be retrieved</param>
            <returns>The component</returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.IScheduler">
            <summary>
            Represents an object which provides scheduling services for BuildRequests over Nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.IScheduler.MinimumAssignableConfigurationId">
            <summary>
            Retrieves the minimum assignable configuration id
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.IsCurrentlyBuildingConfiguration(System.Int32)">
            <summary>
            Determines if the specified configuration is currently being built
            </summary>
            <param name="configurationId">The configuration to query for</param>
            <returns>True if the configuration is being built somewhere, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.GetConfigurationIdFromPlan(System.String)">
            <summary>
            Retrieves a configuration id for a configuration which has a matching path
            </summary>
            <param name="configurationPath">The path for the configuration</param>
            <returns>A positive configuration id if one exists in the plan, 0 otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.ReportRequestBlocked(System.Int32,Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Reports to the scheduler that a request is blocked.
            </summary>
            <param name="nodeId">The node making the report.</param>
            <param name="blocker">The thing blocking the active request on the node.</param>
            <returns>Action to be taken.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.ReportResult(System.Int32,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Reports to the scheduler that a new result has been generated for a build request.
            </summary>
            <param name="nodeId">The node reporting the request.</param>
            <param name="result">The result.</param>
            <returns>Action to be taken.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.ReportNodesCreated(System.Collections.Generic.IEnumerable{Microsoft.Build.BackEnd.NodeInfo})">
            <summary>
            Reports to the scheduler that a node has been created.
            </summary>
            <param name="nodeInfo">Info about the created nodes.</param>
            <returns>Action to be taken.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.ReportBuildAborted(System.Int32)">
            <summary>
            Reports to the scheduler than a node aborted the build.
            </summary>
            <param name="nodeId">The node which aborted.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.Reset">
            <summary>
            Resets the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.IScheduler.WriteDetailedSummary(System.Int32)">
            <summary>
            Writes a detailed summary of the build state which includes informaiton about the scheduling plan.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ScheduleActionType">
            <summary>
            The type of action to take in response to a scheduling request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.NoAction">
            <summary>
            The response indicates that no action should be taken.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.Schedule">
            <summary>
            The response indicates that the request should be sent to the specified node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.ScheduleWithConfiguration">
            <summary>
            The response indicates that the request should be send to the specified node, 
            along with the configuration for the request.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.ReportResults">
            <summary>
            The response has results for a particular blocked request
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.ResumeExecution">
            <summary>
            The specified request id should now resume execution
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.CreateNode">
            <summary>
            The response indicates that a new node should be created rather than scheduling this request.
            The request may be scheduled at a later time.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.SubmissionComplete">
            <summary>
            The response indicates that the submission is complete.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleActionType.CircularDependency">
            <summary>
            The last action caused a circular dependency which cannot be resolved.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ScheduleResponse">
            <summary>
            A response from the scheduler indicating where a build request should be handled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleResponse.Action">
            <summary>
            The type of action to take on this response.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleResponse.NodeId">
            <summary>
            The node ID to which the request should be sent.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleResponse.BuildResult">
            <summary>
            The results for a completed submission.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleResponse.BuildRequest">
            <summary>
            The build request to send.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleResponse.Unblocker">
            <summary>
            The unblocking information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleResponse.RequiredNodeType">
            <summary>
            The type of node we must create.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.ScheduleResponse.NumberOfNodesToCreate">
            <summary>
            The number of nodes of the requested affinity to create.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.#ctor(Microsoft.Build.BackEnd.ScheduleActionType)">
            <summary>
            Constructs a response where no action should be taken.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.#ctor(Microsoft.Build.Execution.NodeAffinity,System.Int32)">
            <summary>
            Constructs a response indicating what type of node we need to create.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.#ctor(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Constructs a response indicating that a specific submission has completed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.#ctor(System.Int32,Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Constructs a response indicating there is a circular dependency caused by the specified request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.#ctor(System.Int32,Microsoft.Build.BackEnd.BuildRequest,System.Boolean)">
            <summary>
            Constructs a response where a request should be scheduled.
            </summary>
            <param name="node">The node ID to which the request should be sent.</param>
            <param name="request">The request to send.</param>
            <param name="sendConfiguration"><code>true</code> to send the configuration, otherwise <code>false</code>.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.#ctor(System.Int32,Microsoft.Build.BackEnd.BuildRequestUnblocker)">
            <summary>
            Constructs a response where a result should be sent or execution should be resumed.
            </summary>
            <param name="node">The node ID to which the result should be sent.</param>
            <param name="unblocker">The result to send.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.CreateScheduleResponse(System.Int32,Microsoft.Build.BackEnd.BuildRequest,System.Boolean)">
            <summary>
            Creates a Schedule or ScheduleWithConfiguration response
            </summary>
            <param name="node">The node to which the response should be sent.</param>
            <param name="requestToSchedule">The request to be scheduled.</param>
            <param name="sendConfiguration">Flag indicating whether or not the configuration for the request must be sent to the node as well.</param>
            <returns>The ScheduleResponse.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.CreateReportResultResponse(System.Int32,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Creates a ReportResult response.
            </summary>
            <param name="node">The node to which the response should be sent.</param>
            <param name="resultToReport">The result to be reported.</param>
            <returns>The ScheduleResponse.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.CreateResumeExecutionResponse(System.Int32,System.Int32)">
            <summary>
            Creates a ResumeExecution response.
            </summary>
            <param name="node">The node to which the response should be sent.</param>
            <param name="globalRequestIdToResume">The request which should resume executing.</param>
            <returns>The ScheduleResponse.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.CreateCircularDependencyResponse(System.Int32,Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Creates a CircularDependency response.
            </summary>
            <param name="node">The node to which the response should be sent.</param>
            <param name="parentRequest">The request which attempted to invoke the request causing the circular dependency.</param>
            <param name="requestCausingCircularDependency">The request which caused the circular dependency.</param>
            <returns>The ScheduleResponse.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.CreateSubmissionCompleteResponse(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Creates a SubmissionComplete response.
            </summary>
            <param name="rootRequestResult">The result for the submission's root request.</param>
            <returns>The ScheduleResponse.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.CreateNewNodeResponse(Microsoft.Build.Execution.NodeAffinity,System.Int32)">
            <summary>
            Create a CreateNode response
            </summary>
            <param name="typeOfNodeToCreate">The type of node to create.</param>
            <param name="count">The number of new nodes of that particular affinity to create.</param>
            <returns>The ScheduleResponse.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ScheduleResponse.ToString">
            <summary>
            Returns the schedule response as a descriptive string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.NodeShutdownDelegate">
            <summary>
            Delegate is called when a node shuts down.
            </summary>
            <param name="reason">The reason for the shutdown</param>
            <param name="e">The exception which caused an unexpected shutdown, if any.</param>
        </member>
        <member name="T:Microsoft.Build.BackEnd.INode">
            <summary>
            This interface is implemented by a build node, and allows the host process to control its execution.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.INode.Run(System.Exception@)">
            <summary>
            Runs the Node.  Returns the reason the node shut down.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskRequirements">
            <summary>
            Flags requrned by ITaskExecutionHost.FindTask().
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskRequirements.None">
            <summary>
            The task was not found.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskRequirements.RequireSTAThread">
            <summary>
            The task must be executed on an STA thread.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskRequirements.RequireSeparateAppDomain">
            <summary>
            The task must be executed in a separate AppDomain.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.ITaskExecutionHost">
            <summary>
            This interface represents the host for task execution.  When used in the in-proc scenario, these method calls essentially
            are pass-throughs to just set some member variables and call methods directly on the task and associated objects.
            In the out-of-proc/AppDomain-isolated case, the object implementing these methods may break apart the information
            in the parameters to be consumed by the IContract representing the remote object through MAF.
            
            REFACTOR - Eliminate this interface.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ITaskExecutionHost.ProjectInstance">
            <summary>
            The associated project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.ITaskExecutionHost.LogTaskInputs">
            <summary>
            Flag to determine whether or not to log task inputs.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForTask(Microsoft.Build.Framework.IBuildEngine2,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Execution.ProjectInstance,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Framework.ITaskHost,System.Boolean,System.AppDomainSetup,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Initialize the host with the objects required to communicate with the host process.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.FindTask(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Ask the task host to find its task in the registry and get it ready for initializing the batch
            </summary>
            <returns>The task requirements if the task is found, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForBatch(Microsoft.Build.BackEnd.Logging.TaskLoggingContext,Microsoft.Build.BackEnd.ItemBucket,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Initializes for running a particular batch
            </summary>
            <returns>True if the task is instantiated, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.SetTaskParameters(System.Collections.Generic.IDictionary{System.String,System.Tuple{System.String,Microsoft.Build.Construction.ElementLocation}})">
            <summary>
            Sets a task parameter using an unevaluated value, which will be expanded by the batch bucket.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.GatherTaskOutputs(System.String,Microsoft.Build.Construction.ElementLocation,System.Boolean,System.String)">
            <summary>
            Gets all of the outputs and stores them in the batch bucket.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForBatch">
            <summary>
            Signal that we are done with this bucket.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForTask">
            <summary>
            Signal that we are done with this task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.ITaskExecutionHost.Execute">
            <summary>
            Executes the task.
            </summary>
            <returns>
            True if execution succeeded, false otherwise.
            </returns>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskExecutionHost">
            <summary>
            The TaskExecutionHost is responsible for instantiating tasks, setting their parameters and gathering outputs using
            reflection, and executing the task in the appropriate context.The TaskExecutionHost does not deal with any part of the task declaration or
            XML.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost.CancelFirstWarningWaitInterval">
            <summary>
            Time interval in miliseconds to wait between receiving a cancelation signal and emitting the first warning that a non-cancelable task has not finished
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost.CancelWarningWaitInterval">
            <summary>
            Time interval in miliseconds between subsequent warnings that a non-cancelable task has not finished
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._resolver">
            <summary>
            Resolver to assist in resolving types when a new appdomain is created
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._buildEngine">
            <summary>
            The interface used to call back into the build engine.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._projectInstance">
            <summary>
            The project instance in whose context we are executing
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._targetLoggingContext">
            <summary>
            The logging context for the target.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._taskLoggingContext">
            <summary>
            The logging context for the task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._cancellationTokenRegistration">
            <summary>
            The registration which handles the callback when task cancellation is invoked.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._taskName">
            <summary>
            The name of the task to execute.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._taskLocation">
            <summary>
            The XML location of the task element.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._taskHost">
            <summary>
            The arbitrary task host object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._batchBucket">
            <summary>
            The bucket used to evaluate items and properties.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._taskFactoryWrapper">
            <summary>
            The task type retrieved from the assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._cancelled">
            <summary>
            Set to true if the execution has been cancelled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._taskExecutionIdle">
            <summary>
            Event which is signalled when a task is not executing.  Used for cancellation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._remotedTaskItems">
            <summary>
            The task items that we remoted across the appdomain boundary
            we use this list to disconnect the task items once we're done.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._buildComponentHost">
            <summary>
            We need access to the build component host so that we can get at the 
            task host node provider when running a task wrapped by TaskHostTask
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskExecutionHost._intrinsicTasks">
            <summary>
            The set of intrinsic tasks mapped for this process.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.#ctor(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.#ctor">
            <summary>
            Constructor, for unit testing only.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskExecutionHost.LogTaskInputs">
            <summary>
            Flag to determine whether or not to log task inputs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#ProjectInstance">
            <summary>
            The associated project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskExecutionHost.TaskInstance">
            <summary>
            Gets the task instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskExecutionHost._UNITTESTONLY_TaskFactoryWrapper">
            <summary>
            FOR UNIT TESTING ONLY
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskExecutionHost.AppDomainSetup">
            <summary>
            App domain configuration.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskExecutionHost.IsOutOfProc">
            <summary>
            Whether or not this is out-of-proc.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Dispose">
            <summary>
            Implementation of IDisposable
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#InitializeForTask(Microsoft.Build.Framework.IBuildEngine2,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Execution.ProjectInstance,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Framework.ITaskHost,System.Boolean,System.AppDomainSetup,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Initialize to run a specific task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#FindTask(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Ask the task host to find its task in the registry and get it ready for initializing the batch
            </summary>
            <returns>True if the task is found in the task registry false if otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#InitializeForBatch(Microsoft.Build.BackEnd.Logging.TaskLoggingContext,Microsoft.Build.BackEnd.ItemBucket,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Initialize to run a specific batch of the current task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#SetTaskParameters(System.Collections.Generic.IDictionary{System.String,System.Tuple{System.String,Microsoft.Build.Construction.ElementLocation}})">
            <summary>
            Sets all of the specified parameters on the task.
            </summary>
            <param name="parameters">The name/value pairs for the parameters.</param>
            <returns>True if the parameters were set correctly, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#GatherTaskOutputs(System.String,Microsoft.Build.Construction.ElementLocation,System.Boolean,System.String)">
            <summary>
            Retrieve the outputs from the task.
            </summary>
            <returns>True of the outputs were gathered successfully, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#CleanupForBatch">
            <summary>
            Cleans up after running a batch.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#CleanupForTask">
            <summary>
            Cleans up after running the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft#Build#BackEnd#ITaskExecutionHost#Execute">
            <summary>
            Executes the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Dispose(System.Boolean)">
            <summary>
            Implementation of IDisposable
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.CleanupCancellationToken">
            <summary>
            Disposes of the cancellation token registration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.Cancel">
            <summary>
            Cancels the currently-running task.
            Kick off a task to wait for the currently-running task and log the wait message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.SetTaskItemParameter(Microsoft.Build.Framework.TaskPropertyInfo,Microsoft.Build.Framework.ITaskItem)">
            <summary>
            Called on the local side.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.SetValueParameter(Microsoft.Build.Framework.TaskPropertyInfo,System.Type,System.String)">
            <summary>
            Called on the local side.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.SetParameterArray(Microsoft.Build.Framework.TaskPropertyInfo,System.Type,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectItemInstance.TaskItem},Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Called on the local side.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.RecordItemForDisconnectIfNecessary(Microsoft.Build.Execution.ProjectItemInstance.TaskItem)">
            <summary>
            Remember this TaskItem so that we can disconnect it when this Task has finished executing
            Only if we're passing TaskItems to another AppDomain is this necessary. This call
            Will make that determination for you.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.GetItemOutputs(Microsoft.Build.Framework.TaskPropertyInfo)">
            <summary>
            Gets the outputs (as an array of ITaskItem) from the specified output parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.GetValueOutputs(Microsoft.Build.Framework.TaskPropertyInfo)">
            <summary>
            Gets the outputs (as an array of string values) from the specified output parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.FindTaskInRegistry(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Given the task name, this method tries to find the task. It uses the following search order:
            1) checks the tasks declared by the project, searching by exact name and task identity parameters
            2) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by exact name and task identity parameters
            3) checks the tasks declared by the project, searching by fuzzy match (missing namespace, etc.) and task identity parameters
            4) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by fuzzy match (missing namespace, etc.) and task identity parameters
            5) 1-4 again in order without the task identity parameters, to gather additional information for the user (if the task identity 
               parameters don't match, it is an error, but at least we can return them a more useful error in this case than just "could not 
               find task")
            
            The search ordering is meant to reduce the number of assemblies we scan, because loading assemblies can be expensive.
            The tasks and assemblies declared by the project are scanned first, on the assumption that if the project declared
            them, they are likely used.
            
            If the set of task identity parameters are defined, only tasks that match that identity are chosen. 
            </summary>
            <returns>The Type of the task, or null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.InstantiateTask(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Instantiates the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.SetTaskParameter(System.String,System.String,Microsoft.Build.Construction.ElementLocation,System.Boolean,System.Boolean@)">
            <summary>
            Set the specified parameter based on its type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.InitializeTaskScalarParameter(Microsoft.Build.Framework.TaskPropertyInfo,System.Type,System.String,Microsoft.Build.Construction.ElementLocation,System.Boolean@)">
            <summary>
            Given an instantiated task, this helper method sets the specified scalar parameter based on its type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.InitializeTaskVectorParameter(Microsoft.Build.Framework.TaskPropertyInfo,System.Type,System.String,Microsoft.Build.Construction.ElementLocation,System.Boolean,System.Boolean@)">
             <summary>
             Given an instantiated task, this helper method sets the specified vector parameter. Vector parameters can be composed
             of multiple item vectors. The semicolon is the only separator allowed, and white space around the semicolon is
             ignored. Any item separator strings are not allowed, and embedded item vectors are not allowed.
             </summary>
             <remarks>This method is marked "internal" for unit-testing purposes only -- it should be "private" ideally.</remarks>
             <example>
             If @(CPPFiles) is a vector for the files a.cpp and b.cpp, and @(IDLFiles) is a vector for the files a.idl and b.idl:
            
                 "@(CPPFiles)"                               converts to     { a.cpp, b.cpp }
            
                 "@(CPPFiles); c.cpp; @(IDLFiles); c.idl"    converts to     { a.cpp, b.cpp, c.cpp, a.idl, b.idl, c.idl }
            
                 "@(CPPFiles,';')"                           converts to     &lt;error&gt;
            
                 "xxx@(CPPFiles)xxx"                         converts to     &lt;error&gt;
             </example>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.InternalSetTaskParameter(Microsoft.Build.Framework.TaskPropertyInfo,System.Collections.IList)">
            <summary>
            Variation to handle arrays, to help with logging the parameters.
            </summary>
            <remarks>
            Logging currently enabled only by an env var.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.InternalSetTaskParameter(Microsoft.Build.Framework.TaskPropertyInfo,System.Object)">
            <summary>
            Given an instantiated task, this helper method sets the specified parameter
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.GatherTaskItemOutputs(System.Boolean,System.String,Microsoft.Build.Framework.ITaskItem[],Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Gets task item outputs
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.GatherArrayStringAndValueOutputs(System.Boolean,System.String,System.String[],Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Gather task outputs in array form
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.GetNamesOfPropertiesWithRequiredAttribute">
            <summary>
            Finds all the task properties that are required.
            Returns them as keys in a dictionary.
            </summary>
            <returns>Gets a list of properties which are required.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskExecutionHost.DisplayCancelWaitMessage">
            <summary>
            Show a message that cancel has not yet finished.
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.AssemblyTaskFactory">
            <summary>
            The assembly task factory is used to wrap and construct tasks which are from .net assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.AssemblyTaskFactory._typeLoader">
            <summary>
            The type loader to load types which derrive from ITask or ITask2
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.AssemblyTaskFactory._taskName">
            <summary>
            Name of the task wrapped by the task factory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.AssemblyTaskFactory._loadedType">
            <summary>
            The loaded type (type, assembly name / file) of the task wrapped by the factory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.AssemblyTaskFactory._tasksAndAppDomains">
            <summary>
            A cache of tasks and the AppDomains they are loaded in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.AssemblyTaskFactory._factoryIdentityParameters">
            <summary>
             the set of parameters owned by this particular task host
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.AssemblyTaskFactory._taskHostFactoryExplicitlyRequested">
            <summary>
            Tracks whether, in the UsingTask invocation, we were specifically asked to use 
            the task host.  If so, that overrides all other concerns, and we will launch 
            the task host even if the requested runtime / architecture match that of the 
            current MSBuild process. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.AssemblyTaskFactory._taskLoggingContext">
            <summary>
            Need to store away the taskloggingcontext used by CreateTaskInstance so that 
            TaskLoader will be able to call back with errors.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.BackEnd.AssemblyTaskFactory"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.AssemblyTaskFactory.FactoryName">
            <summary>
            Name of the factory. In this case the name is the assembly name which is wrapped by the factory
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.AssemblyTaskFactory.TaskType">
            <summary>
            Gets the type of task this factory creates.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.Initialize(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Initializes this factory for instantiating tasks with a particular inline task block.
            </summary>
            <param name="taskName">Name of the task.</param>
            <param name="parameterGroup">The parameter group.</param>
            <param name="taskBody">The task body.</param>
            <param name="taskFactoryLoggingHost">The task factory logging host.</param>
            <returns>A value indicating whether initialization was successful.</returns>
            <remarks>
            <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the factory can be asked
            whether or not task names can be created by the factory.</para>
            <para>
            The taskFactoryLoggingHost will log messages in the context of the target where the task is first used.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.Initialize(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Initializes this factory for instantiating tasks with a particular inline task block and a set of UsingTask parameters.
            </summary>
            <param name="taskName">Name of the task.</param>
            <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks, 
            such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This 
            is the set of parameters that was set on the UsingTask using e.g. the UsingTask Runtime and Architecture parameters.</param>
            <param name="parameterGroup">The parameter group.</param>
            <param name="taskBody">The task body.</param>
            <param name="taskFactoryLoggingHost">The task factory logging host.</param>
            <returns>A value indicating whether initialization was successful.</returns>
            <remarks>
            <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the 
            factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2, 
            this Initialize method will be called in place of ITaskFactory.Initialize.</para>
            <para>
            The taskFactoryLoggingHost will log messages in the context of the target where the task is first used.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.GetTaskParameters">
            <summary>
            Get a list of parameters for the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine)">
            <summary>
            Create an instance of the task to be used.
            The task factory logging host will log messages in the context of the task.
            </summary>
            <param name="taskFactoryLoggingHost">
            The task factory logging host will log messages in the context of the task.
            </param>
            <returns>
            The generated task, or <c>null</c> if the task failed to be created.
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Create an instance of the task to be used.
            </summary>
            <param name="taskFactoryLoggingHost">
            The task factory logging host will log messages in the context of the task.
            </param>
            <param name="taskIdentityParameters">
            Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.  
            The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was 
            set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.  
            </param>
            <remarks>
            If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.  
            </remarks>
            <returns>
            The generated task, or <c>null</c> if the task failed to be created.
            </returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask)">
            <summary>
            Cleans up any context or state that may have been built up for a given task.
            </summary>
            <param name="task">The task to clean up.</param>
            <remarks>
            For many factories, this method is a no-op.  But some factories may have built up
            an AppDomain as part of an individual task instance, and this is their opportunity
            to shutdown the AppDomain.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.InitializeFactory(Microsoft.Build.Shared.AssemblyLoadInfo,System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Framework.TaskPropertyInfo},System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation,System.String)">
            <summary>
            Initialize the factory from the task registry
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.CreateTaskInstance(Microsoft.Build.Construction.ElementLocation,Microsoft.Build.BackEnd.Logging.TaskLoggingContext,Microsoft.Build.BackEnd.IBuildComponentHost,System.Collections.Generic.IDictionary{System.String,System.String},System.AppDomainSetup,System.Boolean)">
            <summary>
            Create an instance of the wrapped ITask for a batch run of the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.TaskNameCreatableByFactory(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Is the given task name able to be created by the task factory. In the case of an assembly task factory 
            this question is answered by checking the assembly wrapped by the task factory to see if it exists. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.VerifyThrowIdentityParametersValid(System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.Shared.IElementLocation,System.String,System.String,System.String)">
            <summary>
            Validates the given set of parameters, logging the appropriate errors as necessary. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.TaskIdentityParametersMatchFactory(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Given the set of parameters that are set to the factory, and the set of parameters coming from the task invocation that we're searching for 
            a matching record to, determine whether the parameters match this record.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.MergeTaskFactoryParameterSets(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Given a set of task parameters from the UsingTask and from the task invocation, generate a dictionary that combines the two, or throws if the merge
            is impossible (we shouldn't ever get to this point if it is ...)
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.TaskHostParametersMatchCurrentProcess(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Returns true if the provided set of task host parameters matches the current process, 
            and false otherwise. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.AssemblyTaskFactory.ErrorLoggingDelegate(System.String,System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            Log errors from TaskLoader. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskHostTask">
            <summary>
            The wrapper task for tasks that wish to take advantage of the 
            task host factory feature.  Generated by AssemblyTaskFactory
            when it wants to run the loaded task in the task host. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._buildEngine">
            <summary>
            The IBuildEngine callback object.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._hostObject">
            <summary>
            The host object that can be passed to this task.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskLoggingContext">
            <summary>
            Logging context for logging errors / issues 
            encountered in the TaskHostTask itself. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskLocation">
            <summary>
            Location of the task in the project file. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._buildComponentHost">
            <summary>
             The provider for the task host nodes. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._packetFactory">
            <summary>
            The packet factory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._packetReceivedEvent">
            <summary>
            The event which is set when we receive packets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._receivedPackets">
            <summary>
            The packet that is the end result of the task host task execution process
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskHostParameters">
            <summary>
            The set of parameters used to decide which host to launch.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskType">
            <summary>
            The type of the task that we are wrapping.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._appDomainSetup">
            <summary>
            The AppDomainSetup we'll want to apply to the AppDomain that we may 
            want to load the OOP task into. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._requiredContext">
            <summary>
            The task host context of the task host we're launching -- used to 
            communicate with the task host. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._connectedToTaskHost">
            <summary>
            True if currently connected to the task host; false otherwise. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskHostProvider">
            <summary>
            The provider for task host nodes. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskHostLock">
            <summary>
            Lock object to serialize access to the task host. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskCancelled">
            <summary>
            Keeps track of whether the wrapped task has had cancel called against it. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._setParameters">
            <summary>
            The set of parameters that has been set to this wrapped task -- save them 
            here so that we can forward them on to the task host. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskHostTask._taskExecutionSucceeded">
            <summary>
            Did the task succeed? 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.#ctor(Microsoft.Build.Shared.IElementLocation,Microsoft.Build.BackEnd.Logging.TaskLoggingContext,Microsoft.Build.BackEnd.IBuildComponentHost,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.Shared.LoadedType,System.AppDomainSetup)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTask.BuildEngine">
            <summary>
            THe IBuildEngine callback object
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskHostTask.HostObject">
            <summary>
            The host object that can be passed to this task.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo,System.Object)">
            <summary>
            Sets the requested task parameter to the requested value. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo)">
            <summary>
            Returns the value of the requested task parameter
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.Cancel">
            <summary>
            Cancels the currently executing task
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.Execute">
            <summary>
            Executes the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers the specified handler for a particular packet type.
            </summary>
            <param name="packetType">The packet type.</param>
            <param name="factory">The factory for packets of the specified type.</param>
            <param name="handler">The handler to be called when packets of the specified type are received.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.
            </summary>
            <param name="packetType">The packet type.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Takes a serializer, deserializes the packet and routes it to the appropriate handler.
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packetType">The packet type.</param>
            <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes the specified packet
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packet">The packet to route.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            This method is invoked by the NodePacketRouter when a packet is received and is intended for
            this recipient.
            </summary>
            <param name="node">The node from which the packet was received.</param>
            <param name="packet">The packet.</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.Cleanup">
            <summary>
            Called by TaskHostFactory to let the task know that if it needs to do any additional cleanup steps, 
            now would be the time.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.HandlePacket(Microsoft.Build.BackEnd.INodePacket,System.Boolean@)">
            <summary>
            Handles the packets received from the task host. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.HandleTaskHostTaskComplete(Microsoft.Build.BackEnd.TaskHostTaskComplete)">
            <summary>
            Task completed executing in the task host
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.HandleNodeShutdown(Microsoft.Build.BackEnd.NodeShutdown)">
            <summary>
            The task host node failed for some reason 
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.HandleLoggedMessage(Microsoft.Build.BackEnd.LogMessagePacket)">
            <summary>
            Handle logged messages from the task host.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskHostTask.LogErrorUnableToCreateTaskHost(Microsoft.Build.Internal.TaskHostContext,System.String,System.String,Microsoft.Build.BackEnd.NodeFailedToLaunchException)">
            <summary>
            Since we log that we weren't able to connect to the task host in a couple of different places,
            extract it out into a separate method. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.BackEnd.TaskFactoryLoggingHost">
            <summary>
            The host allows task factories access to method to allow them to log message during the construction of the task factories.
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskFactoryLoggingHost._elementLocation">
            <summary>
            Location of the task node in the original file
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskFactoryLoggingHost._loggingContext">
            <summary>
            The task factory logging context
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskFactoryLoggingHost._isRunningWithMultipleNodes">
            <summary>
            Is the system running in multi-process mode and requires events to be serializable
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskFactoryLoggingHost._sponsor">
            <summary>
            A client sponsor is a class
            which will respond to a lease renewal request and will
            increase the lease time allowing the object to stay in memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.BackEnd.TaskFactoryLoggingHost._activeProxy">
            <summary>
            True if the task connected to this proxy is alive
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.#ctor(System.Boolean,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.BackEnd.Logging.BuildLoggingContext)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.IsRunningMultipleNodes">
            <summary>
            Returns true in the multiproc case
            REVIEW: Should this mean the same thing in the distributed build case?  If we have 
            a build which happens to be on a distributed cluster, but the build manager has only
            alotted a single machine to this build, is this true?  Because the build manager
            could later decide to add more nodes to this build.
            UNDONE: This means we are building with multiple processes. If we are building on 
            one machine then I think the maxcpu-count is still 1. In my mind this means multiple nodes either distributed or on the same machine.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.ContinueOnError">
            <summary>
            Reflects the value of the ContinueOnError attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.LineNumberOfTaskNode">
            <summary>
            The line number this task is on
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.ColumnNumberOfTaskNode">
            <summary>
            The column number this task is on
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.ProjectFileOfTaskNode">
            <summary>
            The project file this task is in.
            Typically this is an imported .targets file.
            Unfortunately the interface has shipped with a poor name, so we cannot change it.
            </summary>
        </member>
        <member name="P:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.LoggingContext">
            <summary>
            Sets or retrieves the logging context
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Logs an error event for the current task
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Logs a warning event for the current task
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Logs a message event for the current task
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Logs a custom event for the current task
            </summary>
            <param name="e">The event args</param>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.BuildProjectFile(System.String,System.String[],System.Collections.IDictionary,System.Collections.IDictionary)">
            <summary>
            Builds a single project file
            </summary>
            <param name="projectFileName">The project file name</param>
            <param name="targetNames">The set of targets to build.</param>
            <param name="globalProperties">The global properties to use</param>
            <param name="targetOutputs">The outputs from the targets</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.InitializeLifetimeService">
            <summary>
            InitializeLifetimeService is called when the remote object is activated. 
            This method will determine how long the lifetime for the object will be.
            </summary>
            <returns>The lease object to control this object's lifetime.</returns>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.MarkAsInactive">
            <summary>
            Indicates to the TaskHost that it is no longer needed.
            Called by TaskBuilder when the task using the EngineProxy is done.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.IsEventSerializable(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Determine if the event is serializable. If we are running with multiple nodes we need to make sure the logging events are serializable. If not
            we need to log a warning.
            </summary>
        </member>
        <member name="M:Microsoft.Build.BackEnd.TaskFactoryLoggingHost.VerifyActiveProxy">
            <summary>
            Verify the task host is active or not
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.Traits">
            <summary>
                Represents toggleable features of the MSBuild engine
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.UseLazyWildCardEvaluation">
            <summary>
            Do not expand wildcards that match a certain pattern
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.CacheFileExistence">
            <summary>
            Cache file existence for the entire process
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.UseSimpleInternConcurrency">
            <summary>
            Eliminate locking in OpportunisticIntern at the expense of memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.MSBuildCacheFileEnumerations">
            <summary>
            Cache wildcard expansions for the entire process
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.EnableRestoreFirst">
            <summary>
            Enable restore first functionality in MSBuild.exe
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.CopyTaskParallelism">
            <summary>
            Setting the associated environment variable to 1 restores the pre-15.8 single
            threaded (slower) copy behavior. Zero implies Int32.MaxValue, less than zero
            (default) uses the empirical default in Copy.cs, greater than zero can allow
            perf tuning beyond the defaults chosen.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.EmitSolutionMetaproj">
            <summary>
            Instruct MSBuild to write out the generated "metaproj" file to disk when building a solution file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.LogPropertyFunctionsRequiringReflection">
            <summary>
            Log statistics about property functions which require reflection
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.Traits.LogPropertyTracking">
            <summary>
            Log property tracking information.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DoNotSendDeferredMessagesToBuildManager">
            <summary>
            Do not log command line information to build loggers. Useful to unbreak people who parse the msbuild log and who are unwilling to change their code.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DoNotExpandQualifiedMetadataInUpdateOperation">
            <summary>
            https://github.com/microsoft/msbuild/pull/4975 started expanding qualified metadata in Update operations. Before they'd expand to empty strings.
            This escape hatch turns back the old empty string behavior.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.EvaluateElementsWithFalseConditionInProjectEvaluation">
            <summary>
            Force whether Project based evaluations should evaluate elements with false conditions.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.AlwaysUseContentTimestamp">
            <summary>
            Always use the accurate-but-slow CreateFile approach to timestamp extraction.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.TruncateTaskInputs">
            <summary>
            Truncate task inputs when logging them. This can reduce memory pressure
            at the expense of log usefulness.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches._logProjectImports">
            <summary>
            Emit events for project imports.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.EscapeHatches.LogProjectImports">
            <summary>
            Emit events for project imports.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.CacheAssemblyInformation">
            <summary>
            Read information only once per file per ResolveAssemblyReference invocation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime">
            <summary>
            Never use the slow (but more accurate) CreateFile approach to timestamp extraction.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.ReuseTaskHostNodes">
            <summary>
            Allow node reuse of TaskHost nodes. This results in task assemblies locked past the build lifetime, preventing them from being rebuilt if custom tasks change, but may improve performance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.IgnoreEmptyImports">
            <summary>
            Whether or not to ignore imports that are considered empty.  See ProjectRootElement.IsEmptyXmlFile() for more info.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.IgnoreTreatAsLocalProperty">
            <summary>
            Whether to to respect the TreatAsLocalProperty parameter on the Project tag. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DebugEvaluation">
            <summary>
            Whether to write information about why we evaluate to debug output.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.WarnOnUninitializedProperty">
            <summary>
            Whether to warn when we set a property for the first time, after it was previously used.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseCaseSensitiveItemNames">
            <summary>
            MSBUILDUSECASESENSITIVEITEMNAMES is an escape hatch for the fix
            for https://github.com/Microsoft/msbuild/issues/1751. It should
            be removed (permanently set to false) after establishing that
            it's unneeded (at least by the 16.0 timeframe).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableLongPaths">
            <summary>
            Disable the use of paths longer than Windows MAX_PATH limits (260 characters) when running on a long path enabled OS.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableSdkResolutionCache">
            <summary>
            Disable the use of any caching when resolving SDKs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.DisableNuGetSdkResolver">
            <summary>
            Disable the NuGet-based SDK resolver.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.TargetPathForRelatedFiles">
            <summary>
            Don't delete TargetPath metadata from associated files found by RAR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseSingleLoadContext">
            <summary>
            Disable AssemblyLoadContext isolation for plugins.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseAutoRunWhenLaunchingProcessUnderCmd">
            <summary>
            Enables the user of autorun functionality in CMD.exe on Windows which is disabled by default in MSBuild.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.AvoidUnicodeWhenWritingToolTaskBatch">
            <summary>
            Disables switching codepage to UTF-8 after detection of characters that can't be represented in the current codepage.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout">
            <summary>
            Workaround for https://github.com/Microsoft/vstest/issues/1503.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.EscapeHatches.UseMinimalResxParsingInCoreScenarios">
            <summary>
            Use the original, string-only resx parsing in .NET Core scenarios.
            </summary>
            <remarks>
            Escape hatch for problems arising from https://github.com/microsoft/msbuild/pull/4420.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.Build.Utilities.SimpleVersion" -->
        <member name="T:Microsoft.Build.Execution.NodeEngineShutdownReason">
            <summary>
            Reasons for a node to shutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.NodeEngineShutdownReason.BuildComplete">
            <summary>
            The BuildManager sent a command instructing the node to terminate.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.NodeEngineShutdownReason.BuildCompleteReuse">
            <summary>
            The BuildManager sent a command instructing the node to terminate, but to restart for reuse.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.NodeEngineShutdownReason.ConnectionFailed">
            <summary>
            The communication link failed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.NodeEngineShutdownReason.Error">
            <summary>
            The NodeEngine caught an exception which requires the Node to shut down.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildManager">
            <summary>
            This class is the public entry point for executing builds.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager.s_staticSyncLock">
            <summary>
            The object used for thread-safe synchronization of static members.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._syncLock">
            <summary>
            The object used for thread-safe synchronization of BuildManager shared data and the Scheduler.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager.s_singletonInstance">
            <summary>
            The singleton instance for the BuildManager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager.s_nextBuildId">
            <summary>
            The next build id;
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager.s_nextBuildRequestConfigurationId">
            <summary>
            The next build request configuration ID to use.
            These must be unique across build managers, as they
            are used as part of cache file names, for example.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._configCache">
            <summary>
            The cache for build request configurations.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._resultsCache">
            <summary>
            The cache for build results.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._nodeManager">
            <summary>
            The object responsible for creating and managing nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._taskHostNodeManager">
            <summary>
            The object responsible for creating and managing task host nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._scheduler">
            <summary>
            The object which determines which projects to build, and where.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._nodeConfiguration">
            <summary>
            The node configuration to use for spawning new nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._threadException">
            <summary>
            Any exception which occurs on a logging thread will go here.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._activeNodes">
            <summary>
            Set of active nodes in the system.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._noNodesActiveEvent">
            <summary>
            Event signalled when all nodes have shutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._nodeIdToKnownConfigurations">
            <summary>
            Mapping of nodes to the configurations they know about.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._shuttingDown">
            <summary>
            Flag indicating if we are currently shutting down.  When set, we stop processing packets other than NodeShutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._buildManagerState">
            <summary>
            The current state of the BuildManager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._hostName">
            <summary>
            The name given to this BuildManager as the component host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._buildParameters">
            <summary>
            The parameters with which the build was started.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._buildSubmissions">
            <summary>
            The current pending and active submissions.
            </summary>
            <remarks>
            { submissionId, BuildSubmission }
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._graphBuildSubmissions">
            <summary>
            The current pending and active graph build submissions.
            </summary>
            <remarks>
            { submissionId, GraphBuildSubmission }
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._noActiveSubmissionsEvent">
            <summary>
            Event signalled when all build submissions are complete.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._overallBuildSuccess">
            <summary>
            The overall success of the build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._nextBuildSubmissionId">
            <summary>
            The next build submission id.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._unnamedProjectInstanceToNames">
            <summary>
            Mapping of unnamed project instances to the file names assigned to them.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._nextUnnamedProjectId">
            <summary>
            The next ID to assign to a project which has no name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._componentFactories">
            <summary>
            The build component factories.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._projectStartedEvents">
            <summary>
            Mapping of submission IDs to their first project started events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._acquiredProjectRootElementCacheFromProjectInstance">
            <summary>
            Whether a cache has been provided by a project instance, meaning
            we've acquired at least one build submission that included a project instance.
            Once that has happened, we use the provided one, rather than our default.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._projectStartedEventHandler">
            <summary>
            The project started event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._projectFinishedEventHandler">
            <summary>
            The project finished event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._loggingThreadExceptionEventHandler">
            <summary>
            The logging exception event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._legacyThreadingData">
            <summary>
            Legacy threading semantic data associated with this build manager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._workQueue">
            <summary>
            The worker queue.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._graphSchedulingCancellationSource">
            <summary>
            A cancellation token source used to cancel graph build scheduling
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._disposed">
            <summary>
            Flag indicating we have disposed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager._instantiationTimeUtc">
            <summary>
            When the BuildManager was created.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.#ctor">
            <summary>
            Creates a new unnamed build manager.
            Normally there is only one build manager in a process, and it is the default build manager.
            Access it with <see cref="P:Microsoft.Build.Execution.BuildManager.DefaultBuildManager"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.#ctor(System.String)">
            <summary>
            Creates a new build manager with an arbitrary distinct name.
            Normally there is only one build manager in a process, and it is the default build manager.
            Access it with <see cref="P:Microsoft.Build.Execution.BuildManager.DefaultBuildManager"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildManager.BuildManagerState">
            <summary>
            Enumeration describing the current state of the build manager.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager.BuildManagerState.Idle">
            <summary>
            This is the default state.  <see cref="M:Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters)"/> may be called in this state.  All other methods raise InvalidOperationException
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager.BuildManagerState.Building">
            <summary>
            This is the state the BuildManager is in after <see cref="M:Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters)"/> has been called but before <see cref="M:Microsoft.Build.Execution.BuildManager.EndBuild"/> has been called.
            <see cref="M:Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="M:Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="M:Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData)"/>, <see cref="M:Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData)"/>, and <see cref="M:Microsoft.Build.Execution.BuildManager.EndBuild"/> may be called in this state.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildManager.BuildManagerState.WaitingForBuildToComplete">
            <summary>
            This is the state the BuildManager is in after <see cref="M:Microsoft.Build.Execution.BuildManager.EndBuild"/> has been called but before all existing submissions have completed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.DefaultBuildManager">
            <summary>
            Gets the singleton instance of the Build Manager.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.SdkResolverService">
            <summary>
            Retrieves a hosted<see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> instance for resolving SDKs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.Microsoft#Build#BackEnd#IBuildComponentHost#LoggingService">
            <summary>
            Retrieves the logging service associated with a particular build
            </summary>
            <returns>The logging service.</returns>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.Microsoft#Build#BackEnd#IBuildComponentHost#Name">
            <summary>
            Retrieves the name of the component host.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.Microsoft#Build#BackEnd#IBuildComponentHost#BuildParameters">
            <summary>
            Retrieves the build parameters associated with this build.
            </summary>
            <returns>The build parameters.</returns>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.Microsoft#Build#BackEnd#IBuildComponentHost#LegacyThreadingData">
            <summary>
            Retrieves the LegacyThreadingData associated with a particular build manager
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildManager.DeferredBuildMessage">
            <summary>
            <see cref="M:Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters,System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.BuildManager.DeferredBuildMessage})"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters,System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.BuildManager.DeferredBuildMessage})">
            <summary>
            Prepares the BuildManager to receive build requests.
            </summary>
            <param name="parameters">The build parameters.  May be null.</param>
            <param name="deferredBuildMessages"> Build messages to be logged before the build begins. </param>
            <exception cref="T:System.InvalidOperationException">Thrown if a build is already in progress.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters)">
            <summary>
            Prepares the BuildManager to receive build requests.
            </summary>
            <param name="parameters">The build parameters.  May be null.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if a build is already in progress.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.CancelAllSubmissions">
            <summary>
            Cancels all outstanding submissions asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ResetCaches">
            <summary>
            Clears out all of the cached information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project)">
            <summary>
            This methods requests the BuildManager to find a matching ProjectInstance in its cache of previously-built projects.
            If none exist, a new instance will be created from the specified project.
            </summary>
            <param name="project">The Project for which an instance should be retrieved.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)">
            <summary>
            Submits a build request to the current build but does not start it immediately.  Allows the user to
            perform asynchronous execution or access the submission ID prior to executing the request.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData)">
            <summary>
            Submits a graph build request to the current build but does not start it immediately.  Allows the user to
            perform asynchronous execution or access the submission ID prior to executing the request.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)">
            <summary>
            Convenience method. Submits a build request and blocks until the results are available.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData)">
            <summary>
            Convenience method. Submits a graph build request and blocks until the results are available.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.EndBuild">
            <summary>
            Signals that no more build requests are expected (or allowed) and the BuildManager may clean up.
            </summary>
            <remarks>
            This call blocks until all currently pending requests are complete.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if there is no build in progress.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters,Microsoft.Build.Execution.BuildRequestData)">
            <summary>
            Convenience method.  Submits a lone build request and blocks until results are available.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if a build is already in progress.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters,Microsoft.Build.Graph.GraphBuildRequestData)">
            <summary>
            Convenience method.  Submits a lone graph build request and blocks until results are available.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if a build is already in progress.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ShutdownAllNodes">
            <summary>
            Shuts down all idle MSBuild nodes on the machine
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Dispose">
            <summary>
            Dispose of the build manager.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Microsoft#Build#BackEnd#INodePacketHandler#PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            This method is invoked by the NodePacketRouter when a packet is received and is intended for
            this recipient.
            </summary>
            <param name="node">The node from which the packet was received.</param>
            <param name="packet">The packet.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Microsoft#Build#BackEnd#IBuildComponentHost#RegisterFactory(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.BuildComponentFactoryDelegate)">
            <summary>
            Registers a factory which will be used to create the necessary components of the build
            system.
            </summary>
            <param name="componentType">The type which is created by this factory.</param>
            <param name="factory">The factory to be registered.</param>
            <remarks>
            It is not necessary to register any factories.  If no factory is registered for a specific kind
            of object, the system will use the default factory.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Microsoft#Build#BackEnd#IBuildComponentHost#GetComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Gets an instance of the specified component type from the host.
            </summary>
            <param name="type">The component type to be retrieved</param>
            <returns>The component</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ExecuteSubmission(Microsoft.Build.Execution.BuildSubmission,System.Boolean)">
            <summary>
            This method adds the request in the specified submission to the set of requests being handled by the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ExecuteSubmission(Microsoft.Build.Graph.GraphBuildSubmission)">
            <summary>
            This method adds the graph build request in the specified submission to the set of requests being handled by the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.LoadSolutionIntoConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration,Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Creates the traversal and metaproject instances necessary to represent the solution and populates new configurations with them.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.GetNextBuildId">
            <summary>
            Gets the next build id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.CreateConfiguration(Microsoft.Build.Evaluation.Project,Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Creates and optionally populates a new configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ProcessWorkQueue(System.Action)">
            <summary>
            Processes the next action in the work queue.
            </summary>
            <param name="action">The action to be processed.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ProcessPacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Processes a packet
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.HandleExecuteSubmissionException(Microsoft.Build.Execution.BuildSubmission,System.Exception)">
            <summary>
            Deals with exceptions that may be thrown as a result of ExecuteSubmission.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.HandleExecuteSubmissionException(Microsoft.Build.Graph.GraphBuildSubmission,System.Exception)">
            <summary>
            Deals with exceptions that may be thrown as a result of ExecuteSubmission.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.IssueBuildSubmissionToScheduler(Microsoft.Build.Execution.BuildSubmission,System.Boolean)">
            <summary>
            The submission is a top level build request entering the BuildManager.
            Sends the request to the scheduler with optional legacy threading semantics behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ShutdownConnectedNodesAsync(System.Boolean)">
            <summary>
            Asks the nodeManager to tell the currently connected nodes to shut down and sets a flag preventing all non-shutdown-related packets from
            being processed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.GetNextSubmissionId">
            <summary>
            Retrieves the next build submission id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ErrorIfState(Microsoft.Build.Execution.BuildManager.BuildManagerState,System.String)">
            <summary>
            Errors if the BuildManager is in the specified state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.RequireState(Microsoft.Build.Execution.BuildManager.BuildManagerState,System.String)">
            <summary>
            Verifies the BuildManager is in the required state, and throws a <see cref="T:System.InvalidOperationException"/> if it is not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.VerifyStateInternal(Microsoft.Build.Execution.BuildManager.BuildManagerState)">
            <summary>
            Verifies the BuildManager is in the required state, and throws a <see cref="T:System.InvalidOperationException"/> if it is not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Reset">
            <summary>
            Method called to reset the state of the system after a build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.GetNewConfigurationId">
            <summary>
            Returns a new, valid configuration id.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ResolveConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration,Microsoft.Build.BackEnd.BuildRequestConfiguration,System.Boolean)">
            <summary>
            Finds a matching configuration in the cache and returns it, or stores the configuration passed in.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.HandleNewRequest(System.Int32,Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Handles a new request coming from a node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.HandleConfigurationRequest(System.Int32,Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Handles a configuration request coming from a node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.HandleResult(System.Int32,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Handles a build result coming from a node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.HandleNodeShutdown(System.Int32,Microsoft.Build.BackEnd.NodeShutdown)">
            <summary>
            Handles the NodeShutdown packet
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.CheckForActiveNodesAndCleanUpSubmissions">
            <summary>
            If there are no more active nodes, cleans up any remaining submissions.
            </summary>
            <remarks>
            Must only be called from within the sync lock.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.PerformSchedulingActions(System.Collections.Generic.IEnumerable{Microsoft.Build.BackEnd.ScheduleResponse})">
            <summary>
            Carries out the actions specified by the scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ReportResultsToSubmission(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Completes a submission using the specified overall results.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ReportResultsToSubmission(Microsoft.Build.Graph.GraphBuildResult)">
            <summary>
            Completes a submission using the specified overall results.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.CheckSubmissionCompletenessAndRemove(Microsoft.Build.Execution.BuildSubmission)">
            <summary>
            Determines if the submission is fully completed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.CheckSubmissionCompletenessAndRemove(Microsoft.Build.Graph.GraphBuildSubmission)">
            <summary>
            Determines if the submission is fully completed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.GetNodeConfiguration">
            <summary>
            Retrieves the configuration structure for a node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.OnThreadException(System.Exception)">
            <summary>
            Handler for thread exceptions (logging thread, communications thread).  This handler will only get called if the exception did not previously
            get handled by a node exception handlers (for instance because the build is complete for the node.)  In this case we
            get the exception and will put it into the OverallBuildResult so that the host can see what happened.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.OnProjectFinished(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Raised when a project finished logging message has been processed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.OnProjectStarted(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Raised when a project started logging message is about to be processed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.CreateLoggingService(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},System.Collections.Generic.ISet{System.String},System.Collections.Generic.ISet{System.String})">
            <summary>
            Creates a logging service around the specified set of loggers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ExpectPacketType``1(Microsoft.Build.BackEnd.INodePacket,Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Ensures that the packet type matches the expected type
            </summary>
            <typeparam name="I">The instance-type of packet being expected</typeparam>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.SetOverallResultIfWarningsAsErrors(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Sets the overall result of a build only if the user had specified /warnaserror and there were any errors.
            This ensures the old behavior stays intact where builds could succeed even if a failure was logged.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.ShutdownLoggingService(Microsoft.Build.BackEnd.Logging.ILoggingService)">
            <summary>
             Shutdown the logging service
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.Dispose(System.Boolean)">
            <summary>
            Dispose implementation
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildManager.NullLogger">
            <summary>
            The logger registered to the logging service when no other one is.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.NullLogger.Verbosity">
            <summary>
            The logger verbosity.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildManager.NullLogger.Parameters">
            <summary>
            The logger parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.NullLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Initialize.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildManager.NullLogger.Shutdown">
            <summary>
            Shutdown.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildParameters">
            <summary>
            This class represents all of the settings which must be specified to start a build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.DefaultThreadStackSize">
            <summary>
            The default thread stack size for threads owned by MSBuild.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.DefaultEndpointShutdownTimeout">
            <summary>
            The timeout for endpoints to shut down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.DefaultEngineShutdownTimeout">
            <summary>
            The timeout for the engine to shutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.DefaultLoggingThreadShutdownTimeout">
            <summary>
            The shutdown timeout for the logging thread.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.DefaultRequestBuilderShutdownTimeout">
            <summary>
            The shutdown timeout for the request builder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.DefaultIdleRequestBuilderLimit">
            <summary>
            The maximum number of idle request builders to retain before we start discarding them.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_startupDirectory">
            <summary>
            The startup directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_warnOnUninitializedProperty">
            <summary>
            Indicates whether we should warn when a property is uninitialized when it is used.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_dumpOpportunisticInternStats">
            <summary>
            Indicates if we should dump string interning stats.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_debugExpansion">
            <summary>
            Indicates if we should debug the expander.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_keepDuplicateOutputs">
            <summary>
            Indicates if we should keep duplicate target outputs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_enableBuildPlan">
            <summary>
            Indicates if we should enable the build plan
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_idleRequestBuilderLimit">
            <summary>
            The maximum number of idle request builders we will retain.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters.s_msbuildExeKnownToExistAt">
            <summary>
            Location that msbuild.exe was last successfully found at.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._buildId">
            <summary>
            The build id
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._culture">
            <summary>
            The culture
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._defaultToolsVersion">
            <summary>
            The default tools version.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._enableNodeReuse">
            <summary>
            Flag indicating whether node reuse should be enabled.
            By default, it is enabled.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._buildProcessEnvironment">
            <summary>
            The original process environment.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._environmentProperties">
            <summary>
            The environment properties for the build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._forwardingLoggers">
            <summary>
            The forwarding logger records.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._globalProperties">
            <summary>
            The build-global properties.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._loggers">
            <summary>
            The loggers.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._maxNodeCount">
            <summary>
            The maximum number of nodes to use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._memoryUseLimit">
            <summary>
            The maximum amount of memory to use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._nodeExeLocation">
            <summary>
            The location of the node exe.  This is the full path including the exe file itself.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._onlyLogCriticalEvents">
            <summary>
            Flag indicating if we should only log critical events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._uiCulture">
            <summary>
            The UI culture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._toolsetProvider">
            <summary>
            The toolset provider
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._useSynchronousLogging">
            <summary>
            Should the logging service be done Synchronously when the number of cps's is 1
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._shutdownInProcNodeOnBuildFinish">
            <summary>
            Should the inprocess node be shutdown when the build finishes. By default this is false
            since visual studio needs to keep the inprocess node around after the build has finished.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._disableInProcNode">
            <summary>
            When true, the in-proc node will not be available.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._logTaskInputs">
            <summary>
            When true, the build should log task inputs to the loggers.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._logInitialPropertiesAndItems">
            <summary>
            When true, the build should log the input parameters.  Note - logging these is very expensive!
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildParameters._projectLoadSettings">
            <summary>
            The settings used to load the project under build
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.#ctor">
            <summary>
            Constructor for those who intend to set all properties themselves.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.#ctor(Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Creates BuildParameters from a ProjectCollection.
            </summary>
            <param name="projectCollection">The ProjectCollection from which the BuildParameters should populate itself.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for translation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.#ctor(Microsoft.Build.Execution.BuildParameters)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.BuildThreadPriority">
            <summary>
            Gets or sets the desired thread priority for building.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging">
            <summary>
            By default if the number of processes is set to 1 we will use Asynchronous logging. However if we want to use synchronous logging when the number of cpu's is set to 1
            this property needs to be set to true.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment">
            <summary>
            Gets the environment variables which were set when this build was created.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.Culture">
            <summary>
            The name of the culture to use during the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion">
            <summary>
            The default tools version for the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.DetailedSummary">
            <summary>
            When true, indicates that the build should emit a detailed summary at the end of the log.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.DisableInProcNode">
            <summary>
            When true, indicates the in-proc node should not be used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.LogTaskInputs">
            <summary>
            When true, indicates that the task parameters should be logged.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems">
            <summary>
            When true, indicates that the initial properties and items should be logged.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ResetCaches">
            <summary>
            Indicates that the build should reset the configuration and results caches.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.EnableNodeReuse">
            <summary>
            Flag indicating whether out-of-proc nodes should remain after the build and wait for further builds.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.EnvironmentProperties">
            <summary>
            Gets an immutable collection of environment properties.
            </summary>
            <remarks>
            This differs from the BuildProcessEnvironment in that there are certain MSBuild-specific properties which are added, and those environment variables which
            would not be valid as MSBuild properties are removed.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ForwardingLoggers">
            <summary>
            The collection of forwarding logger descriptions.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.GlobalProperties">
            <summary>
            Sets or retrieves an immutable collection of global properties.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.HostServices">
            <summary>
            Interface allowing the host to provide additional control over the build process.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics">
            <summary>
            Enables or disables legacy threading semantics
            </summary>
            <remarks>
            Legacy threading semantics indicate that if a submission is to be built
            only on the in-proc node and the submission is executed synchronously, then all of its
            requests will be built on the thread which invoked the build rather than a
            thread owned by the BuildManager.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.Loggers">
            <summary>
            The collection of loggers to use during the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.MaxNodeCount">
            <summary>
            The maximum number of nodes this build may use.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.MemoryUseLimit">
            <summary>
            The amount of memory the build should limit itself to using, in megabytes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.NodeExeLocation">
            <summary>
            The location of the build node executable.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents">
            <summary>
            Flag indicating if non-critical logging events should be discarded.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.WarningsAsErrors">
            <summary>
            A list of warnings to treat as errors.  To treat all warnings as errors, set this to an empty <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.WarningsAsMessages">
            <summary>
            A list of warnings to treat as low importance messages.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations">
            <summary>
            Locations to search for toolsets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.Toolsets">
            <summary>
            Returns all of the toolsets.
            </summary>
            <comments>
            toolsetProvider.Toolsets is already a readonly collection.
            </comments>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.UICulture">
            <summary>
            The name of the UI culture to use during the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment">
            <summary>
            Flag indicating if the operating environment such as the current directory and environment be saved and restored between project builds and task invocations.
            This should be set to false for any other build managers running in the system so that we do not have two build managers trampling on each others environment.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish">
            <summary>
            Shutdown the inprocess node when the build finishes. By default this is false
            since visual studio needs to keep the inprocess node around after the build finishes.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ThreadStackSize">
            <summary>
            Gets the internal msbuild thread stack size.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.EndpointShutdownTimeout">
            <summary>
            Gets the endpoint shutdown timeout.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.EngineShutdownTimeout">
            <summary>
            Gets or sets the engine shutdown timeout.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.IdleRequestBuilderLimit">
            <summary>
            Gets the maximum number of idle request builders to retain.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.LoggingThreadShutdownTimeout">
            <summary>
            Gets the logging thread shutdown timeout.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.RequestBuilderShutdownTimeout">
            <summary>
            Gets the request builder shutdown timeout.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.StartupDirectory">
            <summary>
            Gets the startup directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.EnableBuildPlan">
            <summary>
            Indicates whether the build plan is enabled or not.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.WarnOnUninitializedProperty">
            <summary>
            Indicates whether we should warn when a property is uninitialized when it is used.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.DumpOpportunisticInternStats">
            <summary>
            Indicates whether we should dump string interning stats
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.DebugExpansion">
            <summary>
            Indicates whether we should dump debugging information about the expander
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.KeepDuplicateOutputs">
            <summary>
            Indicates whether we should keep duplicate target outputs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.BuildId">
            <summary>
            Gets or sets the build id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.EnvironmentPropertiesInternal">
            <summary>
            Gets or sets the environment properties.
            </summary>
            <remarks>
            This is not the same as BuildProcessEnvironment.  See EnvironmentProperties.  These properties are those which
            are used during evaluation of a project, and exclude those properties which would not be valid MSBuild properties
            because they contain invalid characters (such as 'Program Files (x86)').
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.GlobalPropertiesInternal">
            <summary>
            Gets the global properties.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.NodeId">
            <summary>
            Gets or sets the node id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ToolsetProvider">
            <summary>
            Gets the toolset provider.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ProjectRootElementCache">
            <summary>
            The one and only project root element cache to be used for the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.AppDomainSetup">
            <summary>
            Information for configuring child AppDomains.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.IsOutOfProc">
            <summary>
             (for diagnostic use) Whether or not this is out of proc
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings">
            <nodoc/>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.Interactive">
            <summary>
            Gets or sets a value indicating if the build is allowed to interact with the user.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.IsolateProjects">
            <summary>
            Gets or sets a value indicating whether projects should build in isolation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles">
            <summary>
            Input cache files that MSBuild will use to read build results from.
            Setting this also turns on isolated builds.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile">
            <summary>
            Output cache file where MSBuild will write the contents of its build result caches during EndBuild.
            Setting this also turns on isolated builds.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.DiscardBuildResults">
            <summary>
            Determines whether MSBuild will save the results of builds after EndBuild to speed up future builds.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildParameters.LowPriority">
            <summary>
            Gets or sets a value indicating whether the build process should run as low priority.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.GetToolset(System.String)">
            <summary>
            Retrieves a toolset.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.Clone">
            <summary>
            Creates a clone of this BuildParameters object.  This creates a clone of the logger collections, but does not deep clone
            the loggers within.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Implementation of the serialization mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            The class factory for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.GetStaticBoolVariableOrDefault(System.String,System.Nullable{System.Boolean}@,System.Boolean)">
            <summary>
            Gets the value of a boolean environment setting which is not expected to change.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.GetStaticIntVariableOrDefault(System.String,System.Nullable{System.Int32}@,System.Int32)">
            <summary>
            Gets the value of an integer environment variable, or returns the default if none is set or it cannot be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.Initialize(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Evaluation.ProjectRootElementCacheBase,Microsoft.Build.Evaluation.ToolsetProvider)">
            <summary>
            Centralization of the common parts of construction.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.EnsureToolsets">
            <summary>
            Loads the toolsets if we don't have them already.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.FindMSBuildExe">
            <summary>
            This method determines where MSBuild.Exe is and sets the NodeExePath to that by default.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildParameters.CheckMSBuildExeExistsAt(System.String)">
            <summary>
            Helper to avoid doing an expensive disk check for MSBuild.exe when
            we already checked in a previous build.
            This File.Exists otherwise can show up in profiles when there's a lot of
            design time builds going on.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildSubmissionCompleteCallback">
            <summary>
            A callback used to receive notification that a build has completed.
            </summary>
            <remarks>
            When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signalled and the OverallBuildResult will be valid.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildSubmission">
            <summary>
            A BuildSubmission represents an build request which has been submitted to the BuildManager for processing.  It may be used to
            execute synchronous or asynchronous build requests and provides access to the results upon completion.
            </summary>
            <remarks>
            This class is thread-safe.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildSubmission._completionCallback">
            <summary>
            The callback to invoke when the submission is complete.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildSubmission._completionEvent">
            <summary>
            The completion event.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.LoggingCompleted">
            <summary>
            Flag indicating if logging is done.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildSubmission._completionInvoked">
            <summary>
            True if it has been invoked
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildSubmission._legacyThreadingSemantics">
            <summary>
            Flag indicating whether synchronous wait should support legacy threading semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildSubmission.#ctor(Microsoft.Build.Execution.BuildManager,System.Int32,Microsoft.Build.Execution.BuildRequestData,System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.BuildManager">
            <summary>
            The BuildManager with which this submission is associated.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.SubmissionId">
            <summary>
            An ID uniquely identifying this request from among other submissions within the same build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.AsyncContext">
            <summary>
            The asynchronous context provided to <see cref="M:Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback,System.Object)"/>, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.WaitHandle">
            <summary>
            A <see cref="T:System.Threading.WaitHandle"/> which will be signalled when the build is complete.  Valid after <see cref="M:Microsoft.Build.Execution.BuildSubmission.Execute"/> or <see cref="M:Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback,System.Object)"/> returns, otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.IsCompleted">
            <summary>
            Returns true if this submission is complete.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.BuildResult">
            <summary>
            The result of the build.  Valid only after WaitHandle has become signalled.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.BuildRequestData">
            <summary>
            The BuildRequestData being used for this submission.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildSubmission.BuildRequest">
            <summary>
            The build request for execution.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildSubmission.Execute">
            <summary>
            Starts the request and blocks until results are available.
            </summary>
            <exception cref="T:System.InvalidOperationException">The request has already been started or is already complete.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback,System.Object)">
            <summary>
            Starts the request asynchronously and immediately returns control to the caller.
            </summary>
            <exception cref="T:System.InvalidOperationException">The request has already been started or is already complete.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildSubmission.CompleteResults(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Sets the event signaling that the build is complete.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildSubmission.CompleteLogging(System.Boolean)">
            <summary>
            Indicates that all logging events for this submission are complete.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback,System.Object,System.Boolean)">
            <summary>
            Starts the request asynchronously and immediately returns control to the caller.
            </summary>
            <exception cref="T:System.InvalidOperationException">The request has already been started or is already complete.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildSubmission.CheckForCompletion">
            <summary>
            Determines if we are completely done with this submission and can complete it so the user may access results.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.LegacyThreadingData">
            <summary>
            This class represents the data which is used for legacy threading semantics for the build
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.LegacyThreadingData._legacyThreadingEventsById">
            <summary>
            Store the pair of start/end events used by a particular submission to track their ownership 
            of the legacy thread. 
            Item1: Start event, tracks when the submission has permission to start building. 
            Item2: End event, signalled when that submission is no longer using the legacy thread. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.LegacyThreadingData._mainThreadSubmissionId">
            <summary>
            The current submission id building on the main thread, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.LegacyThreadingData._instanceForMainThread">
            <summary>
            The instance to be used when the new request builder is started on the main thread.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.LegacyThreadingData._legacyThreadingEventsLock">
            <summary>
            Lock object for startNewRequestBuilderMainThreadEventsById, since it's possible for multiple submissions to be 
            submitted at the same time. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.LegacyThreadingData.InstanceForMainThread">
            <summary>
            The instance to be used when the new request builder is started on the main thread.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.LegacyThreadingData.MainThreadSubmissionId">
            <summary>
            The current submission id building on the main thread, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.LegacyThreadingData.RegisterSubmissionForLegacyThread(System.Int32)">
            <summary>
            Given a submission ID, assign it "start" and "finish" events to track its use of 
            the legacy thread.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.LegacyThreadingData.UnregisterSubmissionForLegacyThread(System.Int32)">
            <summary>
            This submission is completely done with the legacy thread, so unregister it 
            from the dictionary so that we don't leave random events lying around. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.LegacyThreadingData.GetStartRequestBuilderMainThreadEventForSubmission(System.Int32)">
            <summary>
            Given a submission ID, return the event being used to track when that submission is ready 
            to be executed on the legacy thread. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.LegacyThreadingData.GetLegacyThreadInactiveTask(System.Int32)">
            <summary>
            Given a submission ID, return the event being used to track when that submission is ready 
            to be executed on the legacy thread. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.LegacyThreadingData.SignalLegacyThreadStart(Microsoft.Build.BackEnd.RequestBuilder)">
            <summary>
            Signal that the legacy thread is starting work.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.LegacyThreadingData.SignalLegacyThreadEnd(System.Int32)">
            <summary>
            Signal that the legacy thread has finished its work.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.RequestedProjectState">
            <summary>
            Interface defining properties, items, and metadata of interest for a <see cref="T:Microsoft.Build.Execution.BuildRequestData"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.RequestedProjectState.PropertyFilters">
            <summary>
            Properties of interest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.RequestedProjectState.ItemFilters">
            <summary>
            Items and metadata of interest.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostObjectException.#ctor(System.String)">
            <summary>
            Creates an instance of this exception using the given message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostObjectException.#ctor(System.String,System.String,System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using projectFile, targetName, taskName and inner exception.
            Adds the inner exception's details to the exception message because most bug reporters don't bother
            to provide the inner exception details which is typically what we care about.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostObjectException.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates an instance of this exception using projectFile, targetName, taskName and message.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.RunningObjectTable">
            <summary>
            Wrapper for the COM Running Object Table.
            </summary>
            <remarks>
            See https://docs.microsoft.com/en-us/windows/desktop/api/objidl/nn-objidl-irunningobjecttable.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.RunningObjectTable.GetObject(System.String)">
            <summary>
            Attempts to retrieve an item from the ROT.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildRequestDataFlags">
            <summary>
            Flags providing additional control over the build request
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance">
            <summary>
            When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild">
            <summary>
            When this flag is present, the <see cref="T:Microsoft.Build.Execution.BuildResult"/> issued in response to this request will
            include <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState">
             <summary>
             When this flag is present and the project has previously been built on a node whose affinity is
             incompatible with the affinity this request requires, we will ignore the project state (but not
             target results) that were previously generated.
             </summary>
             <remarks>
             This usually is not desired behavior.  It is only provided for those cases where the client
             knows that the new build request does not depend on project state generated by a previous request.  Setting
             this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
             otherwise have to serialize the project state from one node to another, which may be
             expensive depending on how much data the project previously generated.
            
             This flag has no effect on target results, so if a previous request already built a target, the new
             request will not re-build that target (nor will any of the project state mutations which previously
             occurred as a consequence of building that target be re-applied.)
             </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild">
            <summary>
            When this flag is present, caches including the <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCacheBase"/> will be cleared
            after the build request completes.  This is used when the build request is known to modify a lot of
            state such as restoring packages or generating parts of the import graph.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets">
            <summary>
            When this flag is present, the top level target(s) in the build request will be skipped if those targets
            are not defined in the Project to build. This only applies to this build request (if another target calls
            the "missing target" at any other point this will still result in an error).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild">
            <summary>
            When this flag is present, the <see cref="T:Microsoft.Build.Execution.BuildResult"/> issued in response to this request will
            include a <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild"/> that includes ONLY the
            explicitly-requested properties, items, and metadata.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports">
            <summary>
            When this flag is present, projects loaded during build will ignore missing imports (<see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports"/> and <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports"/>).
            This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildRequestData">
            <summary>
            BuildRequestData encapsulates all of the data needed to submit a build request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String[])">
            <summary>
            Constructs a BuildRequestData for build requests based on project instances.
            </summary>
            <param name="projectInstance">The instance to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String[],Microsoft.Build.Execution.HostServices)">
            <summary>
            Constructs a BuildRequestData for build requests based on project instances.
            </summary>
            <param name="projectInstance">The instance to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String[],Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Constructs a BuildRequestData for build requests based on project instances.
            </summary>
            <param name="projectInstance">The instance to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
            <param name="flags">Flags controlling this build request.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String[],Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs a BuildRequestData for build requests based on project instances.
            </summary>
            <param name="projectInstance">The instance to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
            <param name="flags">Flags controlling this build request.</param>
            <param name="propertiesToTransfer">The list of properties whose values should be transferred from the project to any out-of-proc node.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String[],Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags,System.Collections.Generic.IEnumerable{System.String},Microsoft.Build.Execution.RequestedProjectState)">
            <summary>
            Constructs a BuildRequestData for build requests based on project instances.
            </summary>
            <param name="projectInstance">The instance to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
            <param name="flags">Flags controlling this build request.</param>
            <param name="propertiesToTransfer">The list of properties whose values should be transferred from the project to any out-of-proc node.</param>
            <param name="requestedProjectState">A <see cref="T:Microsoft.Build.Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String[],Microsoft.Build.Execution.HostServices)">
            <summary>
            Constructs a BuildRequestData for build requests based on project files.
            </summary>
            <param name="projectFullPath">The full path to the project file.</param>
            <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
            <param name="toolsVersion">The tools version to use for the build.  May be null.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use.  May be null.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String[],Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags,Microsoft.Build.Execution.RequestedProjectState)">
            <summary>
            Constructs a BuildRequestData for build requests based on project files.
            </summary>
            <param name="projectFullPath">The full path to the project file.</param>
            <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
            <param name="toolsVersion">The tools version to use for the build.  May be null.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use.  May be null.</param>
            <param name="flags">The <see cref="T:Microsoft.Build.Execution.BuildRequestDataFlags"/> to use.</param>
            <param name="requestedProjectState">A <see cref="T:Microsoft.Build.Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String[],Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Constructs a BuildRequestData for build requests based on project files.
            </summary>
            <param name="projectFullPath">The full path to the project file.</param>
            <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
            <param name="toolsVersion">The tools version to use for the build.  May be null.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use.  May be null.</param>
            <param name="flags">The <see cref="T:Microsoft.Build.Execution.BuildRequestDataFlags"/> to use.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildRequestData.#ctor(System.String[],Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Common constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.ProjectInstance">
            <summary>
            The actual project, in the case where the project doesn't come from disk.
            May be null.
            </summary>
            <value>The project instance.</value>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.ProjectFullPath">
            <summary>The project file.</summary>
            <value>The project file to be built.</value>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.TargetNames">
            <summary>
            The name of the targets to build.
            </summary>
            <value>An array of targets in the project to be built.</value>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.Flags">
            <summary>
            Extra flags for this BuildRequest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.GlobalProperties">
            <summary>
            The global properties to use.
            </summary>
            <value>The set of global properties to be used to build this request.</value>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.ExplicitlySpecifiedToolsVersion">
            <summary>
            The explicitly requested tools version to use.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.HostServices">
            <summary>
            Gets the HostServices object for this request.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.PropertiesToTransfer">
            <summary>
            Returns a list of properties to transfer out of proc for the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.RequestedProjectState">
            <summary>
            Returns the properties, items, and metadata that will be returned
            by this build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.ExplicitToolsVersionSpecified">
            <summary>
            Whether the tools version used originated from an explicit specification,
            for example from an MSBuild task or /tv switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildRequestData.GlobalPropertiesDictionary">
            <summary>
            Returns the global properties as a dictionary.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.OutOfProcNode">
            <summary>
            This class represents an implementation of INode for out-of-proc nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode.s_isOutOfProcNode">
            <summary>
            Whether the current appdomain has an out of proc node.
            For diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode.s_projectRootElementCacheBase">
            <summary>
            The one and only project root element cache to be used for the build
            on this out of proc node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._nodeEndpoint">
            <summary>
            The endpoint used to talk to the host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._savedEnvironment">
            <summary>
            The saved environment for the process.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._componentFactories">
            <summary>
            The component factories.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._buildParameters">
            <summary>
            The build system parameters.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._loggingService">
            <summary>
            The logging service.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._loggingContext">
            <summary>
            The node logging context.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._globalConfigCache">
            <summary>
            The global config cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._taskHostNodeManager">
            <summary>
            The global node manager
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._buildRequestEngine">
            <summary>
            The build request engine.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._packetFactory">
            <summary>
            The packet factory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._currentConfiguration">
            <summary>
            The current node configuration
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._receivedPackets">
            <summary>
            The queue of packets we have received but which have not yet been processed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._packetReceivedEvent">
            <summary>
            The event which is set when we receive packets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._shutdownEvent">
            <summary>
            The event which is set when we should shut down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._shutdownReason">
            <summary>
            The reason we are shutting down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._shutdownException">
            <summary>
            The exception, if any, which caused shutdown.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._debugCommunications">
            <summary>
            Flag indicating if we should debug communications or not.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._legacyThreadingData">
            <summary>
            Data for the use of LegacyThreading semantics.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.OutOfProcNode._sdkResolverService">
            <summary>
            The current <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#IBuildComponentHost#LoggingService">
            <summary>
            Get the logging service for a build.
            </summary>
            <returns>The logging service.</returns>
        </member>
        <member name="P:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#IBuildComponentHost#LegacyThreadingData">
            <summary>
            Retrieves the LegacyThreadingData associated with a particular build manager
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#IBuildComponentHost#Name">
            <summary>
            Retrieves the name of this component host.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#IBuildComponentHost#BuildParameters">
            <summary>
            Retrieves the build parameters for the current build.
            </summary>
            <returns>The build parameters.</returns>
        </member>
        <member name="P:Microsoft.Build.Execution.OutOfProcNode.IsOutOfProcNode">
            <summary>
            Whether the current appdomain has an out of proc node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Run(System.Exception@)">
            <summary>
            Starts up the node and processes messages until the node is requested to shut down.
            Assumes no node reuse.
            Assumes low priority is disabled.
            </summary>
            <param name="shutdownException">The exception which caused shutdown, if any.</param>
            <returns>The reason for shutting down.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Run(System.Boolean,System.Exception@)">
            <summary>
            Starts up the node and processes messages until the node is requested to shut down.
            Assumes low priority is disabled.
            </summary>
            <param name="enableReuse">Whether this node is eligible for reuse later.</param>
            <param name="shutdownException">The exception which caused shutdown, if any.</param>
            <returns>The reason for shutting down.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Run(System.Boolean,System.Boolean,System.Exception@)">
            <summary>
            Starts up the node and processes messages until the node is requested to shut down.
            </summary>
            <param name="enableReuse">Whether this node is eligible for reuse later.</param>
            <param name="lowPriority">Whether this node should be running with low priority.</param>
            <param name="shutdownException">The exception which caused shutdown, if any.</param>
            <returns>The reason for shutting down.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#IBuildComponentHost#RegisterFactory(Microsoft.Build.BackEnd.BuildComponentType,Microsoft.Build.BackEnd.BuildComponentFactoryDelegate)">
            <summary>
            Registers a factory with the component host.
            </summary>
            <param name="factoryType">The factory type to register.</param>
            <param name="factory">The factory method.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#IBuildComponentHost#GetComponent(Microsoft.Build.BackEnd.BuildComponentType)">
            <summary>
            Get a component from the host.
            </summary>
            <param name="type">The component type to get.</param>
            <returns>The component.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#INodePacketFactory#RegisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.NodePacketFactoryMethod,Microsoft.Build.BackEnd.INodePacketHandler)">
            <summary>
            Registers a packet handler.
            </summary>
            <param name="packetType">The packet type for which the handler should be registered.</param>
            <param name="factory">The factory used to create packets.</param>
            <param name="handler">The handler for the packets.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#INodePacketFactory#UnregisterPacketHandler(Microsoft.Build.BackEnd.NodePacketType)">
            <summary>
            Unregisters a packet handler.
            </summary>
            <param name="packetType">The type of packet for which the handler should be unregistered.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#INodePacketFactory#DeserializeAndRoutePacket(System.Int32,Microsoft.Build.BackEnd.NodePacketType,Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Deserializes and routes a packer to the appropriate handler.
            </summary>
            <param name="nodeId">The node from which the packet was received.</param>
            <param name="packetType">The packet type.</param>
            <param name="translator">The translator to use as a source for packet data.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#INodePacketFactory#RoutePacket(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Routes a packet to the appropriate handler.
            </summary>
            <param name="nodeId">The node id from which the packet was received.</param>
            <param name="packet">The packet to route.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.Microsoft#Build#BackEnd#INodePacketHandler#PacketReceived(System.Int32,Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Called when a packet has been received.
            </summary>
            <param name="node">The node from which the packet was received.</param>
            <param name="packet">The packet.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.OnRequestComplete(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult)">
            <summary>
            Event handler for the BuildEngine's OnRequestComplete event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.OnNewRequest(Microsoft.Build.BackEnd.BuildRequestBlocker)">
            <summary>
            Event handler for the BuildEngine's OnNewRequest event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.OnNewConfigurationRequest(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Event handler for the BuildEngine's OnNewConfigurationRequest event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.OnLoggingThreadException(System.Exception)">
            <summary>
            Event handler for the LoggingService's OnLoggingThreadException event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.OnEngineException(System.Exception)">
            <summary>
            Event handler for the BuildEngine's OnEngineException event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandleShutdown(System.Exception@)">
            <summary>
            Perform necessary actions to shut down the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.CleanupCaches">
            <summary>
            Clears all the caches used during the build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.OnLinkStatusChanged(Microsoft.Build.BackEnd.INodeEndpoint,Microsoft.Build.BackEnd.LinkStatus)">
            <summary>
            Event handler for the node endpoint's LinkStatusChanged event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.SendPacket(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Callback for logging packets to be sent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandlePacket(Microsoft.Build.BackEnd.INodePacket)">
            <summary>
            Dispatches the packet to the correct handler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandleBuildRequest(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Handles the BuildRequest packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandleBuildRequestConfiguration(Microsoft.Build.BackEnd.BuildRequestConfiguration)">
            <summary>
            Handles the BuildRequestConfiguration packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandleBuildRequestConfigurationResponse(Microsoft.Build.BackEnd.BuildRequestConfigurationResponse)">
            <summary>
            Handles the BuildRequestConfigurationResponse packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandleBuildRequestUnblocker(Microsoft.Build.BackEnd.BuildRequestUnblocker)">
            <summary>
            Handles the BuildResult packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandleNodeConfiguration(Microsoft.Build.BackEnd.NodeConfiguration)">
            <summary>
            Handles the NodeConfiguration packet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.OutOfProcNode.HandleNodeBuildComplete(Microsoft.Build.BackEnd.NodeBuildComplete)">
            <summary>
            Handles the NodeBuildComplete packet.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildResultCode">
            <summary>
            Overall results for targets and requests
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResultCode.Success">
            <summary>
            The target or request was a complete success.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResultCode.Failure">
            <summary>
            The target or request failed in some way.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.BuildResult">
            <summary>
            Contains the current results for all of the targets which have produced results for a particular configuration.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._submissionId">
            <summary>
            The submission with which this result is associated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._configurationId">
            <summary>
            The configuration ID with which this result is associated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._globalRequestId">
            <summary>
            The global build request ID for which these results are intended.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._parentGlobalRequestId">
            <summary>
            The global build request ID which issued the request leading to this result.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._nodeRequestId">
            <summary>
            The build request ID on the originating node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._initialTargets">
            <summary>
            The first build request to generate results for a configuration will set this so that future
            requests may be properly satisfied from the cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._defaultTargets">
            <summary>
            The first build request to generate results for a configuration will set this so that future
            requests may be properly satisfied from the cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._resultsByTarget">
            <summary>
            The set of results for each target.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._circularDependency">
            <summary>
            The request caused a circular dependency in scheduling.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._requestException">
            <summary>
            The exception generated while this request was running, if any.
            Note that this can be set if the request itself fails, or if it receives
            an exception from a target or task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._baseOverallResult">
            <summary>
            The overall result calculated in the constructor.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._savedEnvironmentVariables">
            <summary>
            Snapshot of the environment from the configuration this results comes from.
            This should only be populated when the configuration for this result is moved between nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._savedCurrentDirectory">
            <summary>
            Snapshot of the current directory from the configuration this result comes from.
            This should only be populated when the configuration for this result is moved between nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.BuildResult._projectStateAfterBuild">
            <summary>
            <see cref="T:Microsoft.Build.Execution.ProjectInstance"/> state after the build. This is only provided if <see cref="P:Microsoft.Build.BackEnd.BuildRequest.BuildRequestDataFlags"/>
            includes <see cref="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild"/> or
            <see cref="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/> for the build request which this object is a result of,
            and will be <c>null</c> otherwise. Where available, it may be a non buildable-dummy object, and should only
            be used to retrieve <see cref="P:Microsoft.Build.Execution.ProjectInstance.Properties"/>, <see cref="P:Microsoft.Build.Execution.ProjectInstance.GlobalProperties"/> and
            <see cref="P:Microsoft.Build.Execution.ProjectInstance.Items"/> from it. No other operation is guaranteed to be supported.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor">
            <summary>
            Constructor for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.BackEnd.BuildRequest)">
            <summary>
            Constructor creates an empty build result
            </summary>
            <param name="request">The build request to which these results should be associated.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.BackEnd.BuildRequest,System.Exception)">
            <summary>
            Constructs a build result with an exception
            </summary>
            <param name="request">The build request to which these results should be associated.</param>
            <param name="exception">The exception, if any.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.BackEnd.BuildRequest,System.Boolean)">
            <summary>
            Constructor creates a build result indicating a circular dependency was created.
            </summary>
            <param name="request">The build request to which these results should be associated.</param>
            <param name="circularDependency">Set to true if a circular dependency was detected.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.Execution.BuildResult,System.String[])">
            <summary>
            Constructs a new build result based on existing results, but filtered by a specified set of target names
            </summary>
            <param name="existingResults">The existing results.</param>
            <param name="targetNames">The target names whose results we will take from the existing results, if they exist.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult,System.Exception)">
            <summary>
            Constructs a new build result with existing results, but associated with the specified request.
            </summary>
            <param name="request">The build request with which these results should be associated.</param>
            <param name="existingResults">The existing results, if any.</param>
            <param name="exception">The exception, if any</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.BackEnd.BuildRequest,Microsoft.Build.Execution.BuildResult,System.String[],System.Exception)">
            <summary>
            Constructs a new build result with existing results, but associated with the specified request.
            </summary>
            <param name="request">The build request with which these results should be associated.</param>
            <param name="existingResults">The existing results, if any.</param>
            <param name="targetNames">The list of target names that are the subset of results that should be returned.</param>
            <param name="exception">The exception, if any</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.Execution.BuildResult,System.Int32)">
            <summary>
            Constructor which allows reporting results for a different nodeRequestId
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.SubmissionId">
            <summary>
            Returns the submission id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.ConfigurationId">
            <summary>
            Returns the configuration ID for this result.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.GlobalRequestId">
            <summary>
            Returns the build request id for which this result was generated
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.ParentGlobalRequestId">
            <summary>
            Returns the build request id for the parent of the request for which this result was generated
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.NodeRequestId">
            <summary>
            Returns the node build request id for which this result was generated
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.Exception">
            <summary>
            Returns the exception generated while this result was run, if any. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.CircularDependency">
            <summary>
            Returns a flag indicating if a circular dependency was detected.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.OverallResult">
            <summary>
            Returns the overall result for this result set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.ResultsByTarget">
            <summary>
            Returns an enumerator for all target results in this build result
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild">
            <summary>
            <see cref="T:Microsoft.Build.Execution.ProjectInstance"/> state after the build. In general, it may be a non buildable-dummy object, and should only
            be used to retrieve <see cref="P:Microsoft.Build.Execution.ProjectInstance.Properties"/>, <see cref="P:Microsoft.Build.Execution.ProjectInstance.GlobalProperties"/> and
            <see cref="P:Microsoft.Build.Execution.ProjectInstance.Items"/> from it. Any other operation is not guaranteed to be supported.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.Microsoft#Build#BackEnd#INodePacket#Type">
            <summary>
            Returns the node packet type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.Microsoft#Build#BackEnd#IBuildResults#SavedEnvironmentVariables">
            <summary>
            Holds a snapshot of the environment at the time we blocked.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.Microsoft#Build#BackEnd#IBuildResults#SavedCurrentDirectory">
            <summary>
            Holds a snapshot of the current working directory at the time we blocked.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.InitialTargets">
            <summary>
            Returns the initial targets for the configuration which requested these results.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.DefaultTargets">
            <summary>
            Returns the default targets for the configuration which requested these results.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.SchedulerInducedError">
            <summary>
            Container used to transport errors from the scheduler (issued while computing a build result)
            to the TaskHost that has the proper logging context (project id, target id, task id, file location)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.BuildResult.Item(System.String)">
            <summary>
            Indexer which sets or returns results for the specified target
            </summary>
            <param name="target">The target</param>
            <returns>The results for the specified target</returns>
            <exception>KeyNotFoundException is returned if the specified target doesn't exist when reading this property.</exception>
            <exception>ArgumentException is returned if the specified target already has results.</exception>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.AddResultsForTarget(System.String,Microsoft.Build.Execution.TargetResult)">
            <summary>
            Adds the results for the specified target to this result collection.
            </summary>
            <param name="target">The target to which these results apply.</param>
            <param name="result">The results for the target.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.MergeResults(Microsoft.Build.Execution.BuildResult)">
            <summary>
            Merges the specified results with the results contained herein.
            </summary>
            <param name="results">The results to merge in.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.HasResultsForTarget(System.String)">
            <summary>
            Determines if there are any results for the specified target.
            </summary>
            <param name="target">The target for which results are desired.</param>
            <returns>True if results exist, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.CacheIfPossible">
            <summary>
            Caches all of the targets results we can.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.ClearCachedFiles">
            <summary>
            Clear cached files from disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.Clone">
            <summary>
            Clones the build result (the resultsByTarget field is only a shallow copy).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.SetOverallResult(System.Boolean)">
            <summary>
            Sets the overall result.
            </summary>
            <param name="overallResult"><code>true</code> if the result is success, otherwise <code>false</code>.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.CreateTargetResultDictionary(System.Int32)">
            <summary>
            Creates the target result dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.BuildResult.CreateTargetResultDictionaryWithContents(Microsoft.Build.Execution.BuildResult,System.String[])">
            <summary>
            Creates the target result dictionary and populates it with however many target results are 
            available given the list of targets passed. 
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TargetResultCode">
            <summary>
            The result code for a given target.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResultCode.Skipped">
            <summary>
            The target was skipped because its condition was not met.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResultCode.Success">
            <summary>
            The target successfully built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResultCode.Failure">
            <summary>
            The target failed to build.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ITargetResult">
            <summary>
            An interface representing results for a specific target
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ITargetResult.Exception">
            <summary>
            The exception generated when the target ran, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ITargetResult.Items">
            <summary>
            The set of build items output by the target.
            These are ITaskItem's, so they have no item-type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ITargetResult.ResultCode">
            <summary>
            The result code for the target run.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TargetResult">
            <summary>
            Contains the result items for a single target as well as the overall result code.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult._result">
            <summary>
            The result for this target.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult._targetFailureDoesntCauseBuildFailure">
            <summary>
            Flag indicating whether to consider this target failure as having caused a build failure.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult._afterTargetsHaveFailed">
            <summary>
            Flag indicating whether at least one target which has run after us (transitively via AfterTargets) failed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult._itemsStore">
            <summary>
            The store of items in this result.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult._cacheInfo">
            <summary>
            The context under which these results have been cached.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.#ctor(Microsoft.Build.Execution.ProjectItemInstance.TaskItem[],Microsoft.Build.BackEnd.WorkUnitResult)">
            <summary>
            Initializes the results with specified items and result.
            </summary>
            <param name="items">The items produced by the target.</param>
            <param name="result">The overall result for the target.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.Exception">
            <summary>
            Returns the exception which aborted this target, if any.
            </summary>
            <value>The exception which aborted this target, if any.</value>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.Items">
            <summary>
            Returns the items produced by the target.
            These are ITaskItem's, so they have no item-type.
            </summary>
            <value>The items produced by the target.</value>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.ResultCode">
            <summary>
            Returns the result code for the target.
            </summary>
            <value>The result code for the target.</value>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.WorkUnitResult">
            <summary>
            Returns the internal result for the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.TargetFailureDoesntCauseBuildFailure">
            <summary>
            Sets or gets a flag indicating whether or not a failure results should cause the build to fail.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.AfterTargetsHaveFailed">
            <summary>
            Sets or gets a flag indicating whether at least one target which has run after us (transitively via AfterTargets) failed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.GetCacheFile(System.Int32,System.String)">
            <summary>
            Gets the name of the cache file for this configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.GetCacheDirectory(System.Int32,System.String)">
            <summary>
            Gets the name of the cache file for this configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.CacheItems(System.Int32,System.String)">
            <summary>
            Cache the items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.InternalTranslate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Performs the actual translation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.RetrieveItemsFromCache">
            <summary>
            Retrieve the items from the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.GetResultsCacheTranslator(System.Int32,System.String,Microsoft.Build.BackEnd.TranslationDirection)">
            <summary>
            Gets the translator for this configuration.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TargetResult.CacheInfo">
            <summary>
            Information about where the cache for the items in this result are stored.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.CacheInfo.#ctor(System.Int32,System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.CacheInfo.ConfigId">
            <summary>
            Retrieves the configuration id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.CacheInfo.TargetName">
            <summary>
            Retrieves the target name.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TargetResult.ItemsStore">
            <summary>
            The store of items for the target result.  This class is responsible for the serialization of the items collection, which is 
            useful to keep separate as it is where we spend most of our time serializing for large projects, and these are the bits
            we throw out of memory when the cache gets collected.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult.ItemsStore.DefaultCompressionThreshold">
            <summary>
            The default compression threshold.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult.ItemsStore.s_compressionThreshold">
            <summary>
            The count of items we will store before we start using compression.
            </summary>
            <remarks>
            This value was determined empirically by looking at how many items tend to be transmitted for "normal" projects versus the ones
            which benefit from this technique.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult.ItemsStore._compressedItems">
            <summary>
            The compressed set of items, if any.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult.ItemsStore._itemsCount">
            <summary>
            The count of items, stored here so that we don't have to decompress the items if we are
            only looking at the count.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TargetResult.ItemsStore._uncompressedItems">
            <summary>
            The items produced by this target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.#ctor(Microsoft.Build.Execution.ProjectItemInstance.TaskItem[])">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for serialization.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.ItemsStore.ItemsCount">
            <summary>
            Gets the count of items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TargetResult.ItemsStore.Items">
            <summary>
            Retrieves the items.
            </summary>
            <remarks>
            It's important not to call this method merely to get a count of the items held in the collection.
            Instead use ItemsCount (above) for that.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates an items store.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for the serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.CompressItemsIfNecessary">
            <summary>
            Compresses the items, but only if we have reached the threshold where it makes sense to do so.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.DecompressItems">
            <summary>
            Decompresses the items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TargetResult.ItemsStore.CompressItems">
            <summary>
            Compresses the items.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ReflectableTaskPropertyInfo">
            <summary>
            A reflection-generated TaskPropertyInfo instance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ReflectableTaskPropertyInfo._propertyInfo">
            <summary>
            The reflection-produced PropertyInfo.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ReflectableTaskPropertyInfo._taskType">
            <summary>
            The type of the generated tasks.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ReflectableTaskPropertyInfo.#ctor(Microsoft.Build.Framework.TaskPropertyInfo,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Execution.ReflectableTaskPropertyInfo"/> class.
            </summary>
            <param name="taskPropertyInfo">The original property info that generated this instance.</param>
            <param name="taskType">The type to reflect over to get the reflection propertyinfo later.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ReflectableTaskPropertyInfo.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Execution.ReflectableTaskPropertyInfo"/> class.
            </summary>
            <param name="propertyInfo">The PropertyInfo used to discover this task property.</param>
        </member>
        <member name="P:Microsoft.Build.Execution.ReflectableTaskPropertyInfo.Reflection">
            <summary>
            Gets or sets the reflection-produced PropertyInfo.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.NodeAffinity">
            <summary>
            Controls where projects must be built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.NodeAffinity.InProc">
            <summary>
            The project may only be scheduled on the in-proc node.  This happens automatically if there is a host object or if a ProjectInstance
            was specified.  A host may wish to specify it if they know a task depends explicitly on shared static data or other host-provided
            objects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.NodeAffinity.OutOfProc">
            <summary>
            The project may only be scheduled on an out-of-proc node.  A host may wish to specify this if it is known the project being built
            could contaminate the host environment (or the host contaminates the environment while a build is proceeding.)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.NodeAffinity.Any">
            <summary>
            The project may be scheduled anywhere.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.HostServices">
            <summary>
            Implementation of HostServices that
            mediates access from the build to the host.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.HostServices._hostObjectMap">
            <summary>
            Collection storing host objects for particular project/task/target combinations.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.HostServices._projectAffinities">
            <summary>
            A mapping of project file names to their node affinities.  An entry for String.Empty means that
            all projects which don't otherwise have an affinity should use that affinity.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.GetHostObject(System.String,System.String,System.String)">
            <summary>
            Gets any host object applicable to this task name
            where the task appears within a target and project with the specified names.
            If no host object exists, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.RegisterHostObject(System.String,System.String,System.String,Microsoft.Build.Framework.ITaskHost)">
            <summary>
            Register a host object for a particular task/target pair.
            Overwrites any existing host object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.RegisterHostObject(System.String,System.String,System.String,System.String)">
             <summary>
             Register a remote host object for a particular task/target pair.
             The remote host object require registered in Running Object Table(ROT) already.
             Overwrites any existing host object.
            
             It's caller's responsibly:
             To maintain the live cycle of the host object.
             Register and unregister from ROT.
             Ensure the host object has appropriate COM interface that can be used in task.
             </summary>
             <param name="monikerName">the Moniker used to register host object in ROT</param>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.UnregisterProject(System.String)">
            <summary>
            Unregister the project's host objects, if any and remove any node affinities associated with it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.GetNodeAffinity(System.String)">
            <summary>
            Retrieves the node affinity for a particular project file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.SetNodeAffinity(System.String,Microsoft.Build.Execution.NodeAffinity)">
            <summary>
            Sets the node affinity for a particular project file.
            </summary>
            <param name="projectFile">
            The project file.  If set to String.Empty, all projects will use the specified affinity.  If set to null, all affinities will be cleared.
            </param>
            <param name="nodeAffinity">The <see cref="T:Microsoft.Build.Execution.NodeAffinity"/> to set.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.OnRenameProject(System.String,System.String)">
            <summary>
            Updates the host object table when a project is renamed.
            Old full path may be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.HasInProcessHostObject(System.String)">
            <summary>
            Returns true if there is any in process host object registered for this project file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.GetNodeAffinity(System.String,System.Boolean@)">
            <summary>
            Retrieves the node affinity for a particular project file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.SetTestRunningObjectTable(Microsoft.Build.Execution.IRunningObjectTableWrapper)">
            <summary>
            Test only
            </summary>
            <param name="runningObjectTable"></param>
        </member>
        <member name="T:Microsoft.Build.Execution.HostServices.HostObjects">
            <summary>
            Bag holding host object information for a single project file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.HostServices.HostObjects._hostObjects">
            <summary>
            The mapping of targets and tasks to host objects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.HostObjects.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.HostServices.HostObjects.HasRegisteredInProcessHostObjects">
            <summary>
            Accessor which indicates if there are any registered in process host objects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.HostObjects.RegisterHostObject(System.String,System.String,Microsoft.Build.Framework.ITaskHost)">
            <summary>
            Registers a host object for this project file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.HostObjects.RegisterHostObject(System.String,System.String,System.String)">
            <summary>
            Registers a host object for this project file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.HostObjects.GetAnyMatchingMonikerNameOrITaskHost(System.String,System.String)">
            <summary>
            Gets any host object for this project file matching the task and target names specified.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.HostServices.HostObjects.TargetTaskKey">
            <summary>
            Equatable key for the table
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.HostServices.HostObjects.TargetTaskKey._targetName">
            <summary>
            Target name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.HostServices.HostObjects.TargetTaskKey._taskName">
            <summary>
            Task name
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.HostObjects.TargetTaskKey.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.HostServices.HostObjects.TargetTaskKey.Equals(Microsoft.Build.Execution.HostServices.HostObjects.TargetTaskKey)">
            <summary>
            Implementation of IEquatable.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectTargetInstanceChild">
            <summary>
            Type for ProjectTaskInstance and ProjectPropertyGroupTaskInstance and ProjectItemGroupTaskInstance
            allowing them to be used in a single collection of target children
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstanceChild.Condition">
            <summary>
            Condition on the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstanceChild.FullPath">
            <summary>
            Full path to the file in which the originating element was originally 
            defined.
            If it originated in a project that was not loaded and has never been 
            given a path, returns an empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstanceChild.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstanceChild.ConditionLocation">
            <summary>
            Location of the original condition attribute
            if any
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectTaskInstanceChild">
            <summary>
            Type for TaskOutputItem and TaskOutputProperty
            allowing them to be used in a single collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstanceChild.Condition">
            <summary>
            Condition on the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstanceChild.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstanceChild.TaskParameterLocation">
            <summary>
            Location of the TaskParameter attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstanceChild.ConditionLocation">
            <summary>
            Location of the original condition attribute, if any
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectInstanceSettings">
            <summary>
            Enum for controlling project instance creation
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstanceSettings.None">
            <summary>
            no options
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstanceSettings.Immutable">
            <summary>
            create immutable version of project instance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstanceSettings.ImmutableWithFastItemLookup">
            <summary>
            create project instance with some look up table that improves performance
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectInstance">
            <summary>
            What the user gets when they clone off a ProjectInstance.
            They can hold onto this, change/query items and properties,
            and call it several times to build it.
            </summary>
            <comments>
            Neither this class nor none of its constituents are allowed to have 
            references to any of the Construction or Evaluation objects.
            This class is immutable except for adding instance items and setting instance properties.
            It only exposes items and properties: targets, host services, and the task registry are not exposed as they are only the concern of build.
            Constructors are internal in order to direct users to Project class instead; these are only createable via Project objects.
            </comments>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._actualTargets">
            <summary>
            Targets in the project after overrides have been resolved.
            This is an unordered collection keyed by target name.
            Only the wrapper around this collection is exposed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._targets">
            <summary>
            Targets in the project after overrides have been resolved.
            This is an immutable, unordered collection keyed by target name.
            It is just a wrapper around <see cref="F:Microsoft.Build.Execution.ProjectInstance._actualTargets">actualTargets</see>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._globalProperties">
            <summary>
            The global properties evaluation occurred with.
            Needed by the build as they traverse between projects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._globalPropertiesToTreatAsLocal">
            <summary>
            List of names of the properties that, while global, are still treated as overridable 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._explicitToolsVersionSpecified">
            <summary>
            Whether the tools version used originated from an explicit specification,
            for example from an MSBuild task or /tv switch.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._properties">
            <summary>
            Properties in the project. This is a dictionary of name, value pairs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._environmentVariableProperties">
            <summary>
            Properties originating from environment variables, gotten from the project collection
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._items">
            <summary>
            Items in the project. This is a dictionary of ordered lists of a single type of items keyed by item type.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._itemsByEvaluatedInclude">
            <summary>
            Items organized by evaluatedInclude value
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._directory">
            <summary>
            The project's root directory, for evaluation of relative paths and
            setting the current directory during build.
            Is never null.
            If the project has not been loaded from disk and has not been given a path, returns the current directory from 
            the time the project was loaded - this is the same behavior as Whidbey/Orcas.
            If the project has not been loaded from disk but has been given a path, this path may not exist.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._projectFileLocation">
            <summary>
            The project file location, for logging.
            If the project has not been loaded from disk and has not been given a path, returns null.
            If the project has not been loaded from disk but has been given a path, this path may not exist.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._itemDefinitions">
            <summary>
            The item definitions from the parent Project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._hostServices">
            <summary>
            The HostServices to use during a build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._usingDifferentToolsVersionFromProjectFile">
            <summary>
            Whether when we read a ToolsVersion that is not equivalent to the current one on the Project tag, we 
            treat it as the current one.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._originalProjectToolsVersion">
            <summary>
            The toolsversion that was originally on the project's Project root element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectInstance._isImmutable">
            <summary>
            Whether the instance is immutable.
            The object is always mutable during evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(System.String)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Uses the default project collection.
            </summary>
            <param name="projectFile">The name of the project file.</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Uses the default project collection.
            </summary>
            <param name="projectFile">The name of the project file.</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Global properties may be null.
            Tools version may be null.
            </summary>
            <param name="projectFile">The name of the project file.</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <param name="projectCollection">Project collection</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Global properties may be null.
            Tools version may be null.
            </summary>
            <param name="projectFile">The name of the project file.</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
            <param name="projectCollection">Project collection</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,System.Nullable{Microsoft.Build.Evaluation.ProjectLoadSettings},Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Global properties may be null.
            Tools version may be null.
            Evaluation context may be null.
            </summary>
            <param name="projectFile">The name of the project file.</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
            <param name="projectCollection">Project collection</param>
            <param name="evaluationContext">The context to use for evaluation.</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Uses the default project collection.
            </summary>
            <param name="xml">The project root element</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Global properties may be null.
            Tools version may be null.
            </summary>
            <param name="xml">The project root element</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <param name="projectCollection">Project collection</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Global properties may be null.
            Tools version may be null.
            Sub-toolset version may be null, but if specified will override all other methods of determining the sub-toolset.
            </summary>
            <param name="xml">The project root element</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
            <param name="projectCollection">Project collection</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,System.Nullable{Microsoft.Build.Evaluation.ProjectLoadSettings},Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Global properties may be null.
            Tools version may be null.
            Sub-toolset version may be null, but if specified will override all other methods of determining the sub-toolset.
            </summary>
            <param name="xml">The project root element</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
            <param name="projectCollection">Project collection</param>
            <param name="evaluationContext">The context to use for evaluation.</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(System.String,Microsoft.Build.Execution.ProjectInstance,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Creates a ProjectInstance directly.  Used to generate solution metaprojects.
            </summary>
            <param name="projectFile">The full path to give to this project.</param>
            <param name="projectToInheritFrom">The traversal project from which global properties and tools version will be inherited.</param>
            <param name="globalProperties">An <see cref="T:System.Collections.Generic.IDictionary`2"/> containing global properties.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.Int32,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32)">
            <summary>
            Creates a ProjectInstance directly.
            No intermediate Project object is created.
            This is ideal if the project is simply going to be built, and not displayed or edited.
            Global properties may be null.
            Tools version may be null.
            Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in 
            determining the sub-toolset version. 
            </summary>
            <param name="xml">The project root element</param>
            <param name="globalProperties">The global properties to use.</param>
            <param name="toolsVersion">The tools version.</param>
            <param name="visualStudioVersionFromSolution">The version of the solution, used to help determine which sub-toolset to use.</param>
            <param name="projectCollection">Project collection</param>
            <param name="sdkResolverService">An <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> instance to use when resolving SDKs.</param>
            <param name="submissionId">The current build submission ID.</param>
            <returns>A new project instance</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Execution.BuildParameters,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32,System.Nullable{Microsoft.Build.Evaluation.ProjectLoadSettings})">
            <summary>
            Creates a mutable ProjectInstance directly, using the specified logging service.
            Assumes the project path is already normalized.
            Used by the RequestBuilder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Execution.BuildParameters,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32)">
            <summary>
            Creates a mutable ProjectInstance directly, using the specified logging service.
            Assumes the project path is already normalized.
            Used by this class when generating legacy solution wrappers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Evaluation.Project.Data,System.String,System.String,Microsoft.Build.Execution.HostServices,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Execution.ProjectInstanceSettings)">
            <summary>
            Constructor called by Project's constructor to create a fresh instance.
            Properties and items are cloned immediately and only the instance data is stored.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Constructor for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.#ctor(Microsoft.Build.Execution.ProjectInstance,System.Boolean,Microsoft.Build.Execution.RequestedProjectState)">
            <summary>
            Deep clone of this object.
            Useful for compiling a single file; or for keeping resolved assembly references between builds.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.FromFile(System.String,Microsoft.Build.Definition.ProjectOptions)">
            <summary>
            Create a file based ProjectInstance.
            </summary>
            <param name="file">The file to evaluate the ProjectInstance from.</param>
            <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions"/> to use.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Definition.ProjectOptions)">
            <summary>
            Create a <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/> based ProjectInstance.
            </summary>
            <param name="rootElement">The <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/> to evaluate the ProjectInstance from.</param>
            <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions"/> to use.</param>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.GlobalProperties">
            <summary>
            Global properties this project was evaluated with, if any.
            Read only collection.
            Traverses project references.
            </summary>
            <remarks>
            This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ToolsVersion">
            <summary>
            The tools version this project was evaluated with, if any.
            Not necessarily the same as the tools version on the Project tag, if any;
            it may have been externally specified, for example with a /tv switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ItemTypes">
            <summary>
            Enumerator over item types of the items in this project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Properties">
            <summary>
            Enumerator over properties in this project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Items">
            <summary>
            Enumerator over items in this project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.EvaluatedItemElements">
            <summary>
            Gets a <see cref="T:System.Collections.Generic.List`1"/> object containing evaluated items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.TranslateEntireState">
            <summary>
            Serialize the entire project instance state.
            
            When false, only a part of the project instance state is serialized (properties and items).
            In this case out of proc nodes re-evaluate the project instance from disk to obtain the un-serialized state.
            This partial state recombination may lead to build issues when the project instance state differs from what is on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.EvaluationId">
            <summary>
            The ID of the evaluation that produced this ProjectInstance.
            
            See <see cref="P:Microsoft.Build.Evaluation.Project.LastEvaluationId"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Directory">
            <summary>
            The project's root directory, for evaluation of relative paths and
            setting the current directory during build.
            Is never null: projects not loaded from disk use the current directory from
            the time the build started.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.FullPath">
            <summary>
            The full path to the project, for logging.
            If the project was never given a path, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ItemDefinitions">
            <summary>
            Read-only dictionary of item definitions in this project.
            Keyed by item type
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ImportPaths">
            <summary>
            The full file paths of all the files that during evaluation contributed to this project instance.
            This does not include projects that were never imported because a condition on an Import element was false.
            The outer ProjectRootElement that maps to this project instance itself is not included.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ImportPathsIncludingDuplicates">
            <summary>
            This list will contain duplicate imports if an import is imported multiple times. However, only the first import was used in evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.DefaultTargets">
            <summary>
            DefaultTargets specified in the project, or
            the logically first target if no DefaultTargets is
            specified in the project.
            The build builds these if no targets are explicitly specified
            to build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.InitialTargets">
            <summary>
            InitialTargets specified in the project, plus those
            in all imports, gathered depth-first.
            The build runs these before anything else.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Targets">
            <summary>
            Targets in the project. The build process can find one by looking for its name
            in the dictionary.
            This collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.IsImmutable">
            <summary>
            Whether the instance is immutable.
            This is set permanently when the instance is created.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#TaskRegistry">
            <summary>
            Task classes and locations known to this project. 
            This is the project-specific task registry, which is consulted before
            the toolset's task registry.
            Only set during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#Toolset">
            <summary>
            Gets the Toolset
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#SubToolsetVersion">
            <summary>
            The sub-toolset version we should use during the build, used to determine which set of sub-toolset
            properties we should merge into this toolset. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#ExplicitToolsVersion">
            <summary>
            The externally specified tools version, if any.
            For example, the tools version from a /tv switch.
            Not necessarily the same as the tools version from the project tag or of the toolset used.
            May be null.
            Flows through to called projects.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#GlobalPropertiesDictionary">
            <summary>
            Gets the global properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#GlobalPropertiesToTreatAsLocal">
            <summary>
            List of names of the properties that, while global, are still treated as overridable 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#Properties">
            <summary>
            Gets the global properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#ItemDefinitionsEnumerable">
            <summary>
            Gets the global properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#Items">
            <summary>
            Gets the items
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#InitialTargets">
            <summary>
            Sets the initial targets
            Only set during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#DefaultTargets">
            <summary>
            Gets or sets the default targets
            Only set during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#BeforeTargets">
            <summary>
            Gets or sets the before targets
            Only set during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AfterTargets">
            <summary>
            Gets or sets the after targets
            Only set during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#ConditionedProperties">
            <summary>
            List of possible values for properties inferred from certain conditions,
            keyed by the property name.
            </summary>
            <remarks>
            Because ShouldEvaluateForDesignTime returns false, this should not be called.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#ShouldEvaluateForDesignTime">
            <summary>
            Whether evaluation should collect items ignoring condition,
            as well as items respecting condition; and collect
            conditioned properties, as well as regular properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ProjectFileLocation">
            <summary>
            Location of the originating file itself, not any specific content within it.
            Never returns null, even if the file has not got a path yet.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.GlobalPropertiesDictionary">
            <summary>
            Gets the global properties this project was evaluated with, if any.
            Traverses project references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.Toolset">
            <summary>
            The tools version we should use during the build, used to determine which toolset we should access.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.UsingDifferentToolsVersionFromProjectFile">
            <summary>
            If we are treating a missing toolset as the current ToolsVersion
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.OriginalProjectToolsVersion">
            <summary>
            The toolsversion that was originally specified on the project's root element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ExplicitToolsVersion">
            <summary>
            The externally specified tools version, if any.
            For example, the tools version from a /tv switch.
            Not necessarily the same as the tools version from the project tag or of the toolset used.
            May be null.
            Flows through to called projects.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ExplicitToolsVersionSpecified">
            <summary>
            Whether the tools version used originated from an explicit specification,
            for example from an MSBuild task or /tv switch.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.SubToolsetVersion">
            <summary>
            The sub-toolset version we should use during the build, used to determine which set of sub-toolset
            properties we should merge into this toolset. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.PropertiesToBuildWith">
            <summary>
            Actual collection of properties in this project,
            for the build to start with.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ItemsToBuildWith">
            <summary>
            Actual collection of items in this project,
            for the build to start with.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.TaskRegistry">
            <summary>
            Task classes and locations known to this project. 
            This is the project-specific task registry, which is consulted before
            the toolset's task registry.
            </summary>
            <remarks>
            UsingTask tags have already been evaluated and entered into this task registry.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.TargetsCount">
            <summary>
            Number of targets in the project. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectInstance.ProjectRootElementCache">
            <summary>
            The project root element cache from the project collection
            that began the build. This is a thread-safe object.
            It's held here so it can get passed to the build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Returns the evaluated, escaped value of the provided item's include.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance)">
            <summary>
            Returns the evaluated, escaped value of the provided item definition's include.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance)">
            <summary>
            Gets the escaped value of the provided metadatum. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance,System.String)">
            <summary>
            Gets the escaped value of the metadatum with the provided name on the provided item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance,System.String)">
            <summary>
            Gets the escaped value of the metadatum with the provided name on the provided item definition. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance)">
            <summary>
            Get the escaped value of the provided property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IItemProvider{Microsoft#Build#Execution#ProjectItemInstance}#GetItems(System.String)">
            <summary>
            Gets items of the specified type.
            For internal use.
            </summary>
            <comments>
            Already a readonly collection
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#InitializeForEvaluation(Microsoft.Build.Evaluation.IToolsetProvider,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Initializes the object for evaluation.
            Only called during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#FinishEvaluation">
            <summary>
            Indicates to the data block that evaluation has completed,
            so for example it can mark datastructures read-only.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AddItem(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Adds a new item
            Only called during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AddItemIgnoringCondition(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Adds a new item to the collection of all items ignoring condition
            </summary>
            <remarks>
            Because ShouldEvaluateForDesignTime returns false, this should not be called.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AddItemDefinition(System.String)">
            <summary>
            Adds a new item definition
            Only called during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AddToAllEvaluatedPropertiesList(Microsoft.Build.Execution.ProjectPropertyInstance)">
            <summary>
            Properties encountered during evaluation. These are read during the first evaluation pass.
            Unlike those returned by the Properties property, these are ordered, and include any properties that
            were subsequently overridden by others with the same name. It does not include any 
            properties whose conditions did not evaluate to true.
            </summary>
            <remarks>
            Because ShouldEvaluateForDesignTime returns false, this should not be called.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AddToAllEvaluatedItemDefinitionMetadataList(Microsoft.Build.Execution.ProjectMetadataInstance)">
            <summary>
            Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
            Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
            were subsequently overridden by others with the same name and item type. It does not include any 
            elements whose conditions did not evaluate to true.
            </summary>
            <remarks>
            Because ShouldEvaluateForDesignTime returns false, this should not be called.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AddToAllEvaluatedItemsList(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Items encountered during evaluation. These are read during the third evaluation pass.
            Unlike those returned by the Items property, these are ordered.
            It does not include any elements whose conditions did not evaluate to true.
            It does not include any items added since the last evaluation.
            </summary>
            <remarks>
            Because ShouldEvaluateForDesignTime returns false, this should not be called.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#GetItemDefinition(System.String)">
            <summary>
            Retrieves an existing item definition, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#SetProperty(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets a property which does not come from the Xml.
            This is where global, environment, and toolset properties are added to the project instance by the evaluator, and we mark them
            immutable if we are immutable.
            Only called during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#SetProperty(Microsoft.Build.Construction.ProjectPropertyElement,System.String)">
            <summary>
            Sets a property which comes from the Xml.
            Predecessor is discarded as it is a design time only artefact.
            Only called during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#GetTarget(System.String)">
            <summary>
            Retrieves an existing target, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#AddTarget(Microsoft.Build.Execution.ProjectTargetInstance)">
            <summary>
            Adds a new target.
            Only called during evaluation, so does not check for immutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#RecordImport(Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32,Microsoft.Build.BackEnd.SdkResolution.SdkResult)">
            <summary>
            Record an import opened during evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Execution#ProjectPropertyInstance,Microsoft#Build#Execution#ProjectItemInstance,Microsoft#Build#Execution#ProjectMetadataInstance,Microsoft#Build#Execution#ProjectItemDefinitionInstance}#RecordImportWithDuplicates(Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32)">
            <summary>
            Record an import opened during evaluation. Include duplicates
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetProperty(System.String)">
            <summary>
            Get any property in the item that has the specified name,
            otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#Evaluation#IPropertyProvider{Microsoft#Build#Execution#ProjectPropertyInstance}#GetProperty(System.String,System.Int32,System.Int32)">
            <summary>
            Get any property in the item that has the specified name,
            otherwise returns null.
            Name is the segment of the provided string with the provided start and end indexes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetPropertyValue(System.String)">
            <summary>
            Get the value of a property in this project, or 
            an empty string if it does not exist.
            </summary>
            <remarks>
            A property with a value of empty string and no property
            at all are not distinguished between by this method.
            This is because the build does not distinguish between the two.
            The reason this method exists when users can simply do GetProperty(..).EvaluatedValue,
            is that the caller would have to check for null every time. For properties, empty and undefined are 
            not distinguished, so it much more useful to also have a method that returns empty string in
            either case.
            This function returns the unescaped value.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.SetProperty(System.String,System.String)">
            <summary>
            Add a property with the specified name and value.
            Overwrites any property with the same name already in the collection.
            </summary>
            <remarks>
            We don't take a ProjectPropertyInstance to make sure we don't have one that's already
            in use by another ProjectPropertyInstance.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.AddItem(System.String,System.String)">
            <summary>
            Adds an item with no metadata to the project
            </summary>
            <remarks>
            We don't take a ProjectItemInstance to make sure we don't have one that's already
            in use by another ProjectInstance.
            </remarks>
            <comments>
            For purposes of declaring the project that defined this item (for use with e.g. the 
            DeclaringProject* metadata), the entrypoint project is used for synthesized items 
            like those added by this API. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Adds an item with metadata to the project.
            Metadata may be null.
            </summary>
            <remarks>
            We don't take a ProjectItemInstance to make sure we don't have one that's already
            in use by another ProjectInstance.
            </remarks>
            <comments>
            For purposes of declaring the project that defined this item (for use with e.g. the 
            DeclaringProject* metadata), the entrypoint project is used for synthesized items 
            like those added by this API. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetItems(System.String)">
            <summary>
            Get a list of all the items in the project of the specified
            type, or an empty list if there are none.
            This is a read-only list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetItemsByItemTypeAndEvaluatedInclude(System.String,System.String)">
            <summary>
            get items by item type and evaluated include value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Removes an item from the project, if present.
            Returns true if it was present, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.RemoveProperty(System.String)">
            <summary>
            Removes any property with the specified name.
            Returns true if the property had a value (possibly empty string), otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.DeepCopy">
            <summary>
            Create an independent, deep clone of this object and everything in it.
            Useful for compiling a single file; or for keeping build results between builds.
            Clone has the same mutability as the original.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.FilteredCopy(Microsoft.Build.Execution.RequestedProjectState)">
            <summary>
            Create an independent clone of this object, keeping ONLY the explicitly
            requested project state.
            </summary>
            <remarks>
            Useful for reducing the wire cost of IPC for out-of-proc nodes used during
            design-time builds that only need to populate a known set of data.
            </remarks>
            <param name="filter">Project state that should be returned.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.DeepCopy(System.Boolean)">
            <summary>
            Create an independent, deep clone of this object and everything in it, with
            specified mutability.
            Useful for compiling a single file; or for keeping build results between builds.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build">
            <summary>
            Build default target/s with loggers of the project collection.
            Returns true on success, false on failure.
            Only valid if mutable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})">
            <summary>
            Build default target/s with specified loggers.
            Returns true on success, false on failure.
            Loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})">
            <summary>
            Build default target/s with specified loggers.
            Returns true on success, false on failure.
            Loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})">
            <summary>
            Build a target with specified loggers.
            Returns true on success, false on failure.
            Target may be null.
            Loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})">
            <summary>
            Build a target with specified loggers.
            Returns true on success, false on failure.
            Target may be null.
            Loggers may be null.
            Remote loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})">
            <summary>
            Build a list of targets with specified loggers.
            Returns true on success, false on failure.
            Targets may be null.
            Loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})">
            <summary>
            Build a list of targets with specified loggers.
            Returns true on success, false on failure.
            Targets may be null.
            Loggers may be null.
            Remote loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Execution.TargetResult}@)">
            <summary>
            Build a list of targets with specified loggers.
            Returns true on success, false on failure.
            Targets may be null.
            Loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Execution.TargetResult}@)">
            <summary>
            Build a list of targets with specified loggers.
            Returns true on success, false on failure.
            Targets may be null.
            Loggers may be null.
            Remote loggers may be null.
            Only valid if mutable.
            </summary>
            <remarks>
            If any of the loggers supplied are already attached to the logging service we
            were passed, throws InvalidOperationException.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.ExpandString(System.String)">
            <summary>
            Evaluates the provided string by expanding items and properties,
            using the current items and properties available.
            This is useful for some hosts, or for the debugger immediate window.
            Does not expand bare metadata expressions.
            </summary>
            <comment>
            Not for internal use.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.EvaluateCondition(System.String)">
            <summary>
            Evaluates the provided string as a condition by expanding items and properties,
            using the current items and properties available, then doing a logical evaluation.
            This is useful for the immediate window.
            Does not expand bare metadata expressions.
            </summary>
            <comment>
            Not for internal use.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.ToProjectRootElement">
            <summary>
            Creates a ProjectRootElement from the contents of this ProjectInstance.
            </summary>
            <returns>A ProjectRootElement which represents this instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Replaces the project state (<see cref="P:Microsoft.Build.Execution.ProjectInstance.GlobalProperties"/>, <see cref="P:Microsoft.Build.Execution.ProjectInstance.Properties"/> and <see cref="P:Microsoft.Build.Execution.ProjectInstance.Items"/>) with that
            from the <see cref="T:Microsoft.Build.Execution.ProjectInstance"/> provided.
            </summary>
            <param name="projectState"><see cref="T:Microsoft.Build.Execution.ProjectInstance"/> with the state to use.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.LateInitialize(Microsoft.Build.Evaluation.ProjectRootElementCacheBase,Microsoft.Build.Execution.HostServices)">
            <summary>
            When project instances get serialized between nodes, they need to be initialized with node specific information.
            The node specific information cannot come from the constructor, because that information is not available to INodePacketTranslators
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translate the project instance to or from a stream.
            Only translates global properties, properties, items, and mutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.LoadSolutionForBuild(System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.String,Microsoft.Build.Execution.BuildParameters,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.Boolean,System.Collections.Generic.IReadOnlyCollection{System.String},Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32)">
            <summary>
            Creates a set of project instances which represent the project dependency graph for a solution build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.VerifyThrowNotImmutable(System.Boolean)">
            <summary>
            Throws invalid operation exception if the project instance is immutable.
            Called before an edit.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.BackEnd.Logging.ILoggingService,System.Int32,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Execution.TargetResult}@)">
            <summary>
            Builds a list of targets with the specified loggers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.BackEnd.Logging.ILoggingService,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Execution.TargetResult}@)">
            <summary>
            Builds a list of targets with the specified loggers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetTargetsWhichRunBefore(System.String)">
            <summary>
            Retrieves the list of targets which should run before the specified target.
            Never returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetTargetsWhichRunAfter(System.String)">
            <summary>
            Retrieves the list of targets which should run after the specified target.
            Never returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Cache(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Cache the contents of this project instance to the translator.
            The object is retained, but the bulk of its content is released.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.RetrieveFromCache(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Retrieve the contents of this project from the translator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.AddTarget(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Adds the specified target to the instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.RemoveTarget(System.String)">
            <summary>
            Removes the specified target from the instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.VerifyThrowNotImmutable">
            <summary>
            Throws invalid operation exception if the project instance is immutable.
            Called before an edit.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GenerateSolutionWrapper(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.Collections.Generic.IReadOnlyCollection{System.String},Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32)">
            <summary>
            Generate a 4.0+-style solution wrapper project.
            </summary>
            <param name="projectFile">The solution file to generate a wrapper for.</param>
            <param name="globalProperties">The global properties of this solution.</param>
            <param name="toolsVersion">The ToolsVersion to use when generating the wrapper.</param>
            <param name="loggingService">The logging service used to log messages etc. from the solution wrapper generator.</param>
            <param name="projectBuildEventContext">The build event context in which this project is being constructed.</param>
            <param name="targetNames">A collection of target names that the user requested be built.</param>
            <param name="sdkResolverService"></param>
            <param name="submissionId"></param>
            <returns>The ProjectRootElement for the root traversal and each of the metaprojects.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GenerateSolutionWrapperUsingOldOM(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,Microsoft.Build.Execution.BuildParameters,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.Boolean,Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32)">
            <summary>
            Spawn the old engine to generate a solution wrapper project, so that our build ordering is somewhat more correct 
            when solutions with toolsVersions &lt; 4.0 are passed to us. 
            </summary>
            <comment>
            #############################################################################################
            #### Segregated into another method to avoid loading the old Engine in the regular case. ####
            ####################### Do not move back in to the main code path! ##########################
            #############################################################################################
             We have marked this method as NoInlining because we do not want Microsoft.Build.Engine.dll to be loaded unless we really execute this code path
            </comment>
            <param name="projectFile">The solution file to generate a wrapper for.</param>
            <param name="globalProperties">The global properties of this solution.</param>
            <param name="toolsVersion">The ToolsVersion to use when generating the wrapper.</param>
            <param name="projectRootElementCache">The root element cache which should be used for the generated project.</param>
            <param name="buildParameters">The build parameters.</param>
            <param name="loggingService">The logging service used to log messages etc. from the solution wrapper generator.</param>
            <param name="projectBuildEventContext">The build event context in which this project is being constructed.</param>
            <param name="isExplicitlyLoaded"><code>true</code> if the project is explicitly loaded, otherwise <code>false</code>.</param>
            <param name="sdkResolverService">An <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> to use when resolving SDKs.</param>
            <param name="submissionId"></param>
            <returns>An appropriate ProjectRootElement</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateCloneDictionary``1(System.Collections.Generic.IDictionary{System.String,``0},System.StringComparer)">
            <summary>
            Creates a copy of a dictionary and returns a read-only dictionary around the results.
            </summary>
            <typeparam name="TValue">The value stored in the dictionary</typeparam>
            <param name="dictionary">Dictionary to clone.</param>
            <param name="strComparer">The <see cref="T:System.StringComparer"/> to use for the cloned dictionary.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateCloneDictionary``1(System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>
            Creates a copy of a dictionary and returns a read-only dictionary around the results.
            </summary>
            <typeparam name="TValue">The value stored in the dictionary</typeparam>
            <param name="dictionary">Dictionary to clone.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.Initialize(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,System.Int32,Microsoft.Build.Execution.BuildParameters,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32,System.Nullable{Microsoft.Build.Evaluation.ProjectLoadSettings},Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Common code for the constructors that evaluate directly.
            Global properties may be null.
            Tools version may be null.
            Does not set mutability.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.GetItemsByEvaluatedInclude(System.String)">
            <summary>
            Get items by evaluatedInclude value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateTargetsSnapshot(Microsoft.Build.Evaluation.Project.Data)">
            <summary>
            Create various target snapshots
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateImportsSnapshot(Microsoft.Build.Evaluation.Project.Data)">
            <summary>
            Create various imports snapshots
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateEnvironmentVariablePropertiesSnapshot(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Create environment variable properties snapshot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateGlobalPropertiesSnapshot(Microsoft.Build.Evaluation.Project.Data)">
            <summary>
            Create global properties snapshot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateEvaluatedIncludeSnapshotIfRequested(System.Boolean,Microsoft.Build.Evaluation.Project.Data,System.Collections.Generic.Dictionary{Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Create evaluated include cache snapshot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateItemsSnapshot(Microsoft.Build.Evaluation.Project.Data,System.Boolean)">
            <summary>
            Create Items snapshot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreateItemDefinitionsSnapshot(Microsoft.Build.Evaluation.Project.Data)">
            <summary>
            Create ItemDefinitions snapshot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectInstance.CreatePropertiesSnapshot(Microsoft.Build.Evaluation.Project.Data,System.Boolean)">
            <summary>
            create property snapshot
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemDefinitionInstance">
            <summary>
            An evaluated item definition for a particular item-type, divested of all references to XML.
            Immutable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemDefinitionInstance._itemType">
            <summary>
            Item type, for example "Compile", that this item definition applies to
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemDefinitionInstance._metadata">
            <summary>
            Collection of metadata that link the XML metadata and instance metadata
            Since evaluation has occurred, this is an unordered collection.
            Is never null or empty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.#ctor(System.String)">
            <summary>
            Constructs an empty project item definition instance.
            </summary>
            <param name="projectInstance">The project instance to which this item definition belongs.</param>
            <param name="itemType">The type of item this definition object represents.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.#ctor(Microsoft.Build.Evaluation.ProjectItemDefinition)">
            <summary>
            Called when a ProjectInstance is created.
            </summary>
            <remarks>
            Assumes that the itemType string originated in a ProjectItemDefinitionElement and therefore
            was already validated.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemDefinitionInstance.ItemType">
            <summary>
            Type of this item definition.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemDefinitionInstance.Metadata">
            <summary>
            Metadata on the item definition.
            If there is no metadata, returns empty collection.
            This is a read-only collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataCount">
            <summary>
            Number of pieces of metadata on this item definition.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataNames">
            <summary>
            Names of all metadata on this item definition
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemDefinitionInstance.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the item type, so these 
            can be put in a dictionary conveniently.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.GetMetadata(System.String)">
            <summary>
            Get any metadata in the item that has the specified name,
            otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String)">
            <summary>
            Returns the specified metadata.
            </summary>
            <param name="name">The metadata name.</param>
            <returns>The metadata value, or an empty string if none exists.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String,System.String)">
            <summary>
            Returns the metadata for the specified item type.
            </summary>
            <param name="specifiedItemType">The item type.</param>
            <param name="name">The metadata name.</param>
            <returns>The metadata value, or an empty string if none exists.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Returns the metadata for the specified item type.
            </summary>
            <param name="specifiedItemType">The item type.</param>
            <param name="name">The metadata name.</param>
            <returns>The metadata value, or an null if none exists.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.Microsoft#Build#Evaluation#IItemDefinition{Microsoft#Build#Execution#ProjectMetadataInstance}#SetMetadata(Microsoft.Build.Construction.ProjectMetadataElement,System.String,Microsoft.Build.Execution.ProjectMetadataInstance)">
            <summary>
            Sets a new metadata value.  Called by the evaluator only.
            Discards predecessor as this information is only useful at design time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemDefinitionInstance.ToProjectItemDefinitionElement(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Creates a ProjectItemDefinitionElement representing this instance.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemGroupTaskInstance">
            <summary>
            Wraps an unevaluated itemgroup under a target.
            Immutable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskInstance._condition">
            <summary>
            Condition, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskInstance._items">
            <summary>
            Child items.
            Not ProjectItemInstances, as these are evaluated during the build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskInstance.#ctor(System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,System.Collections.Generic.List{Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance})">
            <summary>
            Constructor called by the Evaluator.
            Assumes ProjectItemGroupTaskItemInstance is an immutable type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskInstance.#ctor(Microsoft.Build.Execution.ProjectItemGroupTaskInstance)">
            <summary>
            Cloning constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Condition">
            <summary>
            Condition, if any.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Items">
            <summary>
            Child items
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskInstance.DeepClone">
            <summary>
            Deep clone
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance">
            <summary>
            Wraps an unevaluated item under an itemgroup in a target.
            Immutable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._itemType">
            <summary>
            Item type, for example "Compile"
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._include">
            <summary>
            Unevaluated include
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._exclude">
            <summary>
            Unevaluated exclude
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._remove">
            <summary>
            Unevaluated remove
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._keepMetadata">
            <summary>
            The list of metadata to keep.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._removeMetadata">
            <summary>
            The list of metadata to remove.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._keepDuplicates">
            <summary>
            True to remove duplicates during the add.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._condition">
            <summary>
            Unevaluated condition
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._includeLocation">
            <summary>
            Location of the include, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._excludeLocation">
            <summary>
            Location of the exclude, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._removeLocation">
            <summary>
            Location of the remove, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._keepMetadataLocation">
            <summary>
            Location of keepMetadata, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._removeMetadataLocation">
            <summary>
            Location of removeMetadata, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._keepDuplicatesLocation">
            <summary>
            Location of keepDuplicates, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance._metadata">
            <summary>
            Ordered collection of unevaluated metadata.
            May be null.
            </summary>
            <remarks>
            There is no need for a PropertyDictionary here as the build always
            walks through all metadata sequentially.
            Lazily created, as so many items have no metadata at all.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,System.Collections.Generic.List{Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance})">
            <summary>
            Constructor called by the Evaluator.
            Metadata may be null, indicating no metadata.
            Metadata collection is ordered.
            Assumes ProjectItemGroupTaskMetadataInstance is an immutable type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.#ctor(Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance)">
            <summary>
            Cloning constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ItemType">
            <summary>
            Item type, for example "Compile"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Include">
            <summary>
            Unevaluated include value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Exclude">
            <summary>
            Unevaluated exclude value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Remove">
            <summary>
            Unevaluated remove value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadata">
            <summary>
            Unevaluated keepMetadata value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadata">
            <summary>
            Unevaluated removeMetadata value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicates">
            <summary>
            Unevaluated keepDuplicates value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Condition">
            <summary>
            Unevaluated condition value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Metadata">
            <summary>
            Ordered collection of unevaluated metadata on the item.
            If there is no metadata, returns an empty collection.
            </summary>IEnumerable
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Location">
            <summary>
            Location of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.IncludeLocation">
            <summary>
            Location of the include attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ExcludeLocation">
            <summary>
            Location of the exclude attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveLocation">
            <summary>
            Location of the remove attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadataLocation">
            <summary>
            Location of the keepMetadata attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadataLocation">
            <summary>
            Location of the removeMetadata attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicatesLocation">
            <summary>
            Location of the keepDuplicates attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ConditionLocation">
            <summary>
            Location of the condition attribute if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.DeepClone">
            <summary>
            Deep clone
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance">
            <summary>
            Wraps an unevaluated metadatum under an item in an itemgroup in a target
            Immutable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance._name">
            <summary>
            Name of the metadatum
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance._value">
            <summary>
            Unevaluated value
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance._condition">
            <summary>
            Unevaluated condition
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.#ctor(System.String,System.String,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Constructor called by the Evaluator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.#ctor(Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance)">
            <summary>
            Cloning constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Name">
            <summary>
            Name of the metadatum
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Value">
            <summary>
            Unevaluated value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Condition">
            <summary>
            Unevaluated condition value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Location">
            <summary>
            Location of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.ConditionLocation">
            <summary>
            Location of the condition attribute if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.DeepClone">
            <summary>
            Deep clone
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemInstance">
            <summary>
            Wraps an evaluated item for build purposes
            </summary>
            <remarks>
            Does not store XML location information. That is not needed by the build process as all correctness checks
            and evaluation has already been performed, so it is unnecessary bulk.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance._project">
            <summary>
            The project instance to which this item belongs.
            Never null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance._itemType">
            <summary>
            Item type, for example "Compile"
            Never null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance._taskItem">
            <summary>
            Backing task item holding the other data.
            Never null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String,System.String,System.String)">
            <summary>
            Constructor for items with no metadata.
            Include may be empty.
            Called before the build when virtual items are added, 
            and during the build when tasks emit items.
            Mutability follows the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String,System.String,System.String,System.String)">
            <summary>
            Constructor for items with no metadata.
            Include may be empty.
            Called before the build when virtual items are added, 
            and during the build when tasks emit items.
            Mutability follows the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String,System.String,System.String,Microsoft.Build.Collections.CopyOnWritePropertyDictionary{Microsoft.Build.Execution.ProjectMetadataInstance},System.Collections.Generic.List{Microsoft.Build.Execution.ProjectItemDefinitionInstance},System.String)">
            <summary>
            Constructor for items with metadata.
            Called before the build when virtual items are added, 
            and during the build when tasks emit items.
            Include may be empty.
            Direct metadata may be null, indicating no metadata. It will be cloned.
            Builtin metadata may be null, indicating it has not been populated. It will be cloned.
            Inherited item definition metadata may be null. It is assumed to ALREADY HAVE BEEN CLONED.
            Mutability follows the project.
            </summary>
            <remarks>
            Not public since the only creation scenario is setting on a project.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String)">
            <summary>
            Constructor for items with metadata.
            Called when a ProjectInstance is created.
            Include may be empty.
            Direct metadata may be null, indicating no metadata. It will be cloned.
            Metadata collection provided is cloned.
            Mutability follows the project.
            </summary>
            <remarks>
            Not public since the only creation scenario is setting on a project.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.#ctor(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Cloning constructor, retaining same parentage.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.#ctor(Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Cloning constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.#ctor(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Constructor for serialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Project">
            <summary>
            Owning project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.ItemType">
            <summary>
            Item type, for example "Compile"
            </summary>
            <remarks>
            This cannot be set, as it is used as the key into 
            the project's items table.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude">
            <summary>
            Evaluated include value.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Evaluation#IItem#EvaluatedIncludeEscaped">
            <summary>
            Evaluated include value, escaped as necessary.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem2#EvaluatedIncludeEscaped">
            <summary>
            Evaluated include value, escaped as necessary.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Metadata">
            <summary>
            Unordered collection of evaluated metadata on the item.
            If there is no metadata, returns an empty collection.
            Does not include built-in metadata.
            Includes any from item definitions.
            This is a read-only collection. To modify the metadata, use <see cref="M:Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.String,System.String)"/>.
            </summary>
            <comment>
            Computed, not necessarily fast.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.DirectMetadataCount">
            <summary>
            Number of pieces of metadata on this item
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the item type
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.MetadataNames">
            <summary>
            Returns all the metadata names on this item.
            Includes names from any applicable item definitions.
            Includes names of built-in metadata.
            </summary>
            <comment>
            Computed, not necessarily fast.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem#ItemSpec">
            <summary>
            ITaskItem implementation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem#MetadataNames">
            <summary>
            ITaskItem implementation
            </summary>
            <comment>
            Computed, not necessarily fast.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.MetadataCount">
            <summary>
            Returns the number of metadata entries.
            Includes any from applicable item definitions.
            Includes both custom and built-in metadata.
            </summary>
            <comment>
            Computed, not necessarily fast.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Evaluation#IItem#ProjectDirectory">
            <summary>
            The directory of the project being built
            Never null: If there is no project filename yet, it will use the current directory
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.EqualityComparer">
            <summary>
            Retrieves the comparer used for determining equality between ProjectItemInstances.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.ProjectFullPath">
            <summary>
            The full path to the project file being built
            Can be null: if the project hasn't been saved yet it will be null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.GetMetadata(System.String)">
            <summary>
            Get any metadata in the item that has the specified name,
            otherwise returns null. 
            Includes any metadata inherited from item definitions.
            Includes any built-in metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.GetMetadataValue(System.String)">
            <summary>
            Get the value of a metadata on this item, or 
            String.Empty if it does not exist or has no value.
            Includes any metadata inherited from item definitions and any built-in metadata.
            To determine whether a piece of metadata is actually present
            but with an empty value, use <see cref="M:Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(System.String)">HasMetadata</see>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(System.String)">
            <summary>
            Returns true if a particular piece of metadata is defined on this item (even if
            its value is empty string) otherwise false.
            This includes built-in metadata and metadata from item definitions.
            </summary>
            <remarks>
            It has to include all of these because it's used for batching, which doesn't
            care where the metadata originated.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.String,System.String)">
            <summary>
            Add a metadata with the specified name and value.
            Overwrites any metadata with the same name already in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Add a metadata with the specified names and values.
            Overwrites any metadata with the same name already in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.RemoveMetadata(System.String)">
            <summary>
            Removes a metadatum with the specified name.
            Used by TaskItem
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.ToString">
            <summary>
            Produce a string representation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Evaluation#IItem#GetMetadataValueEscaped(System.String)">
            <summary>
            Get the value of a metadata on this item, or 
            String.Empty if it does not exist or has no value.
            Includes any metadata inherited from item definitions and any built-in metadata.
            To determine whether a piece of metadata is actually present
            but with an empty value, use <see cref="M:Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(System.String)">HasMetadata</see>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Evaluation#IItem{Microsoft#Build#Execution#ProjectMetadataInstance}#SetMetadata(Microsoft.Build.Construction.ProjectMetadataElement,System.String)">
            <summary>
            Sets the specified metadata.  Discards the xml part except for the name.
            Discards the location of the original element. This is not interesting in the Execution world
            as it should never be needed for any messages, and is just extra bulk.
            Predecessor is discarded as it is only needed for design time.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem#GetMetadata(System.String)">
            <summary>
            ITaskItem implementation.
            </summary>
            <remarks>
            ITaskItem should not return null if metadata is not present.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem2#GetMetadataValueEscaped(System.String)">
            <summary>
            ITaskItem2 implementation.
            </summary>
            <remarks>
            ITaskItem2 should not return null if metadata is not present.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem#SetMetadata(System.String,System.String)">
            <summary>
            ITaskItem implementation
            </summary>
            <comments>
            MetadataValue is assumed to be in its escaped form. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem2#SetMetadataValueLiteral(System.String,System.String)">
            <summary>
            ITaskItem2 implementation
            </summary>
            <comments>
            Assumes metadataValue is unescaped. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem#CopyMetadataTo(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            ITaskItem implementation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem#CloneCustomMetadata">
            <summary>
            ITaskItem implementation
            </summary>
            <comments>
            Returns a dictionary of the UNESCAPED values of the metadata
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Framework#ITaskItem2#CloneCustomMetadataEscaped">
            <summary>
            ITaskItem2 implementation
            </summary>
            <comments>
            Returns a dictionary of the ESCAPED values of the metadata
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name specified.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If no value is available, returns empty string.
            If item type is null, it is ignored, otherwise it must match.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Returns the value if it exists.
            If no value is available, returns null.
            If item type is null, it is ignored, otherwise it must match.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translation method.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.Microsoft#Build#Collections#IDeepCloneable{Microsoft#Build#Execution#ProjectItemInstance}#DeepClone">
            <summary>
            Deep clone the item.
            Any metadata inherited from item definitions are also copied.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Set all the supplied metadata on all the supplied items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(Microsoft.Build.Collections.CopyOnWritePropertyDictionary{Microsoft.Build.Execution.ProjectMetadataInstance})">
            <summary>
            Add a metadata with the specified names and values.
            Overwrites any metadata with the same name already in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.SetMetadataOnTaskOutput(System.String,System.String)">
            <summary>
            Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
            This is not normally legal to set outside of evaluation. However, the CreateItem
            needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
            tasks to set this particular metadata as a task output.
            Other built in metadata names are ignored. That's because often task outputs are items that were passed in,
            which legally have built-in metadata. If necessary we can calculate it on the new items we're making if requested.
            We don't copy them too because tasks shouldn't set them (they might become inconsistent)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.DeepClone">
            <summary>
            Deep clone the item.
            Any metadata inherited from item definitions are also copied.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.DeepClone(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Deep clone the item.
            Any metadata inherited from item definitions are also copied.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.ToProjectItemElement(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Generates a ProjectItemElement representing this instance.
            </summary>
            <param name="parent">The root element to which the element will belong.</param>
            <returns>The new element.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.CommonConstructor(Microsoft.Build.Execution.ProjectInstance,System.String,System.String,System.String,Microsoft.Build.Collections.CopyOnWritePropertyDictionary{Microsoft.Build.Execution.ProjectMetadataInstance},System.Collections.Generic.List{Microsoft.Build.Execution.ProjectItemDefinitionInstance},System.String)">
            <summary>
            Common constructor code.
            Direct metadata may be null, indicating no metadata. It will be cloned.
            Builtin metadata may be null, indicating it has not been populated. It will be cloned.
            Inherited item definition metadata may be null. It is assumed to ALREADY HAVE BEEN CLONED.
            Mutability follows the project.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemInstance.TaskItem">
            <summary>
            An item without an item type. Cast to an ITaskItem, this is 
            what is given to tasks. It is also used for target outputs.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._definingFileEscaped">
            <summary>
            The source file that defined this item.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._includeEscaped">
            <summary>
            Evaluated include, escaped as necessary.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._includeBeforeWildcardExpansionEscaped">
            <summary>
            The evaluated (escaped) include prior to wildcard expansion.  Used to determine the
            RecursiveDir build-in metadata value.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._directMetadata">
            <summary>
            Evaluated metadata.
            May be null.
            </summary>
            <remarks>
            Lazily created, as there are huge numbers of items generated in
            a build that have no metadata at all.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._fullPath">
            <summary>
            Cached value of the fullpath metadata. All other metadata are computed on demand.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._itemDefinitions">
            <summary>
            All the item definitions that apply to this item, in order of
            decreasing precedence. At the bottom will be an item definition
            that directly applies to the item type that produced this item. The others will
            be item definitions inherited from items that were
            used to create this item.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._projectDirectory">
            <summary>
            Directory of the associated project. If this is available,
            it is used to calculate built-in metadata. Otherwise,
            the current directory is used.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem._isImmutable">
            <summary>
            Whether the task item is immutable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of this class given the item-spec.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.#ctor(System.String,System.String,Microsoft.Build.Collections.CopyOnWritePropertyDictionary{Microsoft.Build.Execution.ProjectMetadataInstance},System.Collections.Generic.List{Microsoft.Build.Execution.ProjectItemDefinitionInstance},System.String,System.Boolean,System.String)">
            <summary>
            Creates an instance of this class given the item-spec and a built-in metadata collection.
            Parameters are assumed to be ALREADY CLONED.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.#ctor(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Creates a task item by copying the information from a <see cref="T:Microsoft.Build.Execution.ProjectItemInstance"/>.
            Parameters are cloned.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.#ctor">
            <summary>
            Constructor for deserialization only.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.#ctor(Microsoft.Build.Execution.ProjectItemInstance.TaskItem,System.Boolean)">
            <summary>
            Creates an instance of this class given the backing item.
            Does not copy immutability, since there is no connection with the original.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor used for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.#ctor(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Collections.LookasideStringInterner)">
            <summary>
            Private constructor used for serialization.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ItemSpec">
            <summary>
            Gets or sets the unescaped include, or "name", for the item.
            </summary>
            <comments>
            This one is a bit tricky.  Orcas assumed that the value being set was escaped, but 
            that the value being returned was unescaped.  Maintain that behaviour here.  To get
            the escaped value, use ITaskItem2.EvaluatedIncludeEscaped. 
            </comments>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Framework#ITaskItem2#EvaluatedIncludeEscaped">
            <summary>
            Gets or sets the escaped include, or "name", for the item.
            </summary>
            <remarks>
            Taking the opportunity to fix the property name, although this doesn't
            make it obvious it's an improvement on ItemSpec.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.MetadataNames">
            <summary>
            Gets the names of metadata on the item.
            Includes all built-in metadata.
            Computed, not necessarily fast.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.MetadataCount">
            <summary>
            Gets the number of metadata set on the item.
            Computed, not necessarily fast.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.CustomMetadataNames">
            <summary>
            Gets the names of custom metadata on the item.
            If there is none, returns an empty collection.
            Does not include built-in metadata.
            Computed, not necessarily fast.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.CustomMetadataCount">
            <summary>
            Gets the number of custom metadata set on the item.
            Does not include built-in metadata.
            Computed, not necessarily fast.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Evaluation#IItem#EvaluatedInclude">
            <summary>
            Gets the evaluated include for this item, unescaped.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Evaluation#IItem#EvaluatedIncludeEscaped">
            <summary>
            Gets the evaluated include for this item, escaped.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Evaluation#IItem#ProjectDirectory">
            <summary>
            The directory of the project owning this TaskItem.
            May be null if this is not well defined.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Returns some value useful for a key in a dictionary
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.IncludeEscaped">
            <summary>
            The escaped include for this item
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.IncludeBeforeWildcardExpansionEscaped">
            <summary>
            The value of the include after evaluation but before wildcard expansion.
            Used to determine %(RecursiveDir)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.DirectMetadataCount">
            <summary>
            Number of pieces of metadata directly on this item
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.MetadataCollection">
            <summary>
            Unordered collection of evaluated metadata on the item.
            If there is no metadata, returns an empty collection.
            Does not include built-in metadata.
            Includes any from item definitions not masked by directly set metadata.
            This is a read-only collection. To modify the metadata, use <see cref="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.SetMetadata(System.String,System.String)"/>.
            Computed, not necessarily fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.op_Explicit(Microsoft.Build.Execution.ProjectItemInstance.TaskItem)~System.String">
            <summary>
            This allows an explicit typecast from a "TaskItem" to a "string", returning the ItemSpec for this item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.op_Equality(Microsoft.Build.Execution.ProjectItemInstance.TaskItem,Microsoft.Build.Execution.ProjectItemInstance.TaskItem)">
            <summary>
            The equivalence operator.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>True if the items are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.op_Inequality(Microsoft.Build.Execution.ProjectItemInstance.TaskItem,Microsoft.Build.Execution.ProjectItemInstance.TaskItem)">
            <summary>
            The non-equivalence operator.
            </summary>
            <param name="left">The left hand operand.</param>
            <param name="right">The right hand operand.</param>
            <returns>False if the items are equivalent, true otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ToString">
            <summary>
            Produce a string representation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.InitializeLifetimeService">
            <summary>
            Overridden to give this class infinite lease time. Otherwise we end up with a limited
            lease (5 minutes I think) and instances can expire if they take long time processing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Evaluation#IItem#GetMetadataValue(System.String)">
            <summary>
            Returns the metadata with the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Evaluation#IItem#GetMetadataValueEscaped(System.String)">
            <summary>
            Returns the escaped value of the metadata with the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Framework#ITaskItem2#GetMetadataValueEscaped(System.String)">
            <summary>
            Returns the escaped value of the metadata with the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Evaluation#IItem{Microsoft#Build#Execution#ProjectMetadataInstance}#GetMetadata(System.String)">
            <summary>
            Gets any existing ProjectMetadata on the item, or
            else any on an applicable item definition.
            This is ONLY called during evaluation.
            </summary>
            <remarks>
            Evaluation never creates ITaskItems, so this should never be called.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Evaluation#IItem{Microsoft#Build#Execution#ProjectMetadataInstance}#SetMetadata(Microsoft.Build.Construction.ProjectMetadataElement,System.String)">
            <summary>
            Set metadata
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.GetMetadata(System.String)">
            <summary>
            ITaskItem implementation which returns the specified metadata value, unescaped.
            If metadata is not defined, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.GetMetadataEscaped(System.String)">
            <summary>
            Returns the specified metadata value, escaped.
            If metadata is not defined, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.SetMetadata(System.String,System.String)">
            <summary>
            ITaskItem implementation which sets metadata.
            </summary>
            <comments>
            The value is assumed to be escaped. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Framework#ITaskItem2#SetMetadataValueLiteral(System.String,System.String)">
            <summary>
            ITaskItem2 implementation which sets the literal value of metadata -- it is escaped 
            internally as necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.RemoveMetadata(System.String)">
            <summary>
            ITaskItem implementation which removed the named piece of metadata.
            If the metadata is not present, does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem)">
            <summary>
            ITaskItem implementation which copies the metadata on this item to the specified item.
            Does not copy built-in metadata, and will not overwrite existing, non-empty metadata.
            If the destination implements ITaskItem2, this avoids losing the escaped nature of values.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem,System.Boolean)">
            <summary>
            ITaskItem implementation which copies the metadata on this item to the specified item.
            Copies direct and item definition metadata.
            Does not copy built-in metadata, and will not overwrite existing, non-empty metadata.
            If the destination implements ITaskItem2, this avoids losing the escaped nature of values.
            
            When copying metadata to a task item which can be accessed from a task (Utilities task item)
            this method will merge and expand any metadata originating with item definitions.
            </summary>
            <param name="destinationItem">destination item to copy the metadata from this to</param>
            <param name="addOriginalItemSpec">Whether the OriginalItemSpec should be added as a piece 
            of magic metadata. For copying of items this is useful but for cloning of items this adds 
            additional metadata which is not useful because the OriginalItemSpec will always be identical 
            to the ItemSpec, and the addition will and will cause copy-on-write to trigger.
            </param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.CloneCustomMetadata">
            <summary>
            ITaskItem implementation which returns a clone of the metadata on this object.
            Values returned are unescaped. To get the original escaped values, use ITaskItem2.CloneCustomMetadataEscaped instead.
            </summary>
            <returns>The cloned metadata.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#Framework#ITaskItem2#CloneCustomMetadataEscaped">
            <summary>
            ITaskItem2 implementation which returns a clone of the metadata on this object.
            Values returned are in their original escaped form. 
            </summary>
            <returns>The cloned metadata.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            Built-in metadata is not transmitted, but other metadata is.
            Does not lose escaped nature.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.GetHashCode">
            <summary>
            Override of GetHashCode.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Equals(System.Object)">
            <summary>
            Override of Equals
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.Equals(Microsoft.Build.Execution.ProjectItemInstance.TaskItem)">
            <summary>
            Test for item equivalence.  Items are equivalent if their item specs are the same,
            and they have the same custom metadata, case insensitive.
            </summary>
            <comments>
            The metadata value check has to be case insensitive as batching bucketing is case
            insensitive.
            </comments>
            <param name="other">The item against which to compare.</param>
            <returns>True if the items are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.HasMetadata(System.String)">
            <summary>
            Returns true if a particular piece of metadata is defined on this item (even if
            its value is empty string) otherwise false.
            This includes built-in metadata and metadata from item definitions.
            </summary>
            <remarks>
            It has to include all of these because it's used for batching, which doesn't
            care where the metadata originated.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.SetMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Add a metadata with the specified names and values.
            Overwrites any metadata with the same name already in the collection.
            </summary>
            <comments>
            Assumes that metadataDictionary contains escaped values
            </comments>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Collections.LookasideStringInterner)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TranslateWithInterning(Microsoft.Build.BackEnd.ITranslator,Microsoft.Build.Collections.LookasideStringInterner)">
            <summary>
            Reads or writes the task item to the translator using an interner for metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.GetMetadataObject(System.String)">
            <summary>
            Gets any metadata with the specified name.
            Does not include built-in metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.SetMetadata(Microsoft.Build.Collections.CopyOnWritePropertyDictionary{Microsoft.Build.Execution.ProjectMetadataInstance})">
            <summary>
            Add a metadata with the specified name and value.
            Overwrites any metadata with the same name already in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.SetMetadataObject(System.String,System.String,System.Boolean)">
            <summary>
            Add a metadata with the specified name and value.
            Overwrites any metadata with the same name already in the collection.
            Does not allow built-in metadata unless allowItemSpecModifiers is set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.SetMetadataOnTaskOutput(System.String,System.String)">
            <summary>
            Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
            This is not normally legal to set outside of evaluation. However, the CreateItem
            needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
            tasks to set this particular metadata as a task output.
            Other built in metadata names are ignored. That's because often task outputs are items that were passed in,
            which legally have built-in metadata. If necessary we can calculate it on the new items we're making if requested.
            We don't copy them too because tasks shouldn't set them (they might become inconsistent)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.DeepClone">
            <summary>
            Deep clone this into another TaskItem
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.DeepClone(System.Boolean)">
            <summary>
            Deep clone this into another TaskItem
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.GetBuiltInMetadataEscaped(System.String)">
            <summary>
            Helper to get the value of a built-in metadatum with
            the specified name, if any.
            If value is not available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.GetItemDefinitionMetadata(System.String)">
            <summary>
            Retrieves the named metadata from the item definition, if any.
            If it is not present, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory">
            <summary>
            A class factory for instance model items.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory._project">
            <summary>
            The project to which item instances created by this factory will belong.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.#ctor(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Constructor not taking an item type.
            This indicates that the user of this factory should set the item type
            on it before using it to create items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.#ctor(Microsoft.Build.Execution.ProjectInstance,System.String)">
            <summary>
            Constructor taking the itemtype for the generated items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.ItemType">
            <summary>
            The item type that generated items should have
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.ItemElement">
            <summary>
            Sets the item type via the item xml.
            Used by the evaluator only.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.CreateItem(System.String,System.String)">
            <summary>
            Creates an instance-model item.
            </summary>
            <param name="include">The include.</param>
            <param name="definingProject">The project that defined the item.</param>
            <returns>A new instance item.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.CreateItem(Microsoft.Build.Execution.ProjectItemInstance,System.String)">
            <summary>
            Create a ProjectItemInstance, changing the item type but keeping the include.
            This is to support the scenario Include="@(i)" where we are copying
            metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.CreateItem(System.String,Microsoft.Build.Execution.ProjectItemInstance,System.String)">
            <summary>
            Create a ProjectItemInstance, changing the item type and include but retaining the
            metadata of the original item.
            This is to support this scenario: Include="@(i->'xxx')"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.CreateItem(System.String,System.String,System.String)">
            <summary>
            Create a new item from the specified include and include before wildcard expansion.
            This is to support the scenario Include="@(i)" where we are creating new items before adding metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.SetMetadata(System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{Microsoft.Build.Construction.ProjectMetadataElement,System.String}},System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Applies the supplied metadata to the destination item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory.CreateItem(System.String,System.String,Microsoft.Build.Execution.ProjectItemInstance,System.String)">
            <summary>
            Create a ProjectItemInstance from another item, changing the item type and include.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory">
            <summary>
            A class factory for task items.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.s_instance">
            <summary>
            The singleton instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.#ctor">
            <summary>
            Private constructor for singleton creation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.ItemType">
            <summary>
            The item type of items created by this factory.
            Since TaskItems don't have an item type, this returns null, and cannot be set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.ItemElement">
            <summary>
            The item xml for items in this factory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.Instance">
            <summary>
            The singleton instance. Can be cast to the interface required.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.CreateItem(System.String,System.String)">
            <summary>
            Creates a taskitem.
            </summary>
            <param name="includeEscaped">The include.</param>
            <param name="definingProject">The project that defined the item.</param>
            <returns>A new instance item.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.CreateItem(Microsoft.Build.Evaluation.ProjectItem,System.String)">
            <summary>
            Creates a task item from a ProjectItem
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.CreateItem(System.String,Microsoft.Build.Evaluation.ProjectItem,System.String)">
            <summary>
            Creates a task item from a ProjectItem but changing the itemspec
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.CreateItem(Microsoft.Build.Execution.ProjectItemInstance,System.String)">
            <summary>
            Create a task item from a ProjectItemInstance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.CreateItem(System.String,Microsoft.Build.Execution.ProjectItemInstance,System.String)">
            <summary>
            Creates a task item from a ProjectItem
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.CreateItem(System.String,System.String,System.String)">
            <summary>
            Creates a task item using the specified include and include before wildcard expansion.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory.SetMetadata(System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{Microsoft.Build.Construction.ProjectMetadataElement,System.String}},System.Collections.Generic.IEnumerable{Microsoft.Build.Execution.ProjectItemInstance.TaskItem})">
            <summary>
            Applies the supplied metadata to the destination item.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.BuiltInMetadataTable">
            <summary>
            Implementation of IMetadataTable that can be passed to expander to expose only built-in metadata on this item.
            Built-in metadata is stored in a separate table so it can be cleared out when the item is renamed, as this invalidates the values.
            Also, more importantly, because typically the same regular metadata values can be shared by many items, 
            and keeping item-specific metadata out of it could allow it to be implemented as a copy-on-write table.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.BuiltInMetadataTable._itemType">
            <summary>
            Item type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.BuiltInMetadataTable._item">
            <summary>
            Backing item
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.BuiltInMetadataTable.#ctor(System.String,Microsoft.Build.Execution.ProjectItemInstance.TaskItem)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.BuiltInMetadataTable.GetEscapedValue(System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name specified.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.BuiltInMetadataTable.GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If item type is null, it is ignored.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.TaskItem.BuiltInMetadataTable.GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Returns the value if it exists, null otherwise.
            If item type is null, it is ignored.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectItemInstance.ProjectItemInstanceEqualityComparer">
            <summary>
            Implementation of a comparer that determines equality between ProjectItemInstances
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectItemInstance.ProjectItemInstanceEqualityComparer.s_comparer">
            <summary>
            The singleton comparer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.ProjectItemInstanceEqualityComparer.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectItemInstance.ProjectItemInstanceEqualityComparer.Default">
            <summary>
            Returns the default comparer instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.ProjectItemInstanceEqualityComparer.Equals(Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Implemtnation of IEqualityComparer.Equals.
            </summary>
            <param name="x">The left hand side.</param>
            <param name="y">The right hand side.</param>
            <returns>True of the instances are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectItemInstance.ProjectItemInstanceEqualityComparer.GetHashCode(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Implementation of IEqualityComparer.GetHashCode.
            </summary>
            <param name="obj">The item instance.</param>
            <returns>The hash code of the instance.</returns>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectMetadataInstance">
            <summary>
            Wraps an evaluated piece of metadata for build purposes
            Added and removed via methods on the ProjectItemInstance object.
            IMMUTABLE OBJECT.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectMetadataInstance._name">
            <summary>
            Name of the metadatum
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectMetadataInstance._escapedValue">
            <summary>
            Evaluated value
            Never null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.#ctor(System.String,System.String)">
            <summary>
            Constructor for metadata.
            Does not allow item spec modifiers.
            Discards the location of the original element. This is not interesting in the Execution world
            as it should never be needed for any subsequent messages, and is just extra bulk.
            IMMUTABLE OBJECT.
            </summary>
            <remarks>
            Not public since the only creation scenario is setting on an item
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor for metadata.
            Called when a ProjectInstance is created, before the build
            when virtual items are added, and during the build when tasks
            emit items.
            Discards the location of the original element. This is not interesting in the Execution world
            as it should never be needed for any subsequent messages, and is just extra bulk.
            IMMUTABLE OBJECT.
            If the value passed in is null, will be changed to String.Empty.
            </summary>
            <remarks>
            Not public since the only creation scenario is setting on an item
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.#ctor(Microsoft.Build.Evaluation.ProjectMetadata)">
            <summary>
            Constructor for metadata from a ProjectMetadata.
            Called when a ProjectInstance is created.
            IMMUTABLE OBJECT.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor used for serialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectMetadataInstance.Name">
            <summary>
            Name of the metadata
            </summary>
            <remarks>
            This cannot be set, as it is used as the key into 
            the item's metadata table.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValue">
            <summary>
            Evaluated value of the metadatum. 
            Never null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectMetadataInstance.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the metadatum name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectMetadataInstance.Microsoft#Build#Collections#IValued#EscapedValue">
            <summary>
            Implementation of IValued
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValueEscaped">
            <summary>
            Evaluated and escaped value of the metadata.
            Never null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.ToString">
            <summary>
            String representation handy for tracing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.System#IEquatable{Microsoft#Build#Execution#ProjectMetadataInstance}#Equals(Microsoft.Build.Execution.ProjectMetadataInstance)">
            <summary>
            Compares this metadata to another for equivalence.
            </summary>
            <param name="other">The other metadata</param>
            <returns>True if they are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.DeepClone">
            <summary>
            Deep clone the metadata
            Strings are immutable (copy on write) so there is no work to do.
            Allows built-in metadata names, as they are still valid on the new metadatum.
            </summary>
            <returns>A new metadata instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectMetadataInstance.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectOnErrorInstance">
            <summary>
            Wraps an onerror element
            </summary>
            <remarks>
            This is an immutable class
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectOnErrorInstance._executeTargets">
            <summary>
            Unevaluated executetargets value.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectOnErrorInstance._condition">
            <summary>
            Condition on the element.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectOnErrorInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectOnErrorInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectOnErrorInstance._executeTargetsLocation">
            <summary>
            Location of the executeTargets attribute
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectOnErrorInstance.#ctor(System.String,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Constructor called by Evaluator.
            All parameters are in the unevaluated state.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectOnErrorInstance.Condition">
            <summary>
            Unevaluated condition.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargets">
            <summary>
            Unevaluated ExecuteTargets value.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectOnErrorInstance.Location">
            <summary>
            Location of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectOnErrorInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargetsLocation">
            <summary>
            Location of the execute targets attribute, if any
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance">
            <summary>
            Wraps an unevaluated propertygroup under a target.
            Immutable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance._condition">
            <summary>
            Condition, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance._properties">
            <summary>
            Child properties.
            Not ProjectPropertyInstances, as these are evaluated during the build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.#ctor(System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,System.Collections.Generic.List{Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance})">
            <summary>
            Constructor called by the Evaluator.
            Assumes ProjectPropertyGroupTaskPropertyInstance is an immutable type.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.#ctor(Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance)">
            <summary>
            Cloning constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Condition">
            <summary>
            Condition, if any.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Properties">
            <summary>
            Child properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Location">
            <summary>
            Location of the element itself
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.DeepClone">
            <summary>
            Deep clone
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance">
            <summary>
            Wraps an unevaluated property under an propertygroup in a target.
            Immutable.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance._name">
            <summary>
            Name of the property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance._value">
            <summary>
            Unevaluated value
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance._condition">
            <summary>
            Unevaluated condition
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.#ctor(System.String,System.String,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Constructor called by the Evaluator.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.#ctor(Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance)">
            <summary>
            Cloning constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Name">
            <summary>
            Property name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Value">
            <summary>
            Unevaluated value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Condition">
            <summary>
            Unevaluated condition value
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.DeepClone">
            <summary>
            Deep clone
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectPropertyInstance">
            <summary>
            Wraps an evaluated property for build purposes.
            Added and removed via methods on the ProjectInstance object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyInstance._name">
            <summary>
            Name of the property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectPropertyInstance._escapedValue">
            <summary>
            Evaluated value: stored escaped. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.#ctor(System.String,System.String)">
            <summary>
            Private constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyInstance.Name">
            <summary>
            Name of the property
            </summary>
            <remarks>
            This cannot be set, as it is used as the key into 
            the project's properties table.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue">
            <summary>
            Evaluated value of the property.
            Setter assumes caller has protected global properties, if necessary
            SETTER ASSUMES CALLER ONLY CALLS IF PROJECTINSTANCE IS MUTABLE because it cannot always be verified.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyInstance.IsImmutable">
            <summary>
            Whether this object is immutable.
            An immutable object can not be made mutable.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyInstance.Microsoft#Build#Evaluation#IProperty#EvaluatedValueEscaped">
            <summary>
            Evaluated value of the property, escaped as necessary.
            Setter assumes caller has protected global properties, if necessary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyInstance.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the property name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyInstance.Microsoft#Build#Collections#IValued#EscapedValue">
            <summary>
            Implementation of IValued
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.System#IEquatable{Microsoft#Build#Execution#ProjectPropertyInstance}#Equals(Microsoft.Build.Execution.ProjectPropertyInstance)">
            <summary>
            Compares this property to another for equivalence.
            </summary>
            <param name="other">The other property.</param>
            <returns>True if the properties are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Microsoft#Build#Collections#IDeepCloneable{Microsoft#Build#Execution#ProjectPropertyInstance}#DeepClone">
            <summary>
            Performs a deep clone
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.ToString">
            <summary>
            String representation handy for tracing
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(System.String,System.String)">
            <summary>
            Called before the build when virtual properties are added, 
            and during the build when tasks emit properties.
            If name is invalid or reserved, throws ArgumentException.
            Creates mutable object.
            </summary>
            <remarks>
            Not public since the only creation scenario is setting on a project.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(System.String,System.String,System.Boolean)">
            <summary>
            Called before the build when virtual properties are added, 
            and during the build when tasks emit properties.
            If name is invalid or reserved, throws ArgumentException.
            Creates mutable object.
            </summary>
            <remarks>
            Not public since the only creation scenario is setting on a project.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Called by the Evaluator during creation of the ProjectInstance.
            Reserved properties can be set with this constructor using the appropriate flag.
            This flags should ONLY be set by the evaluator or by cloning; after the ProjectInstance is created, they must be illegal.
            If name is invalid or reserved, throws ArgumentException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(System.String,System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Called during project build time to create a property.  Reserved properties will cause
            an invalid project file exception.
            Creates mutable object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(System.String,System.String,Microsoft.Build.Construction.ElementLocation,System.Boolean)">
            <summary>
            Called during project build time to create a property.  Reserved properties will cause
            an invalid project file exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(Microsoft.Build.Execution.ProjectPropertyInstance)">
            <summary>
            Cloning constructor.
            Strings are immutable (copy on write) so there is no work to do
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(Microsoft.Build.Execution.ProjectPropertyInstance,System.Boolean)">
            <summary>
            Cloning constructor.
            Strings are immutable (copy on write) so there is no work to do
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.DeepClone">
            <summary>
            Performs a deep clone
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.DeepClone(System.Boolean)">
            <summary>
            Performs a deep clone, optionally changing mutability
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.ToProjectPropertyElement(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Creates a ProjectPropertyElement representing this instance.
            </summary>
            <param name="parent">The root element to which this element will belong.</param>
            <returns>The new element.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.Create(System.String,System.String,System.Boolean,Microsoft.Build.Construction.ElementLocation,System.Boolean)">
            <summary>
            Private constructor which throws the right sort of exception depending on whether it is invoked as a result of
            a design-time or build-time call.
            Discards the location of the original element after error checking. This is not interesting in the Execution world
            as it should never be needed for any subsequent messages, and is just extra bulk.
            Inherits mutability from project if any.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectPropertyInstance.ProjectPropertyInstanceImmutable">
            <summary>
            Version of the class that's immutable.
            Could have a single class with a boolean field, but there are large numbers of these
            so it's important to avoid adding another field. Both types of objects are 16 bytes instead of 20.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectPropertyInstance.ProjectPropertyInstanceImmutable.#ctor(System.String,System.String)">
            <summary>
            Private constructor.
            Called by outer class factory method.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectPropertyInstance.ProjectPropertyInstanceImmutable.IsImmutable">
            <summary>
            Whether this object can be changed.
            An immutable object can not be made mutable.
            </summary>
            <remarks>
            Usually gotten from the parent ProjectInstance.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectTargetInstance">
            <summary>
            Wraps a target element
            </summary>
            <remarks>
            This is an immutable class.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._name">
            <summary>
            Name of the target
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._condition">
            <summary>
            Condition on the target. 
            Evaluated during the build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._inputs">
            <summary>
            Inputs on the target
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._outputs">
            <summary>
            Outputs on the target
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._returns">
            <summary>
            Return values on the target. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._dependsOnTargets">
            <summary>
            Semicolon separated list of targets it depends on
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._beforeTargets">
            <summary>
            Semicolon separated list of targets it runs before
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._afterTargets">
            <summary>
            Semicolon separated list of targets it runs after
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._keepDuplicateOutputs">
            <summary>
            Condition for whether to trim duplicate outputs
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._onErrorChildren">
            <summary>
            Child entries of the target which refer to OnError targets
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._parentProjectSupportsReturnsAttribute">
            <summary>
            Whether the project file that this target lives in has at least one target
            with a Returns attribute on it.  If so, the default behaviour for all targets
            in the file without Returns attributes changes from returning the Outputs, to 
            returning nothing. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._inputsLocation">
            <summary>
            Location of the inputs attribute, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._outputsLocation">
            <summary>
            Location of the outputs attribute, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._returnsLocation">
            <summary>
            Location of the returns attribute, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._keepDuplicateOutputsLocation">
            <summary>
            Location of KeepDuplicateOutputs attribute, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._dependsOnTargetsLocation">
            <summary>
            Location of the DependsOnTargets attribute ,if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._beforeTargetsLocation">
            <summary>
            Location of the BeforeTargets attribute ,if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._afterTargetsLocation">
            <summary>
            Location of the AfterTargets attribute ,if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTargetInstance._children">
            <summary>
            Child tasks below the target (both regular tasks and "intrinsic tasks" like ItemGroup and PropertyGroup).
            This is a read-only list unless the instance has been modified using AddTask.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTargetInstance.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Build.Execution.ProjectTargetInstanceChild},System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Build.Execution.ProjectOnErrorInstance},System.Boolean)">
            <summary>
            Constructor called by Evaluator.
            All parameters are in the unevaluated state.
            All location parameters may be null if not applicable, except for the main location parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Name">
            <summary>
            Name of the target
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Condition">
            <summary>
            Unevaluated condition on the task.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Inputs">
            <summary>
            Unevaluated inputs on the target element.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Outputs">
            <summary>
            Unevaluated outputs on the target element
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Returns">
            <summary>
            Unevaluated return values on the target element
            May be empty string or null, if no return value is specified.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputs">
            <summary>
            Unevaluated condition on which we will trim duplicate outputs from the target outputs
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargets">
            <summary>
            Unevaluated semicolon separated list of targets it depends on.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargets">
            <summary>
            Unevaluated semicolon separated list of targets it runs before.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.AfterTargets">
            <summary>
            Unevaluated semicolon separated list of targets it runs after.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Children">
            <summary>
            Children below the target. The build iterates through this to get each task to execute.
            This is an ordered collection.
            This is a read-only list; the ProjectTargetInstance class is immutable.
            This collection does not contain the OnError target references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.OnErrorChildren">
            <summary>
            The children below the target which refer to OnError targets.
            This is an ordered collection.
            This is a read-only list; the ProjectTargetInstance class is immutable.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Tasks">
            <summary>
            Just the tasks below this target, if any.
            Other kinds of children are not included.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.FullPath">
            <summary>
            Full path to the file from which this target originated.
            If it originated in a project that was not loaded and has never been 
            given a path, returns an empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.InputsLocation">
            <summary>
            Location of the inputs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.OutputsLocation">
            <summary>
            Location of the outputs
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.ReturnsLocation">
            <summary>
            Location of the returns
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputsLocation">
            <summary>
            Location of the KeepDuplicatOutputs attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargetsLocation">
            <summary>
            Location of the dependsOnTargets
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargetsLocation">
            <summary>
            Location of the beforeTargets
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.AfterTargetsLocation">
            <summary>
            Location of the afterTargets
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the target name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTargetInstance.ParentProjectSupportsReturnsAttribute">
            <summary>
            Whether the project file that this target lives in has at least one target
            with a Returns attribute on it.  If so, the default behaviour for all targets
            in the file without Returns attributes changes from returning the Outputs, to 
            returning nothing. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTargetInstance.ToProjectTargetElement(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates a ProjectTargetElement representing this instance.  Attaches it to the specified root element.
            </summary>
            <param name="rootElement">The root element to which the new element will belong.</param>
            <returns>The new element.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTargetInstance.AddProjectTargetInstanceChild(Microsoft.Build.Execution.ProjectTargetInstanceChild)">
            <summary> Adds new child instance. </summary>
            <param name="projectTargetInstanceChild"> Child instance. </param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTargetInstance.AddTask(System.String,System.String,System.String)">
            <summary>
            Creates a new task and adds it to the end of the list of tasks.
            </summary>
            <param name="taskName">The name of the task to create.</param>
            <param name="condition">The task's condition.</param>
            <param name="continueOnError">The continue on error flag.</param>
            <returns>The new task instance.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTargetInstance.AddTask(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new task and adds it to the end of the list of tasks.
            </summary>
            <param name="taskName">The name of the task to create.</param>
            <param name="condition">The task's condition.</param>
            <param name="continueOnError">The continue on error flag.</param>
            <param name="msbuildRuntime">The MSBuild runtime.</param>
            <param name="msbuildArchitecture">The MSBuild architecture.</param>
            <returns>The new task instance.</returns>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectTaskInstance">
            <summary>
            Wraps a task element
            </summary>
            <remarks>
            This is an immutable class
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._name">
            <summary>
            Name of the task, possibly qualified, as it appears in the project
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._condition">
            <summary>
            Condition on the task, if any
            May be empty string
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._continueOnError">
            <summary>
            Continue on error on the task, if any
            May be empty string
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._msbuildRuntime">
            <summary>
            Runtime on the task, if any
            May be empty string
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._msbuildArchitecture">
            <summary>
            Architecture on the task, if any
            May be empty string
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._parameters">
            <summary>
            Unordered set of task parameter names and unevaluated values.
            This is a dead, read-only collection.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._outputs">
            <summary>
            Output properties and items below this task. This is an ordered collection
            as one may depend on another.
            This is a dead, read-only collection.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._location">
            <summary>
            Location of this element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._conditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._continueOnErrorLocation">
            <summary>
            Location of the continueOnError attribute, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._msbuildRuntimeLocation">
            <summary>
            Location of the MSBuildRuntime attribute, if any
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskInstance._msbuildArchitectureLocation">
            <summary>
            Location of the MSBuildArchitecture attribute, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskInstance.#ctor(Microsoft.Build.Construction.ProjectTaskElement,System.Collections.Generic.IList{Microsoft.Build.Execution.ProjectTaskInstanceChild})">
            <summary>
            Constructor called by Evaluator.
            All parameters are in the unevaluated state.
            Locations other than the main location may be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskInstance.#ctor(System.String,Microsoft.Build.Construction.ElementLocation,System.String,System.String,System.String,System.String)">
            <summary>
                Creates a new task instance directly.  Used for generating instances on-the-fly.
            </summary>
            <param name="name">The task name.</param>
            <param name="location">The location for this task.</param>
            <param name="condition">The unevaluated condition.</param>
            <param name="continueOnError">The unevaluated continue on error.</param>
            <param name="msbuildRuntime">The MSBuild runtime.</param>
            <param name="msbuildArchitecture">The MSBuild architecture.</param>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.Name">
            <summary>
            Name of the task, possibly qualified, as it appears in the project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.Condition">
            <summary>
            Unevaluated condition on the task
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnError">
            <summary>
            Unevaluated ContinueOnError on the task.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntime">
            <summary>
            Unevaluated MSBuildRuntime on the task.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitecture">
            <summary>
            Unevaluated MSBuildArchitecture on the task.
            May be empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.Parameters">
            <summary>
            Read-only dead unordered set of task parameter names and unevaluated values.
            Condition and ContinueOnError, which have their own properties, are not included in this collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.Outputs">
            <summary>
            Ordered set of output property and item objects.
            This is a read-only dead collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnErrorLocation">
            <summary>
            Location of the ContinueOnError attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntimeLocation">
            <summary>
            Location of the MSBuildRuntime attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitectureLocation">
            <summary>
            Location of the MSBuildArchitecture attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskInstance.ParametersForBuild">
            <summary>
            Retrieves the parameters dictionary as used during the build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskInstance.GetParameter(System.String)">
            <summary>
            Returns the value of a named parameter, or null if there is no such parameter.
            </summary>
            <param name="parameterName">The name of the parameter to retrieve.</param>
            <returns>The parameter value, or null if it does not exist.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskInstance.SetParameter(System.String,System.String)">
            <summary>
            Sets the unevaluated value for the specified parameter.
            </summary>
            <param name="parameterName">The name of the parameter to set.</param>
            <param name="unevaluatedValue">The unevaluated value for the parameter.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskInstance.AddOutputItem(System.String,System.String,System.String)">
            <summary>
            Adds an output item to the task.
            </summary>
            <param name="taskOutputParameterName">The name of the parameter on the task which produces the output.</param>
            <param name="itemName">The item which will receive the output.</param>
            <param name="condition">The condition.</param>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskInstance.AddOutputProperty(System.String,System.String,System.String)">
            <summary>
            Adds an output property to the task.
            </summary>
            <param name="taskOutputParameterName">The name of the parameter on the task which produces the output.</param>
            <param name="propertyName">The property which will receive the output.</param>
            <param name="condition">The condition.</param>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectTaskOutputItemInstance">
            <summary>
            Wraps an output item element under a task element
            </summary>
            <remarks>
            Immutable.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputItemInstance._itemType">
            <summary>
            Name of the property to put the output in
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputItemInstance._taskParameter">
            <summary>
            Property on the task class to retrieve the output from
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputItemInstance._condition">
            <summary>
            Condition on the output element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputItemInstance._location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputItemInstance._itemTypeLocation">
            <summary>
            Location of the original item type attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputItemInstance._taskParameterLocation">
            <summary>
            Location of the original task parameter attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputItemInstance._conditionLocation">
            <summary>
            Location of the original condition attribute
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.#ctor(System.String,System.String,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Constructor called by evaluator
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemType">
            <summary>
            Name of the item type that the outputs go into
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameter">
            <summary>
            Property on the task class to retrieve the outputs from
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Condition">
            <summary>
            Condition on the element.
            If there is no condition, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameterLocation">
            <summary>
            Location of the TaskParameter attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemTypeLocation">
            <summary>
            Location of the ItemType attribute
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance">
            <summary>
            Represents an output property element beneath a task element
            </summary>
            <remarks>
            Immutable.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance._propertyName">
            <summary>
            Name of the property to put the output in
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance._taskParameter">
            <summary>
            Property on the task class to retrieve the output from
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance._condition">
            <summary>
            Condition on the output element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance._location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance._propertyNameLocation">
            <summary>
            Location of the original property name attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance._taskParameterLocation">
            <summary>
            Location of the original task parameter attribute
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance._conditionLocation">
            <summary>
            Location of the original condition attribute
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.#ctor(System.String,System.String,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Constructor called by Evaluator
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyName">
            <summary>
            Name of the property to put the output in
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameter">
            <summary>
            Property on the task class to retrieve the output from
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Condition">
            <summary>
            Condition on the output element.
            If there is no condition, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyNameLocation">
            <summary>
            Location of the original PropertyName attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Location">
            <summary>
            Location of the original element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.ConditionLocation">
            <summary>
            Location of the condition, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameterLocation">
            <summary>
            Location of the TaskParameter attribute
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TaskFactoryWrapper">
            <summary>
            This class packages information about task which has been loaded from a task factory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskFactoryWrapper._taskFactory">
            <summary>
            Factory which is wrapped by the wrapper
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskFactoryWrapper._namesOfPropertiesWithRequiredAttribute">
            <summary>
            Cache of names of required properties on this type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskFactoryWrapper._namesOfPropertiesWithOutputAttribute">
            <summary>
            Cache of names of output properties on this type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskFactoryWrapper._namesOfPropertiesWithAmbiguousMatches">
            <summary>
            Cache of names of properties on this type whose names are ambiguous
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskFactoryWrapper._propertyInfoCache">
            <summary>
            Cache of PropertyInfos for this type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskFactoryWrapper._taskName">
            <summary>
            The name of the task this factory can create.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskFactoryWrapper._factoryIdentityParameters">
            <summary>
            The set of special parameters that, along with the name, contribute to the identity of 
            this factory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskFactoryWrapper.#ctor(Microsoft.Build.Framework.ITaskFactory,Microsoft.Build.Shared.LoadedType,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Creates an instance of this class for the given type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskFactoryWrapper.TaskFactoryLoadedType">
            <summary>
            Load information about the task factory itself
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskFactoryWrapper.TaskFactory">
            <summary>
            The task factory wrapped by the wrapper
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskFactoryWrapper.GetNamesOfPropertiesWithRequiredAttribute">
            <summary>
            Gets the list of names of public instance properties that have the required attribute applied.
            Caches the result - since it can't change during the build.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskFactoryWrapper.GetNamesOfPropertiesWithOutputAttribute">
            <summary>
            Gets the list of names of public instance properties that have the output attribute applied.
            Caches the result - since it can't change during the build.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskFactoryWrapper.Name">
            <summary>
            Get the name of the factory wrapped by the wrapper
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskFactoryWrapper.FactoryIdentityParameters">
            <summary>
            The set of task identity parameters that were set on 
            this particular factory's UsingTask statement. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskFactoryWrapper.GetProperty(System.String)">
            <summary>
            Get the cached propertyinfo of the given name
            </summary>
            <param name="propertyName">property name</param>
            <returns>PropertyInfo</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskFactoryWrapper.SetPropertyValue(Microsoft.Build.Framework.ITask,Microsoft.Build.Framework.TaskPropertyInfo,System.Object)">
            <summary>
            Sets the given property on the task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskFactoryWrapper.GetPropertyValue(Microsoft.Build.Framework.ITask,Microsoft.Build.Framework.TaskPropertyInfo)">
            <summary>
            Gets the value of a given property on the given task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskFactoryWrapper.IsCreatableByFactory(System.String)">
            <summary>
            Determines whether a task with the given name is instantiable by this factory.
            </summary>
            <param name="taskName">Name of the task.</param>
            <returns>
            <c>true</c> if this factory can instantiate such a task; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskFactoryWrapper.PopulatePropertyInfoCacheIfNecessary">
            <summary>
            Populate the cache of PropertyInfos for this type
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TaskRegistry">
             <summary>
             This class is used to track tasks used by a project. Tasks are declared in project files with the &lt;UsingTask&gt; tag.
             Task and assembly names must be specified per .NET guidelines, however, the names do not need to be fully qualified if
             they provide enough information to locate the tasks they refer to. Assemblies can also be referred to using file paths --
             this is useful when it is not possible/desirable to place task assemblies in the GAC, or in the same directory as MSBuild.
             </summary>
             <remarks>
             1) specifying a task assembly using BOTH its assembly name (strong or weak) AND its file path is not allowed
             2) when specifying the assembly name, the file extension (usually ".dll") must NOT be specified
             3) when specifying the assembly file, the file extension MUST be specified
             </remarks>
             <example>
             &lt;UsingTask TaskName="Microsoft.Build.Tasks.Csc"                     ==> look for the "Csc" task in the
                        AssemblyName="Microsoft.Build.Tasks"/&gt;                       weakly-named "Microsoft.Build.Tasks" assembly
             
             &lt;UsingTask TaskName="t1"                                            ==> look for the "t1" task in the
                        AssemblyName="mytasks, Culture=en, Version=1.0.0.0"/&gt;        strongly-named "mytasks" assembly
            
             &lt;UsingTask TaskName="foo"                                           ==> look for the "foo" task in the
                        AssemblyFile="$(MyDownloadedTasks)\utiltasks.dll"/&gt;          "utiltasks" assembly file
            
             &lt;UsingTask TaskName="UtilTasks.Bar"                                 ==> invalid task declaration
                        AssemblyName="utiltasks.dll"
                        AssemblyFile="$(MyDownloadedTasks)\"/&gt;
             </example>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry._toolset">
            <summary>
            The fallback task registry
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_forceTaskHostLaunch">
            <summary>
            If true, we will force all tasks to run in the MSBuild task host EXCEPT
            a small well-known set of tasks that are known to depend on IBuildEngine
            callbacks; as forcing those out of proc would be just setting them up for 
            known failure.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_tasksV4SimpleName">
            <summary>
            Simple name for the MSBuild tasks (v4), used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_tasksV4Filename">
            <summary>
            Filename for the MSBuild tasks (v4), used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_potentialTasksV4Location">
            <summary>
            Expected location that MSBuild tasks (v4) is picked up from if the user 
            references it with just a simple name, used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_tasksV12SimpleName">
            <summary>
            Simple name for the MSBuild tasks (v12), used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_tasksV12Filename">
            <summary>
            Filename for the MSBuild tasks (v12), used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_potentialTasksV12Location">
            <summary>
            Expected location that MSBuild tasks (v12) is picked up from if the user 
            references it with just a simple name, used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_tasksCoreSimpleName">
            <summary>
            Simple name for the MSBuild tasks (v14+), used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_tasksCoreFilename">
            <summary>
            Filename for the MSBuild tasks (v14+), used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.s_potentialTasksCoreLocation">
            <summary>
            Expected location that MSBuild tasks (v14+) is picked up from if the user 
            references it with just a simple name, used for shimming in loading 
            task factory UsingTasks
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry._cachedTaskRecordsWithExactMatch">
            <summary>
            Cache of tasks already found using exact matching,
            keyed by the task identity requested.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry._cachedTaskRecordsWithFuzzyMatch">
            <summary>
            Cache of tasks already found using fuzzy matching,
            keyed by the task name requested.
            Value is a dictionary of all possible matches for that 
            task name, by unique identity.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry._taskRegistrations">
            <summary>
            Cache of task declarations i.e. the &lt;UsingTask&gt; tags fed to this registry,
            keyed by the task name declared.
            Task name may be qualified or not.
            This field may be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RootElementCache">
            <summary>
            The cache to load the *.tasks files into
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.#ctor(Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Creates a task registry that does not fall back to any other task registry.
            Default constructor does no work because the tables are initialized lazily when a task is registered
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.#ctor(Microsoft.Build.Evaluation.Toolset,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Creates a task registry that defers to the specified toolset's registry for those tasks it cannot resolve.        
            UNDONE: (Logging.) We can't pass the base task registry from the Toolset because we can't call GetTaskRegistry
            without logging context information.  When the Project load code is altered to contain logging service
            references, we can load the toolset task registry at the time this registry is created and pass it to
            this constructor instead of the toolset state.
            </summary>
            <param name="toolset">The Toolset containing the toolser task registry</param>
            <param name="projectRootElementCache">The <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCache"/> to use.</param>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.Toolset">
            <summary>
            Returns the toolset state used to initialize this registry, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.TaskRegistrations">
            <summary>
            Access list of task registrations.
            FOR UNIT TESTING ONLY.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisterTasksFromUsingTaskElement``2(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.String,Microsoft.Build.Construction.ProjectUsingTaskElement,Microsoft.Build.Execution.TaskRegistry,Microsoft.Build.Evaluation.Expander{``0,``1},Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Evaluate the usingtask and add the result into the data passed in
            </summary>
            <typeparam name="P">A type derived from IProperty</typeparam>
            <typeparam name="I">A type derived from IItem</typeparam>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.GetRegisteredTask(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Given a task name, this method retrieves the task class. If the task has been requested before, it will be found in
            the class cache; otherwise, &lt;UsingTask&gt; declarations will be used to search the appropriate assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.GetTaskRegistrationRecord(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean,Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation,System.Boolean@)">
            <summary>
            Retrieves the task registration record for the specified task.
            </summary>
            <param name="taskName">The name of the task to retrieve.</param>
            <param name="taskProjectFile">The task's project file.</param>
            <param name="taskIdentityParameters">The set of task identity parameters to be used to identify the 
            correct task record match.</param>
            <param name="exactMatchRequired">True if an exact name match is required.</param>
            <param name="targetLoggingContext">The logging context.</param>
            <param name="elementLocation">The location of the task element in the project file.</param>
            <param name="retrievedFromCache">True if the record was retrieved from the cache.</param>
            <returns>The task registration record, or null if none was found.</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.IsTaskFactoryClass(System.Type,System.Object)">
            <summary>
            Is the class being loaded a task factory class
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.GetRelevantRegistrations(Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity,System.Boolean)">
            <summary>
            Searches all task declarations for the given task name.
            If no exact match is found, looks for partial matches.
            A task name that is not fully qualified may produce several partial matches.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisterTask(System.String,Microsoft.Build.Shared.AssemblyLoadInfo,System.String,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord)">
            <summary>
            Registers an evaluated using task tag for future 
            consultation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.GetMatchingRegistration(System.String,System.Collections.Generic.List{Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord},System.String,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name 
            can be created by the factories which are wrapped by the records. (this is done by instantiating the task factory and asking it).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity">
            <summary>
            An object representing the identity of a task -- not just task name, but also 
            the set of identity parameters
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.Name">
            <summary>
            The name of the task
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.TaskIdentityParameters">
            <summary>
            The identity parameters
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer">
            <summary>
            Comparer used to figure out whether two RegisteredTaskIdentities are equal or not. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.s_exact">
            <summary>
            The singleton comparer to use when an exact match is desired
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.s_fuzzy">
            <summary>
            The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the 
            name, but does a fuzzy match on the task identity parameters. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer._exactMatchRequired">
            <summary>
            Keeps track of whether we're doing exact or fuzzy equivalency
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact">
            <summary>
            The singleton comparer to use for when an exact match is desired 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Fuzzy">
            <summary>
            The singleton comparer to use for when a fuzzy match is desired 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity,Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity)">
            <summary>
            Returns true if these two identities match "fuzzily" -- if the names pass a partial type name 
            match and the task identity parameters would constitute a valid merge (e.g. "don't care" and 
            something explicit).  Otherwise returns false. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Equals(Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity,Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity)">
            <summary>
            Returns true if the two task identities are equal; false otherwise. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.GetHashCode(Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity)">
            <summary>
            Returns a hash code for the given task identity
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IdentityParametersMatch(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>
            Returns true if the two dictionaries representing sets of task identity parameters match; false otherwise.
            Internal so that RegisteredTaskRecord can use this function in its determination of whether the task factory 
            supports a certain task identity.  
            </summary>
        </member>
        <member name="T:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord">
            <summary>
            A record for a task registration which also contains the factory which matches the record
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.AssemblyTaskFactory">
            <summary>
            Default task factory to use if one is not specified
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.TaskHostFactory">
            <summary>
            Default task factory to use if one is not specified and runtime or architecture is specified
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.CodeTaskFactory">
            <summary>
            Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
            supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.XamlTaskFactory">
            <summary>
            Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
            supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.s_taskFactoryTypeLoaderLock">
            <summary>
            Lock for the taskFactoryTypeLoader
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.s_taskFactoryTypeFilter">
            <summary>
            Type filter to make sure we only look for taskFactoryClasses
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._taskIdentity">
            <summary>
            Identity of this task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.s_taskFactoryTypeLoader">
            <summary>
            Typeloader for taskFactories
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._registeredName">
            <summary>
            The task name this record was registered with from the using task element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._taskFactoryAssemblyLoadInfo">
            <summary>
            The assembly information about the task factory to be instantiated. For
            AssemblyTaskFactories this is the task assembly which should be loaded
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._taskFactory">
            <summary>
            The task factory class name which will be used to lookup the task factory from the assembly specified in the assemblyName or assemblyFile.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._taskFactoryWrapperInstance">
            <summary>
            A task factory wrapper which caches and combines information related to the parameters of the task.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._taskNamesCreatableByFactory">
            <summary>
            Cache of task names which can be created by the factory. 
            When ever a taskName is checked against the factory we cache the result so we do not have to 
            make possibly expensive calls over and over again.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._taskFactoryParameters">
            <summary>
            Set of parameters that can be used by the task factory specifically.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord._parameterGroupAndTaskBody">
            <summary>
            Encapsulates the parameters and the body of the task element for the inline task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.#ctor(System.String,Microsoft.Build.Shared.AssemblyLoadInfo,System.String,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.RegisteredName">
            <summary>
            Gets the task name this record was registered with.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.TaskFactoryAssemblyLoadInfo">
            <summary>
            Gets the assembly load information.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.TaskFactoryAttributeName">
            <summary>
            Gets the task factory attribute value.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.TaskFactoryParameters">
            <summary>
            Gets the set of parameters for the task factory
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskBody">
            <summary>
            Gets the inline task record
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.TaskIdentity">
            <summary>
            Identity of this task. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.CanTaskBeCreatedByFactory(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Ask the question, whether or not the task name can be created by the task factory. 
            To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name. 
            This question is useful for assembly tasks where the task may or may not be in an assembly, this can also be useful if the task factory 
            loads an external file and uses that to generate the tasks.
            </summary>
            <returns>true if the task can be created by the factory, false if it cannot be created</returns>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.GetTaskFactoryFromRegistrationRecord(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Given a Registered task record and a task name. Check create an instance of the task factory using the record. 
            If the factory is a assembly task factory see if the assemblyFile has the correct task inside of it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.GetTaskFactory(Microsoft.Build.BackEnd.Logging.TargetLoggingContext,Microsoft.Build.Construction.ElementLocation,System.String)">
            <summary>
            Create an instance of the task factory and load it from the assembly.
            </summary>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">If the task factory could not be properly created an InvalidProjectFileException will be thrown</exception>
        </member>
        <member name="T:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord">
            <summary>
            Keep track of the xml which will be sent to the inline task factory and the parameters if any which will also be passed in
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord._usingTaskParameters">
            <summary>
            The list of parameters found in the using task along with a corosponding UsingTaskParameterInfo which contains the specific information about it
            Populated lazily as it is often empty.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord._inlineTaskXmlBody">
            <summary>
            The body of the task element which will be passed to the task factory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord._taskBodyEvaluated">
            <summary>
            Was the task body evaluated or not
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord.#ctor">
            <summary>
            Create an empty ParameterGroupAndTaskElementRecord
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord.UsingTaskParameters">
            <summary>
            The parameters from the ParameterGroup from the using task element which will be passed to the task factory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord.InlineTaskXmlBody">
            <summary>
            The body of the task element which will be passed to the task factory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord.TaskBodyEvaluated">
            <summary>
            Has the task body been passed to the expander to be expanded
            </summary>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord.ExpandUsingTask``2(Microsoft.Build.Construction.ProjectUsingTaskElement,Microsoft.Build.Evaluation.Expander{``0,``1},Microsoft.Build.Evaluation.ExpanderOptions)">
            <summary>
            Keep track of the xml which will be sent to the inline task factory and the parameters if any which will also be passed in
            </summary>
            <typeparam name="P">Property type</typeparam>
            <typeparam name="I">Item Type</typeparam>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord.EvaluateTaskBody``2(Microsoft.Build.Evaluation.Expander{``0,``1},Microsoft.Build.Construction.ProjectUsingTaskBodyElement,Microsoft.Build.Evaluation.ExpanderOptions)">
            <summary>
            Evaluate the task body of the using task
            </summary>
            <typeparam name="P">IProperttyTypes</typeparam>
            <typeparam name="I">IItems</typeparam>
        </member>
        <member name="M:Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord.ParseUsingTaskParameterGroupElement``2(Microsoft.Build.Construction.UsingTaskParameterGroupElement,Microsoft.Build.Evaluation.Expander{``0,``1},Microsoft.Build.Evaluation.ExpanderOptions)">
            <summary>
            Convert the UsingTaskParameterGroupElement into a list of parameter names and UsingTaskParameters
            </summary>
            <typeparam name="P">Property type</typeparam>
            <typeparam name="I">Item types</typeparam>
        </member>
        <member name="T:Microsoft.Build.Internal.TaskHostContext">
            <summary>
            Enumeration of all possible (currently supported) types of task host context.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.TaskHostContext.X32CLR2">
            <summary>
            32-bit Intel process, using the 2.0 CLR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.TaskHostContext.X64CLR2">
            <summary>
            64-bit Intel process, using the 2.0 CLR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.TaskHostContext.X32CLR4">
            <summary>
            32-bit Intel process, using the 4.0 CLR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.TaskHostContext.X64CLR4">
            <summary>
            64-bit Intel process, using the 4.0 CLR.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.TaskHostContext.Invalid">
            <summary>
            Invalid task host context
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.CommunicationsUtilities">
            <summary>
            This class contains utility methods for the MSBuild engine.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.CommunicationsUtilities.DefaultNodeConnectionTimeout">
            <summary>
            The timeout to connect to a node.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.CommunicationsUtilities.s_fileVersionChecked">
            <summary>
            Flag if we have already calculated the FileVersion hashcode
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.CommunicationsUtilities.s_fileVersionHash">
            <summary>
            A hashcode calculated from the fileversion
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.CommunicationsUtilities.s_trace">
            <summary>
            Whether to trace communications
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.CommunicationsUtilities.s_debugDumpPath">
            <summary>
            Place to dump trace
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.CommunicationsUtilities.s_lastLoggedTicks">
            <summary>
            Ticks at last time logged
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.CommunicationsUtilities.LogDebugCommunications">
            <summary>
            Delegate to debug the communication utilities.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Internal.CommunicationsUtilities.NodeConnectionTimeout">
            <summary>
            Gets or sets the node connection timeout.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Internal.CommunicationsUtilities.FileVersionHash">
            <summary>
            Looks up the file version and caches the hashcode
            This file version hashcode is used in calculating the handshake
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetEnvironmentStrings">
            <summary>
            Get environment block
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.FreeEnvironmentStrings(System.Char*)">
            <summary>
            Free environment block
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetEnvironmentVariables">
            <summary>
            Copied from the BCL implementation to eliminate some expensive security asserts.
            Returns key value pairs of environment variables in a new dictionary
            with a case-insensitive key comparer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.SetEnvironment(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Updates the environment to match the provided dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GenerateHostHandshakeFromBase(System.Int64,System.Int64)">
            <summary>
            Given a base handshake, generates the real handshake based on e.g. elevation level.  
            Client handshake required for comparison purposes only.  Returns the update handshake.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetHostHandshake(Microsoft.Build.Internal.TaskHostContext)">
            <summary>
            Magic number sent by the host to the client during the handshake.
            Derived from the binary timestamp to avoid mixing binary versions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetClientHandshake(Microsoft.Build.Internal.TaskHostContext)">
            <summary>
            Magic number sent by the client to the host during the handshake.
            Munged version of the host handshake.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.WriteLongForHandshake(System.IO.Pipes.PipeStream,System.Int64)">
            <summary>
            Extension method to write a series of bytes to a stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.ReadLongForHandshake(System.IO.Pipes.PipeStream)">
            <summary>
            Extension method to read a series of bytes from a stream
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.ReadLongForHandshake(System.IO.Pipes.PipeStream,System.Byte[],System.Byte)">
            <summary>
            Extension method to read a series of bytes from a stream.
            If specified, leading byte matches one in the supplied array if any, returns rejection byte and throws IOException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetTaskHostContext(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Given the appropriate information, return the equivalent TaskHostContext.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetTaskHostContext(System.Boolean,System.Int32)">
            <summary>
            Given the appropriate information, return the equivalent TaskHostContext.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetCurrentTaskHostContext">
            <summary>
            Returns the TaskHostContext corresponding to this process
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetIntegerVariableOrDefault(System.String,System.Int32)">
            <summary>
            Gets the value of an integer environment variable, or returns the default if none is set or it cannot be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.Trace(System.String,System.Object[])">
            <summary>
            Writes trace information to a log file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.Trace(System.Int32,System.String,System.Object[])">
            <summary>
            Writes trace information to a log file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetBaseHandshakeForContext(Microsoft.Build.Internal.TaskHostContext)">
            <summary>
            Add the task host context to this handshake, to make sure that task hosts with different contexts 
            will have different handshakes. Shift it into the upper 32-bits to avoid running into the 
            session ID. The connection may be salted to allow MSBuild to only connect to nodes that come from the same
            test environment.
            </summary>
            <param name="hostContext">TaskHostContext</param>
            <returns>Base Handshake</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.CommunicationsUtilities.GetHandshakeHashCode(System.String)">
            <summary>
            Gets a hash code for this string.  If strings A and B are such that A.Equals(B), then
            they will return the same hash code.
            This is as implemented in CLR String.GetHashCode() [ndp\clr\src\BCL\system\String.cs]
            but stripped out architecture specific defines
            that causes the hashcode to be different and this causes problem in cross-architecture handshaking
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.ReservedPropertyNames">
            <summary>
            Contains a list of the special (reserved) properties that are settable by MSBuild code only.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.ReservedPropertyNames.ReservedProperties">
            <summary>
            Lookup for reserved property names. Intentionally do not include MSBuildExtensionsPath* or MSBuildUserExtensionsPath in this list.  We need tasks to be able to override those.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ReservedPropertyNames.IsReservedProperty(System.String)">
            <summary>
            Indicates if the given property is a reserved property.
            </summary>
            <returns>true, if specified property is reserved</returns>
        </member>
        <member name="T:Microsoft.Build.Internal.Constants">
            <summary>
            Constants used by the Engine
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Constants.defaultToolsVersion">
            <summary>
            If no default tools version is specified in the config file or registry, we'll use 2.0.
            The engine will use its binpath for the matching toolset path.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Constants.defaultFallbackToolsVersion">
            <summary>
            The toolsversion we will fall back to as a last resort if the default one cannot be found, this fallback should be the most current toolsversion known
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Constants.defaultSolutionWrapperProjectToolsVersion">
            <summary>
            The toolsversion we will use when we construct the solution wrapper metaprojects; this should be the most current toolsversion known
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Constants.VisualStudioVersionPropertyName">
            <summary>
            Name of the property used to specify a Visual Studio version.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Constants.SubToolsetVersionPropertyName">
            <summary>
            Name of the property used to select which sub-toolset to use. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Constants.Dev10SubToolsetValue">
            <summary>
            Value we should be setting VisualStudioVersion as the ultimate fallback when Dev10 is installed. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Constants.assemblyTimestamp">
            <summary>
            Number representing the current assembly's timestamp
            </summary>
        </member>
        <member name="P:Microsoft.Build.Internal.Constants.AssemblyVersion">
            <summary>
            Current version of this MSBuild Engine assembly in the 
            form, e.g, "4.0"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Internal.Constants.AssemblyTimestamp">
            <summary>
            Number representing the current assembly's timestamp
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.AvailableStaticMethods">
            <summary>
            The set of available static methods.
            NOTE: Do not allow methods here that could do "bad" things under any circumstances.
            These must be completely benign operations, as they run during project load, which must be safe in VS.
            Key = Type or Type::Method, Value = AssemblyQualifiedTypeName (where null = mscorlib)
            </summary>
            <remarks>
            Placed here to avoid StyleCop error.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Internal.AvailableStaticMethods.s_availableStaticMethods">
            <summary>
            Static methods that are allowed in constants. Key = Type or Type::Method, Value = Tuple of AssemblyQualifiedTypeName (where null = mscorlib) or the actual type object
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.AvailableStaticMethods.s_locker">
            <summary>
            Locker to protect initialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.ContainsKey(System.String)">
            <summary>
            Whether a key is present
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.TryAdd(System.String,System.Tuple{System.String,System.Type})">
            <summary>
            Add an entry if not already present
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.TryAdd(System.String,System.String,System.Tuple{System.String,System.Type})">
            <summary>
            Constructs the fully qualified method name and adds it to the cache
            </summary>
            <param name="typeFullName"></param>
            <param name="simpleMethodName"></param>
            <param name="typeInformation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.TryGetValue(System.String,System.Tuple{System.String,System.Type}@)">
            <summary>
            Get an entry if present
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.GetValue(System.String)">
            <summary>
            Get an entry or null if not present
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.GetTypeInformationFromTypeCache(System.String,System.String)">
            <summary>
            Tries to retrieve the type information for a type name / method name combination. 
            
            It does 2 lookups:
            1st try: 'typeFullName'
            2nd try: 'typeFullName::simpleMethodName'
            
            </summary>
            <param name="typeFullName">namespace qualified type name</param>
            <param name="simpleMethodName">name of the method</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.CreateQualifiedMethodName(System.String,System.String)">
            <summary>
            Returns the fully qualified format for the given method: see typeFullName::methodName
            </summary>
            <param name="typeFullName">namespace qualified type name</param>
            <param name="simpleMethodName">simple name of the method</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.Reset_ForUnitTestsOnly">
            <summary>
            Re-initialize.
            Unit tests need this when they enable "unsafe" methods -- which will then go in the collection,
            and mess up subsequent tests.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.AvailableStaticMethods.InitializeAvailableMethods">
            <summary>
            Fill up the dictionary for first use
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.MSBuildAssemblyFileVersion">
            <summary>
            Gets the <see cref="T:System.Reflection.AssemblyFileVersionAttribute"/> of Microsoft.Build.dll.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Internal.MSBuildAssemblyFileVersion.Instance">
            <summary>
            Gets a singleton instance of <see cref="T:Microsoft.Build.Internal.MSBuildAssemblyFileVersion"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Internal.MSBuildAssemblyFileVersion.MajorMinorBuild">
            <summary>
            Gets the assembly file version in the format major.minor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.EngineFileUtilities.GetFileListUnescaped(System.String,System.String,System.Boolean)">
            <summary>
            Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
            ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
            doesn't appear to point to an actual file on disk, then we just give back the input string as an array of length one,
            assuming that it wasn't really intended to be a filename (as items are not required to necessarily represent files).
            Any wildcards passed in that are unescaped will be treated as real wildcards.
            The "include" of items passed back from the filesystem will be returned canonically escaped.
            The ordering of the list returned is deterministic (it is sorted).
            Will never throw IO exceptions. If path is invalid, just returns filespec verbatim.
            </summary>
            <param name="directoryEscaped">The directory to evaluate, escaped.</param>
            <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
            <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
            <returns>Array of file paths, unescaped.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.EngineFileUtilities.GetFileListEscaped(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
            ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
            doesn't appear to point to an actual file on disk, then we just give back the input string as an array of length one,
            assuming that it wasn't really intended to be a filename (as items are not required to necessarily represent files).
            Any wildcards passed in that are unescaped will be treated as real wildcards.
            The "include" of items passed back from the filesystem will be returned canonically escaped.
            The ordering of the list returned is deterministic (it is sorted).
            Will never throw IO exceptions. If path is invalid, just returns filespec verbatim.
            </summary>
            <param name="directoryEscaped">The directory to evaluate, escaped.</param>
            <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
            <param name="excludeSpecsEscaped">Filespecs to exclude, escaped.</param>
            <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
            <returns>Array of file paths, escaped.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.EngineFileUtilities.GetFileList(System.String,System.String,System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
            ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
            doesn't appear to point to an actual file on disk, then we just give back the input string as an array of length one,
            assuming that it wasn't really intended to be a filename (as items are not required to necessarily represent files).
            Any wildcards passed in that are unescaped will be treated as real wildcards.
            The "include" of items passed back from the filesystem will be returned canonically escaped.
            The ordering of the list returned is deterministic (it is sorted).
            Will never throw IO exceptions: if there is no match, returns the input verbatim.
            </summary>
            <param name="directoryEscaped">The directory to evaluate, escaped.</param>
            <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
            <param name="returnEscaped"><code>true</code> to return escaped specs.</param>
            <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off</param>
            <param name="excludeSpecsEscaped">The exclude specification, escaped.</param>
            <returns>Array of file paths.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.EngineFileUtilities.GetFileSpecMatchTester(System.Collections.Generic.IList{System.String},System.String)">
            Returns a Func that will return true IFF its argument matches any of the specified filespecs
            Assumes filespec may be escaped, so it unescapes it
            The returned function makes no escaping assumptions or escaping operations. Its callers should control escaping.
        </member>
        <member name="T:Microsoft.Build.Internal.RegistryKeyWrapper">
            <summary>
            Thin wrapper around Microsoft.Win32.RegistryKey that can be 
            subclassed for testing purposes
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.RegistryKeyWrapper._disposed">
            <summary>
            Has the object been disposed yet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.#ctor(Microsoft.Win32.RegistryKey,Microsoft.Win32.RegistryKey)">
            <summary>
            Initializes this RegistryKeyWrapper to wrap the specified key.
            Does not check for a null key.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.#ctor(System.String)">
            <summary>
            Initializes this RegistryKeyWrapper to wrap the key at the specified path
            and assumes the key is underneath HKLM
            Note that registryKeyPath should be relative to HKLM.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.#ctor(System.String,Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)">
            <summary>
            Initializes this RegistryKeyWrapper to wrap the key at the specified path
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.#ctor(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Initializes this RegistryKeyWrapper to wrap the key at the specified path
            </summary>
        </member>
        <member name="P:Microsoft.Build.Internal.RegistryKeyWrapper.Name">
            <summary>
            Name of the registry key
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.KeyExists(System.String,Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)">
            <summary>
            Convenient static helper method on RegistryKeyWrapper, for when someone is only intersted in knowing 
            whether a particular registry key exists or not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.GetValue(System.String)">
            <summary>
            Gets the value with name "name" stored under this registry key
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.GetValueNames">
            <summary>
            Gets the names of all values underneath this registry key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.GetSubKeyNames">
            <summary>
            Gets the names of all sub keys immediately below this registry key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.OpenSubKey(System.String)">
            <summary>
            Returns the RegistryKeyWrapper around the sub key with name "name". If that does
            not exist, returns a RegistryKeyWrapper around null.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Internal.RegistryKeyWrapper.Exists">
            <summary>
            Returns true if the wrapped registry key exists.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Internal.RegistryKeyWrapper.WrappedKey">
            <summary>
            Lazy getter for the root tools version registry key: means that this class
            will never throw registry exceptions from the constructor
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.Utilities">
            <summary>
            This class contains utility methods for the MSBuild engine.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Utilities.s_shouldTreatHigherToolsVersionsAsCurrent">
            <summary>
            Save off the contents of the environment variable that specifies whether we should treat higher toolsversions as the current 
            toolsversion.  (Some hosts require this.)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Utilities.s_shouldTreatOtherToolsVersionsAsCurrent">
            <summary>
            Save off the contents of the environment variable that specifies whether we should treat all toolsversions, regardless of 
            whether they are higher or lower, as the current toolsversion.  (Some hosts require this.)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Utilities.s_uselegacyDefaultToolsVersionBehavior">
            <summary>
            If set, default to the ToolsVersion from the project file (or if that doesn't isn't set, default to 2.0).  Otherwise, use Dev12+ 
            defaulting logic: first check the MSBUILDDEFAULTTOOLSVERSION environment variable, then check for a DefaultOverrideToolsVersion, 
            then if both fail, use the current ToolsVersion. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Utilities.s_defaultToolsVersionFromEnvironment">
            <summary>
            If set, will be used as the ToolsVersion to build with (unless MSBUILDLEGACYDEFAULTTOOLSVERSION is set).
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.Utilities.GetToolset">
            <summary>
            Delegate for a method that, given a ToolsVersion string, returns the matching Toolset.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.RefreshInternalEnvironmentValues">
            <summary>
            INTERNAL FOR UNIT-TESTING ONLY
            
            We've got several environment variables that we read into statics since we don't expect them to ever 
            reasonably change, but we need some way of refreshing their values so that we can modify them for 
            unit testing purposes. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.SetXmlNodeInnerContents(Microsoft.Build.Construction.XmlElementWithLocation,System.String)">
            <summary>
            Sets the inner XML/text of the given XML node, escaping as necessary.
            </summary>
            <param name="node"></param>
            <param name="s">Can be empty string, but not null.</param>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.GetXmlNodeInnerContents(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Extracts the inner XML/text of the given XML node, unescaping as necessary.
            </summary>
            <param name="node"></param>
            <returns>Inner XML/text of specified node.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.ContainsNoTagsOtherThanComments(System.String,System.Int32)">
            <summary>
            Figure out whether there are any XML tags, other than comment tags,
            in the string.
            </summary>
            <remarks>
            We know the string coming in is a valid XML fragment. (The project loaded after all.)
            So for example we can ignore an open comment tag without a matching closing comment tag.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.RemoveXmlNamespace(System.String)">
            <summary>
            Removes the xmlns attribute from an XML string.
            </summary>
            <param name="xml">XML string to process.</param>
            <returns>The modified XML string.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.CreateToolsVersionListString(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.Toolset})">
            <summary>
            Creates a comma separated list of valid tools versions suitable for an error message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.GenerateToolsVersionToUse(System.String,System.String,Microsoft.Build.Internal.Utilities.GetToolset,System.String,System.Boolean@)">
            <summary>
            Figure out what ToolsVersion to use to actually build the project with. 
            </summary>
            <param name="explicitToolsVersion">The user-specified ToolsVersion (through e.g. /tv: on the command line)</param>
            <param name="toolsVersionFromProject">The ToolsVersion from the project file</param>
            <param name="getToolset">Delegate used to test whether a toolset exists for a given ToolsVersion.  May be null, in which
            case we act as though that toolset existed.</param>
            <param name="defaultToolsVersion">The default ToolsVersion</param>
            <param name="usingDifferentToolsVersionFromProjectFile">true if the project file specifies an explicit toolsversion but a different one is chosen</param>
            <returns>The ToolsVersion we should use to build this project.  Should never be null.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.GetEnvironmentProperties">
            <summary>
            Retrieves properties derived from the current
            environment variables.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.FastCountOrZero(System.Collections.IEnumerable)">
            <summary>
            Extension to IEnumerable to get the count if it 
            can be quickly gotten, otherwise 0.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Utilities.Values``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,``0}})">
            <summary>
            Extension to IEnumerable of KVP of string, something to just return the somethings.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.ProjectXmlUtilities">
            <summary>
            Project-related Xml utilities
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.GetVerifyThrowProjectChildElements(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Gets child elements, ignoring whitespace and comments.
            Throws InvalidProjectFileException for unexpected XML node types.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.GetChildElements(Microsoft.Build.Construction.XmlElementWithLocation,System.Boolean)">
            <summary>
            Gets child elements, ignoring whitespace and comments.
            Throws InvalidProjectFileException for unexpected XML node types if parameter is set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyThrowProjectNoChildElements(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Throw an invalid project exception if there are any child elements at all
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.ThrowProjectInvalidChildElementDueToDuplicate(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Throw an invalid project exception indicating that the child is not valid beneath the element because it is a duplicate
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.ThrowProjectInvalidChildElement(System.String,System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Throw an invalid project exception indicating that the child is not valid beneath the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyValidProjectNamespace(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Verify that if a namespace is specified it matches the default MSBuild namespace.
            </summary>
            <param name="element">Element to check namespace.</param>
            <returns>True when the namespace is in the MSBuild namespace or no namespace.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyThrowProjectAttributeEitherMissingOrNotEmpty(Microsoft.Build.Construction.XmlElementWithLocation,System.String)">
            <summary>
            Verifies that if the attribute is present on the element, its value is not empty
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyThrowProjectAttributeEitherMissingOrNotEmpty(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.XmlAttributeWithLocation,System.String)">
            <summary>
            Verifies that if the attribute is present on the element, its value is not empty
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyThrowProjectNoAttributes(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            If there are any attributes on the element, throws an InvalidProjectFileException complaining that the attribute is not valid on this element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyThrowProjectInvalidAttribute(System.Boolean,Microsoft.Build.Construction.XmlAttributeWithLocation)">
            <summary>
            If the condition is false, throws an InvalidProjectFileException complaining that the attribute is not valid on this element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyThrowProjectRequiredAttribute(Microsoft.Build.Construction.XmlElementWithLocation,System.String)">
            <summary>
            Verify that the element has the specified required attribute on it and
            it has a value other than empty string
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.VerifyThrowProjectAttributes(Microsoft.Build.Construction.XmlElementWithLocation,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Verify  that all attributes on the element are on the list of legal attributes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.ThrowProjectInvalidAttribute(Microsoft.Build.Construction.XmlAttributeWithLocation)">
            <summary>
            Throws an InvalidProjectFileException complaining that the attribute is not valid on this element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.SetOrRemoveAttribute(Microsoft.Build.Construction.XmlElementWithLocation,System.String,System.String)">
            <summary>
            Sets the value of an attribute, but if the value to set is null or empty, just
            removes the attribute. Returns the attribute, or null if it was removed.
            UNDONE: Make this return a bool if the attribute did not change, so we can avoid dirtying.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.SetOrRemoveAttribute(Microsoft.Build.Construction.XmlElementWithLocation,System.String,System.String,System.Boolean)">
            <summary>
            Sets the value of an attribute, removing the attribute if the value is null, but still setting it 
            if the value is the empty string. Returns the attribute, or null if it was removed.
            UNDONE: Make this return a bool if the attribute did not change, so we can avoid dirtying.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.GetAttributeValue(Microsoft.Build.Construction.XmlAttributeWithLocation,System.Boolean)">
            <summary>
            Returns the value of the attribute. 
            If the attribute is null, returns an empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.GetAttributeValue(Microsoft.Build.Construction.XmlElementWithLocation,System.String)">
            <summary>
            Returns the value of the attribute. 
            If the attribute is not present, returns an empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.ProjectXmlUtilities.GetAttributeValue(Microsoft.Build.Construction.XmlElementWithLocation,System.String,System.Boolean)">
            <summary>
            Returns the value of the attribute. 
            If the attribute is not present, returns either null or an empty string, depending on the value 
            of nullIfNotExists.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Internal.XmlReaderExtension">
            <summary>
                Disposable helper class to wrap XmlReader / XmlTextReader functionality.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.XmlReaderExtension.Create(System.String,System.Boolean)">
            <summary>
                Creates an XmlReaderExtension with handle to an XmlReader.
            </summary>
            <param name="filePath">Path to the file on disk.</param>
            <returns>Disposable XmlReaderExtension object.</returns>
        </member>
        <member name="M:Microsoft.Build.Internal.XmlReaderExtension.GetEncodingFromAttribute(System.Xml.XmlReader)">
            <summary>
            Get the Encoding type from the XML declaration tag
            </summary>
            <param name="reader">XML Reader object</param>
            <returns>Encoding if specified, else null.</returns>
        </member>
        <member name="T:Microsoft.Build.Internal.Tracing">
            <summary>
            A debug only helper class for tracing
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_counts">
            <summary>
            A dictionary of named counters
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_last">
            <summary>
            Last time logging happened
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_interval">
            <summary>
            How often to log
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_slot">
            <summary>
            A place callers can put something worth logging later
            </summary>
        </member>
        <member name="F:Microsoft.Build.Internal.Tracing.s_currentAssemblyName">
            <summary>
            Short name of the current assembly - to distinguish statics when this type is shared into different assemblies
            </summary> 
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Slot(System.String,System.String)">
            <summary>
            Put something in the slot
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Slot``2(System.String,System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Put something in the slot
            </summary>
            <typeparam name="K">The key type.</typeparam>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Record(System.String)">
            <summary>
            Increment the named counter, and dump if it's time to do so
            </summary>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.List``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Log the provided items
            </summary>
            <typeparam name="T">The item type.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Internal.Tracing.Dump">
            <summary>
            Dump all the named counters, if any
            </summary>
        </member>
        <member name="T:Microsoft.Build.InterningBinaryReader">
            <summary>
            Replacement for BinaryReader which attempts to intern the strings read by ReadString.
            </summary>
        </member>
        <member name="F:Microsoft.Build.InterningBinaryReader.MaxCharsBuffer">
            <summary>
            The maximum size, in bytes, to read at once.
            </summary>
        </member>
        <member name="F:Microsoft.Build.InterningBinaryReader._buffer">
            <summary>
            Shared buffer saves allocating these arrays many times.
            </summary>
        </member>
        <member name="F:Microsoft.Build.InterningBinaryReader._decoder">
            <summary>
            The decoder used to translate from UTF8 (or whatever).
            </summary>
        </member>
        <member name="M:Microsoft.Build.InterningBinaryReader.#ctor(System.IO.Stream,Microsoft.Build.InterningBinaryReader.Buffer)">
            <summary>
            Comment about constructing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.InterningBinaryReader.ReadString">
            <summary>
            Read a string while checking the string precursor for intern opportunities.
            Taken from ndp\clr\src\bcl\system\io\binaryreader.cs-ReadString()
            </summary>
        </member>
        <member name="M:Microsoft.Build.InterningBinaryReader.CreateSharedBuffer">
            <summary>
            A shared buffer to avoid extra allocations in InterningBinaryReader.
            </summary>
        </member>
        <member name="M:Microsoft.Build.InterningBinaryReader.Create(System.IO.Stream,Microsoft.Build.SharedReadBuffer)">
            <summary>
            Create a BinaryReader. It will either be an interning reader or standard binary reader
            depending on whether the interning reader is possible given the buffer and stream.
            </summary>
        </member>
        <member name="T:Microsoft.Build.InterningBinaryReader.Buffer">
            <summary>
            Holds thepreallocated buffer. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.InterningBinaryReader.Buffer.#ctor">
            <summary>
            Yes, we are constructing.
            </summary>
        </member>
        <member name="P:Microsoft.Build.InterningBinaryReader.Buffer.CharBuffer">
            <summary>
            The char buffer.
            </summary>
        </member>
        <member name="P:Microsoft.Build.InterningBinaryReader.Buffer.ByteBuffer">
            <summary>
            The byte buffer.
            </summary>
        </member>
        <member name="P:Microsoft.Build.InterningBinaryReader.Buffer.Encoding">
            <summary>
            The encoding.
            </summary>
        </member>
        <member name="T:Microsoft.Build.SharedReadBuffer">
            <summary>
            Opaque holder of shared buffer.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectUsingTaskParameterElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider">
            <summary>
            Enable providing access to external [potentially remote] ProjectCollection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.GetLoadedProjects(System.String)">
            <summary>
            Provide the list of remote projects (projects in the remote collection)
            Note all returned objects will be local "linked" Project object proxies.
            </summary>
            <param name="filePath">[optional] project full path. Can be null in which case function will return all projects</param>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Called when External provider is "disconnected" from the local collection - aka it will be no longer used to extend
            the projects list.
            This is triggered by either project collection disposing or when another call to SetExternalProjectsProvider is invoked.
            The purpose of this call is to allow the external provider release any associate data (caches/connections etc).
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider)">
             <summary>
             Attach an external project provider to a msbuild ProjectCollection.
            
             Note at any time there could be only one ExternalProvider attached.
            
             Can be called with link == null, in which case it will "clear" the external provider on the target collection
             </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ILinkableObject">
            <summary>
            implemented by MSBuild objects that support remote linking;
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ILinkableObject.Link">
            <summary>
            Gets the current link, if any. For local objects returns null;
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory">
            <summary>
            Provide facility to ExternalProjectsProvider implementation
            to create local OM objects based on the remote link.
            These object are fully useful for associated Collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Get(Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Acquire a <see cref="T:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory"/> instance for a given ProjectCollection.
            Allows creating a local MSBuild OM objects representing externally hosted Projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLink(System.Object)">
            <summary>
            Get the underlying "link" proxy for a given MSBuild object model object (null if it is not linked).
            can be used by ExternalProjectsProvider to prevent double linking when implementing remote calls.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.IsLocal(System.Object)">
            <summary>
            Check if an msbuild object is local (aka not from External Project)
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Collection">
            <summary>
            Local collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection,System.String)">
            <summary>
            Gets only locally load projects, excluding external
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.LinkedProjectProperty.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink)">
            <summary>
            Creates a regular evaluated property, with backing XML.
            Called by Project.SetProperty.
            Property MAY NOT have reserved name and MAY NOT overwrite a global property.
            Predecessor is any immediately previous property that was overridden by this one during evaluation and may be null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Evaluation.ProjectItemDefinition"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Project">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectItemDefinition.Project"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ItemType">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Metadata">
            <summary>
            Facilitate remoting the <see cref="P:Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata"/> and <see cref="P:Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadata(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadataValue(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.SetMetadataValue(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectItemLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Evaluation.ProjectItem"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Project">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectItem.Project"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Xml">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectItem.Xml"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.EvaluatedInclude">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.MetadataCollection">
            <summary>
            Facilitate remoting the <see cref="P:Microsoft.Build.Evaluation.ProjectItem.Metadata"/> and <see cref="P:Microsoft.Build.Evaluation.ProjectItem.MetadataCount"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.DirectMetadata">
            <summary>
            Facilitate remoting the <see cref="P:Microsoft.Build.Evaluation.ProjectItem.DirectMetadata"/> and <see cref="P:Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.HasMetadata(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItem.HasMetadata(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadata(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadata(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadataValue(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.SetMetadataValue(System.String,System.String,System.Boolean)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.RemoveMetadata(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Rename(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ChangeItemType(System.String)">
            <summary>
            Helps implementing the item type change for remoted objects>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Evaluation.Project"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.Xml">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.Xml"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.IsDirty">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.IsDirty"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalProperties">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.GlobalProperties"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemTypes">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.ItemTypes"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.Properties">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.Properties"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.ConditionedProperties">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.ConditionedProperties"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemDefinitions">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.ItemDefinitions"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.Items">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.Items"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemsIgnoringCondition">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.Imports">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.Imports"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.ImportsIncludingDuplicates">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.Targets">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.Targets"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedProperties">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.AllEvaluatedProperties"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItemDefinitionMetadata">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItems">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItems"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.ToolsVersion">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.ToolsVersion"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.SubToolsetVersion">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.SubToolsetVersion"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.SkipEvaluation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.DisableMarkDirty"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.IsBuildEnabled"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectLink.LastEvaluationId">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.Project.LastEvaluationId"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetLogicalProject">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetLogicalProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetProperty(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetProperty(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetPropertyValue(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetPropertyValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.SetProperty(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.SetProperty(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.SetGlobalProperty(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItems(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetItems(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsIgnoringCondition(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsByEvaluatedInclude(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveGlobalProperty(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.ExpandString(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.ExpandString(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.MarkDirty">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.SaveLogicalProject(System.IO.TextWriter)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Facilitate support for remote build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.Unload">
            <summary>
            Called by the local project collection to indicate to this project that it is no longer loaded.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Evaluation.ProjectMetadata"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Parent">
            <summary>
            MSBuild object that this meta data belong to.
            Can be either <see cref="T:Microsoft.Build.Evaluation.ProjectItem"/>, or <see cref="T:Microsoft.Build.Evaluation.ProjectItemDefinition"/>
            Not a public property on original ProjectMetadata object, but int is needed to create a local proxy object.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Xml">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectMetadata.Xml"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.EvaluatedValueEscaped">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValueEscaped"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Predecessor">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectMetadata.Predecessor"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetParent(Microsoft.Build.Evaluation.ProjectMetadata)">
            <summary>
            Helper utility for External projects provider implementation to get access of the parent object.
            At this point this is internal property for <see cref="T:Microsoft.Build.Evaluation.ProjectMetadata"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata)" -->
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Evaluation.ProjectProperty"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Project">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.Project"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Xml">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.Xml"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Name">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.Name"/>.
            (note can not Use Xml.Name since for global properties Xml is null;
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.EvaluatedIncludeEscaped">
            <summary>
            Allow implement the <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue"/> for remoted objects.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsEnvironmentProperty">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsGlobalProperty">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsReservedProperty">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Predecessor">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.Predecessor"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsImported">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Evaluation.ProjectProperty.IsImported"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty)" -->
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external construction objects derived from <see cref="T:Microsoft.Build.Construction.ProjectElementContainer"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.Count">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElementContainer.Count"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.FirstChild">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElementContainer.FirstChild"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.LastChild">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElementContainer.LastChild"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertAfterChild(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Helps implementation of the <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            helps implementation the <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.RemoveChild(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            ExternalProjectsProvider helpers
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectChooseElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectImportGroupElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectItemDefinitionElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectItemGroupElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectOtherwiseElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectPropertyGroupElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectSdkElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectUsingTaskElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectWhenElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.UsingTaskParameterGroupElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ILinkedXml">
            <summary>
            This interface will allow us to share a single field between
            <see cref="T:Microsoft.Build.Construction.XmlElementWithLocation"/> and <see cref="T:Microsoft.Build.ObjectModelRemoting.ProjectElementLink"/>
            for construction objects so therefore not increasing the storage size while supporting
            external linking.
            <see cref="P:Microsoft.Build.Construction.ProjectElement.XmlElement"/> and <see cref="P:Microsoft.Build.Construction.ProjectElement.Link"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ILinkedXml.Link">
            <summary>
            Not null for "external" objects, null for internal objects
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ILinkedXml.Xml">
            <summary>
            Null for "external" objects, not null for internal objects
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external construction objects derived from <see cref="T:Microsoft.Build.Construction.ProjectElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Microsoft#Build#ObjectModelRemoting#ILinkedXml#Link">
            <summary>
            <see cref="P:Microsoft.Build.ObjectModelRemoting.ILinkedXml.Link"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Microsoft#Build#ObjectModelRemoting#ILinkedXml#Xml">
            <summary>
            <see cref="P:Microsoft.Build.ObjectModelRemoting.ILinkedXml.Xml"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Parent">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.Parent"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ContainingProject">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.ContainingProject"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ElementName">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.ElementName"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.OuterElement">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.OuterElement"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.ExpressedAsAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PreviousSibling">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.PreviousSibling"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.NextSibling">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.NextSibling"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Location">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectElement.Location"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Attributes">
            <summary>
            Supports <see cref="M:Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PureText">
            <summary>
            Supports <see cref="M:Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)"/>.
            return raw xml content of the element if it has exactly 1 text child
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(System.String)">
            <summary>
            Required to implement Attribute access for remote element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(System.String,System.Boolean)">
            <summary>
            Required to implement Attribute access for remote element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(System.String,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Required to implement Attribute access for remote element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CopyFrom(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Facilitate remoting to remote <see cref="M:Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Facilitate remoting to remote <see cref="M:Microsoft.Build.Construction.ProjectElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Utility function for ExternalProjects provider
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectOnErrorElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectOutputElement"/>
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectExtensionsElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectExtensionsElement.Content"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.GetSubElement(System.String)">
            <summary>
            Helps implementing sub element indexer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.SetSubElement(System.String,System.String)">
            <summary>
            Helps implementing sub element indexer.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectImportElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ImplicitImportLocation">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.OriginalElement">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectImportElement.OriginalElement"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectItemElement"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ChangeItemType(System.String)">
            <summary>
            Help implement ItemType setter for remote objects.
            </summary>
            <param name="newType"></param>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectMetadataElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectMetadataElement.Value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ChangeName(System.String)">
            <summary>
            Help implement rename.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectPropertyElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectMetadataElement.Value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ChangeName(System.String)">
            <summary>
            Help implement rename.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Version">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.Version"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.HasUnsavedChanges">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.TimeLastChanged">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.LastWriteTimeWhenRead">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.DirectoryPath">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.DirectoryPath"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.FullPath"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectFileLocation">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Encoding">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.Encoding"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.RawXml">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.RawXml"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.PreserveFormatting">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateChooseElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionGroupElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemGroupElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportGroupElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOnErrorElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOtherwiseElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOutputElement(System.String,System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(System.String,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectExtensionsElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyGroupElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTargetElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTaskElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskElement(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(System.String,System.String,System.String,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterGroupElement">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterElement(System.String,System.String,System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskBodyElement(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateWhenElement(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectSdkElement(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.Text.Encoding)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.IO.TextWriter)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.String,System.Boolean,System.Boolean)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.String,System.Boolean,System.Nullable{System.Boolean})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.Xml.XmlReader,System.Boolean,System.Boolean)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader,System.Boolean,System.Nullable{System.Boolean})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.MarkDirty(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.MarkDirty(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectTargetElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectTargetElement.Name"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Returns">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectTargetElement.Returns"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectTaskElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.Parameters">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectTaskElement.Parameters"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ParameterLocations">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.GetParameter(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectTaskElement.GetParameter(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.SetParameter(System.String,System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectTaskElement.SetParameter(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveParameter(System.String)">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveAllParameters">
            <summary>
            Facilitate remoting the <see cref="M:Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink">
            <summary>
            External projects support.
            Allow for creating a local representation to external object of type <see cref="T:Microsoft.Build.Construction.ProjectUsingTaskBodyElement"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody">
            <summary>
            Access to remote <see cref="P:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4">
            <summary>
            Wraps an existing <see cref="T:Microsoft.Build.Evaluation.IEvaluatorData`4"/> allowing the property usage to be tracked.
            </summary>
            <typeparam name="P">The type of properties to be produced.</typeparam>
            <typeparam name="I">The type of items to be produced.</typeparam>
            <typeparam name="M">The type of metadata on those items.</typeparam>
            <typeparam name="D">The type of item definitions to be produced.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.#ctor(Microsoft.Build.Evaluation.IEvaluatorData{`0,`1,`2,`3},Microsoft.Build.BackEnd.Components.Logging.EvaluationLoggingContext,System.Int32)">
            <summary>
            Creates an instance of the PropertyTrackingEvaluatorDataWrapper class.
            </summary>
            <param name="dataToWrap">The underlying <see cref="T:Microsoft.Build.Evaluation.IEvaluatorData`4"/> to wrap for property tracking.</param>
            <param name="evaluationLoggingContext">The <see cref="T:Microsoft.Build.BackEnd.Components.Logging.EvaluationLoggingContext"/> used to log relevant events.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.GetProperty(System.String)">
            <summary>
            Returns a property with the specified name, or null if it was not found.
            </summary>
            <param name="name">The property name.</param>
            <returns>The property.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.GetProperty(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a property with the specified name, or null if it was not found.
            Name is the segment of the provided string with the provided start and end indexes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.SetProperty(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets a property which does not come from the Xml.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.SetProperty(Microsoft.Build.Construction.ProjectPropertyElement,System.String)">
            <summary>
            Sets a property which comes from the Xml.
            Predecessor is any immediately previous property that was overridden by this one during evaluation.
            This would include all properties with the same name that lie above in the logical
            project file, and whose conditions evaluated to true.
            If there are none above this is null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.TrackPropertyRead(System.String,`0)">
            <summary>
            Logic containing what to do when a property is read.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="property">The value of the property that was read (null if there is no value).</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.TrackEnvironmentVariableRead(System.String)">
            <summary>
            Logs an EnvironmentVariableRead event.
            </summary>
            <param name="name">The name of the environment variable read.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.TrackUninitializedPropertyRead(System.String)">
            <summary>
            Logs an UninitializedPropertyRead event.
            </summary>
            <param name="name">The name of the uninitialized property read.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.TrackPropertyInitialValueSet(`0,Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper{`0,`1,`2,`3}.PropertySource)">
            <summary>
            If the property's initial value is set, it logs a PropertyInitialValueSet event.
            </summary>
            <param name="property">The property being set.</param>
            <param name="source">The source of the property.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.TrackPropertyReassignment(`0,`0,System.String)">
            <summary>
            If the property's value has changed, it logs a PropertyReassignment event.
            </summary>
            <param name="predecessor">The property's preceding state. Null if none.</param>
            <param name="property">The property's current state.</param>
            <param name="location">The location of this property's reassignment.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.DeterminePropertySource(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Determines the source of a property given the variables SetProperty arguments provided. This logic follows what's in <see cref="T:Microsoft.Build.Evaluation.Evaluator`4"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4.PropertySource">
            <summary>
            The available sources for a property.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.NewProjectFileOptions">
            <summary>
            Flags to control options when creating a new, in memory, project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.NewProjectFileOptions.None">
            <summary>
            Do not include any options.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlDeclaration">
            <summary>
            Include the XML declaration element.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeToolsVersion">
            <summary>
            Include the ToolsVersion attribute on the Project element.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlNamespace">
            <summary>
            Include the default MSBuild namespace on the Project element.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeAllOptions">
            <summary>
            Include all file options.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectCollectionChangedState">
            <summary>
            Properties or other mutable state associated with a <see cref="T:Microsoft.Build.Evaluation.ProjectCollection"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.DefaultToolsVersion">
            <summary>
            The <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.Toolsets">
            <summary>
            The toolsets changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.Loggers">
            <summary>
            The loggers changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.GlobalProperties">
            <summary>
            The global properties changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.IsBuildEnabled">
            <summary>
            The <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.OnlyLogCriticalEvents">
            <summary>
            The <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.HostServices">
            <summary>
            The <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.HostServices"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.DisableMarkDirty">
            <summary>
            The <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollectionChangedState.SkipEvaluation">
            <summary>
            The <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation"/> property changed.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs">
            <summary>
            Event arguments for the <see cref="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged"/> event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.#ctor(Microsoft.Build.Evaluation.ProjectCollectionChangedState)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.Changed">
            <summary>
            Gets the nature of the change made to the <see cref="T:Microsoft.Build.Evaluation.ProjectCollection"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectImportPathMatch">
            <summary>
            Class representing a reference to a project import path with property fall-back
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectImportPathMatch.None">
            <summary>
            ProjectImportPathMatch instance representing no fall-back
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectImportPathMatch.PropertyName">
            <summary>
            String representation of the property reference - eg. "MSBuildExtensionsPath32"
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectImportPathMatch.MsBuildPropertyFormat">
            <summary>
            Returns the corresponding property name - eg. "$(MSBuildExtensionsPath32)"
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectImportPathMatch.SearchPaths">
            <summary>
            Enumeration of the search paths for the property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectImportPathMatch.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectLoadSettings">
            <summary>
            Flags for controlling the project load.
            </summary>
            <remarks>
            This is a "flags" enum, allowing future settings to be added
            in an additive, non breaking fashion.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.Default">
            <summary>
            Normal load. This is the default.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports">
            <summary>
            Ignore nonexistent targets files when evaluating the project
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordDuplicateButNotCircularImports">
            <summary>
            Record imports including duplicate, but not circular, imports on the ImportsIncludingDuplicates property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RejectCircularImports">
            <summary>
            Throw an exception and stop the evaluation of a project if any circular imports are detected
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements">
            <summary>
            Record the item elements that got evaluated
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreEmptyImports">
            <summary>
            Ignore empty targets files when evaluating the project
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.DoNotEvaluateElementsWithFalseCondition">
            <summary>
            By default, evaluations performed via <see cref="T:Microsoft.Build.Evaluation.Project"/> evaluate and collect elements whose conditions were false (e.g. <see cref="P:Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition"/>).
            This flag turns off this behaviour. <see cref="T:Microsoft.Build.Evaluation.Project"/> members that collect such elements will throw when accessed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports">
            <summary>
            Ignore invalid target files when evaluating the project
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectLoadSettings.ProfileEvaluation">
            <summary>
            Whether to profile the evaluation
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Context.EvaluationContext">
            <summary>
                An object used by the caller to extend the lifespan of evaluation caches (by passing the object on to other
                evaluations).
                The caller should throw away the context when the environment changes (IO, environment variables, SDK resolution
                inputs, etc).
                This class and it's closure needs to be thread safe since API users can do evaluations in parallel.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Context.EvaluationContext.FileEntryExpansionCache">
            <summary>
            Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy)">
            <summary>
                Factory for <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext" />
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EvaluationLocationMarkdownPrettyPrinter">
            <summary>
            Pretty prints an evaluation location in markdown format
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationMarkdownPrettyPrinter.AppendHeader(System.Text.StringBuilder)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationMarkdownPrettyPrinter.AppendLocation(System.Text.StringBuilder,System.TimeSpan,Microsoft.Build.Framework.Profiler.EvaluationLocation,Microsoft.Build.Framework.Profiler.ProfiledLocation)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationMarkdownPrettyPrinter.NormalizeExpression(System.String,Microsoft.Build.Framework.Profiler.EvaluationLocationKind)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase">
            <summary>
            Pretty prints an evaluation location with its associated profiled location
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.AppendHeader(System.Text.StringBuilder)">
            <summary>
            Appends the header of all the locations to the string builder
            </summary>
            <param name="stringBuilder"></param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.AppendLocation(System.Text.StringBuilder,System.TimeSpan,Microsoft.Build.Framework.Profiler.EvaluationLocation,Microsoft.Build.Framework.Profiler.ProfiledLocation)">
            <summary>
            Appends a pretty printed location with its associated profiled data
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.NormalizeExpression(System.String,Microsoft.Build.Framework.Profiler.EvaluationLocationKind)">
            <summary>
            Normalizes the expression returned by <see cref="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.GetElementOrConditionText(System.String,Microsoft.Build.Framework.Profiler.EvaluationLocationKind)"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.GetMilliseconds(System.TimeSpan)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.GetPercentage(System.TimeSpan,System.TimeSpan)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.GetElementOrConditionText(System.String,Microsoft.Build.Framework.Profiler.EvaluationLocationKind)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.AppendDefaultHeaderWithSeparator(System.Text.StringBuilder,System.String)">
            <summary>
            Appends a default header with a given separator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase.AppendDefaultLocationWithSeparator(System.Text.StringBuilder,System.TimeSpan,Microsoft.Build.Framework.Profiler.EvaluationLocation,Microsoft.Build.Framework.Profiler.ProfiledLocation,System.String)">
            <summary>
            Appends a default representation of an evaluation location with a given separator
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EvaluationLocationTabSeparatedPrettyPrinter">
            <summary>
            Pretty prints an evaluation location in tab separated value (TSV) format
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationTabSeparatedPrettyPrinter.AppendHeader(System.Text.StringBuilder)">
            <inheritdoc/> 
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationTabSeparatedPrettyPrinter.AppendLocation(System.Text.StringBuilder,System.TimeSpan,Microsoft.Build.Framework.Profiler.EvaluationLocation,Microsoft.Build.Framework.Profiler.ProfiledLocation)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationLocationTabSeparatedPrettyPrinter.NormalizeExpression(System.String,Microsoft.Build.Framework.Profiler.EvaluationLocationKind)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EvaluationProfiler">
            <summary>
            Tracks an assortment of evaluation elements in a stack-like fashion, keeping inclusive and exclusive times for each of them.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.#ctor(System.Boolean)">
            <summary>
            If <param name="shouldTrackElements"/> is false, then requesting to track a given element has no effect and a null <see cref="T:System.IDisposable"/> is returned.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.EvaluationProfiler.ProfiledResult">
            <summary>
            Contains each evaluated location with its associated timed entry
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.TrackPass(Microsoft.Build.Framework.Profiler.EvaluationPass,System.String)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.TrackFile(System.String)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.TrackGlob(System.String,System.String,System.Collections.Generic.ISet{System.String})">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.TrackElement(Microsoft.Build.Construction.ProjectElement)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.TrackCondition(Microsoft.Build.Shared.IElementLocation,System.String)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.IsEmpty">
            <summary>
            Returns true when the evaluation stack is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EvaluationProfiler.EvaluationFrame">
            <summary>
            A frame in the evaluation tracker
            </summary>
            <remarks>
            Each frame keeps track of its inclusive and exclusive times
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.EvaluationProfiler.EvaluationFrame.Location">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.EvaluationFrame.#ctor(Microsoft.Build.Evaluation.EvaluationProfiler,Microsoft.Build.Framework.Profiler.EvaluationLocation)">
            <summary>
            Constructs a new evaluation frame and pushes it to the tracker stack
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluationProfiler.EvaluationFrame.Dispose">
            <summary>
            Pops this from the tracker stack and computes inclusive and exclusive times
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ItemSpec`2">
            <summary>
                Represents the elements of an item specification string (e.g. Include="*.cs;foo;@(i)") and
                provides some operations over them (like matching items against a given ItemSpec)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ItemSpec`2.Fragments">
            <summary>
                The fragments that compose an item spec string (values, globs, item references)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ItemSpec`2.Expander">
            <summary>
                The expander needs to have a default item factory set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ItemSpec`2.ItemSpecLocation">
            <summary>
                The xml attribute where this itemspec comes from
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ItemSpec`2.#ctor(System.String,Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.String,System.Boolean)">
            <param name="itemSpec">The string containing item syntax</param>
            <param name="expander">Expects the expander to have a default item factory set</param>
            <param name="itemSpecLocation">The xml location the itemspec comes from</param>
            <param name="projectDirectory">The directory that the project is in.</param>
            <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ItemSpec`2.MatchesItem(`1)">
            <summary>
                Return true if the given <paramref name="item" /> matches this itemspec
            </summary>
            <param name="item">The item to attempt to find a match for.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ItemSpec`2.FragmentsMatchingItem(System.String,System.Int32@)">
            <summary>
                Return the fragments that match against the given <paramref name="itemToMatch" />
            </summary>
            <param name="itemToMatch">The item to match.</param>
            <param name="matches">
                Total number of matches. Some fragments match more than once (item expression may contain multiple instances of
                <paramref name="itemToMatch" />)
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ItemSpec`2.ToMSBuildGlob">
            <summary>
                Return an MSBuildGlob that represents this ItemSpec.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ItemSpec`2.FlattenFragmentsAsStrings">
            <summary>
                Returns all the fragment strings that represent it.
                "1;*;2;@(foo)" gets returned as ["1", "2", "*", "a", "b"], given that @(foo)=["a", "b"]
                Order is not preserved. Globs are not expanded. Item expressions get replaced with their referring item instances.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ItemSpecFragment.TextFragment">
            <summary>
                The substring from the original itemspec representing this fragment
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ItemSpecFragment.ProjectDirectory">
            <summary>
                Path of the project the itemspec is coming from
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ItemSpecFragment.MatchCount(System.String)">
            <returns>The number of times the
                <param name="itemToMatch"></param>
                appears in this fragment
            </returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ItemsAndMetadataPair">
            <summary>
            Wrapper of two tables for a convenient method return value.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ItemsAndMetadataPair._items">
            <summary>
            The item set
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ItemsAndMetadataPair._metadata">
            <summary>
            The metadata dictionary.
            The key is the possibly qualified metadata name, for example
            "EmbeddedResource.Culture" or "Culture"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ItemsAndMetadataPair.#ctor(System.Collections.Generic.HashSet{System.String},System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.MetadataReference})">
            <summary>
            Constructs a pair from an item set and metadata
            </summary>
            <param name="items">The item set</param>
            <param name="metadata">The metadata dictionary</param>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ItemsAndMetadataPair.Items">
            <summary>
            Gets or sets the item set
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ItemsAndMetadataPair.Metadata">
            <summary>
            Gets or sets the metadata dictionary
            The key is the possibly qualified metadata name, for example
            "EmbeddedResource.Culture" or "Culture"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LazyItemEvaluator`4.GetCurrentDirectoryForConditionEvaluation(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Evaluation.LazyItemEvaluator{`0,`1,`2,`3})">
            <summary>
            COMPAT: Whidbey used the "current project file/targets" directory for evaluating Import and PropertyGroup conditions
            Orcas broke this by using the current root project file for all conditions
            For Dev10+, we'll fix this, and use the current project file/targets directory for Import, ImportGroup and PropertyGroup
            but the root project file for the rest. Inside of targets will use the root project file as always.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LazyItemEvaluator`4.MemoizedOperation.MarkAsReferenced">
            <summary>
            Somebody is referencing this operation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LazyItemEvaluator`4.LazyItemOperation.SelectItems(System.Collections.Immutable.ImmutableList{Microsoft.Build.Evaluation.LazyItemEvaluator{`0,`1,`2,`3}.ItemData}.Builder,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            Produce the items to operate on. For example, create new ones or select existing ones
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.MetadataReference">
            <summary>
            This struct represents a reference to a piece of item metadata.  For example,
            %(EmbeddedResource.Culture) or %(Culture) in the project file.  In this case,
            "EmbeddedResource" is the item name, and "Culture" is the metadata name.
            The item name is optional.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.MetadataReference.ItemName">
            <summary>
            The item name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.MetadataReference.MetadataName">
            <summary>
            The metadata name
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MetadataReference.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="itemName">Name of the item</param>
            <param name="metadataName">Name of the metadata</param>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProfilerResultPrettyPrinter">
            <summary>
            Pretty prints a profiled result to a variety of formats
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProfilerResultPrettyPrinter.GetMarkdownContent(Microsoft.Build.Framework.Profiler.ProfilerResult)">
            <summary>
            Gets a profiled result in a markdown-like form.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProfilerResultPrettyPrinter.GetTsvContent(Microsoft.Build.Framework.Profiler.ProfilerResult)">
            <summary>
            Gets a profiled result in a tab separated value form.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectChangedEventArgs">
            <summary>
            Event arguments for the <see cref="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged"/> event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectChangedEventArgs.#ctor(Microsoft.Build.Evaluation.Project)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Evaluation.ProjectChangedEventArgs"/> class.
            </summary>
            <param name="project">The changed project.</param>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectChangedEventArgs.Project">
            <summary>
            Gets the project that was marked dirty.
            </summary>
            <value>Never null.</value>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs">
            <summary>
            Event arguments for the <see cref="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged"/> event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs._unformattedReason">
            <summary>
            The unformatted reason for dirtying the project collection.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs._formattingParameter">
            <summary>
            The formatting parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs"/> class
            that represents a change to a specific project root element.
            </summary>
            <param name="projectXml">The ProjectRootElement whose content was actually changed.</param>
            <param name="unformattedReason">The unformatted (may contain {0}) reason for the dirty event.</param>
            <param name="formattingParameter">The formatting parameter to use with <paramref name="unformattedReason"/>.</param>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.ProjectXml">
            <summary>
            Gets the project root element which was just changed..
            </summary>
            <value>Never null.</value>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.Reason">
            <summary>
            Gets the reason for the change.
            </summary>
            <value>May be null.</value>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IToolsetProvider">
            <summary>
            Interface for an object which can provide toolsets for evaulation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IToolsetProvider.Toolsets">
            <summary>
            Gets an enumeration of all toolsets in the provider.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IToolsetProvider.GetToolset(System.String)">
            <summary>
            Retrieves a specific toolset.
            </summary>
            <param name="toolsVersion">The tools version for the toolset.</param>
            <returns>The requested toolset.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.BuiltInMetadata">
            <summary>
            This class encapsulates the behavior and collection of built-in metadata.  These metadatum
            are inferred from the content of the include and sometimes the context of the project or
            current directory.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.BuiltInMetadata.MetadataCount">
            <summary>
            Retrieves the count of built-in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.BuiltInMetadata.MetadataNames">
            <summary>
            Retrieves the list of metadata names.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.BuiltInMetadata.GetMetadataValue(System.String,System.String,System.String,System.String,System.String,System.String@)">
            <summary>
            Retrieves a built-in metadata value and caches it.
            Never returns null.
            </summary>
            <param name="currentDirectory">
            The current directory for evaluation.  Null if this is being called from a task, otherwise
            it should be the project's directory.
            </param>
            <param name="evaluatedIncludeBeforeWildcardExpansionEscaped">The evaluated include prior to wildcard expansion.</param>
            <param name="evaluatedIncludeEscaped">The evaluated include for the item.</param>
            <param name="definingProjectEscaped">The path to the project that defined this item</param>
            <param name="name">The name of the metadata.</param>
            <param name="fullPath">The generated full path, for caching</param>
            <returns>The unescaped metadata value.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.BuiltInMetadata.GetMetadataValueEscaped(System.String,System.String,System.String,System.String,System.String,System.String@)">
            <summary>
            Retrieves a built-in metadata value and caches it.
            If value is not available, returns empty string.
            </summary>
            <param name="currentDirectory">
            The current directory for evaluation.  Null if this is being called from a task, otherwise
            it should be the project's directory.
            </param>
            <param name="evaluatedIncludeBeforeWildcardExpansionEscaped">The evaluated include prior to wildcard expansion.</param>
            <param name="evaluatedIncludeEscaped">The evaluated include for the item.</param>
            <param name="definingProjectEscaped">The path to the project that defined this item</param>
            <param name="name">The name of the metadata.</param>
            <param name="fullPath">The generated full path, for caching</param>
            <returns>The escaped as necessary metadata value.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.BuiltInMetadata.GetRecursiveDirValue(System.String,System.String)">
            <summary>
            Extract the value for "RecursiveDir", if any, from the Include.
            If there is none, returns an empty string.
            </summary>
            <remarks>
            Inputs to and outputs of this function are all escaped.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetDefinitionLocations">
            <summary>
            Flags for controlling the toolset initialization.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetDefinitionLocations.None">
            <summary>
            Do not read toolset information from any external location.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile">
            <summary>
            Read toolset information from the exe configuration file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry">
            <summary>
            Read toolset information from the registry (HKLM\Software\Microsoft\MSBuild\ToolsVersions).
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Local">
            <summary>
            Read toolset information from the current exe path
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Default">
            <summary>
            Use the default location or locations.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectCollection">
            <summary>
            This class encapsulates a set of related projects, their toolsets, a default set of global properties,
            and the loggers that should be used to build them.
            A global version of this class acts as the default ProjectCollection.
            Multiple ProjectCollections can exist within an appdomain. However, these must not build concurrently.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._locker">
            <summary>
            The object to synchronize with when accessing certain fields.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.s_globalProjectCollection">
            <summary>
            The global singleton project collection used as a default for otherwise
            unassociated projects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.s_engineVersion">
            <summary>
            Gets the file version of the file in which the Engine assembly lies.
            </summary>
            <remarks>
            This is the Windows file version (specifically the value of the ProductVersion
            resource), not necessarily the assembly version.
            If you want the assembly version, use Constants.AssemblyVersion.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.s_assemblyDisplayVersion">
            <summary>
            The display version of the file in which the Engine assembly lies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._loadedProjects">
            <summary>
            The projects loaded into this collection.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._link">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._loggingService">
            <summary>
            Single logging service used for all builds of projects in this project collection
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._hostServices">
            <summary>
            Any object exposing host services.
            May be null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._toolsets">
            <summary>
            A mapping of tools versions to Toolsets, which contain the public Toolsets.
            This is the collection we use internally.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._globalProperties">
            <summary>
            The default global properties.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._environmentProperties">
            <summary>
            The properties representing the environment.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._defaultToolsVersion">
            <summary>
            The default tools version obtained by examining all of the toolsets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._toolsetsVersion">
            <summary>
            A counter incremented every time the toolsets change which would necessitate a re-evaluation of
            associated projects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._isBuildEnabled">
            <summary>
            This is the default value used by newly created projects for whether or not the building
            of projects is enabled.  This is for security purposes in case a host wants to closely
            control which projects it allows to run targets/tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._onlyLogCriticalEvents">
            <summary>
            We may only wish to log critical events, record that fact so we can apply it to build requests
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._skipEvaluation">
            <summary>
            Whether reevaluation is temporarily disabled on projects in this collection.
            This is useful when the host expects to make a number of reads and writes 
            to projects, and wants to temporarily sacrifice correctness for performance.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._disableMarkDirty">
            <summary>
            Whether <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty">MarkDirty()</see> is temporarily disabled on
            projects in this collection.
            This allows, for example, global properties to be set without projects getting
            marked dirty for reevaluation as a consequence.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection._maxNodeCount">
            <summary>
            The maximum number of nodes which can be started during the build
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.#cctor">
            <summary>
            Hook up last minute dumping of any exceptions bringing down the process
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor">
            <summary>
            Instantiates a project collection with no global properties or loggers that reads toolset 
            information from the configuration file and registry.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(Microsoft.Build.Evaluation.ToolsetDefinitionLocations)">
            <summary>
            Instantiates a project collection using toolsets from the specified locations,
            and no global properties or loggers.
            May throw InvalidToolsetDefinitionException.
            </summary>
            <param name="toolsetLocations">The locations from which to load toolsets.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Instantiates a project collection with specified global properties, no loggers,
            and that reads toolset information from the configuration file and registry.
            May throw InvalidToolsetDefinitionException.
            </summary>
            <param name="globalProperties">The default global properties to use. May be null.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},Microsoft.Build.Evaluation.ToolsetDefinitionLocations)">
            <summary>
            Instantiates a project collection with specified global properties and loggers and using the
            specified toolset locations.
            May throw InvalidToolsetDefinitionException.
            </summary>
            <param name="globalProperties">The default global properties to use. May be null.</param>
            <param name="loggers">The loggers to register. May be null.</param>
            <param name="toolsetDefinitionLocations">The locations from which to load toolsets.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.ToolsetDefinitionLocations,System.Int32,System.Boolean)">
            <summary>
            Instantiates a project collection with specified global properties and loggers and using the
            specified toolset locations, node count, and setting of onlyLogCriticalEvents.
            Global properties and loggers may be null.
            Throws InvalidProjectFileException if any of the global properties are reserved.
            May throw InvalidToolsetDefinitionException.
            </summary>
            <param name="globalProperties">The default global properties to use. May be null.</param>
            <param name="loggers">The loggers to register. May be null and specified to any build instead.</param>
            <param name="remoteLoggers">Any remote loggers to register. May be null and specified to any build instead.</param>
            <param name="toolsetDefinitionLocations">The locations from which to load toolsets.</param>
            <param name="maxNodeCount">The maximum number of nodes to use for building.</param>
            <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.ToolsetDefinitionLocations,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Instantiates a project collection with specified global properties and loggers and using the
            specified toolset locations, node count, and setting of onlyLogCriticalEvents.
            Global properties and loggers may be null.
            Throws InvalidProjectFileException if any of the global properties are reserved.
            May throw InvalidToolsetDefinitionException.
            </summary>
            <param name="globalProperties">The default global properties to use. May be null.</param>
            <param name="loggers">The loggers to register. May be null and specified to any build instead.</param>
            <param name="remoteLoggers">Any remote loggers to register. May be null and specified to any build instead.</param>
            <param name="toolsetDefinitionLocations">The locations from which to load toolsets.</param>
            <param name="maxNodeCount">The maximum number of nodes to use for building.</param>
            <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
            <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler">
            <summary>
            Handler to receive which project got added to the project collection.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded">
            <summary>
            Event that is fired when a project is added to the ProjectRootElementCache of this project collection.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged">
            <summary>
            Raised when state is changed on this instance.
            </summary>
            <remarks>
            This event is NOT raised for changes in individual projects.
            </remarks>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged">
            <summary>
            Raised when a <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/> contained by this instance is changed.
            </summary>
            <remarks>
            This event is NOT raised for changes to global properties, or any other change that doesn't actually dirty the XML.
            </remarks>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged">
            <summary>
            Raised when a <see cref="T:Microsoft.Build.Evaluation.Project"/> contained by this instance is directly changed.
            </summary>
            <remarks>
            This event is NOT raised for direct project XML changes via the construction model.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection">
            <summary>
            Retrieves the global project collection object.
            This is a singleton project collection with no global properties or loggers that reads toolset 
            information from the configuration file and registry.
            May throw InvalidToolsetDefinitionException.
            Thread safe.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.Version">
            <summary>
            Gets the file version of the file in which the Engine assembly lies.
            </summary>
            <remarks>
            This is the Windows file version (specifically the value of the FileVersion
            resource), not necessarily the assembly version.
            If you want the assembly version, use Constants.AssemblyVersion.
            This is not the <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.ToolsetsVersion">ToolsetCollectionVersion</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.DisplayVersion">
            <summary>
            Gets a version of the Engine suitable for display to a user.
            </summary>
            <remarks>
            This is in the form of a SemVer v2 version, Major.Minor.Patch-prerelease+metadata.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion">
            <summary>
            The default tools version of this project collection. Projects use this tools version if they
            aren't otherwise told what tools version to use.
            This value is gotten from the .exe.config file, or else in the registry, 
            or if neither specify a default tools version then it is hard-coded to the tools version "2.0".
            Setter throws InvalidOperationException if a toolset with the provided tools version has not been defined.
            Always defined.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties">
            <summary>
            Returns default global properties for all projects in this collection.
            Read-only dead dictionary.
            </summary>
            <remarks>
            This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
            
            To be consistent with Project, setting and removing global properties is done with 
            <see cref="M:Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(System.String,System.String)">SetGlobalProperty</see> and <see cref="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(System.String)">RemoveGlobalProperty</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects">
            <summary>
            All the projects currently loaded into this collection.
            Each has a unique combination of path, global properties, and tools version.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.Count">
            <summary>
            Number of projects currently loaded into this collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.Loggers">
            <summary>
            Loggers that all contained projects will use for their builds.
            Loggers are added with the <see cref="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger)"/>.
            UNDONE: Currently they cannot be removed.
            Returns an empty collection if there are no loggers.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.Toolsets">
            <summary>
            Returns the toolsets this ProjectCollection knows about.
            </summary>
            <comments>
            ValueCollection is already read-only
            </comments>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations">
            <summary>
            Returns the locations used to find the toolsets.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled">
            <summary>
            This is the default value used by newly created projects for whether or not the building
            of projects is enabled.  This is for security purposes in case a host wants to closely
            control which projects it allows to run targets/tasks.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents">
            <summary>
            When true, only log critical events such as warnings and errors. Has to be in here for API compat
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.HostServices">
            <summary>
            Object exposing host services to tasks during builds of projects
            contained by this project collection.
            By default, <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.HostServices">HostServices</see> is used.
            May be set to null, but the getter will create a new instance in that case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation">
            <summary>
            Whether reevaluation is temporarily disabled on projects in this collection.
            This is useful when the host expects to make a number of reads and writes 
            to projects, and wants to temporarily sacrifice correctness for performance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty">
            <summary>
            Whether <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty">MarkDirty()</see> is temporarily disabled on
            projects in this collection.
            This allows, for example, global properties to be set without projects getting
            marked dirty for reevaluation as a consequence.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.CollectionId">
            <summary>
            Global collection id.
            Can be used for external providers to optimize the cross-site link exchange
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.Link">
            <summary>
            External project support.
            Establish a remote project link for this collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.LoggingService">
            <summary>
            Logging service that should be used for project load and for builds
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.GlobalPropertiesCollection">
            <summary>
            Gets default global properties for all projects in this collection.
            Dead copy.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.EnvironmentProperties">
            <summary>
            Returns the property dictionary containing the properties representing the environment.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.ToolsetsVersion">
            <summary>
            Returns the internal version for this object's state.
            Updated when toolsets change, indicating all contained projects are potentially invalid.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.MaxNodeCount">
            <summary>
            The maximum number of nodes which can be started during the build
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.ProjectRootElementCache">
            <summary>
            The cache of project root elements associated with this project collection.
            Each is associated with a specific project collection for two reasons:
            - To help protect one project collection from any XML edits through another one:
            until a reload from disk - when it's ready to accept changes - it won't see the edits;
            - So that the owner of this project collection can force the XML to be loaded again
            from disk, by doing <see cref="M:Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.Escape(System.String)">
            <summary>
            Escape a string using MSBuild escaping format. For example, "%3b" for ";".
            Only characters that are especially significant to MSBuild parsing are escaped.
            Callers can use this method to make a string safe to be parsed to other methods
            that would otherwise expand it; or to make a string safe to be written to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.Unescape(System.String)">
            <summary>
            Unescape a string using MSBuild escaping format. For example, "%3b" for ";".
            All escaped characters are unescaped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(System.String)">
            <summary>
            Returns true if there is a toolset defined for the specified 
            tools version, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset)">
            <summary>
            Add a new toolset.
            Replaces any existing toolset with the same tools version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(System.String)">
            <summary>
            Remove a toolset.
            Returns true if it was present, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets">
            <summary>
            Removes all toolsets.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.GetToolset(System.String)">
            <summary>
            Get the toolset with the specified tools version.
            If it is not present, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.GetEffectiveToolsVersion(System.String,System.String)">
            <summary>
            Figure out what ToolsVersion to use to actually build the project with. 
            </summary>
            <param name="explicitToolsVersion">The user-specified ToolsVersion (through e.g. /tv: on the command line). May be null</param>
            <param name="toolsVersionFromProject">The ToolsVersion from the project file. May be null</param>
            <returns>The ToolsVersion we should use to build this project.  Should never be null.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(System.String)">
            <summary>
            Returns any and all loaded projects with the provided path.
            There may be more than one, if they are distinguished by global properties
            and/or tools version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(System.Boolean,System.String)">
            <summary>
            Returns any and all loaded projects with the provided path.
            There may be more than one, if they are distinguished by global properties
            and/or tools version.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.String)">
            <summary>
            Loads a project with the specified filename, using the collection's global properties and tools version.
            If a matching project is already loaded, it will be returned, otherwise a new project will be loaded.
            </summary>
            <param name="fileName">The project file to load</param>
            <returns>A loaded project.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.String,System.String)">
            <summary>
            Loads a project with the specified filename and tools version, using the collection's global properties.
            If a matching project is already loaded, it will be returned, otherwise a new project will be loaded.
            </summary>
            <param name="fileName">The project file to load</param>
            <param name="toolsVersion">The tools version to use. May be null.</param>
            <returns>A loaded project.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Loads a project with the specified filename, tools version and global properties.
            If a matching project is already loaded, it will be returned, otherwise a new project will be loaded.
            </summary>
            <param name="fileName">The project file to load</param>
            <param name="globalProperties">The global properties to use. May be null, in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">The tools version. May be null.</param>
            <returns>A loaded project.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader)">
            <summary>
            Loads a project with the specified reader, using the collection's global properties and tools version.
            The project will be added to this project collection when it is named.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
            <returns>A loaded project.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader,System.String)">
            <summary>
            Loads a project with the specified reader and tools version, using the collection's global properties.
            The project will be added to this project collection when it is named.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
            <param name="toolsVersion">The tools version to use. May be null.</param>
            <returns>A loaded project.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Loads a project with the specified reader, tools version and global properties.
            The project will be added to this project collection when it is named.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
            <param name="globalProperties">The global properties to use. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">The tools version. May be null.</param>
            <returns>A loaded project.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger)">
            <summary>
            Adds a logger to the collection of loggers used for builds of projects in this collection.
            If the logger object is already in the collection, does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})">
            <summary>
            Adds some loggers to the collection of loggers used for builds of projects in this collection.
            If any logger object is already in the collection, does nothing for that logger.
            May be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})">
            <summary>
            Adds some remote loggers to the collection of remote loggers used for builds of projects in this collection.
            May be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers">
            <summary>
            Removes all loggers from the collection of loggers used for builds of projects in this collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project)">
            <summary>
            Unloads the specific project specified.
            Host should call this when they are completely done with the project.
            If project was not already loaded, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Unloads a project XML root element from the weak cache.
            </summary>
            <param name="projectRootElement">The project XML root element to unload.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the project XML root element to unload is still in use by a loaded project or its imports.
            </exception>
            <remarks>
            This method is useful for the case where the host knows that all projects using this XML element
            are unloaded, and desires to discard any unsaved changes.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects">
            <summary>
            Unloads all the projects contained by this ProjectCollection.
            Host should call this when they are completely done with all the projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(System.String)">
            <summary>
            Get any global property on the project collection that has the specified name,
            otherwise returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(System.String,System.String)">
            <summary>
            Set a global property at the collection-level,
            and on all projects in the project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(System.String)">
            <summary>
            Removes a global property from the collection-level set of global properties,
            and all projects in the project collection.
            If it was on this project collection, returns true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.Dispose">
            <summary>
            Called when a host is completely done with the project collection.
            UNDONE: This is a hack to make sure the logging thread shuts down if the build used the logging service
            off the ProjectCollection. After CTP we need to rationalize this and see if we can remove the logging service from
            the project collection entirely so this isn't necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.Microsoft#Build#BackEnd#IBuildComponent#InitializeComponent(Microsoft.Build.BackEnd.IBuildComponentHost)">
            <summary>
            Initializes the component with the component host.
            </summary>
            <param name="host">The component host.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.Microsoft#Build#BackEnd#IBuildComponent#ShutdownComponent">
            <summary>
            Shuts down the component.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Unloads a project XML root element from the cache entirely, if it is not
            in use by project loaded into this collection.
            Returns true if it was unloaded successfully, or was not already loaded.
            Returns false if it was not unloaded because it was still in use by a loaded <see cref="T:Microsoft.Build.Evaluation.Project"/>.
            </summary>
            <param name="projectRootElement">The project XML root element to unload.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.OnAfterRenameLoadedProject(System.String,Microsoft.Build.Evaluation.Project)">
            <summary>
            Called by a Project object to load itself into this collection.
            If the project was already loaded under a different name, it is unloaded.
            Stores the project in the list of loaded projects if it has a name.
            Does not store the project if it has no name because it has not been saved to disk yet.
            If the project previously had a name, but was not in the collection already, throws InvalidOperationException.
            If the project was not previously in the collection, sets the collection's global properties on it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.AfterUpdateLoadedProjectGlobalProperties(Microsoft.Build.Evaluation.Project)">
            <summary>
            Called after a loaded project's global properties are changed, so we can update
            our loaded project table.
            Project need not already be in the project collection yet, but it can't be in another one.
            </summary>
            <remarks>
            We have to remove and re-add so that there's an error if there's already an equivalent
            project loaded.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.Dispose(System.Boolean)">
            <summary>
            Following standard framework guideline dispose pattern.
            Shut down logging service if the project collection owns one, in order
            to shut down the logger thread and loggers.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources..</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveToolsetInternal(System.String)">
            <summary>
            Remove a toolset and does not raise events. The caller should have acquired a write lock on this method's behalf.
            </summary>
            <param name="toolsVersion">The toolset to remove.</param>
            <returns><c>true</c> if the toolset was found and removed; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggerInternal(Microsoft.Build.Framework.ILogger)">
            <summary>
            Adds a logger to the collection of loggers used for builds of projects in this collection.
            If the logger object is already in the collection, does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ProjectRootElementCache_ProjectRootElementAddedHandler(System.Object,Microsoft.Build.Evaluation.ProjectRootElementCacheAddEntryEventArgs)">
            <summary>
            Handler which is called when a project is added to the RootElementCache of this project collection. We then fire an event indicating that a project was added to the collection itself.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ProjectRootElementCache_ProjectRootElementDirtiedHandler(System.Object,Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs)">
            <summary>
            Handler which is called when a project that is part of this collection is dirtied. We then fire an event indicating that a project has been dirtied.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ProjectRootElementCache_ProjectDirtiedHandler(System.Object,Microsoft.Build.Evaluation.ProjectChangedEventArgs)">
            <summary>
            Handler which is called when a project is dirtied.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.OnProjectXmlChanged(Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs)">
            <summary>
            Raises the <see cref="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged"/> event.
            </summary>
            <param name="e">The event arguments that indicate ProjectRootElement-specific details.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.OnProjectChanged(Microsoft.Build.Evaluation.ProjectChangedEventArgs)">
            <summary>
            Raises the <see cref="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged"/> event.
            </summary>
            <param name="e">The event arguments that indicate Project-specific details.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.OnProjectCollectionChanged(Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged"/> event.
            </summary>
            <param name="e">The event arguments that indicate details on what changed on the collection.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ShutDownLoggingService">
            <summary>
            Shutdown the logging service
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.CreateLoggingService(System.Int32,System.Boolean)">
            <summary>
            Create a new logging service
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ResetToolsetsForTests(Microsoft.Build.Evaluation.ToolsetConfigurationReader)">
            <summary>
            Reset the toolsets using the provided toolset reader, used by unit tests
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ResetToolsetsForTests(Microsoft.Build.Evaluation.ToolsetRegistryReader)">
            <summary>
            Reset the toolsets using the provided toolset reader, used by unit tests
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.InitializeToolsetCollection(Microsoft.Build.Evaluation.ToolsetRegistryReader,Microsoft.Build.Evaluation.ToolsetConfigurationReader)">
            <summary>
            Populate Toolsets with a dictionary of (toolset version, Toolset) 
            using information from the registry and config file, if any.  
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs">
            <summary>
            Event to provide information about what project just got added to the project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.#ctor(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            The root element which was added to the project collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectRootElement">
            <summary>
            Root element which was added to the project collection.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger">
            <summary>
            The ReusableLogger wraps a logger and allows it to be used for both design-time and build-time.  It internally swaps
            between the design-time and build-time event sources in response to Initialize and Shutdown events.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._originalLogger">
            <summary>
            The logger we are wrapping.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._designTimeEventSource">
            <summary>
            The design-time event source
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._buildTimeEventSource">
            <summary>
            The build-time event source
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._anyEventHandler">
            <summary>
            The Any event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._buildFinishedEventHandler">
            <summary>
            The BuildFinished event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._buildStartedEventHandler">
            <summary>
            The BuildStarted event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._customBuildEventHandler">
            <summary>
            The Custom event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._buildErrorEventHandler">
            <summary>
            The Error event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._buildMessageEventHandler">
            <summary>
            The Message event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._projectFinishedEventHandler">
            <summary>
            The ProjectFinished event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._projectStartedEventHandler">
            <summary>
            The ProjectStarted event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._buildStatusEventHandler">
            <summary>
            The Status event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._targetFinishedEventHandler">
            <summary>
            The TargetFinished event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._targetStartedEventHandler">
            <summary>
            The TargetStarted event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._taskFinishedEventHandler">
            <summary>
            The TaskFinished event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._taskStartedEventHandler">
            <summary>
            The TaskStarted event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._buildWarningEventHandler">
            <summary>
            The Warning event handler
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger._telemetryEventHandler">
            <summary>
             The telemetry event handler.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.#ctor(Microsoft.Build.Framework.ILogger)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.MessageRaised">
            <summary>
            The Message logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.ErrorRaised">
            <summary>
            The Error logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.WarningRaised">
            <summary>
            The Warning logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.BuildStarted">
            <summary>
            The BuildStarted logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.BuildFinished">
            <summary>
            The BuildFinished logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.ProjectStarted">
            <summary>
            The ProjectStarted logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.ProjectFinished">
            <summary>
            The ProjectFinished logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TargetStarted">
            <summary>
            The TargetStarted logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TargetFinished">
            <summary>
            The TargetFinished logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TaskStarted">
            <summary>
            The TashStarted logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TaskFinished">
            <summary>
            The TaskFinished logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.CustomEventRaised">
            <summary>
            The Custom logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.StatusEventRaised">
            <summary>
            The Status logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.AnyEventRaised">
            <summary>
            The Any logging event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TelemetryLogged">
            <summary>
            The telemetry sent event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.IncludeEvaluationMetaprojects">
            <summary>
            Should evaluation events include generated metaprojects?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.IncludeEvaluationProfiles">
            <summary>
            Should evaluation events include profiling information?
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.IncludeTaskInputs">
            <summary>
            Should task events include task inputs?
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.Verbosity">
            <summary>
            The logger verbosity
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.Parameters">
            <summary>
            The logger parameters
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            If we haven't yet been initialized, we register for design time events and initialize the logger we are holding.
            If we are in design-time mode
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            If we haven't yet been initialized, we register for design time events and initialize the logger we are holding.
            If we are in design-time mode
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.Shutdown">
            <summary>
            If we are in build-time mode, we unregister for build-time events and re-register for design-time events.
            If we are in design-time mode, we unregister for design-time events and shut down the logger we are holding.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.RegisterForEvents(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Registers for all of the events on the specified event source.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.UnregisterForEvents(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Unregisters for all events on the specified event source.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.WarningRaisedHandler(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Handler for Warning events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs)">
            <summary>
            Handler for TaskStarted events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs)">
            <summary>
            Handler for TaskFinished events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs)">
            <summary>
            Handler for TargetStarted events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Handler for TargetFinished events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.StatusEventRaisedHandler(System.Object,Microsoft.Build.Framework.BuildStatusEventArgs)">
            <summary>
            Handler for Status events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Handler for ProjectStarted events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Handler for ProjectFinished events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.MessageRaisedHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Handler for Message events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.ErrorRaisedHandler(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Handler for Error events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.CustomEventRaisedHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Handler for Custom events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Handler for BuildStarted events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Handler for BuildFinished events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.AnyEventRaisedHandler(System.Object,Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Handler for Any events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.TelemetryLoggedHandler(System.Object,Microsoft.Build.Framework.TelemetryEventArgs)">
            <summary>
            Handler for telemetry events.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection">
            <summary>
            Holder for the projects loaded into this collection.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection._loadedProjects">
             <summary>
             The collection of all projects already loaded into this collection.
             Key is the full path to the project, value is a list of projects with that path, each
             with different global properties and/or tools version.
             </summary>
             <remarks>
             If hosts tend to load lots of projects with the same path, the value will have to be 
             changed to a more efficient type of collection.
            
             Lock on this object. Concurrent load must be thread safe.
             Not using ConcurrentDictionary because some of the add/update
             semantics would get convoluted.
             </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection._count">
            <summary>
            Count of loaded projects
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.Count">
            <summary>
            Returns the number of projects currently loaded
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.GetEnumerator">
            <summary>
            Enumerate all the projects
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerate all the projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.GetMatchingProjectsIfAny(System.String)">
            <summary>
            Get all projects with the provided path.
            Returns an empty list if there are none.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.GetMatchingProjectIfAny(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Returns the project in the collection matching the path, global properties, and tools version provided.
            There can be no more than one match.
            If none is found, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.AddProject(Microsoft.Build.Evaluation.Project)">
            <summary>
            Adds the provided project to the collection.
            If there is already an equivalent project, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.RemoveProject(Microsoft.Build.Evaluation.Project)">
            <summary>
            Removes the provided project from the collection.
            If project was not loaded, returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.RemoveProject(System.String,Microsoft.Build.Evaluation.Project)">
            <summary>
            Removes a project, using the specified full path to use as the key to find it.
            This is specified separately in case the project was previously stored under a different path.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.RemoveAllProjects">
            <summary>
            Removes all projects from the collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjectCollection.HasEquivalentGlobalPropertiesAndToolsVersion(Microsoft.Build.Evaluation.Project,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Returns true if the global properties and tools version provided are equivalent to
            those in the provided project, otherwise false.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Project">
            <summary>
            Represents an evaluated project with design time semantics.
            Always backed by XML; can be built directly, or an instance can be cloned off to add virtual items/properties and build.
            Edits to this project always update the backing XML.
            </summary>
            <remarks>
            UNDONE: (Multiple configurations.) Protect against problems when attempting to edit, after edits were made to the same ProjectRootElement either directly or through other projects evaluated from that ProjectRootElement.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.s_debugEvaluation">
            <summary>
            Whether to write information about why we evaluate to debug output.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.s_buildEventContext">
            <summary>
            Context to log messages and events in
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.DefaultNewProjectTemplateOptions">
            <summary>
            Default project template options (include all features).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement">
             <summary>
             Certain item operations split the item element in multiple elements if the include
             contains globs, references to items or properties, or multiple item values.
            
             The items operations that may expand item elements are:
             - <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)"/>
             - <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})"/>
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})"/>
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.ChangeItemType(System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)"/>
             
             When this property is set to true, the previous item operations throw an <exception cref="T:System.InvalidOperationException"></exception>
             instead of expanding the item element. 
             </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor">
            <summary>
            Construct an empty project, evaluating with the global project collection's
            global properties and default tools version.
            Project will be added to the global project collection when it is named.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Construct an empty project, evaluating with the global project collection's
            global properties and default tools version.
            Project will be added to the global project collection when it is named.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Construct an empty project, evaluating with the specified project collection's
            global properties and default tools version.
            Project will be added to the specified project collection when it is named.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Construct an empty project, evaluating with the specified project collection's
            global properties and default tools version.
            Project will be added to the specified project collection when it is named.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Construct an empty project, evaluating with the specified project collection and
            the specified global properties and default tools version, either of which may be null.
            Project will be added to the specified project collection when it is named.
            </summary>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection"/> the project is added to.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Construct an empty project, evaluating with the specified project collection and
            the specified global properties and default tools version, either of which may be null.
            Project will be added to the specified project collection when it is named.
            </summary>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection"/> the project is added to.</param>
            <param name="newProjectFileOptions">The <see cref="T:Microsoft.Build.Evaluation.NewProjectFileOptions"/> to use for the new project.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Construct over a ProjectRootElement object, evaluating with the global project collection's
            global properties and default tools version.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xml">ProjectRootElement to use</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xml">ProjectRootElement to use</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xml">ProjectRootElement to use</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection"/> the project is added to.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)">
            <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xml">ProjectRootElement to use</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection"/> the project is added to.</param>
            <param name="loadSettings">The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings"/> to use for evaluation.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)">
            <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xml">ProjectRootElement to use</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
            <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection"/> the project is added to.</param>
            <param name="loadSettings">The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings"/> to use for evaluation.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader)">
            <summary>
            Construct over a text reader over project xml, evaluating with the global project collection's
            global properties and default tools version.
            Project will be added to the global project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the global project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the specified project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)">
            <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the specified project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
            <param name="loadSettings">The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings"/> to use for evaluation.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)">
            <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the specified project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="xmlReader">Xml reader to read project from</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
            <param name="loadSettings">The load settings for this project.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.String)">
            <summary>
            Construct over an existing project file, evaluating with the global project collection's
            global properties and default tools version.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">If the evaluation fails.</exception>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            Construct over an existing project file, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Construct over an existing project file, evaluating with the specified global properties and 
            using the tools version provided, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
            <param name="projectFile">The project file</param>
            <param name="globalProperties">The global properties. May be null.</param>
            <param name="toolsVersion">The tools version. May be null.</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)">
            <summary>
            Construct over an existing project file, evaluating with the specified global properties and 
            using the tools version provided, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
            <param name="projectFile">The project file</param>
            <param name="globalProperties">The global properties. May be null.</param>
            <param name="toolsVersion">The tools version. May be null.</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
            <param name="loadSettings">The load settings for this project.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)">
            <summary>
            Construct over an existing project file, evaluating with the specified global properties and 
            using the tools version provided, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
            <param name="projectFile">The project file</param>
            <param name="globalProperties">The global properties. May be null.</param>
            <param name="toolsVersion">The tools version. May be null.</param>
            <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
            <param name="loadSettings">The load settings for this project.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.FromFile(System.String,Microsoft.Build.Definition.ProjectOptions)">
            <summary>
            Create a file based project.
            </summary>
            <param name="file">The file to evaluate the project from.</param>
            <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions"/> to use.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Definition.ProjectOptions)">
            <summary>
            Create a <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/> based project.
            </summary>
            <param name="rootElement">The <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/> to evaluate the project from.</param>
            <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions"/> to use.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader,Microsoft.Build.Definition.ProjectOptions)">
            <summary>
            Create a <see cref="T:System.Xml.XmlReader"/> based project.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> to evaluate the project from.</param>
            <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions"/> to use.</param>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Project.BuildEnabledSetting">
            <summary>
            Whether build is enabled for this project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.BuildEnabledSetting.BuildEnabled">
            <summary>
            Explicitly enabled
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.BuildEnabledSetting.BuildDisabled">
            <summary>
            Explicitly disabled
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.BuildEnabledSetting.UseProjectCollectionSetting">
            <summary>
            No explicit setting, uses the setting on the
            project collection.
            This is the default.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectCollection">
            <summary>
            Gets or sets the project collection which contains this project.
            Can never be null.
            Cannot be modified.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Xml">
            <summary>
            The backing Xml project.
            Can never be null
            </summary>
            <remarks>
            There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.IsDirty">
            <summary>
            Whether this project is dirty such that it needs reevaluation.
            This may be because its underlying XML has changed (either through this project or another)
            either the XML of the main project or an imported file; 
            or because its toolset may have changed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.GlobalProperties">
            <summary>
            Read only dictionary of the global properties used in the evaluation
            of this project.
            </summary>
            <remarks>
            This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
            
            In order to easily tell when we're dirtied, setting and removing global properties is done with 
            <see cref="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)">SetGlobalProperty</see> and <see cref="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)">RemoveGlobalProperty</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ItemTypes">
            <summary>
            Item types in this project.
            This is an ordered collection.
            </summary>
            <comments>
            data.ItemTypes is a KeyCollection, so it doesn't need any 
            additional read-only protection
            </comments>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Properties">
            <summary>
            Properties in this project.
            Since evaluation has occurred, this is an unordered collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ConditionedProperties">
            <summary>
            Collection of possible values implied for properties contained in the conditions found on properties,
            property groups, imports, and whens.
            
            For example, if the following conditions existed on properties in a project:
            
            Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
            Condition="'$(Configuration)' == 'Release'"
            
            the table would be populated with
            
            { "Configuration", { "Debug", "Release" }}
            { "Platform", { "x86" }}
            
            This is used by Visual Studio to determine the configurations defined in the project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ItemDefinitions">
            <summary>
            Read-only dictionary of item definitions in this project.
            Keyed by item type
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Items">
            <summary>
            Items in this project, ordered within groups of item types
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition">
            <summary>
            Items in this project, ordered within groups of item types,
            including items whose conditions evaluated to false, or that were
            contained within item groups who themselves had conditioned evaluated to false.
            This is useful for hosts that wish to display all items, even if they might not be part 
            of the build in the current configuration.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Imports">
            <summary>
            All the files that during evaluation contributed to this project, as ProjectRootElements,
            with the ProjectImportElement that caused them to be imported.
            This does not include projects that were never imported because a condition on an Import element was false.
            The outer ProjectRootElement that maps to this project itself is not included.
            </summary>
            <remarks>
            This can be used by the host to figure out what projects might be impacted by a change to a particular file.
            It could also be used, for example, to find the .user file, and use its ProjectRootElement to modify properties in it.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates">
            <summary>
            This list will contain duplicate imports if an import is imported multiple times. However, only the first import was used in evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Targets">
            <summary>
            Targets in the project. The key to the dictionary is the target's name.
            Overridden targets are not included in this collection.
            This collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.AllEvaluatedProperties">
            <summary>
            Properties encountered during evaluation. These are read during the first evaluation pass.
            Unlike those returned by the Properties property, these are ordered, and includes any properties that
            were subsequently overridden by others with the same name. It does not include any 
            properties whose conditions did not evaluate to true.
            It does not include any properties added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata">
            <summary>
            Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
            Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
            were subsequently overridden by others with the same name and item type. It does not include any 
            elements whose conditions did not evaluate to true.
            It does not include any item definition metadata added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItems">
            <summary>
            Items encountered during evaluation. These are read during the third evaluation pass.
            Unlike those returned by the Items property, these are ordered with respect to all other items 
            encountered during evaluation, not just ordered with respect to items of the same item type.
            In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
            can use this property.
            It does not include any elements whose conditions did not evaluate to true.
            It does not include any items added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ToolsVersion">
            <summary>
            The tools version this project was evaluated with, if any.
            Not necessarily the same as the tools version on the Project tag, if any;
            it may have been externally specified, for example with a /tv switch.
            The actual tools version on the Project tag, can be gotten from <see cref="P:Microsoft.Build.Evaluation.Project.Xml">Xml.ToolsVersion</see>.
            Cannot be changed once the project has been created.
            </summary>
            <remarks>
            Set by construction.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.SubToolsetVersion">
            <summary>
            The sub-toolset version that, combined with the ToolsVersion, was used to determine
            the toolset properties for this project.  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.DirectoryPath">
            <summary>
            The root directory for this project.
            Is never null: in-memory projects use the current directory from the time of load.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.FullPath">
            <summary>
            The full path to this project's file.
            May be null, if the project was not loaded from disk.
            Setter renames the project, if it already had a name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.SkipEvaluation">
            <summary>
            Whether ReevaluateIfNecessary is temporarily disabled.
            This is useful when the host expects to make a number of reads and writes 
            to the project, and wants to temporarily sacrifice correctness for performance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.DisableMarkDirty">
            <summary>
            Whether <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty">MarkDirty()</see> is temporarily disabled.
            This allows, for example, a global property to be set without the project getting
            marked dirty for reevaluation as a consequence.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.IsBuildEnabled">
            <summary>
            This controls whether or not the building of targets/tasks is enabled for this
            project.  This is for security purposes in case a host wants to closely
            control which projects it allows to run targets/tasks.  By default, for a newly
            created project, we will use whatever setting is in the parent project collection.
            When build is disabled, the Build method on this class will fail. However if
            the host has already created a ProjectInstance, it can still build it. (It is 
            free to put a similar check around where it does this.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectFileLocation">
            <summary>
            Location of the originating file itself, not any specific content within it.
            If the file has not been given a name, returns an empty location.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.EvaluationCounter">
            <summary>
            Obsolete. Use <see cref="P:Microsoft.Build.Evaluation.Project.LastEvaluationId"/> instead.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.LastEvaluationId">
            <summary>
            The ID of the last evaluation for this Project.
            A project is always evaluated upon construction and can subsequently get evaluated multiple times via
            <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" />
            
            It is an arbitrary number that changes when this project reevaluates.
            Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
            their previously stored value to find out, and if so perhaps decide to update their own state.
            Note that the number may not increase monotonically.
            
            This number corresponds to the <seealso cref="P:Microsoft.Build.Framework.BuildEventContext.EvaluationId"/> and can be used to connect
            evaluation logging events back to the Project instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.GlobalPropertiesToTreatAsLocal">
            <summary>
            List of names of the properties that, while global, are still treated as overridable 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.LoggingService">
            <summary>
            The logging service used for evaluation errors
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Returns the evaluated, escaped value of the provided item's include.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition)">
            <summary>
            Returns the evaluated, escaped value of the provided item definition's include.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetAllGlobs">
             <summary>
             Finds all the globs specified in item includes.
             </summary>
             <example>
             
             <code>
            <P>*.txt</P>
             
            <Bar Include="bar"/> (both outside and inside project cone)
            <Zar Include="C:\**\*.foo"/> (both outside and inside project cone)
            <Foo Include="*.a;*.b" Exclude="3.a"/>
            <Foo Remove="2.a" />
            <Foo Include="**\*.b" Exclude="1.b;**\obj\*.b;**\bar\*.b"/>
            <Foo Include="$(P)"/> 
            <Foo Include="*.a;@(Bar);3.a"/> (If Bar has globs, they will have been included when querying Bar ProjectItems for globs)
            <Foo Include="*.cs" Exclude="@(Bar)"/>
            </code>
             
            Example result: 
            [
            GlobResult(glob: "C:\**\*.foo", exclude: []),
            GlobResult(glob: ["*.a", "*.b"], exclude=["3.a"], remove=["2.a"]),
            GlobResult(glob: "**\*.b", exclude=["1.b, **\obj\*.b", **\bar\*.b"]),
            GlobResult(glob: "*.txt", exclude=[]),
            GlobResult(glob: "*.a", exclude=[]),
            GlobResult(glob: "*.cs", exclude=["bar"])
            ]
             </example>
             <remarks>
             <see cref="P:Microsoft.Build.Evaluation.GlobResult.MsBuildGlob"/> is a <see cref="T:Microsoft.Build.Globbing.IMSBuildGlob"/> that combines all globs in the include element and ignores
             all the fragments in the exclude attribute and all the fragments in all Remove elements that apply to the include element.
             
             Users can construct a composite glob that incorporates all the globs in the Project:
             <code>
             var uberGlob = new CompositeGlob(project.GetAllGlobs().Select(r => r.MSBuildGlob).ToArray());
             uberGlob.IsMatch("foo.cs");
             </code>
             
             </remarks>
             <returns>
             List of <see cref="T:Microsoft.Build.Evaluation.GlobResult"/>.
             </returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)">
            <summary>
            Overload of <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs"/>
            </summary>
            <param name="itemType">Confine search to item elements of this type</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)">
             <summary>
             Finds all the item elements in the logical project with itemspecs that match the given string:
             - elements that would include (or exclude) the string
             - elements that would update the string (not yet implemented)
             - elements that would remove the string (not yet implemented)
             </summary>
             
             <example>
             The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
             <code>
             <A Include="a.cs;*.cs"/> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
             <B Include="*.cs" Exclude="a.cs"/> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
             <C Include="b.cs"/> // NA
             <D Include="@(A)"/> // Occurrences: 2; Operation: Include; Provenance: Inconclusive (it is an indirect occurrence from a referenced item)
             <E Include="$(P)"/> // Occurrences: 4; Operation: Include; Provenance: FromLiteral (direct reference in $P) | Glob (direct reference in $P) | Inconclusive (it is an indirect occurrence from referenced properties and items)
             <PropertyGroup>
                 <P>a.cs;*.cs;@(A)</P>
             </PropertyGroup>
             </code>
             
             </example>
             
             <remarks>
             This method and its overloads are useful for clients that need to inspect all the item elements
             that might refer to a specific item instance. For example, Visual Studio uses it to inspect
             projects with globs. Upon a file system or IDE file artifact change, VS calls this method to find all the items
             that might refer to the detected file change (e.g. 'which item elements refer to "Program.cs"?').
             It uses such information to know which elements it should edit to reflect the user or file system changes.
             
             Literal string matching tries to first match the strings. If the check fails, it then tries to match
             the strings as if they represented files: it normalizes both strings as files relative to the current project directory
            
             GetItemProvenance suffers from some sources of inaccuracy:
             - it is performed after evaluation, thus is insensitive to item data flow when item references are present
             (it sees items as they are at the end of evaluation)
             
             This API and its return types are prone to change.
             </remarks>
             
             <param name="itemToMatch">The string to perform matching against</param>
             
             <returns>
             A list of <see cref="T:Microsoft.Build.Evaluation.ProvenanceResult"/>, sorted in project evaluation order.
             </returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)">
            <summary>
            Overload of <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)"/>
            </summary>
            <param name="itemToMatch">The string to perform matching against</param>
            <param name="itemType">The item type to constrain the search in</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Overload of <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)"/>
            </summary>
            <param name="item"> 
            The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
            The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
            The element that produced this <paramref name="item"/> is included in the results.
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata)">
            <summary>
            Gets the escaped value of the provided metadatum. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem,System.String)">
            <summary>
            Gets the escaped value of the metadatum with the provided name on the provided item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition,System.String)">
            <summary>
            Gets the escaped value of the metadatum with the provided name on the provided item definition. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Get the escaped value of the provided property
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetLogicalProject">
            <summary>
            Returns an iterator over the "logical project". The logical project is defined as
            the unevaluated project obtained from the single MSBuild file that is the result 
            of inlining the text of all imports of the original MSBuild project manifest file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetProperty(System.String)">
            <summary>
            Get any property in the project that has the specified name,
            otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetPropertyValue(System.String)">
            <summary>
            Get the unescaped value of a property in this project, or 
            an empty string if it does not exist.
            </summary>
            <remarks>
            A property with a value of empty string and no property
            at all are not distinguished between by this method.
            That makes it easier to use. To find out if a property is set at
            all in the project, use GetProperty(name).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.SetProperty(System.String,System.String)">
            <summary>
            Set or add a property with the specified name and value.
            Overwrites the value of any property with the same name already in the collection if it did not originate in an imported file.
            If there is no such existing property, uses this heuristic:
            Updates the last existing property with the specified name that has no condition on itself or its property group, if any,
            and is in this project file rather than an imported file.
            Otherwise, adds a new property in the first property group without a condition, creating a property group if necessary after
            the last existing property group, else at the start of the project.
            Returns the property set.
            Evaluates on a best-effort basis:
                -expands with all properties. Properties that are defined in the XML below the new property may be used, even though in a real evaluation they would not be.
                -only this property is evaluated. Anything else that would depend on its value is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)">
            <summary>
            Change a global property after the project has been evaluated.
            If the value changes, this makes the project require reevaluation.
            If the value changes, returns true, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String)">
            <summary>
            Adds an item with no metadata to the project.
            Any metadata can be added subsequently.
            Does not modify the XML if a wildcard expression would already include the new item.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Adds an item with metadata to the project.
            Metadata may be null, indicating no metadata.
            Does not modify the XML if a wildcard expression would already include the new item.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String)">
            <summary>
            Adds an item with no metadata to the project.
            Makes no effort to see if an existing wildcard would already match the new item, unless it is the first item in an item group.
            Makes no effort to locate the new item near similar items.
            Appends the item to the first item group that does not have a condition and has either no children or whose first child is an item of the same type.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Adds an item with metadata to the project.
            Metadata may be null, indicating no metadata.
            Makes no effort to see if an existing wildcard would already match the new item, unless it is the first item in an item group.
            Makes no effort to locate the new item near similar items.
            Appends the item to the first item group that does not have a condition and has either no children or whose first child is an item of the same type.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItems(System.String)">
            <summary>
            All the items in the project of the specified
            type.
            If there are none, returns an empty list.
            Use AddItem or RemoveItem to modify items in this project.
            </summary>
            <comments>
            data.GetItems returns a read-only collection, so no need to re-wrap it here. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(System.String)">
            <summary>
            All the items in the project of the specified
            type, irrespective of whether the conditions on them evaluated to true.
            This is a read-only list: use AddItem or RemoveItem to modify items in this project.
            </summary>
            <comments>
            ItemDictionary[] returns a read only collection, so no need to wrap it. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(System.String)">
            <summary>
            Returns all items that have the specified evaluated include.
            For example, all items that have the evaluated include "bar.cpp".
            Typically there will be zero or one, but sometimes there are two items with the
            same path and different item types, or even the same item types. This will return
            them all.
            </summary>
            <comments>
            data.GetItemsByEvaluatedInclude already returns a read-only collection, so no need
            to wrap it further.
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Removes the specified property.
            Property must be associated with this project.
            Property must not originate from an imported file.
            Returns true if the property was in this evaluated project, otherwise false.
            As a convenience, if the parent property group becomes empty, it is also removed.
            Updates the evaluated project, but does not affect anything else in the project until reevaluation. For example,
            if "p" is removed, it will be removed from the evaluated project, but "q" which is evaluated from "$(p)" will not be modified until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)">
            <summary>
            Removes a global property.
            If it was set, returns true, and marks the project
            as requiring reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Removes an item from the project.
            Item must be associated with this project.
            Item must not originate from an imported file.
            Returns true if the item was in this evaluated project, otherwise false.
            As a convenience, if the parent item group becomes empty, it is also removed.
            If the item originated from a wildcard or semicolon separated expression, expands that expression into multiple items first.
            Updates the evaluated project, but does not affect anything else in the project until reevaluation. For example,
            if an item of type "i" is removed, "j" which is evaluated from "@(i)" will not be modified until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
            <remarks>
            Normally this will return true, since if the item isn't in the project, it will throw.
            The exception is removing an item that was only in ItemsIgnoringCondition.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})">
            <summary>
            Removes all the specified items from the project.
            Items that are not associated with this project are skipped.
            </summary>
            <remarks>
            Removing one item could cause the backing XML
            to be expanded, which could zombie (disassociate) the next item.
            To make this case easy for the caller, if an item
            is not associated with this project it is simply skipped.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ExpandString(System.String)">
            <summary>
            Evaluates the provided string by expanding items and properties,
            as if it was found at the very end of the project file.
            This is useful for some hosts for which this kind of best-effort
            evaluation is sufficient.
            Does not expand bare metadata expressions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance">
            <summary>
            Returns an instance based on this project, but completely disconnected.
            This instance can be used to build independently.
            Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)">
            <summary>
            Returns an instance based on this project, but completely disconnected.
            This instance can be used to build independently.
            Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
            The instance is immutable; none of the objects that form it can be modified. This makes it safe to 
            access concurrently from multiple threads.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)"/>
            </summary>
            <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.MarkDirty">
            <summary>
            Called to forcibly mark the project as dirty requiring reevaluation. Generally this is not necessary to set; all edits affecting
            this project will automatically make it dirty. However there are potential corner cases where it is necessary to mark the project dirty
            directly. For example, if the project has an import conditioned on a file existing on disk, and the file did not exist at
            evaluation time, then someone subsequently creates that file, the project cannot know that reevaluation would be productive.
            In such a case the host can help us by setting the dirty flag explicitly so that <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary">ReevaluateIfNecessary()</see>
            will recognize an evaluation is indeed necessary.
            Does not mark the underlying project file as requiring saving.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary">
            <summary>
            Reevaluate the project to get it into a queryable state, if it's dirty.
            This incorporates all changes previously made to the backing XML by editing this project.
            Throws InvalidProjectFileException if the evaluation fails.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary"/>
            </summary>
            <param name="evaluationContext">The <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext"/> to use. See <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext"/></param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Save">
            <summary>
            Save the project to the file system, if dirty.
            Uses the default encoding.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding)">
            <summary>
            Save the project to the file system, if dirty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Save(System.String)">
            <summary>
            Save the project to the file system, if dirty or the path is different.
            Uses the default encoding.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Save(System.String,System.Text.Encoding)">
            <summary>
            Save the project to the file system, if dirty or the path is different.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter)">
            <summary>
            Save the project to the provided TextWriter, whether or not it is dirty.
            Uses the encoding of the TextWriter.
            Clears the Dirty flag.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter)">
            <summary>
            Saves a "logical" or "preprocessed" project file, that includes all the imported 
            files as if they formed a single file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build">
            <summary>
            Starts a build using this project, building the default targets.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger)">
            <summary>
            Starts a build using this project, building the default targets and the specified logger.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})">
            <summary>
            Starts a build using this project, building the default targets and the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})">
            <summary>
            Starts a build using this project, building the default targets and the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.String)">
            <summary>
            Starts a build using this project, building the specified target.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})">
            <summary>
            Starts a build using this project, building the specified target with the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})">
            <summary>
            Starts a build using this project, building the specified target with the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.String[])">
            <summary>
            Starts a build using this project, building the specified targets.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})">
            <summary>
            Starts a build using this project, building the specified targets with the specified loggers.
            Returns true on success, false on failure.
            If build is disabled on this project, does not build, and returns false.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})">
            <summary>
            Starts a build using this project, building the specified targets with the specified loggers.
            Returns true on success, false on failure.
            If build is disabled on this project, does not build, and returns false.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})"/>
            </summary>
            <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.UsesProjectRootElement(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Tests whether a given project IS or IMPORTS some given project xml root element.
            </summary>
            <param name="xmlRootElement">The project xml root element in question.</param>
            <returns>True if this project is or imports the xml file; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.SplitItemElementIfNecessary(Microsoft.Build.Construction.ProjectItemElement)">
            <summary>
            If the ProjectItemElement evaluated to more than one ProjectItem, replaces it with a new ProjectItemElement for each one of them.
            If the ProjectItemElement did not evaluate into more than one ProjectItem, does nothing.
            Returns true if a split occurred, otherwise false.
            </summary>
            <remarks>
            A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
            Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
            sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
            
            For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
            item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
            
            This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
            For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
            Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
            If that's important, the host can manipulate the ProjectItemElement's directly, instead, and it can be as fastidious as it wishes.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.IsSuitableExistingItemXml(Microsoft.Build.Construction.ProjectItemElement,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
            item we wish to add, and does not have a condition or an exclude.
            Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
            Returns true if it is suitable, otherwise false.
            </summary>
            <remarks>
            Outside this class called ONLY from <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)"/>ProjectItem.Rename(string name).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.RemoveItemBeforeItemTypeChange(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Before an item changes its item type, it must be removed from
            our datastructures, which key off item type. 
            This should be called ONLY by ProjectItems, in this situation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ReAddExistingItemAfterItemTypeChange(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            After an item has changed its item type, it needs to be added back again,
            since our data structures key off the item type.
            This should be called ONLY by ProjectItems, in this situation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ExpandPropertyValueBestEffortLeaveEscaped(System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Provided a property that is already part of this project, does a best-effort expansion
            of the unevaluated value provided and sets it as the evaluated value.
            </summary>
            <remarks>
            On project in order to keep Project's expander hidden.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ExpandItemIncludeBestEffortLeaveEscaped(Microsoft.Build.Construction.ProjectItemElement)">
            <summary>
            Provided an item element that has been renamed with a new unevaluated include,
            returns a best effort guess at the evaluated include that results.
            If the best effort expansion produces anything other than one item, it just
            returns the unevaluated include.
            This is not at all generalized, but useful for the majority case where an item is a very
            simple file name with perhaps a property prefix.
            </summary>
            <remarks>
            On project in order to keep Project's expander hidden.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ExpandMetadataValueBestEffortLeaveEscaped(Microsoft.Build.Evaluation.IMetadataTable,System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Provided a metadatum that is already part of this project, does a best-effort expansion
            of the unevaluated value provided and returns the resulting value.
            This is a interim expansion only: it may not be the value that a full project reevaluation would produce.
            The metadata table passed in is that of the parent item or item definition.
            </summary>
            <remarks>
            On project in order to keep Project's expander hidden.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Zombify">
            <summary>
            Called by the project collection to indicate to this project that it is no longer loaded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.VerifyThrowInvalidOperationNotZombie">
            <summary>
            Verify that the project has not been unloaded from its collection.
            Once it's been unloaded, it cannot be used.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.VerifyThrowInvalidOperationNotImported(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Verify that the provided object location is in the same file as the project.
            If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
            This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
            main project, but for some reason was actually read in from an imported targets file.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.Build.Evaluation.Project.ProjectImpl" -->
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl._data">
            <summary>
            Backing data; stored in a nested class so it can be passed to the Evaluator to fill
            in on re-evaluation, without having to expose property setters for that purpose.
            Also it makes it easy to re-evaluate this project without creating a new project object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl._evaluatedVersion">
            <summary>
            The highest version of the backing ProjectRootElements (including imports) that this object was last evaluated from.
            Edits to the ProjectRootElement either by this Project or another Project increment the number.
            If that number is different from this one a reevaluation is necessary at some point.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl._evaluatedToolsetCollectionVersion">
            <summary>
            The version of the tools information in the project collection against we were last evaluated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl._explicitlyMarkedDirty">
            <summary>
            Whether the project has been explicitly marked as dirty. Generally this is not necessary to set; all edits affecting
            this project will automatically make it dirty. However there are potential corner cases where it is necessary to mark it dirty
            directly. For example, if the project has an import conditioned on a file existing on disk, and the file did not exist at
            evaluation time, then someone subsequently writes the file, the project will not know that reevaluation would be productive,
            and would not dirty itself. In such a case the host should help us by setting the dirty flag explicitly.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl._isBuildEnabled">
            <summary>
            This controls whether or not the building of targets/tasks is enabled for this
            project.  This is for security purposes in case a host wants to closely
            control which projects it allows to run targets/tasks.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl._loadSettings">
            <summary>
            The load settings, such as to ignore missing imports.
            This is retained after construction as it will be needed for reevaluation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl._renameHandler">
            <summary>
            The delegate registered with the ProjectRootElement to be called if the file name
            is changed. Retained so that ultimately it can be unregistered.
            If it has been set to null, the project has been unloaded from its collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectLoadSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            
            </summary>
            <param name="owner">The owning project object</param>
            <param name="xml">ProjectRootElement to use</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
            <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ProjectCollection"/> the project is added to.</param>
            <param name="loadSettings">The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings"/> to use for evaluation.</param>
            <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.#ctor(Microsoft.Build.Evaluation.Project,System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectLoadSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the specified project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
            <param name="owner">The owning project object</param>
            <param name="xmlReader">Xml reader to read project from</param>
            <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
            <param name="toolsVersion">Tools version to evaluate with. May be null</param>
            <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
            <param name="loadSettings">The load settings for this project.</param>
            <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.#ctor(Microsoft.Build.Evaluation.Project,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectLoadSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Construct over an existing project file, evaluating with the specified global properties and 
            using the tools version provided, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
            <param name="owner">The owning project object</param>
            <param name="projectFile">The project file</param>
            <param name="globalProperties">The global properties. May be null.</param>
            <param name="toolsVersion">The tools version. May be null.</param>
            <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
            <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
            <param name="loadSettings">The load settings for this project.</param>
            <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ProjectCollection">
            <summary>
            Gets or sets the project collection which contains this project.
            Can never be null.
            Cannot be modified.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ThrowInsteadOfSplittingItemElement">
             <summary>
             Certain item operations split the item element in multiple elements if the include
             contains globs, references to items or properties, or multiple item values.
            
             The items operations that may expand item elements are:
             - <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)"/>
             - <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})"/>
             - <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})"/>
             - <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.ChangeItemType(System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)"/>
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)"/>
             
             When this property is set to true, the previous item operations throw an <exception cref="T:System.InvalidOperationException"></exception>
             instead of expanding the item element. 
             </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Project.ProjectImpl.BuildEnabledSetting">
            <summary>
            Whether build is enabled for this project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl.BuildEnabledSetting.BuildEnabled">
            <summary>
            Explicitly enabled
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl.BuildEnabledSetting.BuildDisabled">
            <summary>
            Explicitly disabled
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.ProjectImpl.BuildEnabledSetting.UseProjectCollectionSetting">
            <summary>
            No explicit setting, uses the setting on the
            project collection.
            This is the default.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.Xml">
            <summary>
            The backing Xml project.
            Can never be null
            </summary>
            <remarks>
            There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.IsDirty">
            <summary>
            Whether this project is dirty such that it needs reevaluation.
            This may be because its underlying XML has changed (either through this project or another)
            either the XML of the main project or an imported file; 
            or because its toolset may have changed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.GlobalProperties">
            <summary>
            Read only dictionary of the global properties used in the evaluation
            of this project.
            </summary>
            <remarks>
            This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
            
            In order to easily tell when we're dirtied, setting and removing global properties is done with 
            <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.SetGlobalProperty(System.String,System.String)">SetGlobalProperty</see> and <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveGlobalProperty(System.String)">RemoveGlobalProperty</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ItemTypes">
            <summary>
            Item types in this project.
            This is an ordered collection.
            </summary>
            <comments>
            data.ItemTypes is a KeyCollection, so it doesn't need any 
            additional read-only protection
            </comments>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.Properties">
            <summary>
            Properties in this project.
            Since evaluation has occurred, this is an unordered collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ConditionedProperties">
            <summary>
            Collection of possible values implied for properties contained in the conditions found on properties,
            property groups, imports, and whens.
            
            For example, if the following conditions existed on properties in a project:
            
            Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
            Condition="'$(Configuration)' == 'Release'"
            
            the table would be populated with
            
            { "Configuration", { "Debug", "Release" }}
            { "Platform", { "x86" }}
            
            This is used by Visual Studio to determine the configurations defined in the project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ItemDefinitions">
            <summary>
            Read-only dictionary of item definitions in this project.
            Keyed by item type
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.Items">
            <summary>
            Items in this project, ordered within groups of item types
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ItemsIgnoringCondition">
            <summary>
            Items in this project, ordered within groups of item types,
            including items whose conditions evaluated to false, or that were
            contained within item groups who themselves had conditioned evaluated to false.
            This is useful for hosts that wish to display all items, even if they might not be part 
            of the build in the current configuration.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.Imports">
            <summary>
            All the files that during evaluation contributed to this project, as ProjectRootElements,
            with the ProjectImportElement that caused them to be imported.
            This does not include projects that were never imported because a condition on an Import element was false.
            The outer ProjectRootElement that maps to this project itself is not included.
            </summary>
            <remarks>
            This can be used by the host to figure out what projects might be impacted by a change to a particular file.
            It could also be used, for example, to find the .user file, and use its ProjectRootElement to modify properties in it.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ImportsIncludingDuplicates">
            <summary>
            This list will contain duplicate imports if an import is imported multiple times. However, only the first import was used in evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.Targets">
            <summary>
            Targets in the project. The key to the dictionary is the target's name.
            Overridden targets are not included in this collection.
            This collection is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.AllEvaluatedProperties">
            <summary>
            Properties encountered during evaluation. These are read during the first evaluation pass.
            Unlike those returned by the Properties property, these are ordered, and includes any properties that
            were subsequently overridden by others with the same name. It does not include any 
            properties whose conditions did not evaluate to true.
            It does not include any properties added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.AllEvaluatedItemDefinitionMetadata">
            <summary>
            Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
            Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
            were subsequently overridden by others with the same name and item type. It does not include any 
            elements whose conditions did not evaluate to true.
            It does not include any item definition metadata added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.AllEvaluatedItems">
            <summary>
            Items encountered during evaluation. These are read during the third evaluation pass.
            Unlike those returned by the Items property, these are ordered with respect to all other items 
            encountered during evaluation, not just ordered with respect to items of the same item type.
            In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
            can use this property.
            It does not include any elements whose conditions did not evaluate to true.
            It does not include any items added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ToolsVersion">
            <summary>
            The tools version this project was evaluated with, if any.
            Not necessarily the same as the tools version on the Project tag, if any;
            it may have been externally specified, for example with a /tv switch.
            The actual tools version on the Project tag, can be gotten from <see cref="P:Microsoft.Build.Evaluation.Project.ProjectImpl.Xml">Xml.ToolsVersion</see>.
            Cannot be changed once the project has been created.
            </summary>
            <remarks>
            Set by construction.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.SubToolsetVersion">
            <summary>
            The sub-toolset version that, combined with the ToolsVersion, was used to determine
            the toolset properties for this project.  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.DirectoryPath">
            <summary>
            The root directory for this project.
            Is never null: in-memory projects use the current directory from the time of load.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.FullPath">
            <summary>
            The full path to this project's file.
            May be null, if the project was not loaded from disk.
            Setter renames the project, if it already had a name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.SkipEvaluation">
            <summary>
            Whether ReevaluateIfNecessary is temporarily disabled.
            This is useful when the host expects to make a number of reads and writes 
            to the project, and wants to temporarily sacrifice correctness for performance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.DisableMarkDirty">
            <summary>
            Whether <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.MarkDirty">MarkDirty()</see> is temporarily disabled.
            This allows, for example, a global property to be set without the project getting
            marked dirty for reevaluation as a consequence.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.IsBuildEnabled">
            <summary>
            This controls whether or not the building of targets/tasks is enabled for this
            project.  This is for security purposes in case a host wants to closely
            control which projects it allows to run targets/tasks.  By default, for a newly
            created project, we will use whatever setting is in the parent project collection.
            When build is disabled, the Build method on this class will fail. However if
            the host has already created a ProjectInstance, it can still build it. (It is 
            free to put a similar check around where it does this.)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.ProjectFileLocation">
            <summary>
            Location of the originating file itself, not any specific content within it.
            If the file has not been given a name, returns an empty location.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.EvaluationCounter">
            <summary>
            Obsolete. Use <see cref="P:Microsoft.Build.Evaluation.Project.ProjectImpl.LastEvaluationId"/> instead.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.LastEvaluationId">
            <summary>
            The ID of the last evaluation for this Project.
            A project is always evaluated upon construction and can subsequently get evaluated multiple times via
            <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)" />
            
            It is an arbitrary number that changes when this project reevaluates.
            Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
            their previously stored value to find out, and if so perhaps decide to update their own state.
            Note that the number may not increase monotonically.
            
            This number corresponds to the <seealso cref="P:Microsoft.Build.Framework.BuildEventContext.EvaluationId"/> and can be used to connect
            evaluation logging events back to the Project instance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.GlobalPropertiesToTreatAsLocal">
            <summary>
            List of names of the properties that, while global, are still treated as overridable 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.ProjectImpl.LoggingService">
            <summary>
            The logging service used for evaluation errors
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements"/>
            </param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetEvaluatedItemElements(Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Some project APIs need to do analysis that requires the Evaluator to record more data than usual as it evaluates.
            This method checks if the Evaluator was run with the extra required settings and if not, does a re-evaluation.
            If a re-evaluation was necessary, it saves this information so a next call does not re-evaluate.
            
            Using this method avoids storing extra data in memory when its not needed.
            </summary>
            <param name="evaluationContext"></param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ItemMatchesInItemSpecString(System.String,System.String,Microsoft.Build.Shared.IElementLocation,System.String,Microsoft.Build.Evaluation.Expander{Microsoft.Build.Evaluation.ProjectProperty,Microsoft.Build.Evaluation.ProjectItem},Microsoft.Build.Evaluation.Provenance@)">
            <summary>
            Since:
                - we have no proper AST and interpreter for itemspecs that we can do analysis on
                - GetItemProvenance needs to have correct counts for exclude strings (as correct as it can get while doing it after evaluation)
            
            The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetLogicalProject">
            <summary>
            Returns an iterator over the "logical project". The logical project is defined as
            the unevaluated project obtained from the single MSBuild file that is the result 
            of inlining the text of all imports of the original MSBuild project manifest file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetProperty(System.String)">
            <summary>
            Get any property in the project that has the specified name,
            otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetPropertyValue(System.String)">
            <summary>
            Get the unescaped value of a property in this project, or 
            an empty string if it does not exist.
            </summary>
            <remarks>
            A property with a value of empty string and no property
            at all are not distinguished between by this method.
            That makes it easier to use. To find out if a property is set at
            all in the project, use GetProperty(name).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.SetProperty(System.String,System.String)">
            <summary>
            Set or add a property with the specified name and value.
            Overwrites the value of any property with the same name already in the collection if it did not originate in an imported file.
            If there is no such existing property, uses this heuristic:
            Updates the last existing property with the specified name that has no condition on itself or its property group, if any,
            and is in this project file rather than an imported file.
            Otherwise, adds a new property in the first property group without a condition, creating a property group if necessary after
            the last existing property group, else at the start of the project.
            Returns the property set.
            Evaluates on a best-effort basis:
                -expands with all properties. Properties that are defined in the XML below the new property may be used, even though in a real evaluation they would not be.
                -only this property is evaluated. Anything else that would depend on its value is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.SetGlobalProperty(System.String,System.String)">
            <summary>
            Change a global property after the project has been evaluated.
            If the value changes, this makes the project require reevaluation.
            If the value changes, returns true, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Adds an item with metadata to the project.
            Metadata may be null, indicating no metadata.
            Does not modify the XML if a wildcard expression would already include the new item.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Adds an item with metadata to the project.
            Metadata may be null, indicating no metadata.
            Makes no effort to see if an existing wildcard would already match the new item, unless it is the first item in an item group.
            Makes no effort to locate the new item near similar items.
            Appends the item to the first item group that does not have a condition and has either no children or whose first child is an item of the same type.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetItems(System.String)">
            <summary>
            All the items in the project of the specified
            type.
            If there are none, returns an empty list.
            Use AddItem or RemoveItem to modify items in this project.
            </summary>
            <comments>
            data.GetItems returns a read-only collection, so no need to re-wrap it here. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetItemsIgnoringCondition(System.String)">
            <summary>
            All the items in the project of the specified
            type, irrespective of whether the conditions on them evaluated to true.
            This is a read-only list: use AddItem or RemoveItem to modify items in this project.
            </summary>
            <comments>
            ItemDictionary[] returns a read only collection, so no need to wrap it. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetItemsByEvaluatedInclude(System.String)">
            <summary>
            Returns all items that have the specified evaluated include.
            For example, all items that have the evaluated include "bar.cpp".
            Typically there will be zero or one, but sometimes there are two items with the
            same path and different item types, or even the same item types. This will return
            them all.
            </summary>
            <comments>
            data.GetItemsByEvaluatedInclude already returns a read-only collection, so no need
            to wrap it further.
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Removes the specified property.
            Property must be associated with this project.
            Property must not originate from an imported file.
            Returns true if the property was in this evaluated project, otherwise false.
            As a convenience, if the parent property group becomes empty, it is also removed.
            Updates the evaluated project, but does not affect anything else in the project until reevaluation. For example,
            if "p" is removed, it will be removed from the evaluated project, but "q" which is evaluated from "$(p)" will not be modified until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveGlobalProperty(System.String)">
            <summary>
            Removes a global property.
            If it was set, returns true, and marks the project
            as requiring reevaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Removes an item from the project.
            Item must be associated with this project.
            Item must not originate from an imported file.
            Returns true if the item was in this evaluated project, otherwise false.
            As a convenience, if the parent item group becomes empty, it is also removed.
            If the item originated from a wildcard or semicolon separated expression, expands that expression into multiple items first.
            Updates the evaluated project, but does not affect anything else in the project until reevaluation. For example,
            if an item of type "i" is removed, "j" which is evaluated from "@(i)" will not be modified until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
            <remarks>
            Normally this will return true, since if the item isn't in the project, it will throw.
            The exception is removing an item that was only in ItemsIgnoringCondition.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})">
            <summary>
            Removes all the specified items from the project.
            Items that are not associated with this project are skipped.
            </summary>
            <remarks>
            Removing one item could cause the backing XML
            to be expanded, which could zombie (disassociate) the next item.
            To make this case easy for the caller, if an item
            is not associated with this project it is simply skipped.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ExpandString(System.String)">
            <summary>
            Evaluates the provided string by expanding items and properties,
            as if it was found at the very end of the project file.
            This is useful for some hosts for which this kind of best-effort
            evaluation is sufficient.
            Does not expand bare metadata expressions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.MarkDirty">
            <summary>
            Called to forcibly mark the project as dirty requiring reevaluation. Generally this is not necessary to set; all edits affecting
            this project will automatically make it dirty. However there are potential corner cases where it is necessary to mark the project dirty
            directly. For example, if the project has an import conditioned on a file existing on disk, and the file did not exist at
            evaluation time, then someone subsequently creates that file, the project cannot know that reevaluation would be productive.
            In such a case the host can help us by setting the dirty flag explicitly so that <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)">ReevaluateIfNecessary()</see>
            will recognize an evaluation is indeed necessary.
            Does not mark the underlying project file as requiring saving.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">The <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext"/> to use. See <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext"/></param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.SaveLogicalProject(System.IO.TextWriter)">
            <summary>
            Saves a "logical" or "preprocessed" project file, that includes all the imported 
            files as if they formed a single file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            See <see cref="M:Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.Context.EvaluationContext)"/>
            </summary>
            <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.UsesProjectRootElement(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Tests whether a given project IS or IMPORTS some given project xml root element.
            </summary>
            <param name="xmlRootElement">The project xml root element in question.</param>
            <returns>True if this project is or imports the xml file; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.SplitItemElementIfNecessary(Microsoft.Build.Construction.ProjectItemElement)">
            <summary>
            If the ProjectItemElement evaluated to more than one ProjectItem, replaces it with a new ProjectItemElement for each one of them.
            If the ProjectItemElement did not evaluate into more than one ProjectItem, does nothing.
            Returns true if a split occurred, otherwise false.
            </summary>
            <remarks>
            A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
            Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
            sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
            
            For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
            item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
            
            This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
            For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
            Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
            If that's important, the host can manipulate the ProjectItemElement's directly, instead, and it can be as fastidious as it wishes.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.IsSuitableExistingItemXml(Microsoft.Build.Construction.ProjectItemElement,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
            item we wish to add, and does not have a condition or an exclude.
            Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
            Returns true if it is suitable, otherwise false.
            </summary>
            <remarks>
            Outside this class called ONLY from <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)"/>ProjectItem.Rename(string name).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItemBeforeItemTypeChange(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Before an item changes its item type, it must be removed from
            our datastructures, which key off item type. 
            This should be called ONLY by ProjectItems, in this situation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ReAddExistingItemAfterItemTypeChange(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            After an item has changed its item type, it needs to be added back again,
            since our data structures key off the item type.
            This should be called ONLY by ProjectItems, in this situation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ExpandPropertyValueBestEffortLeaveEscaped(System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Provided a property that is already part of this project, does a best-effort expansion
            of the unevaluated value provided and sets it as the evaluated value.
            </summary>
            <remarks>
            On project in order to keep Project's expander hidden.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ExpandItemIncludeBestEffortLeaveEscaped(Microsoft.Build.Construction.ProjectItemElement)">
            <summary>
            Provided an item element that has been renamed with a new unevaluated include,
            returns a best effort guess at the evaluated include that results.
            If the best effort expansion produces anything other than one item, it just
            returns the unevaluated include.
            This is not at all generalized, but useful for the majority case where an item is a very
            simple file name with perhaps a property prefix.
            </summary>
            <remarks>
            On project in order to keep Project's expander hidden.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ExpandMetadataValueBestEffortLeaveEscaped(Microsoft.Build.Evaluation.IMetadataTable,System.String,Microsoft.Build.Construction.ElementLocation)">
            <summary>
            Provided a metadatum that is already part of this project, does a best-effort expansion
            of the unevaluated value provided and returns the resulting value.
            This is a interim expansion only: it may not be the value that a full project reevaluation would produce.
            The metadata table passed in is that of the parent item or item definition.
            </summary>
            <remarks>
            On project in order to keep Project's expander hidden.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.Unload">
            <summary>
            Called by the project collection to indicate to this project that it is no longer loaded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.VerifyThrowInvalidOperationNotImported(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Verify that the provided object location is in the same file as the project.
            If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
            This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
            main project, but for some reason was actually read in from an imported targets file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.AddItemHelper(Microsoft.Build.Construction.ProjectItemElement,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Common code for the AddItem methods.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItemHelper(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Helper for <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)"/> and <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})"/>.
            If the item is not associated with a project, returns false.
            If the item is not present in the evaluated project, returns false.
            If the item is associated with another project, throws ArgumentException.
            Otherwise removes the item and returns true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Re-evaluates the project using the specified logging service.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Evaluation.ProjectLoadSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Re-evaluates the project using the specified logging service and load settings.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.CreateProjectInstance(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Creates a project instance based on this project using the specified logging service.
            </summary>  
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.Initialize(System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectLoadSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)">
            <summary>
            Common code for the constructors.
            Applies global properties that are on the collection.
            Global properties provided for the project overwrite any global properties from the collection that have the same name.
            Global properties may be null.
            Tools version may be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.ProjectRootElement_ProjectXmlChangedHandler(System.Object,Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs)">
            <summary>
            Raised when any XML in the underlying ProjectRootElement has changed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetAnySuitableExistingItemXml(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},Microsoft.Build.Construction.ProjectItemElement@)">
            <summary>
            Tries to find a ProjectItemElement already in the project file XML that has a wildcard that would match the
            item we wish to add, does not have a condition or an exclude, and is within an itemgroup without a condition.
            
            For perf reasons, this method does several jobs in one.
            If it finds a suitable existing item element, it returns that as the out parameter, otherwise the out parameter returns null.
            Otherwise, if it finds an item element suitable to be just below our new element, it returns that.
            Otherwise, if it finds an item group at least that's suitable to put our element in somewhere, it returns that.
            
            Returns null if the include of the item being added itself has wildcards, or semicolons, as the case is too difficult.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetLogicalProject(System.Collections.Generic.IEnumerable{Microsoft.Build.Construction.ProjectElement})">
            <summary>
            Recursive helper for <see cref="M:Microsoft.Build.Evaluation.Project.ProjectImpl.GetLogicalProject">GetLogicalProject</see>.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Project.IProjectLinkInternal">
             <summary>
             Internal
            
             Note: For deeper integration of remote project we might need to expose [some] of this functionality via IProjectLink3.
             </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Project.Data">
            <summary>
            Encapsulates the backing data of a Project, so that it can be passed to the Evaluator to
            fill in on a re-evaluation without having to expose property setters.
            </summary>
            <remarks>
            This object is only passed to the Evaluator.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.Data.s_typicalTargetsCollection">
            <summary>
            Almost always, projects have the same set of targets because they all import the same ones.
            So we keep around the last set seen and if ours is the same at the end of evaluation, unify the references.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Project.Data._globalPropertiesToTreatAsLocal">
            <summary>
            List of names of the properties that, while global, are still treated as overridable 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.String,System.String,System.Boolean)">
            <summary>
            Constructor taking the immutable global properties and tools version.
            Tools version may be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ShouldEvaluateForDesignTime">
            <summary>
            Whether evaluation should collect items ignoring condition,
            as well as items respecting condition; and collect
            conditioned properties, as well as regular properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Evaluation#ProjectProperty,Microsoft#Build#Evaluation#ProjectItem,Microsoft#Build#Evaluation#ProjectMetadata,Microsoft#Build#Evaluation#ProjectItemDefinition}#ItemDefinitionsEnumerable">
            <summary>
            Collection of all evaluated item definitions, one per item-type
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.DefaultTargets">
            <summary>
            DefaultTargets specified in the project, or
            the logically first target if no DefaultTargets is
            specified in the project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.GlobalPropertiesDictionary">
            <summary>
            The global properties to evaluate with, if any.
            Can never be null.
            Read-only; to use different global properties, evaluate yourself a new project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.EnvironmentVariablePropertiesDictionary">
            <summary>
            A dictionary of all of the properties read from environment variables during evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.GlobalPropertiesToTreatAsLocal">
            <summary>
            List of names of the properties that, while global, are still treated as overridable 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.InitialTargets">
            <summary>
            InitialTargets specified in the project, plus those
            in all imports, gathered depth-first.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.BeforeTargets">
            <summary>
            Sets or retrieves the list of targets which run before the keyed target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.AfterTargets">
            <summary>
            Sets or retrieves the list of targets which run after the keyed target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ExplicitToolsVersion">
            <summary>
            The externally specified tools version, if any.
            For example, the tools version from a /tv switch.
            Not necessarily the same as the tools version from the project tag or of the toolset used.
            May be null.
            Flows through to called projects.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Toolset">
            <summary>
            The toolset data used during evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ExplicitSubToolsetVersion">
            <summary>
            The externally specified sub-toolset version that, combined with the ToolsVersion, is used to determine
            the toolset properties for this project.  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.SubToolsetVersion">
            <summary>
            The sub-toolset version that, combined with the ToolsVersion, was used to determine
            the toolset properties for this project.  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Items">
            <summary>
            Items in this project, ordered within groups of item types.
            Protected by an upcast to IEnumerable.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ItemsIgnoringCondition">
            <summary>
            List of items that link the XML items and evaluated items,
            evaluated as if their conditions were true.
            This is useful for hosts that wish to display all items regardless of their condition.
            This is an ordered collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Properties">
            <summary>
            Collection of properties that link the XML properties and evaluated properties.
            Since evaluation has occurred, this is an unordered collection.
            Includes any global and reserved properties.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ConditionedProperties">
            <summary>
            Collection of possible values implied for properties contained in the conditions found on properties,
            property groups, imports, and whens.
            
            For example, if the following conditions existed on properties in a project:
            
            Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
            Condition="'$(Configuration)' == 'Release'"
            
            the table would be populated with
            
            { "Configuration", { "Debug", "Release" }}
            { "Platform", { "x86" }}
            
            This is used by Visual Studio to determine the configurations defined in the project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.EvaluationId">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Directory">
            <summary>
            The root directory for this project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.TaskRegistry">
            <summary>
            Registry of usingtasks, for build
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ItemTypes">
            <summary>
            Get the item types that have at least one item.
            Read only collection.
            </summary>
            <comments>
            item.ItemTypes is a KeyCollection, so it doesn't need any 
            additional read-only protection
            </comments>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.AllEvaluatedProperties">
            <summary>
            Properties encountered during evaluation. These are read during the first evaluation pass.
            Unlike those returned by the Properties property, these are ordered, and includes any properties that
            were subsequently overridden by others with the same name. It does not include any 
            properties whose conditions did not evaluate to true.
            It does not include any properties added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.AllEvaluatedItemDefinitionMetadata">
            <summary>
            Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
            Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
            were subsequently overridden by others with the same name and item type. It does not include any 
            elements whose conditions did not evaluate to true.
            It does not include any item definition metadata added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.AllEvaluatedItems">
            <summary>
            Items encountered during evaluation. These are read during the third evaluation pass.
            Unlike those returned by the Items property, these are ordered.
            It does not include any elements whose conditions did not evaluate to true.
            It does not include any items added since the last evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Expander">
            <summary>
            Expander to use to expand any expressions encountered after the project has been fully evaluated.
            For example, to expand the values of any properties added at design time.
            It's convenient to store it here.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.HasUnsavedChanges">
            <summary>
            Whether something in this data has been modified since evaluation.
            For example, a global property has been set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ItemDefinitions">
            <summary>
            Collection of all evaluated item definitions, one per item-type
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Project">
            <summary>
            Project that owns this data
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.Targets">
            <summary>
            Targets in the project, used to build
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ImportClosure">
            <summary>
            Complete list of all imports pulled in during evaluation.
            This includes the outer project itself.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ImportClosureWithDuplicates">
            <summary>
            Complete list of all imports pulled in during evaluation including duplicate imports.
            This includes the outer project itself.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.OriginalProjectToolsVersion">
            <summary>
            The toolsversion that was originally specified on the project's root element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.UsingDifferentToolsVersionFromProjectFile">
            <summary>
            Whether when we read a ToolsVersion other than the current one in the Project tag, we treat it as the current one.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Project.Data.ItemsByEvaluatedIncludeCache">
            <summary>
            expose mutable precalculated cache to outside so that other can take advantage of the cache as well.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.InitializeForEvaluation(Microsoft.Build.Evaluation.IToolsetProvider,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Prepares the data object for evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.FinishEvaluation">
            <summary>
            Indicates to the data block that evaluation has completed,
            so for example it can mark datastructures read-only.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.AddItem(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Adds a new item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.AddItemIgnoringCondition(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Adds a new item to the collection of all items ignoring condition
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.AddToAllEvaluatedPropertiesList(Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Properties encountered during evaluation. These are read during the first evaluation pass.
            Unlike those returned by the Properties property, these are ordered, and includes any properties that
            were subsequently overridden by others with the same name. It does not include any 
            properties whose conditions did not evaluate to true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.AddToAllEvaluatedItemDefinitionMetadataList(Microsoft.Build.Evaluation.ProjectMetadata)">
            <summary>
            Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
            Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
            were subsequently overridden by others with the same name and item type. It does not include any 
            elements whose conditions did not evaluate to true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.AddToAllEvaluatedItemsList(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Items encountered during evaluation. These are read during the third evaluation pass.
            Unlike those returned by the Items property, these are ordered.
            It does not include any elements whose conditions did not evaluate to true.
            It does not include any items added since the last evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.AddItemDefinition(System.String)">
            <summary>
            Adds a new item definition
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.GetItemDefinition(System.String)">
            <summary>
            Gets an existing item definition, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.SetProperty(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets a property which is not derived from Xml.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.SetProperty(Microsoft.Build.Construction.ProjectPropertyElement,System.String)">
            <summary>
            Sets a property derived from Xml.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.GetTarget(System.String)">
            <summary>
            Retrieves an existing target, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.AddTarget(Microsoft.Build.Execution.ProjectTargetInstance)">
            <summary>
            Adds the specified target, overwriting any existing target with the same name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.RecordImport(Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32,Microsoft.Build.BackEnd.SdkResolution.SdkResult)">
            <summary>
            Record an import opened during evaluation.
            This is used to check later whether any of them have been changed.
            </summary>
            <remarks>
            This may include imported files that ended up contributing nothing to the evaluated project.
            These might otherwise have no strong references to them at all.
            If they are dirtied, though, they might affect the evaluated project; and that's why we record them. 
            Mostly these will be common imports, so they'll be shared anyway.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.RecordImportWithDuplicates(Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32)">
            <summary>
            Record a duplicate import, possible a duplicate import opened during evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.Microsoft#Build#Evaluation#IEvaluatorData{Microsoft#Build#Evaluation#ProjectProperty,Microsoft#Build#Evaluation#ProjectItem,Microsoft#Build#Evaluation#ProjectMetadata,Microsoft#Build#Evaluation#ProjectItemDefinition}#ExpandString(System.String)">
            <summary>
            Evaluates the provided string by expanding items and properties,
            using the current items and properties available.
            This is useful for the immediate window.
            Does not expand bare metadata expressions.
            </summary>
            <comment>
            Not for internal use.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.EvaluateCondition(System.String)">
            <summary>
            Evaluates the provided string as a condition by expanding items and properties,
            using the current items and properties available, then doing a logical evaluation.
            This is useful for the immediate window.
            Does not expand bare metadata expressions.
            </summary>
            <comment>
            Not for internal use.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.GetItems(System.String)">
            <summary>
            Returns a list of items of the specified type.
            If there are none, returns an empty list.
            </summary>
            <comments>
            ItemDictionary returns a read-only collection, so no need to wrap it here.
            </comments>
            <param name="itemType">The type of items to return.</param>
            <returns>A list of matching items.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.GetProperty(System.String)">
            <summary>
            Returns the property with the specified name or null if it was not present
            </summary>
            <param name="name">The property name.</param>
            <returns>The property.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.GetProperty(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the property with the specified name or null if it was not present
            </summary>
            <returns>The property.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Removes an item.
            Returns true if it was previously present, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.GetItemsByEvaluatedInclude(System.String)">
            <summary>
            Returns all items that have the specified evaluated include.
            For example, all items that have the evaluated include "bar.cpp".
            Typically there will be no more than one, but sometimes there are two items with the
            same path and different item types, or even the same item types. This will return
            them all.
            </summary>
            <remarks>
            Assumes that the evaluated include value is unescaped.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Project.Data.GetPropertyValue(System.String)">
            <summary>
            Get the value of a property in this project, or 
            an empty string if it does not exist.
            Returns the unescaped value.
            </summary>
            <remarks>
            A property with a value of empty string and no property
            at all are not distinguished between by this method.
            That makes it easier to use. To find out if a property is set at
            all in the project, use GetProperty(name).
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Evaluation.GlobResult">
            <summary>
            Data class representing a result from <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs"/> and its overloads.
            This represents all globs found in an item include together with the item element it came from,
            the excludes that were present on that item, and all the Remove item elements pertaining to the Include item element.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.GlobResult.ItemElement">
            <summary>
            Gets the original <see cref="T:Microsoft.Build.Construction.ProjectItemElement"/> that contained the globs.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.GlobResult.IncludeGlobs">
            <summary>
            Gets all the evaluated glob strings (properties expanded) from the include.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.GlobResult.MsBuildGlob">
            <summary>
            A <see cref="T:Microsoft.Build.Globbing.IMSBuildGlob"/> representing the include globs. It also takes the excludes and relevant removes into consideration.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.GlobResult.Excludes">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ISet`1"/> containing strings that were excluded.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.GlobResult.Removes">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ISet`1"/> containing strings that were later removed via the Remove element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GlobResult.#ctor(Microsoft.Build.Construction.ProjectItemElement,System.Collections.Generic.IEnumerable{System.String},Microsoft.Build.Globbing.IMSBuildGlob,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Provenance">
            <summary>
            Bit flag enum that specifies how a string representing an item matched against an itemspec.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Provenance.Undefined">
            <summary>
            Undefined is the bottom element and should not appear in actual results 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Provenance.StringLiteral">
            <summary>
            A string matched against a string literal from an itemspec
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Provenance.Glob">
            <summary>
            A string matched against a glob pattern from an itemspec
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Provenance.Inconclusive">
            <summary>
            Inconclusive means that the match is indirect, coming from either property or item references.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Operation">
            <summary>
            Enum that specifies how an item element references an item
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Operation.Include">
            <summary>
            The element referenced the item by an Include.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Operation.Exclude">
            <summary>
            The element referenced the item by an Exclude.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Operation.Update">
            <summary>
            The element referenced the item by an Update.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Operation.Remove">
            <summary>
            The element referenced the item by a Remove.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProvenanceResult">
            <summary>
            Data class representing a result from <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)"/> and its overloads.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProvenanceResult.Operation">
            <summary>
            Gets the <see cref="P:Microsoft.Build.Evaluation.ProvenanceResult.Operation"/> that was performed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProvenanceResult.ItemElement">
            <summary>
            Gets the <see cref="T:Microsoft.Build.Construction.ProjectItemElement"/> that contains the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProvenanceResult.Provenance">
            <summary>
            Gets the <see cref="P:Microsoft.Build.Evaluation.ProvenanceResult.Provenance"/> of how the item appeared in the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProvenanceResult.Occurrences">
            <summary>
            Gets the number of occurrences of the item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProvenanceResult.#ctor(Microsoft.Build.Construction.ProjectItemElement,Microsoft.Build.Evaluation.Operation,Microsoft.Build.Evaluation.Provenance,System.Int32)">
            <summary>
            Initializes an instance of the ProvenanceResult class.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectItem">
            <summary>
            An evaluated design-time item
            </summary>
            <remarks>
            Edits to this object will indirectly dirty the containing project because they will modify the backing XML.
            </remarks>
            <comment>
            We cannot use a copy-on-write table for the metadata, as ProjectMetadata objects are mutable. However,
            we do use it for build-time items.
            </comment>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem._project">
            <summary>
            Project that this item lives in.
            ProjectItems always live in a project.
            Used to get item definitions and project directory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem._evaluatedIncludeBeforeWildcardExpansionEscaped">
            <summary>
            Fragment of the original include that led to this item,
            with properties expanded but not wildcards.  Escaped as necessary
            </summary>
            <remarks>
            This is ONLY used to figure out %(RecursiveDir) when it is requested.
            It's likely too expensive to figure that out if it isn't needed, so we store 
            the necessary material here.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem._inheritedItemDefinitions">
            <summary>
            Item definitions are stored in one single table shared by all items of a particular item type.
            
            When an item is created from another item, such as by using an expression like Include="@(x)",
            any item definition metadata those source items have must override any item definition metadata 
            associated with the new item type. 
            
            Copying all those item definition metadata into real metadata on this item would be very inefficient, because
            it would turn a single shared table into a separate table for every item.
            
            Instead, we get a reference to the item definition of the source items, and consult
            that table before we consult our own item type's item definition. Since item definitions can't change at this point,
            it's safe to reference their original table.
            
            If our item gets copied again, we need a reference to the inherited item definition and we need the real item
            definition of the source items. Thus a list is created. On copying, a list is created, beginning with a clone
            of any list the source item had, and ending with the item definition list of the source item type.
            
            When we look up a metadata value we look at 
            (1) directly associated metadata and built-in metadata
            (2) the inherited item definition list, starting from the top
            (3) the item definition associated with our item type
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem._xml">
            <summary>
            Backing XML item.
            Can never be null
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem._evaluatedIncludeEscaped">
            <summary>
            Evaluated include.
            The original XML may have evaluated to several of these items,
            each with a different include.
            May be empty, for example from expanding an empty list or from a transform with undefined metadata.
            Escaped as necessary
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem._directMetadata">
            <summary>
            Collection of metadata that link the XML metadata and evaluated metadata.
            Since evaluation has occurred, this is an unordered collection.
            May be null.
            </summary>
            <remarks>
            Lazily created, as there are lots of items
            that have no metadata at all.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem._fullPath">
            <summary>
            Cached value of the fullpath metadata. All other metadata are computed on demand.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.#ctor(Microsoft.Build.Construction.ProjectItemElement,Microsoft.Build.Evaluation.Project)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.Construction.ProjectItemElement,System.String,System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Evaluation.ProjectMetadata},System.Collections.Generic.List{Microsoft.Build.Evaluation.ProjectItemDefinition})">
            <summary>
            Called by the Evaluator during project evaluation.
            Direct metadata may be null, indicating no metadata. It is assumed to have already been cloned.
            Inherited item definition metadata may be null. It is assumed that its list has already been cloned.
            ProjectMetadata objects may be shared with other items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.Xml">
            <summary>
            Backing XML item.
            Can never be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.ItemType">
            <summary>
            Gets or sets the type of this item.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude">
            <summary>
            Gets or sets the unevaluated value of the Include.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude">
            <summary>
            Gets the evaluated value of the include, unescaped. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IItem#EvaluatedIncludeEscaped">
            <summary>
            Gets the evaluated value of the include, escaped as necessary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IItem#ProjectDirectory">
            <summary>
            The directory of the project being built
            Never null: If there is no project filename yet, it will use the current directory
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.Project">
            <summary>
            Project that this item lives in.
            ProjectItems always live in a project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.IsImported">
            <summary>
            If the item originated in an imported file, returns true.
            Otherwise returns false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.DirectMetadata">
            <summary>
            Metadata directly on the item, if any.
            Does not include metadata from item definitions.
            Does not include built-in metadata.
            Never returns null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount">
            <summary>
            Count of direct metadata on this item, if any.
            Does NOT count any metadata inherited from item definitions.
            Does not count built-in metadata, such as "FullPath".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.Metadata">
            <summary>
            Metadata on the item, if any.  Includes metadata specified by the definition, if any.
            If there is no metadata, returns an empty collection.
            Does not include built-in metadata, such as "FullPath".
            Get the values of built-in metadata using <see cref="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(System.String)"/>.
            This is a read-only collection. To modify the metadata, use <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.MetadataCount">
            <summary>
            Count of metadata on this item, if any.
            Includes any metadata inherited from item definitions.
            Includes both custom and built-in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the item type, so items
            can be put in a dictionary conveniently.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.MetadataCollection">
            <summary>
            Internal version of <see cref="P:Microsoft.Build.Evaluation.ProjectItem.Metadata">Metadata</see> that returns
            a full ICollection.
            Unordered collection of evaluated metadata on the item.
            If there is no metadata, returns an empty collection.
            Does not include built-in metadata.
            Includes any from item definitions not masked by directly set metadata.
            This is a read-only collection. To modify the metadata, use <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.EvaluatedIncludeBeforeWildcardExpansion">
            <summary>
            Accesses the unescaped evaluated include prior to wildcard expansion
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.EvaluatedIncludeBeforeWildcardExpansionEscaped">
            <summary>
            Accesses the evaluated include prior to wildcard expansion
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.InheritedItemDefinitions">
            <summary>
            Accesses the inherited item definitions, if any.
            Used ONLY by the ProjectInstance, when cloning a ProjectItem.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadata(System.String)">
            <summary>
            Gets an evaluated metadata on this item.
            Potentially includes a metadata from an item definition.
            Does not return built-in metadata, such as "FullPath".
            Returns null if not found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(System.String)">
            <summary>
            Get the evaluated value of a metadata on this item, possibly from an item definition. 
            Returns empty string if it does not exist.
            To determine whether a piece of metadata does not exist vs. simply has no value, use <see cref="M:Microsoft.Build.Evaluation.ProjectItem.HasMetadata(System.String)">HasMetadata</see>.
            May be used to access the value of built-in metadata, such as "FullPath".
            Attempting to get built-in metadata on a value that is not a valid path throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.HasMetadata(System.String)">
            <summary>
            Returns true if a particular piece of metadata is defined on this item,
            otherwise false.
            Includes built-in metadata and metadata inherited from item definitions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IItem#GetMetadataValueEscaped(System.String)">
            <summary>
            See <see cref="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(System.String)">GetMetadataValue</see> for a more detailed explanation.  
            Returns the escaped value of the metadatum requested.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IItem{Microsoft#Build#Evaluation#ProjectMetadata}#GetMetadata(System.String)">
            <summary>
            Gets any existing ProjectMetadata on the item, or
            else any on an applicable item definition.
            This is ONLY called during evaluation.
            Does not return built-in metadata, such as "FullPath".
            Returns null if not found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IItem{Microsoft#Build#Evaluation#ProjectMetadata}#SetMetadata(Microsoft.Build.Construction.ProjectMetadataElement,System.String)">
            <summary>
            Adds a ProjectMetadata to the item. 
            This is ONLY called during evaluation and does not affect the XML.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)">
            <summary>
            Adds metadata with the specified name and value to the item.
            Updates an existing metadata if one already exists with the same name on the item directly, as opposed to inherited from an item definition.
            Updates the evaluated project, but does not affect anything else in the project until reevaluation. For example,
            if a piece of metadata named "m" is added on item of type "i", it does not affect "j" which is evaluated from "@(j->'%(m)')" until reevaluation.
            Also if the unevaluated value of "m" is set to something that is modified by evaluation, such as "$(p)", the evaluated value will be set to literally "$(p)" until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state without a reevaluation.
            Returns the new or existing metadatum.
            </summary>
            <remarks>Unevaluated value is assumed to be escaped as necessary</remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)">
            <summary>
            Overload of <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)"/>. Adds the option of not splitting the item element and thus affecting all sibling items.
            Sibling items are defined as all ProjectItem instances that were created from the same item element.
            
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state without a reevaluation
            </summary>
            /// <param name="name">Metadata name</param>
            <param name="unevaluatedValue">Metadata value</param>
            <param name="propagateMetadataToSiblingItems">
            If true, adds direct metadata to the <see cref="T:Microsoft.Build.Construction.ProjectItemElement"/> from which this <see cref="T:Microsoft.Build.Evaluation.ProjectItem"/> originated. The intent is to affect all other sibling items.
            </param>
            <returns>Returns the new or existing metadatum.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)">
            <summary>
            Removes any metadata with the specified name.
            Returns true if the evaluated metadata existed, otherwise false.
            If the metadata name is one of the built-in metadata, like "FullPath", throws InvalidArgumentException.
            If the metadata originates in an item definition, and was not overridden, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)">
            <summary>
            Renames the item.
            Equivalent to setting the <see cref="P:Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude"/> value.
            Generally, no expansion occurs. This is because it would potentially result in several items, 
            which is not meaningful semantics when renaming a single item.
            However if the item does not need to be split (which would invalidate its ProjectItemElement),
            and the new value expands to exactly one item, then its evaluated include is updated
            with the expanded value, rather than the unexpanded value.
            </summary>
            <remarks>
            Even if the new value expands to zero items, we do not expand it.
            The common case we are interested in for expansion here is setting something 
            like "$(sourcesroot)\foo.cs" and expanding that to a single item. 
            If say "@(foo)" is set as the new name, and it expands to blank, that might 
            be surprising to the host and maybe even unhandled, if on full reevaluation 
            it wouldn’t expand to blank. That’s why we're being cautious and supporting 
            the most common scenario only. 
            Many hosts will do a ReevaluateIfNecessary before reading anyway.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name specified.
            If no value is available, returns empty string.
            Value, if escaped, remains escaped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If no value is available, returns empty string.
            If item type is null, it is ignored, otherwise it must match.
            Value, if escaped, remains escaped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Returns the value if it exists.
            If no value is available, returns null.
            If item type is null, it is ignored, otherwise it must match.
            Value, if escaped, remains escaped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ChangeItemType(System.String)">
            <summary>
            Changes the item type of this item.
            Until reevaluation puts it in the correct place, it will be placed at
            the end of the list of items of its new type.
            </summary>
            <remarks>
            This is a little involved, as it requires replacing
            the XmlElement, and updating the project's datastructures.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.SplitOwnItemElement">
            <summary>
            Creates new xml objects for itself, disconnecting from the old xml objects.
            Called ONLY by <see cref="M:Microsoft.Build.Evaluation.Project.SplitItemElementIfNecessary(Microsoft.Build.Construction.ProjectItemElement)"/>
            </summary>
            <remarks>
            Called when breaking up a single ProjectItemElement that evaluates into several ProjectItems.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.GetBuiltInMetadataEscaped(System.String)">
            <summary>
            Helper to get the value of a built-in metadatum with
            the specified name, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.GetItemDefinitionMetadata(System.String)">
            <summary>
            Retrieves the named metadata from the item definition, if any.
            If it is not present, returns null
            </summary>
            <param name="name">The metadata name.</param>
            <returns>The value if it exists, null otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory">
            <summary>
            A class factory for ProjectItems.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory._project">
            <summary>
            The Project with which each item should be associated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory._xml">
            <summary>
            The project item's XML
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.#ctor(Microsoft.Build.Evaluation.Project)">
            <summary>
            Creates an item factory which does not specify an item xml.  The item xml must
            be specified later.
            </summary>
            <param name="project">The project for items generated.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.Construction.ProjectItemElement)">
            <summary>
            Constructor
            </summary>
            <param name="project">The project for items generated.</param>
            <param name="xml">The xml for items generated.</param>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.ItemType">
            <summary>
            Item type that items created by this factory will have.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.ItemElement">
            <summary>
            Set the item xml from which items will be created.
            Used by the evaluator only.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.CreateItem(System.String,System.String)">
            <summary>
            Creates an item with the specified type and evaluated include.
            Used for making items from "just strings" and from expressions like "@(Compile, ';')"
            </summary>
            <param name="include">The include.</param>
            <param name="definingProject">The path to the project that defined the item.</param>
            <returns>A new project item.</returns>
            <comments>
            NOTE: defining project is ignored because we already know the ItemElement associated with 
            this item, and use that for where it is defined. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.CreateItem(Microsoft.Build.Evaluation.ProjectItem,System.String)">
            <summary>
            Creates an item based on the provided item, but with
            the project and xml of this factory. Metadata is cloned,
            but continues to point to the original ProjectMetadataElement objects.
            This is to support the scenario Include="@(i)" where we are copying
            metadata, and are happy to see changes in the original metadata, but
            setting metadata should create new XML.
            </summary>
            <comments>
            NOTE: defining project is ignored because we already know the ItemElement associated with 
            this item, and use that for where it is defined. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.CreateItem(System.String,Microsoft.Build.Evaluation.ProjectItem,System.String)">
            <summary>
            Creates an item based on the provided item, but with
            the project and xml of this factory and the specified include. Metadata is cloned,
            but continues to point to the original ProjectMetadataElement objects.
            This is to support this scenario: Include="@(i->'xxx')"
            </summary>
            <remarks>
            If the item type of the source is the same as the item type of the destination,
            then it's not necessary to copy metadata originating in an item definition.
            If it's not, we have to clone that too.
            </remarks>
            <comments>
            NOTE: defining project is ignored because we already know the ItemElement associated with 
            this item, and use that for where it is defined. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.CreateItem(System.String,System.String,System.String)">
            <summary>
            Creates an item with the specified include and include before wildcard expansion.
            This is to support creating items from an include that may have a wildcard expression in it.
            </summary>
            <comments>
            NOTE: defining project is ignored because we already know the ItemElement associated with 
            this item, and use that for where it is defined. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.SetMetadata(System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{Microsoft.Build.Construction.ProjectMetadataElement,System.String}},System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})">
            <summary>
            Applies the supplied metadata to the destination item.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory.CreateItem(System.String,System.String,Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Creates an item based on the provided item, with the specified include and item type.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectItem.BuiltInMetadataTable">
            <summary>
            Implementation of IMetadataTable that can be passed to expander
            to expose only built-in metadata on this item.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItem.BuiltInMetadataTable._item">
            <summary>
            Backing item
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.BuiltInMetadataTable.#ctor(Microsoft.Build.Evaluation.ProjectItem)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.BuiltInMetadataTable.GetEscapedValue(System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name specified.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.BuiltInMetadataTable.GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If item type is null, it is ignored.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItem.BuiltInMetadataTable.GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Returns the value if it exists, null otherwise.
            If item type is null, it is ignored.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectItemDefinition">
            <summary>
            An evaluated item definition for a particular item-type.
            </summary>
            <remarks>
            Note that these are somewhat different to items. Like items, they can have metadata; like properties, the metadata
            can override each other. So during evaluation all the item definitions for a type are rolled together (assuming
            their conditions are true) to create one ProjectItemDefinition for each type. For this reason, the ProjectItemDefinition
            often will not point to a single ProjectItemDefinitionElement. The metadata within, however, will each point to a single
            ProjectMetadataElement, and these can be added, removed, and modified.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItemDefinition._project">
            <summary>
            Project that this item definition lives in.
            ProjectItemDefinitions always live in a project.
            Used to evaluate any updates to child metadata.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItemDefinition._itemType">
            <summary>
            Item type, for example "Compile", that this item definition applies to
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectItemDefinition._metadata">
            <summary>
            Collection of metadata that link the XML metadata and instance metadata
            Since evaluation has occurred, this is an unordered collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.#ctor(Microsoft.Build.Evaluation.Project,System.String)">
            <summary>
            Called by the Evaluator during project evaluation.
            </summary>
            <remarks>
            Assumes that the itemType string originated in a ProjectItemDefinitionElement and therefore
            was already validated.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItemDefinition.Project">
            <summary>
            Project that this item lives in.
            ProjectDefinitions always live in a project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType">
            <summary>
            Type of this item definition.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata">
            <summary>
            Metadata on the item definition.
            If there is no metadata, returns empty collection.
            This is a read-only collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount">
            <summary>
            Count of metadata on the item definition.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectItemDefinition.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the item type, so these 
            can be put in a dictionary conveniently.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(System.String)">
            <summary>
            Get any metadata in the item that has the specified name,
            otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(System.String)">
            <summary>
            Get the value of any metadata in the item that has the specified
            name, otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(System.String,System.String)">
            <summary>
            Sets a new metadata value on the ItemDefinition.
            </summary>
            <remarks>Unevaluated value is assumed to be escaped as necessary</remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.Microsoft#Build#Evaluation#IItemDefinition{Microsoft#Build#Evaluation#ProjectMetadata}#SetMetadata(Microsoft.Build.Construction.ProjectMetadataElement,System.String,Microsoft.Build.Evaluation.ProjectMetadata)">
            <summary>
            Sets a new metadata value on the ItemDefinition.
            This is ONLY called during evaluation and does not affect the XML.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String)">
            <summary>
            Retrieves the value of the named metadatum.
            </summary>
            <param name="name">The metadatum to retrieve.</param>
            <returns>The value, or an empty string if there is none by that name.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves the value of the named metadatum.
            </summary>
            <param name="specifiedItemType">The type of item.</param>
            <param name="name">The metadatum to retrieve.</param>
            <returns>The value, or an empty string if there is none by that name.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectItemDefinition.Microsoft#Build#Evaluation#IMetadataTable#GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Retrieves the value of the named metadatum, or null if it doesn't exist
            </summary>
            <param name="specifiedItemType">The type of item.</param>
            <param name="name">The metadatum to retrieve.</param>
            <returns>The value, or null if there is none by that name.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectMetadata">
            <summary>
            An evaluated design-time metadatum.
            Parented either by a ProjectItemDefinition or a ProjectItem.
            </summary>
            <remarks>
            Never used to represent built-in metadata, like %(Filename). There is always a backing XML object.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectMetadata._parent">
            <summary>
            Parent item or item definition that this metadatum lives in.
            ProjectMetadata's always live in a project and always have a parent.
            The project can be gotten from this parent.
            Used to evaluate any updates.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectMetadata._xml">
            <summary>
            Backing XML metadata.
            Can never be null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectMetadata._evaluatedValueEscaped">
            <summary>
            Evaluated value
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectMetadata._predecessor">
            <summary>
            Any immediately previous metadatum (from item definition or item) that was overridden by this one during evaluation.
            This would include all metadata with the same name that lie above in the logical
            project file, who are on item definitions of the same type, and whose conditions evaluated to true.
            If this metadatum is on an item, it would include any previous metadatum with the same name on the same item whose condition
            evaluated to true, and following that any item definition metadata.
            If there are none above this is null.
            If the project has not been reevaluated since the last modification this value may be incorrect.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectMetadata.#ctor(System.Object,Microsoft.Build.Construction.ProjectMetadataElement)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectMetadata.#ctor(Microsoft.Build.Evaluation.IProjectMetadataParent,Microsoft.Build.Construction.ProjectMetadataElement,System.String,Microsoft.Build.Evaluation.ProjectMetadata)">
            <summary>
            Creates a metadata backed by XML. 
            Constructed during evaluation of a project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.Name">
            <summary>
            Name of the metadata
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue">
            <summary>
            Gets the evaluated metadata value.
            Cannot be set directly: only the unevaluated value can be set.
            Is never null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue">
            <summary>
            Gets or sets the unevaluated metadata value.
            
            As well as updating the unevaluated value, the setter updates the evaluated value, but does not affect anything else in the project until reevaluation. For example,
                --if a piece of metadata named "m" is modified on item of type "i", it does not affect "j" which is evaluated from "@(j->'%(m)')" until reevaluation.
                --if the unevaluated value of "m" is set to something that is modified by evaluation, such as "$(p)", the evaluated value will be set to "$(p)" until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state.
            
            Setting metadata through a ProjectItem may cause the underlying ProjectItemElement to be split, if it originated with an itemlist, wildcard, or semicolon expression,
            because it was clear that the caller intended to only affect that particular item.
            Setting metadata through a ProjectMetadata does not cause any splitting, because we assume the caller presumably intends to affect all items using the underlying
            ProjectMetadataElement. At least, this seems a reasonable assumption, and it avoids the need for metadata to hold a pointer to their containing items.
            </summary>
            <remarks>
            The containing project will be dirtied by the XML modification.  Unevaluated values are assumed to be passed in escaped as necessary. 
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.Xml">
            <summary>
            Backing XML metadata.
            Can never be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.Project">
            <summary>
            Project that this metadatum lives in.
            ProjectMetadata's always live in a project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.ItemType">
            <summary>
            The item type of the parent item definition or item.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.Predecessor">
            <summary>
            Any immediately previous metadatum (from item definition or item) that was overridden by this one during evaluation.
            This would include all metadata with the same name that lie above in the logical
            project file, who are on item definitions of the same type, and whose conditions evaluated to true.
            If this metadatum is on an item, it would include any previous metadatum with the same name on the same item whose condition
            evaluated to true, and following that any item definition metadata.
            If there are none above this is null.
            If the project has not been reevaluated since the last modification this value may be incorrect.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.IsImported">
            <summary>
            If the metadatum originated in an imported file, returns true.
            Otherwise returns false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.Location">
            <summary>
            Location of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation">
            <summary>
            Location of the condition attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the metadata name, so metadata
            can be put in a dictionary conveniently.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.Microsoft#Build#Collections#IValued#EscapedValue">
            <summary>
            Implementation of IValued
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValueEscaped">
            <summary>
            Gets the evaluated metadata value.
            Cannot be set directly: only the unevaluated value can be set.
            Is never null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectMetadata.System#IEquatable{Microsoft#Build#Evaluation#ProjectMetadata}#Equals(Microsoft.Build.Evaluation.ProjectMetadata)">
            <summary>
            Compares this metadata to another for equivalence.
            </summary>
            <param name="other">The other metadata</param>
            <returns>True if they are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectMetadata.DeepClone">
            <summary>
            Deep clone a metadatum, retaining the same parent.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectProperty">
            <summary>
            An evaluated design-time property 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectProperty._project">
            <summary>
            Project that this property lives in.
            ProjectProperty's always live in a project.
            Used to evaluate any updates.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectProperty._evaluatedValueEscaped">
            <summary>
            Evaluated value of the property.  Escaped as necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.#ctor(Microsoft.Build.Evaluation.Project,System.String)">
            <summary>
            Creates a property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.Name">
            <summary>
            Name of the property.
            Cannot be set.
            </summary>
            <comment>
            If this could be set, it would be necessary to have a callback
            so that the containing collections could be updated, as they use the name as 
            their key.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue">
            <summary>
            Gets the evaluated property value.
            Cannot be set directly: only the unevaluated value can be set.
            Is never null.
            </summary>
            <remarks>
            Unescaped value of the evaluated property
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.Microsoft#Build#Evaluation#IProperty#EvaluatedValueEscaped">
            <summary>
            Gets the evaluated property value.
            Cannot be set directly: only the unevaluated value can be set.
            Is never null.
            </summary>
            <remarks>
            Evaluated property escaped as necessary
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue">
            <summary>
            Gets or sets the unevaluated property value.
            Updates the evaluated value in the project, although this is not sure to be correct until re-evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty">
            <summary>
            Whether the property originated from the environment (or the toolset)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty">
            <summary>
            Whether the property is a global property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty">
            <summary>
            Whether the property is a reserved property,
            like 'MSBuildProjectFile'.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.Xml">
            <summary>
            Backing XML property.
            Null only if this is a global, environment, or built-in property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.Project">
            <summary>
            Project that this property lives in.
            ProjectProperty's always live in a project.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.Predecessor">
            <summary>
            Any immediately previous property that was overridden by this one during evaluation.
            This would include all properties with the same name that lie above in the logical
            project file, and whose conditions evaluated to true.
            If there are none above this is null.
            If the project has not been reevaluated since the last modification this value may be incorrect.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.IsImported">
            <summary>
            If the property originated in an imported file, returns true.
            If the property originates from the environment, a global property, or is a built-in property, returns false.
            Otherwise returns false.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.Microsoft#Build#Collections#IKeyed#Key">
            <summary>
            Implementation of IKeyed exposing the property name, so properties
            can be put in a dictionary conveniently.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.Microsoft#Build#Collections#IValued#EscapedValue">
            <summary>
            Implementation of IValued
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.System#IEquatable{Microsoft#Build#Evaluation#ProjectProperty}#Equals(Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Compares this property to another for equivalence.
            </summary>
            <param name="other">The other property.</param>
            <returns>True if the properties are equivalent, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.Create(Microsoft.Build.Evaluation.Project,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a property without backing XML. 
            Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
            This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
            All other properties originate in XML, and should have a backing XML object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.Create(Microsoft.Build.Evaluation.Project,Microsoft.Build.Construction.ProjectPropertyElement,System.String,Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Creates a regular evaluated property, with backing XML.
            Called by Project.SetProperty.
            Property MAY NOT have reserved name and MAY NOT overwrite a global property.
            Predecessor is any immediately previous property that was overridden by this one during evaluation and may be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.UpdateEvaluatedValue(System.String)">
            <summary>
            Called ONLY by the project in order to update the evaluated value
            after a property set occurring between full evaluations.
            </summary>
            <remarks>
            Method instead of a setter on EvaluatedValue to try to make clear its limited purpose.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.ProjectHasMatchingGlobalProperty(Microsoft.Build.Evaluation.Project,System.String)">
            <summary>
            Looks for a matching global property.
            </summary>
            <remarks>
            The reason we do this and not just look at project.GlobalProperties is
            that when the project is being loaded, the GlobalProperties collection is already populated.  When we do our
            evaluation, we may attempt to add some properties, such as environment variables, to the master Properties 
            collection.  As GlobalProperties are supposed to override these and thus be added last, we can't check against
            the GlobalProperties collection as they are being added.  The correct behavior is to always check against the
            collection which is accumulating properties as we go, which is the Properties collection.  Once the project has
            been fully populated, this method will also ensure that further properties do not attempt to override global
            properties, as those will have the global property flag set.
            </remarks>
            <param name="project">The project to compare with.</param>
            <param name="propertyName">The property name to look up</param>
            <returns>True if there is a matching global property, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked">
            <summary>
            Regular property, originating in an XML node, but with no predecessor (property with same name that it overrode during evaluation)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked._xml">
            <summary>
            Backing XML property.
            Never null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.Construction.ProjectPropertyElement,System.String)">
            <summary>
            Creates a regular evaluated property, with backing XML.
            Called by Project.SetProperty.
            Property MAY NOT have reserved name and MAY NOT overwrite a global property.
            Predecessor is any immediately previous property that was overridden by this one during evaluation and may be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.Name">
            <summary>
            Name of the property.
            Cannot be set.
            </summary>
            <comment>
            If this could be set, it would be necessary to have a callback
            so that the containing collections could be updated, as they use the name as 
            their key.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.UnevaluatedValue">
            <summary>
            Gets or sets the unevaluated property value.
            Updates the evaluated value in the project, although this is not sure to be correct until re-evaluation.
            </summary>
            <remarks>
            The containing project will be dirtied by the XML modification.
            If there is no XML backing, the evaluated value returned is the value of the property that has been 
            escaped as necessary.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.IsEnvironmentProperty">
            <summary>
            Whether the property originated from the environment (or the toolset)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.IsGlobalProperty">
            <summary>
            Whether the property is a global property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.IsReservedProperty">
            <summary>
            Whether the property is a reserved property,
            like 'MSBuildProjectFile'.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.Xml">
            <summary>
            Backing XML property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.Predecessor">
            <summary>
            Any immediately previous property that was overridden by this one during evaluation.
            This would include all properties with the same name that lie above in the logical
            project file, and whose conditions evaluated to true.
            In this class this is null.
            If the project has not been reevaluated since the last modification this value may be incorrect.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBacked.IsImported">
            <summary>
            If the property originated in an imported file, returns true.
            Otherwise returns false.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBackedWithPredecessor">
            <summary>
            Regular property, originating in an XML node, and with a predecessor (property with same name that was overridden during evaluation)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBackedWithPredecessor._predecessor">
            <summary>
            Any immediately previous property that was overridden by this one during evaluation.
            This would include all properties with the same name that lie above in the logical
            project file, and whose conditions evaluated to true.
            If there are none above this is null.
            If the project has not been reevaluated since the last modification this value may be incorrect.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBackedWithPredecessor.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.Construction.ProjectPropertyElement,System.String,Microsoft.Build.Evaluation.ProjectProperty)">
            <summary>
            Creates a regular evaluated property, with backing XML.
            Called by Project.SetProperty.
            Property MAY NOT have reserved name and MAY NOT overwrite a global property.
            Predecessor is any immediately previous property that was overridden by this one during evaluation and may be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyXmlBackedWithPredecessor.Predecessor">
            <summary>
            Any immediately previous property that was overridden by this one during evaluation.
            This would include all properties with the same name that lie above in the logical
            project file, and whose conditions evaluated to true.
            If there are none above this is null.
            If the project has not been reevaluated since the last modification this value may be incorrect.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked">
            <summary>
            Global/environment/toolset properties are the minority;
            they don't originate with XML, so we must store their name (instead)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked._name">
            <summary>
            Name of the property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.#ctor(Microsoft.Build.Evaluation.Project,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a property without backing XML. 
            Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
            This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
            All other properties originate in XML, and should have a backing XML object.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.Name">
            <summary>
            Name of the property.
            Cannot be set.
            </summary>
            <comment>
            If this could be set, it would be necessary to have a callback
            so that the containing collections could be updated, as they use the name as 
            their key.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.UnevaluatedValue">
            <summary>
            Gets or sets the unevaluated property value.
            Updates the evaluated value in the project, although this is not sure to be correct until re-evaluation.
            </summary>
            <remarks>
            The containing project will be dirtied.
            As there is no XML backing, the evaluated value returned is the value of the property that has been 
            escaped as necessary.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.IsEnvironmentProperty">
            <summary>
            Whether the property originated from the environment (or the toolset)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.IsGlobalProperty">
            <summary>
            Whether the property is a global property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.IsReservedProperty">
            <summary>
            Whether the property is a reserved property,
            like 'MSBuildProjectFile'.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.Xml">
            <summary>
            Backing XML property.
            Null because this is a global, environment, or built-in property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.Predecessor">
            <summary>
            Any immediately previous property that was overridden by this one during evaluation.
            Because these properties are not backed by XML, they cannot have precedessors.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ProjectProperty.ProjectPropertyNotXmlBacked.IsImported">
            <summary>
            Whether the property originated in an imported file.
            Because these properties did not originate in an XML file, this always returns null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ResolvedImport">
            <summary>
            Encapsulates an import relationship in an evaluated project
            between a ProjectImportElement and the ProjectRootElement of the
            imported project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ResolvedImport.#ctor(Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32,Microsoft.Build.Framework.SdkResult,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Evaluation.ResolvedImport"/> struct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ResolvedImport.#ctor(Microsoft.Build.Evaluation.Project,Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32,Microsoft.Build.Framework.SdkResult)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Build.Evaluation.ResolvedImport"/> struct.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ResolvedImport.ImportingElement">
            <summary>
            Gets the element doing the import.
            Null if this is the top project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ResolvedImport.ImportedProject">
            <summary>
            Gets one of the imported projects.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ResolvedImport.SdkResult">
            <summary>
            Non null if this import was an sdk import.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ResolvedImport.IsImported">
            <summary>
            Whether the importing element is itself imported.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.SubToolset">
            <summary>
            Aggregation of a set of properties that correspond to a particular sub-toolset.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.SubToolset._subToolsetVersion">
            <summary>
            VisualStudioVersion that corresponds to this subtoolset
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.SubToolset._properties">
            <summary>
            The properties defined by the subtoolset.
            </summary> 
        </member>
        <member name="M:Microsoft.Build.Evaluation.SubToolset.#ctor(System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Constructor that associates a set of properties with a sub-toolset version.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.SubToolset.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for translation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.SubToolset.SubToolsetVersion">
            <summary>
            VisualStudioVersion that corresponds to this subtoolset
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.SubToolset.Properties">
            <summary>
            The properties that correspond to this particular sub-toolset. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.SubToolset.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates the sub-toolset.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.SubToolset.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.LoadXmlFromPath">
            <summary>
            Delegate for loading an Xml file, for unit testing.
            </summary>
            <param name="path">The path to load.</param>
            <returns>An Xml document.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Toolset">
            <summary>
            Aggregation of a toolset version (eg. "2.0"), tools path, and optional set of associated properties.
            Toolset is immutable.
            </summary>
            <remarks>
            UNDONE: Review immutability. If this is not immutable, add a mechanism to notify the project collection/s owning it to increment their toolsetVersion.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.DefaultTasksFilePattern">
            <summary>
            these files list all default tasks and task assemblies that do not need to be explicitly declared by projects
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.OverrideTasksFilePattern">
            <summary>
            these files list all Override tasks and task assemblies that do not need to be explicitly declared by projects
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10OverallInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether Dev10 is installed.  This should exist if any SKU of Dev10 is installed, 
            but is not removed even when the last version of Dev10 is uninstalled, due to 10.0\bsln sticking around. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10UltimateInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether Dev10 Ultimate is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10PremiumInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether Dev10 Premium is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10ProfessionalInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether Dev10 Professional is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10VCSExpressInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether C# Express 2010 is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10VBExpressInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether VB Express 2010 is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10VCExpressInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether VC Express 2010 is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10VWDExpressInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether VWD Express 2010 is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.Dev10LightSwitchInstallKeyRegistryPath">
            <summary>
            Regkey that we check to see whether LightSwitch 2010 is installed.  This will exist if it is installed, and be 
            properly removed after it has been uninstalled.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset.s_dev10IsInstalled">
            <summary>
            Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
            the current machine, false otherwise. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._toolsVersion">
            <summary>
            Name of the tools version
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._toolsPath">
            <summary>
            The MSBuildBinPath (and ToolsPath) for this tools version
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._properties">
            <summary>
            The properties defined by the toolset.
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._overrideTasksPath">
            <summary>
            Path to look for msbuild override task files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._defaultOverrideToolsVersion">
            <summary>
            ToolsVersion to use as the default ToolsVersion for this version of MSBuild
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._environmentProperties">
            <summary>
            The environment properties
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._globalProperties">
            <summary>
            The build-global properties
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._defaultTasksRegistrationAttempted">
            <summary>
            indicates if the default tasks file has already been scanned
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._overrideTasksRegistrationAttempted">
            <summary>
            indicates if the override tasks file has already been scanned
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._defaultTaskRegistry">
            <summary>
            holds all the default tasks we know about and the assemblies they exist in
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._overrideTaskRegistry">
            <summary>
            holds all the override tasks we know about and the assemblies they exist in
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._getFiles">
            <summary>
            Delegate to retrieving files.  For unit testing only.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._directoryExists">
            <summary>
            Delegate to check to see if a directory exists
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._loadXmlFromPath">
            <summary>
            Delegate for loading Xml.  For unit testing only.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._expander">
            <summary>
            Expander to expand the properties and items in the using tasks files
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._propertyBag">
            <summary>
            Bag of properties for the expander to expand the properties and items in the using tasks files
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._subToolsets">
            <summary>
            SubToolsets that map to this toolset. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._defaultSubToolsetVersion">
            <summary>
            If no sub-toolset is specified, this is the default sub-toolset version.  Null == no default 
            sub-toolset, just use the base toolset. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Toolset._propertySearchPathsTable">
            <summary>
            Map of project import properties to their list of fall-back search paths
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.#ctor(System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,System.String)">
            <summary>
            Constructor taking only tools version and a matching tools path
            </summary>
            <param name="toolsVersion">Name of the toolset</param>
            <param name="toolsPath">Path to this toolset's tasks and targets</param>
            <param name="projectCollection">The project collection from which to obtain the properties.</param>
            <param name="msbuildOverrideTasksPath">The path to search for msbuild overridetasks files.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.Evaluation.ProjectCollection,System.String)">
            <summary>
            Constructor that also associates a set of properties with the tools version
            </summary>
            <param name="toolsVersion">Name of the toolset</param>
            <param name="toolsPath">Path to this toolset's tasks and targets</param>
            <param name="buildProperties">
            Properties that should be associated with the Toolset.
            May be null, in which case an empty property group will be used.
            </param>
            <param name="projectCollection">The project collection that this toolset should inherit from</param>
            <param name="msbuildOverrideTasksPath">The override tasks path.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.Evaluation.ProjectCollection,System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Evaluation.SubToolset},System.String)">
            <summary>
            Constructor that also associates a set of properties with the tools version
            </summary>
            <param name="toolsVersion">Name of the toolset</param>
            <param name="toolsPath">Path to this toolset's tasks and targets</param>
            <param name="buildProperties">
            Properties that should be associated with the Toolset.
            May be null, in which case an empty property group will be used.
            </param>
            <param name="projectCollection">The project collection that this toolset should inherit from</param>
            <param name="subToolsets">The set of sub-toolsets to add to this toolset</param>
            <param name="msbuildOverrideTasksPath">The override tasks path.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.#ctor(System.String,System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.String,System.String)">
            <summary>
            Constructor taking only tools version and a matching tools path
            </summary>
            <param name="toolsVersion">Name of the toolset</param>
            <param name="toolsPath">Path to this toolset's tasks and targets</param>
            <param name="environmentProperties">A <see cref="T:Microsoft.Build.Collections.PropertyDictionary`1"/> containing the environment properties.</param>
            <param name="globalProperties">A <see cref="T:Microsoft.Build.Collections.PropertyDictionary`1"/> containing the global properties.</param>
            <param name="msbuildOverrideTasksPath">The override tasks path.</param>
            <param name="defaultOverrideToolsVersion">ToolsVersion to use as the default ToolsVersion for this version of MSBuild.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.#ctor(System.String,System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.Collections.Generic.IDictionary{System.String,Microsoft.Build.Evaluation.SubToolset},System.String,System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.ProjectImportPathMatch})">
            <summary>
            Constructor that also associates a set of properties with the tools version
            </summary>
            <param name="toolsVersion">Name of the toolset</param>
            <param name="toolsPath">Path to this toolset's tasks and targets</param>
            <param name="buildProperties">
            Properties that should be associated with the Toolset.
            May be null, in which case an empty property group will be used.
            </param>
            <param name="environmentProperties">A <see cref="T:Microsoft.Build.Collections.PropertyDictionary`1"/> containing the environment properties.</param>
            <param name="globalProperties">A <see cref="T:Microsoft.Build.Collections.PropertyDictionary`1"/> containing the global properties.</param>
            <param name="subToolsets">A list of <see cref="T:Microsoft.Build.Evaluation.SubToolset"/> to use.</param>
            <param name="msbuildOverrideTasksPath">The override tasks path.</param>
            <param name="defaultOverrideToolsVersion">ToolsVersion to use as the default ToolsVersion for this version of MSBuild.</param>
            <param name="importSearchPathsTable">Map of parameter name to property search paths for use during Import.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.#ctor(System.String,System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Shared.DirectoryGetFiles,Microsoft.Build.Evaluation.LoadXmlFromPath,System.String,Microsoft.Build.Shared.DirectoryExists)">
            <summary>
            Additional constructor to make unit testing the TaskRegistry support easier
            </summary>
            <remarks>
            Internal for unit test purposes only.
            </remarks>
            <param name="toolsVersion">Name of the toolset</param>
            <param name="toolsPath">Path to this toolset's tasks and targets</param>
            <param name="buildProperties">
            Properties that should be associated with the Toolset.
            May be null, in which case an empty property group will be used.
            </param>
            <param name="projectCollection">The project collection.</param>
            <param name="getFiles">A delegate to intercept GetFiles calls.  For unit testing.</param>
            <param name="loadXmlFromPath">A delegate to intercept Xml load calls.  For unit testing.</param>
            <param name="msbuildOverrideTasksPath">The override tasks path.</param>
            <param name="directoryExists"></param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GetProjectImportSearchPaths(System.String)">
            <summary>
            Returns a ProjectImportPathMatch struct for the first property found in the expression for which
            project import search paths is enabled.
            <param name="expression">Expression to search for properties in (first level only, not recursive)</param>
            <returns>List of search paths or ProjectImportPathMatch.None if empty</returns>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.ToolsVersion">
            <summary>
            Name of this toolset
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.ToolsPath">
            <summary>
            Path to this toolset's tasks and targets. Corresponds to $(MSBuildToolsPath) in a project or targets file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.Properties">
            <summary>
            Properties associated with the toolset
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.SubToolsets">
            <summary>
            The set of sub-toolsets associated with this toolset.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.DefaultSubToolsetVersion">
            <summary>
            Returns the default sub-toolset version for this sub-toolset.  Heuristic used is: 
            1) If Visual Studio 2010 is installed and our ToolsVersion is "4.0", use the base toolset, and return 
               a sub-toolset version of "10.0", to be set as a publicly visible property so that e.g. targets can 
               consume it.  This is to handle the fact that Visual Studio 2010 did not have any concept of sub-toolsets. 
            2) Otherwise, use the highest-versioned sub-toolset found.  Sub-toolsets with numbered versions will 
               be ordered numerically; any additional sub-toolsets will be prepended to the beginning of the list in 
               the order found. We use the highest-versioned sub-toolset because, in the absence of any other information, 
               we assume that higher-versioned tools will be more likely to be able to generate something more correct.  
            
            Will return null if there is no sub-toolset available (and Dev10 is not installed). 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.Dev10IsInstalled">
            <summary>
            Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
            the current machine, false otherwise. 
            </summary>
            <comments>
            Internal so that unit tests can use it too. 
            </comments>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.OverrideTasksPath">
            <summary>
            Path to look for msbuild override task files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.DefaultOverrideToolsVersion">
            <summary>
            ToolsVersion to use as the default ToolsVersion for this version of MSBuild
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.ImportPropertySearchPathsTable">
            <summary>
            Map of properties to their list of fall-back search paths
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Toolset.MSBuildExtensionsPathSearchPathsTable">
            <summary>
            Map of MSBuildExtensionsPath properties to their list of fallback search paths
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Function for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion">
            <summary>
            Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
            1. If "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
               use that. 
            2. Otherwise, use the default sub-toolset version for this toolset. 
            
            The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
            just the base toolset on its own. The sub-toolset version returned may not map to an existing 
            sub-toolset.  
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
            <summary>
            Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
            1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
            2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
               use that. 
            3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
            4. Otherwise, use the default sub-toolset version for this toolset. 
            
            The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
            just the base toolset on its own. The sub-toolset version returned may not map to an existing 
            sub-toolset.  
            
            The global properties dictionary may be null. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GetProperty(System.String,System.String)">
            <summary>
            Given a property name and a sub-toolset version, searches for that property first in the 
            sub-toolset, then falls back to the base toolset if necessary, and returns the property 
            if it was found. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GetTaskFiles(Microsoft.Build.Shared.DirectoryGetFiles,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.String,System.String,System.String)">
            <summary>
            Given a search path and a task pattern get a list of task or override task files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
            1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
            2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
               use that. 
            3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
            4. Otherwise, use the default sub-toolset version for this toolset. 
            
            The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
            just the base toolset on its own. The sub-toolset version returned may not map to an existing 
            sub-toolset.  
            
            The global properties dictionary may be null. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Int32)">
            <summary>
            Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
            1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
            2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
               use that. 
            3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
            4. Otherwise, use the default sub-toolset version for this toolset. 
            
            The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
            just the base toolset on its own. The sub-toolset version returned may not map to an existing 
            sub-toolset.  
            
            The global properties dictionary may be null. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GetTaskRegistry(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Return a task registry stub for the tasks in the *.tasks file for this toolset         
            </summary>
            <param name="loggingServices">The logging services used to log during task registration.</param>
            <param name="buildEventContext">The build event context used to log during task registration.</param>
            <param name="projectRootElementCache">The <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCache"/> to use.</param>
            <returns>The task registry</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersionUsingVisualStudioVersion(System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
            <summary>
            Get SubToolset version using Visual Studio version from Dev 12 solution file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.GetOverrideTaskRegistry(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Return a task registry for the override tasks in the *.overridetasks file for this toolset         
            </summary>
            <param name="loggingServices">The logging services used to log during task registration.</param>
            <param name="buildEventContext">The build event context used to log during task registration.</param>
            <param name="projectRootElementCache">The <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCache"/> to use.</param>
            <returns>The task registry</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.RegisterDefaultTasks(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Used to load information about default MSBuild tasks i.e. tasks that do not need to be explicitly declared in projects
            with the &lt;UsingTask&gt; element. Default task information is read from special files, which are located in the same
            directory as the MSBuild binaries.
            </summary>
            <remarks>
            1) a default tasks file needs the &lt;Project&gt; root tag in order to be well-formed
            2) the XML declaration tag &lt;?xml ...&gt; is ignored
            3) comment tags are always ignored regardless of their placement
            4) the rest of the tags are expected to be &lt;UsingTask&gt; tags
            </remarks>
            <param name="loggingServices">The logging services to use to log during this registration.</param>
            <param name="buildEventContext">The build event context to use to log during this registration.</param>
            <param name="projectRootElementCache">The <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCache"/> to use.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.InitializeProperties(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Initialize the properties which are used to evaluate the tasks files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.RegisterOverrideTasks(Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Used to load information about MSBuild override tasks i.e. tasks that override tasks declared in tasks or project files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Toolset.LoadAndRegisterFromTasksFile(System.String[],Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,Microsoft.Build.Execution.TaskRegistry)">
            <summary>
            Do the actual loading of the tasks or override tasks file and register the tasks in the task registry
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetConfigurationReader">
            <summary>
            Class used to read toolset configurations.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetConfigurationReader._configurationSection">
            <summary>
            A section of a toolset configuration
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetConfigurationReader._readApplicationConfiguration">
            <summary>
            Delegate used to read application configurations
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetConfigurationReader._configurationReadAttempted">
            <summary>
            Flag indicating that an attempt has been made to read the configuration
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetConfigurationReader.s_separatorForExtensionsPathSearchPaths">
            <summary>
            Character used to separate search paths specified for MSBuildExtensionsPath* in
            the config file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetConfigurationReader._projectImportSearchPathsCache">
            <summary>
            Cached values of tools version -> project import search paths table
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.#ctor(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.#ctor(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.Func{System.Configuration.Configuration})">
            <summary>
            Constructor taking a delegate for unit test purposes only
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationReader.ToolsVersions">
            <summary>
            Returns the list of tools versions
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationReader.DefaultToolsVersion">
            <summary>
            Returns the default tools version, or null if none was specified
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationReader.MSBuildOverrideTasksPath">
            <summary>
            Returns the path to find override tasks, or null if none was specified
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationReader.DefaultOverrideToolsVersion">
            <summary>
            DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the tools version that should be used by 
            default to build projects with this version of MSBuild.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationReader.ConfigurationSection">
            <summary>
            Lazy getter for the ToolsetConfigurationSection
            Returns null if the section is not present
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.GetPropertyDefinitions(System.String)">
            <summary>
            Provides an enumerator over property definitions for a specified tools version
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.GetSubToolsetVersions(System.String)">
            <summary>
            Provides an enumerator over the set of sub-toolset names available to a particular
            tools version.  MSBuild config files do not currently support sub-toolsets, so
            we return nothing. 
            </summary>
            <param name="toolsVersion">The tools version.</param>
            <returns>An enumeration of the sub-toolsets that belong to that tools version.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.GetSubToolsetPropertyDefinitions(System.String,System.String)">
            <summary>
            Provides an enumerator over property definitions for a specified sub-toolset version 
            under a specified toolset version. In the ToolsetConfigurationReader case, breaks 
            immediately because we do not currently support sub-toolsets in the configuration file. 
            </summary>
            <param name="toolsVersion">The tools version.</param>
            <param name="subToolsetVersion">The sub-toolset version.</param>
            <returns>An enumeration of property definitions.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.GetProjectImportSearchPathsTable(System.String,System.String)">
            <summary>
            Returns a map of project property names / list of search paths for the specified toolsVersion and os
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.ComputeDistinctListOfSearchPaths(Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection)">
            <summary>
            Returns a list of the search paths for a given search path property collection
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReader.ReadApplicationConfiguration">
            <summary>
            Reads the application configuration file.
            NOTE: this is abstracted into a method to support unit testing GetToolsetDataFromConfiguration().
            Unit tests wish to avoid reading (nunit.exe) application configuration file.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetConfigurationReaderHelpers">
            <summary>
            Helper class for reading toolsets out of the configuration file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetConfigurationReaderHelpers.ConfigurationFileMayHaveToolsets">
            <summary>
            Creating a ToolsetConfigurationReader, and also reading toolsets from the 
            configuration file, are a little expensive. To try to avoid this cost if it's 
            not necessary, we'll check if the file exists first. If it exists, we'll scan for 
            the string "toolsVersion" to see if it might actually have any tools versions
            defined in it.
            </summary>
            <returns>True if there may be toolset definitions, otherwise false</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement">
            <summary>
            Class representing the Toolset element
            </summary>
            <remarks>
            Internal for unit testing only
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.toolsVersion">
            <summary>
            ToolsVersion attribute of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElements">
            <summary>
            Property element collection 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.AllProjectImportSearchPaths">
            <summary>
            Collection of all the search paths for project imports, per OS
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection">
            <summary>
            Class representing all the per-OS search paths for MSBuildExtensionsPath*
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection._previouslySeenOS">
            <summary>
            We use this dictionary to track whether or not we've seen a given
            searchPaths definition before, since the .NET configuration classes
            won't perform this check without respect for case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.CollectionType">
            <summary>
            Type of the collection
            This has to be public as cannot change access modifier when overriding
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.ThrowOnDuplicate">
            <summary>
            Throw exception if an element with a duplicate key is added to the collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.ElementName">
            <summary>
            Name of the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.GetElement(System.String)">
            <summary>
            Gets an element with the specified name
            </summary>
            <param name="os">OS of the element</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.GetElement(System.Int32)">
            <summary>
            Gets an element based at the specified position
            </summary>
            <param name="index">position</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Returns the key value for the given element
            </summary>
            <param name="element">element whose key is returned</param>
            <returns>key</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.CreateNewElement">
            <summary>
            Creates a new element of the collection
            </summary>
            <returns>Created element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.BaseAdd(System.Int32,System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen elements
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.BaseAdd(System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen elements
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathsElementCollection.UpdateOSMap(System.Configuration.ConfigurationElement)">
            <summary>
            Stores the name of the OS in a case-insensitive map
            so we can detect if it is specified more than once but with
            different case
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathElement">
            <summary>
            Class representing searchPaths element for a single OS
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathElement.OS">
            <summary>
            OS attribute of the element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.ExtensionsPathElement.PropertyElements">
            <summary>
            Property element collection
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection">
            <summary>
            Class representing collection of property elements
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection._previouslySeenPropertyNames">
            <summary>
            We use this dictionary to track whether or not we've seen a given
            property definition before, since the .NET configuration classes
            won't perform this check without respect for case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.CollectionType">
            <summary>
            Collection type
            This has to be public as cannot change access modifier when overriding  
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.ThrowOnDuplicate">
            <summary>
            Throw exception if an element with a duplicate is added
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.ElementName">
            <summary>
            name of the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.GetElement(System.String)">
            <summary>
            Gets an element with the specified name
            </summary>
            <param name="name">name of the element</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.GetElement(System.Int32)">
            <summary>
            Gets an element at the specified position
            </summary>
            <param name="index">position</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.CreateNewElement">
            <summary>
            Creates a new element
            </summary>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.BaseAdd(System.Int32,System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen property names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.BaseAdd(System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen property names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Gets the key for the element
            </summary>
            <param name="element">element</param>
            <returns>key</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElement.PropertyElementCollection.UpdatePropertyNameMap(System.Configuration.ConfigurationElement)">
            <summary>
            Stores the name of the tools version in a case-insensitive map
            so we can detect if it is specified more than once but with
            different case
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElement.PropertyElement">
            <summary>
            This class represents property element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElement.Name">
            <summary>
            name attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElement.PropertyElement.Value">
            <summary>
            value attribute
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetElementCollection">
            <summary>
            Class representing the collection of toolset elements
            </summary>
            <remarks>
            Internal for unit testing only
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetElementCollection._previouslySeenToolsVersions">
            <summary>
            We use this dictionary to track whether or not we've seen a given
            toolset definition before, since the .NET configuration classes
            won't perform this check without respect for case.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElementCollection.CollectionType">
            <summary>
            Type of the collection
            This has to be public as cannot change access modifier when overriding
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElementCollection.ThrowOnDuplicate">
            <summary>
            Throw exception if an element with a duplicate key is added to the collection
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetElementCollection.ElementName">
            <summary>
            Name of the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.GetElement(System.String)">
            <summary>
            Gets an element with the specified name
            </summary>
            <param name="toolsVersion">toolsVersion of the element</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.GetElement(System.Int32)">
            <summary>
            Gets an element based at the specified position
            </summary>
            <param name="index">position</param>
            <returns>element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Returns the key value for the given element
            </summary>
            <param name="element">element whose key is returned</param>
            <returns>key</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.CreateNewElement">
            <summary>
            Creates a new element of the collection
            </summary>
            <returns>Created element</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.BaseAdd(System.Int32,System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen tools versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.BaseAdd(System.Configuration.ConfigurationElement)">
            <summary>
            overridden so we can track previously seen tools versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetElementCollection.UpdateToolsVersionMap(System.Configuration.ConfigurationElement)">
            <summary>
            Stores the name of the tools version in a case-insensitive map
            so we can detect if it is specified more than once but with
            different case
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetConfigurationSection">
            <summary>
            This class is used to programmatically read msbuildToolsets section
            in from the configuration file.  An example of application config file:
            
            &lt;configuration&gt;
                &lt;msbuildToolsets default="2.0"&gt;
                    &lt;toolset toolsVersion="2.0"&gt;
                        &lt;property name="MSBuildBinPath" value="D:\windows\Microsoft.NET\Framework\v2.0.x86ret\"/&gt;
                        &lt;property name="SomeOtherProperty" value="SomeOtherPropertyValue"/&gt;
                    &lt;/toolset&gt;
                    &lt;toolset toolsVersion="3.5"&gt;
                        &lt;property name="MSBuildBinPath" value="D:\windows\Microsoft.NET\Framework\v3.5.x86ret\"/&gt;
                    &lt;/toolset&gt;
                &lt;/msbuildToolsets&gt;
            &lt;/configuration&gt;
            
            </summary>
            <remarks>
            Internal for unit testing only
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.Toolsets">
            <summary>
            toolsVersion element collection 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.Default">
            <summary>
            default attribute on msbuildToolsets element, specifying the default ToolsVersion
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.MSBuildOverrideTasksPath">
            <summary>
            MsBuildOverrideTasksPath attribute on msbuildToolsets element, specifying the path to find msbuildOverrideTasks files
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetConfigurationSection.DefaultOverrideToolsVersion">
            <summary>
            DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by 
            default to build projects with this version of MSBuild.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetPropertyDefinition">
            <summary>
            A class representing a property.  Used internally by the toolset readers.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetPropertyDefinition._name">
            <summary>
            The property name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetPropertyDefinition._value">
            <summary>
            The property value
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetPropertyDefinition._source">
            <summary>
            The property source
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetPropertyDefinition.#ctor(System.String,System.String,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Creates a new property
            </summary>
            <param name="name">The property name</param>
            <param name="value">The property value</param>
            <param name="source">The property source</param>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetPropertyDefinition.Name">
            <summary>
            The name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetPropertyDefinition.Value">
            <summary>
            The value of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetPropertyDefinition.Source">
            <summary>
            A description of the location where the property was defined,
            such as a registry key path or a path to a config file and 
            line number.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetReader">
            <summary>
            The abstract base class for all Toolset readers.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetReader._globalProperties">
            <summary>
            The global properties used to read the toolset.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetReader._environmentProperties">
            <summary>
            The environment properties used to read the toolset.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.#ctor(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetReader.ToolsVersions">
            <summary>
            Returns the list of tools versions
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetReader.DefaultToolsVersion">
            <summary>
            Returns the default tools version, or null if none was specified
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetReader.MSBuildOverrideTasksPath">
            <summary>
            Returns the path to find override tasks, or null if none was specified
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetReader.DefaultOverrideToolsVersion">
            <summary>
            ToolsVersion to use as the default ToolsVersion for this version of MSBuild
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.ReadAllToolsets(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.Toolset},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Evaluation.ToolsetDefinitionLocations)">
            <summary>
            Gathers toolset data from the registry and configuration file, if any:
            allows you to specify which of the registry and configuration file to
            read from by providing ToolsetInitialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.ReadAllToolsets(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.Toolset},Microsoft.Build.Evaluation.ToolsetRegistryReader,Microsoft.Build.Evaluation.ToolsetConfigurationReader,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Evaluation.ToolsetDefinitionLocations)">
            <summary>
            Gathers toolset data from the registry and configuration file, if any.
            NOTE:  this method is internal for unit testing purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.ReadToolsets(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.Toolset},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.Boolean,System.String@,System.String@)">
            <summary>
            Populates the toolset collection passed in with the toolsets read from some location.
            </summary>
            <remarks>Internal for unit testing only</remarks>
            <returns>the default tools version if available, or null otherwise</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.GetPropertyDefinitions(System.String)">
            <summary>
            Provides an enumerator over property definitions for a specified tools version
            </summary>
            <param name="toolsVersion">The tools version.</param>
            <returns>An enumeration of property definitions.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.GetSubToolsetVersions(System.String)">
            <summary>
            Provides an enumerator over the set of sub-toolset names available to a particular
            toolsversion
            </summary>
            <param name="toolsVersion">The tools version.</param>
            <returns>An enumeration of the sub-toolsets that belong to that toolsversion.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.GetSubToolsetPropertyDefinitions(System.String,System.String)">
            <summary>
            Provides an enumerator over property definitions for a specified sub-toolset version 
            under a specified toolset version. 
            </summary>
            <param name="toolsVersion">The tools version.</param>
            <param name="subToolsetVersion">The sub-toolset version.</param>
            <returns>An enumeration of property definitions.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.GetProjectImportSearchPathsTable(System.String,System.String)">
            <summary>
            Returns a map of MSBuildExtensionsPath* property names/kind to list of search paths
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.ReadEachToolset(System.Collections.Generic.Dictionary{System.String,Microsoft.Build.Evaluation.Toolset},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.Boolean)">
            <summary>
            Reads all the toolsets and populates the given ToolsetCollection with them
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.ReadToolset(Microsoft.Build.Evaluation.ToolsetPropertyDefinition,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.Boolean)">
            <summary>
            Reads the settings for a specified tools version
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.CreateStandardProperties(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.String,System.String,System.String)">
            <summary>
            Create a dictionary with standard properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.AppendStandardProperties(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.String,System.String,System.String)">
            <summary>
            Appends standard properties to a dictionary. These properties are read from
            the registry under Windows (they are a part of a toolset definition).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.EvaluateAndSetProperty(Microsoft.Build.Evaluation.ToolsetPropertyDefinition,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.Boolean,System.String@,System.String@,Microsoft.Build.Evaluation.Expander{Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance}@)">
            <summary>
            Processes a particular ToolsetPropertyDefinition into the correct value and location in the initial and/or final property set. 
            </summary>
            <param name="property">The ToolsetPropertyDefinition being analyzed.</param>
            <param name="properties">The final set of properties that we wish this toolset property to be added to. </param>
            <param name="globalProperties">The global properties, used for expansion and to make sure none are overridden.</param>
            <param name="initialProperties">The initial properties, used for expansion and added to if "accumulateProperties" is true.</param>
            <param name="accumulateProperties">If "true", we add this property to the initialProperties dictionary, as well, so that properties later in the toolset can use this value.</param>
            <param name="toolsPath">If this toolset property is the "MSBuildToolsPath" property, we will return the value in this parameter.</param>
            <param name="binPath">If this toolset property is the "MSBuildBinPath" property, we will return the value in this parameter.</param>
            <param name="expander">The expander used to expand the value of the properties.  Ref because if we are accumulating the properties, we need to re-create the expander to account for the new property value.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.ExpandPropertyUnescaped(Microsoft.Build.Evaluation.ToolsetPropertyDefinition,Microsoft.Build.Evaluation.Expander{Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance})">
            <summary>
            Expands the given unexpanded property expression using the properties in the
            given expander.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.SetProperty(Microsoft.Build.Evaluation.ToolsetPropertyDefinition,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Sets the given property in the given property group.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetReader.ExpandRelativePathsRelativeToExeLocation(System.String)">
            <summary>
            Given a path, de-relativizes it using the location of the currently
            executing .exe as the base directory. For example, the path "..\foo"
            becomes "c:\windows\microsoft.net\framework\foo" if the current exe is
            "c:\windows\microsoft.net\framework\v3.5.1234\msbuild.exe".
            If the path is not relative, it is returned without modification.
            If the path is invalid, it is returned without modification.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind">
            <summary>
            struct representing a reference to MSBuildExtensionsPath* property
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind.Default">
            <summary>
            MSBuildExtensionsPathReferenceKind instance for property named "MSBuildExtensionsPath"
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind.Path32">
            <summary>
            MSBuildExtensionsPathReferenceKind instance for property named "MSBuildExtensionsPath32"
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind.Path64">
            <summary>
            MSBuildExtensionsPathReferenceKind instance for property named "MSBuildExtensionsPath64"
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind.None">
            <summary>
            MSBuildExtensionsPathReferenceKind instance representing no MSBuildExtensionsPath* property reference
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind.StringRepresentation">
            <summary>
            String representation of the property reference - eg. "MSBuildExtensionsPath32"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind.MSBuildPropertyName">
            <summary>
            Returns the corresponding property name - eg. "$(MSBuildExtensionsPath32)"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind.FindIn(System.String)">
            <summary>
            Tries to find a reference to MSBuildExtensionsPath* property in the given string
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetRegistryReader">
            <summary>
            Reads registry at the base key and returns a Dictionary keyed on ToolsVersion.
            Dictionary contains another dictionary of (property name, property value) pairs.
            If a registry value is not a string, this will throw a InvalidToolsetDefinitionException.
            An example of how the registry will look (note that the DefaultToolsVersion is per-MSBuild-version)
            [HKLM]\SOFTWARE\Microsoft
              msbuild
                3.5
                  @DefaultToolsVersion = 2.0
                ToolsVersions
                  2.0
                    @MSBuildToolsPath = D:\SomeFolder
                  3.5
                    @MSBuildToolsPath = D:\SomeOtherFolder
                    @MSBuildBinPath = D:\SomeOtherFolder
                    @SomePropertyName = PropertyOtherValue
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetRegistryReader.MSBuildRegistryPath">
            <summary>
            Registry location for storing tools version dependent data for msbuild
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetRegistryReader._msbuildRegistryWrapper">
            <summary>
            Cached registry wrapper at root of the msbuild entries
            </summary> 
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.#ctor(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance})">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.#ctor(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Internal.RegistryKeyWrapper)">
            <summary>
            Constructor overload accepting a registry wrapper for unit testing purposes only
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetRegistryReader.ToolsVersions">
            <summary>
            Returns the list of tools versions
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetRegistryReader.DefaultToolsVersion">
            <summary>
            Returns the default tools version, or null if none was specified
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetRegistryReader.MSBuildOverrideTasksPath">
            <summary>
            Returns the path to find override tasks, or null if none was specified
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetRegistryReader.DefaultOverrideToolsVersion">
            <summary>
            ToolsVersion to use as the default ToolsVersion for this version of MSBuild
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.GetPropertyDefinitions(System.String)">
            <summary>
            Provides an enumerator over property definitions for a specified tools version
            </summary>
            <param name="toolsVersion">The tools version</param>
            <returns>An enumeration of property definitions</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.GetSubToolsetVersions(System.String)">
            <summary>
            Provides an enumerator over the set of sub-toolset names available to a particular
            toolsversion
            </summary>
            <param name="toolsVersion">The tools version.</param>
            <returns>An enumeration of the sub-toolsets that belong to that toolsversion.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.GetSubToolsetPropertyDefinitions(System.String,System.String)">
            <summary>
            Provides an enumerator over property definitions for a specified sub-toolset version 
            under a specified toolset version. 
            </summary>
            <param name="toolsVersion">The tools version.</param>
            <param name="subToolsetVersion">The sub-toolset version.</param>
            <returns>An enumeration of property definitions.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.GetProjectImportSearchPathsTable(System.String,System.String)">
            <summary>
            Returns a map of MSBuildExtensionsPath* property names/kind to list of search paths
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.CreatePropertyFromRegistry(Microsoft.Build.Internal.RegistryKeyWrapper,System.String)">
            <summary>
            Given a registry location containing a property name and value, create the ToolsetPropertyDefinition that maps to it
            </summary>
            <param name="toolsetWrapper">Wrapper for the key that we're getting values from</param>
            <param name="propertyName">The name of the property whose value we wish to generate a ToolsetPropertyDefinition for.</param>
            <returns>A ToolsetPropertyDefinition instance corresponding to the property name requested.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetRegistryReader.GetValue(Microsoft.Build.Internal.RegistryKeyWrapper,System.String)">
            <summary>
            Reads a string value from the specified registry key
            </summary>
            <param name="wrapper">wrapper around key</param>
            <param name="valueName">name of the value</param>
            <returns>string data in the value</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.UpdateConditionedPropertiesTable(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String}},System.String,System.String)">
             <summary>
             Update our table which keeps track of all the properties that are referenced
             inside of a condition and the string values that they are being tested against.
             So, for example, if the condition was " '$(Configuration)' == 'Debug' ", we
             would get passed in leftValue="$(Configuration)" and rightValueExpanded="Debug".
             This call would add the string "Debug" to the list of possible values for the 
             "Configuration" property.
            
             This method also handles the case when two or more properties are being
             concatenated together with a vertical bar, as in '
                 $(Configuration)|$(Platform)' == 'Debug|x86'
             </summary>
             <param name="conditionedPropertiesTable"></param>
             <param name="leftValue"></param>
             <param name="rightValueExpanded"></param>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ConditionEvaluator.s_disableExpressionCaching">
            <summary>
            For debugging leaks, a way to disable caching expression trees, to reduce noise
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.EvaluateCondition``2(System.String,Microsoft.Build.Evaluation.ParserOptions,Microsoft.Build.Evaluation.Expander{``0,``1},Microsoft.Build.Evaluation.ExpanderOptions,System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Shared.FileSystem.IFileSystem,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Evaluates a string representing a condition from a "condition" attribute.
            If the condition is a malformed string, it throws an InvalidProjectFileException.
            This method uses cached expression trees to avoid generating them from scratch every time it's called.
            This method is thread safe and is called from engine and task execution module threads
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.EvaluateConditionCollectingConditionedProperties``2(System.String,Microsoft.Build.Evaluation.ParserOptions,Microsoft.Build.Evaluation.Expander{``0,``1},Microsoft.Build.Evaluation.ExpanderOptions,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String}},System.String,Microsoft.Build.Construction.ElementLocation,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.Shared.FileSystem.IFileSystem,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Evaluates a string representing a condition from a "condition" attribute.
            If the condition is a malformed string, it throws an InvalidProjectFileException.
            This method uses cached expression trees to avoid generating them from scratch every time it's called.
            This method is thread safe and is called from engine and task execution module threads
            Logging service may be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState.ConditionedPropertiesInProject">
            <summary>
                Table of conditioned properties and their values.
                Used to populate configuration lists in some project systems.
                If this is null, as it is for command line builds, conditioned properties
                are not recorded.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState.ExpandIntoStringBreakEarly(System.String)">
            <summary>
                May return null if the expression would expand to non-empty and it broke out early.
                Otherwise, returns the correctly expanded expression.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState.ExpandIntoTaskItems(System.String)">
            <summary>
                Expands the specified expression into a list of TaskItem's.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState.ExpandIntoString(System.String)">
            <summary>
                Expands the specified expression into a string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState.LoadedProjectsCache">
            <summary>
                PRE cache
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ConditionEvaluator.ConditionEvaluationState`2">
            <summary>
            All the state necessary for the evaluation of conditionals so that the expression tree 
            is stateless and reusable
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ConditionEvaluator.ConditionEvaluationState`2.Condition">
            <summary>
            Condition that was parsed. This does not belong here,
            it belongs to the expression tree, not the condition evaluation state.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ConditionEvaluator.ConditionEvaluationState`2.ConditionedPropertiesInProject">
            <summary>
            Table of conditioned properties and their values.
            Used to populate configuration lists in some project systems.
            If this is null, as it is for command line builds, conditioned properties
            are not recorded.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ConditionEvaluator.ConditionEvaluationState`2.LoadedProjectsCache">
            <summary>
            PRE collection. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.ConditionEvaluationState`2.ExpandIntoStringBreakEarly(System.String)">
            <summary>
            May return null if the expression would expand to non-empty and it broke out early.
            Otherwise, returns the correctly expanded expression.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.ConditionEvaluationState`2.ExpandIntoTaskItems(System.String)">
            <summary>
            Expands the properties and items in the specified expression into a list of taskitems.
            </summary>
            <param name="expression">The expression to expand.</param>
            <returns>A list of items.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ConditionEvaluator.ConditionEvaluationState`2.ExpandIntoString(System.String)">
            <summary>
            Expands the specified expression into a string.
            </summary>
            <param name="expression">The expression to expand.</param>
            <returns>The expanded string.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.AndExpressionNode">
            <summary>
            Performs logical AND on children
            Does not update conditioned properties table
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.AndExpressionNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as boolean
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EqualExpressionNode">
            <summary>
            Compares for equality
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EqualExpressionNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numbers
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EqualExpressionNode.Compare(System.Boolean,System.Boolean)">
            <summary>
            Compare booleans
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EqualExpressionNode.Compare(System.String,System.String)">
            <summary>
            Compare strings
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.FunctionCallExpressionNode">
            <summary>
            Evaluates a function expression, such as "Exists('foo')"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.FunctionCallExpressionNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate node as boolean
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.FunctionCallExpressionNode.ExpandArgumentForScalarParameter(System.String,Microsoft.Build.Evaluation.GenericExpressionNode,Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState,System.Boolean)">
            <summary>
            Expands properties and items in the argument, and verifies that the result is consistent
            with a scalar parameter type.
            </summary>
            <param name="function">Function name for errors</param>
            <param name="argumentNode">Argument to be expanded</param>
            <param name="state"></param>
            <param name="isFilePath">True if this is afile name and the path should be normalized</param>
            <returns>Scalar result</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.FunctionCallExpressionNode.VerifyArgumentCount(System.Int32,Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Check that the number of function arguments is correct.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.GenericExpressionNode">
            <summary>
            Base class for all expression nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GenericExpressionNode.EvaluatesToEmpty(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Returns true if this node evaluates to an empty string,
            otherwise false.
            (It may be cheaper to determine whether an expression will evaluate
            to empty than to fully evaluate it.)
            Implementations should cache the result so that calls after the first are free.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GenericExpressionNode.GetExpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Value after any item and property expressions are expanded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GenericExpressionNode.GetUnexpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Value before any item and property expressions are expanded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GenericExpressionNode.ResetState">
            <summary>
            If any expression nodes cache any state for the duration of evaluation, 
            now's the time to clean it up
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GenericExpressionNode.Evaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            The main evaluate entry point for expression trees
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Build.Evaluation.GenericExpressionNode.DebuggerDisplay">
            <summary>
            Get display string for this node for use in the debugger.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.GreaterThanExpressionNode">
            <summary>
            Compares for left > right
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanExpressionNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numerically
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanExpressionNode.Compare(System.Version,System.Version)">
            <summary>
            Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanExpressionNode.Compare(System.Version,System.Double)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanExpressionNode.Compare(System.Double,System.Version)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode">
            <summary>
            Compares for left >= right
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numerically
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode.Compare(System.Version,System.Version)">
            <summary>
            Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode.Compare(System.Version,System.Double)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode.Compare(System.Double,System.Version)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.LessThanExpressionNode">
            <summary>
            Compares for left &lt; right
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanExpressionNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numerically
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanExpressionNode.Compare(System.Version,System.Version)">
            <summary>
            Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanExpressionNode.Compare(System.Version,System.Double)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanExpressionNode.Compare(System.Double,System.Version)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode">
            <summary>
            Compares for left &lt;= right
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numerically
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode.Compare(System.Version,System.Version)">
            <summary>
            Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode.Compare(System.Version,System.Double)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode.Compare(System.Double,System.Version)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.MultipleComparisonNode">
            <summary>
            Evaluates as boolean and evaluates children as boolean, numeric, or string.
            Order in which comparisons are attempted is numeric, boolean, then string.
            Updates conditioned properties table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MultipleComparisonNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numbers
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MultipleComparisonNode.Compare(System.Boolean,System.Boolean)">
            <summary>
            Compare booleans
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MultipleComparisonNode.Compare(System.String,System.String)">
            <summary>
            Compare strings
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MultipleComparisonNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluates as boolean and evaluates children as boolean, numeric, or string.
            Order in which comparisons are attempted is numeric, boolean, then string.
            Updates conditioned properties table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MultipleComparisonNode.ResetState">
            <summary>
            Reset temporary state
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.MultipleComparisonNode.UpdateConditionedProperties(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Updates the conditioned properties table if it hasn't already been done.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.NotEqualExpressionNode">
            <summary>
            Compares for inequality
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NotEqualExpressionNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numbers
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NotEqualExpressionNode.Compare(System.Boolean,System.Boolean)">
            <summary>
            Compare booleans
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NotEqualExpressionNode.Compare(System.String,System.String)">
            <summary>
            Compare strings
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.NotExpressionNode">
            <summary>
            Performs logical NOT on left child
            Does not update conditioned properties table
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NotExpressionNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as boolean
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NotExpressionNode.GetUnexpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Returns unexpanded value with '!' prepended. Useful for error messages.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NotExpressionNode.GetExpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Returns expanded value with '!' prepended. Useful for error messages.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.NumericComparisonExpressionNode">
            <summary>
            Evaluates a numeric comparison, such as less-than, or greater-or-equal-than
            Does not update conditioned properties table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericComparisonExpressionNode.Compare(System.Double,System.Double)">
            <summary>
            Compare numbers
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericComparisonExpressionNode.Compare(System.Version,System.Version)">
            <summary>
            Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericComparisonExpressionNode.Compare(System.Version,System.Double)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericComparisonExpressionNode.Compare(System.Double,System.Version)">
            <summary>
            Compare mixed numbers and Versions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericComparisonExpressionNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as boolean
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.NumericExpressionNode">
            <summary>
            Represents a number - evaluates as numeric.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as boolean
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.NumericEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as numeric
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.VersionEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as a Version
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.CanBoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Whether it can be evaluated as a boolean: never allowed for numerics
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.CanNumericEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Whether it can be evaluated as numeric
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.CanVersionEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Whether it can be evaluated as a Version
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.GetUnexpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Get the unexpanded value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.GetExpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Get the expanded value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.NumericExpressionNode.ResetState">
            <summary>
            If any expression nodes cache any state for the duration of evaluation, 
            now's the time to clean it up
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.OperandExpressionNode">
            <summary>
            Base class for all nodes that are operands (are leaves in the parse tree)
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.OperatorExpressionNode">
            <summary>
            Base class for nodes that are operators (have children in the parse tree)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.NumericEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Numeric evaluation is never allowed for operators
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.VersionEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Version evaluation is never allowed for operators
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.CanBoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Whether boolean evaluation is allowed: always allowed for operators
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.CanNumericEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Whether the node can be evaluated as a numeric: by default,
            this is not allowed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.CanVersionEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Whether the node can be evaluated as a version: by default,
            this is not allowed
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.GetExpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Value after any item and property expressions are expanded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.GetUnexpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Value before any item and property expressions are expanded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OperatorExpressionNode.ResetState">
            <summary>
            If any expression nodes cache any state for the duration of evaluation, 
            now's the time to clean it up
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.OperatorExpressionNode.LeftChild">
            <summary>
            Storage for the left child
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.OperatorExpressionNode.RightChild">
            <summary>
            Storage for the right child
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.OrExpressionNode">
            <summary>
            Performs logical OR on children
            Does not update conditioned properties table
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.OrExpressionNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as boolean
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Parser">
             <summary>
             This class implements the grammar for complex conditionals.
            
             The usage is:
                Parser p = new Parser(CultureInfo);
                ExpressionTree t = p.Parse(expression, XmlNode);
            
             The expression tree can then be evaluated and re-evaluated as needed.
             </summary>
             <remarks>
             UNDONE: When we copied over the conditionals code, we didn't copy over the unit tests for scanner, parser, and expression tree.
             </remarks>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Parser.LogBuildEventContext">
            <summary>
             Location contextual information which are attached to logging events to 
             say where they are in relation to the process, engine, project, target,task which is executing
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Parser.LoggingServices">
            <summary>
            Engine Logging Service reference where events will be logged to
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Scanner">
            <summary>
            Class:       Scanner
            This class does the scanning of the input and returns tokens.
            The usage pattern is:
               Scanner s = new Scanner(expression, CultureInfo)
               do {
                 s.Advance();
               while (s.IsNext(Token.EndOfInput));
            
             After Advance() is called, you can get the current token (s.CurrentToken),
             check it's type (s.IsNext()), get the string for it (s.NextString()).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Scanner.EndOfInput">
            <summary>
            Lazily format resource string to help avoid (in some perf critical cases) even loading
            resources at all.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.GetErrorResource">
            <summary>
            If the lexer errors, it has the best knowledge of the error message to show. For example,
            'unexpected character' or 'illformed operator'. This method returns the name of the resource
            string that the parser should display.
            </summary>
            <remarks>Intentionally not a property getter to avoid the debugger triggering the Assert dialog</remarks>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.Advance">
             <summary>
             Advance
             returns true on successful advance
                 and false on an erroneous token
            
             Doesn't return error until the bogus input is encountered.
             Advance() returns true even after EndOfInput is encountered.
             </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.ParsePropertyOrItemMetadata">
            <summary>
            Parses either the $(propertyname) syntax or the %(metadataname) syntax, 
            and returns the parsed string beginning with the '$' or '%', and ending with the
            closing parenthesis.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.ScanForPropertyExpressionEnd(System.String,System.Int32)">
            <summary>
            Scan for the end of the property expression
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.ParseProperty">
            <summary>
            Parses a string of the form $(propertyname).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.ParseItemMetadata">
            <summary>
            Parses a string of the form %(itemmetadataname).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.CheckForUnexpectedMetadata(System.String)">
            <summary>
            Helper to verify that any AllowBuiltInMetadata or AllowCustomMetadata
            specifications are not respected.
            Returns true if it is ok, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Scanner.ParseQuotedString">
            <summary>
            Parse any part of the conditional expression that is quoted. It may contain a property, item, or 
            metadata element that needs expansion during evaluation.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.StringExpressionNode">
            <summary>
            Node representing a string
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.StringExpressionNode._expandable">
            <summary>
            Whether the string potentially has expandable content,
            such as a property expression or escaped character.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringExpressionNode.BoolEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as boolean
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringExpressionNode.NumericEvaluate(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Evaluate as numeric
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringExpressionNode.EvaluatesToEmpty(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Returns true if this node evaluates to an empty string,
            otherwise false.
            It may be cheaper to determine whether an expression will evaluate
            to empty than to fully evaluate it.
            Implementations should cache the result so that calls after the first are free.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringExpressionNode.GetUnexpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Value before any item and property expressions are expanded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringExpressionNode.GetExpandedValue(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Value after any item and property expressions are expanded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringExpressionNode.ResetState">
            <summary>
            If any expression nodes cache any state for the duration of evaluation, 
            now's the time to clean it up
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringExpressionNode.ShouldBeTreatedAsVisualStudioVersion(Microsoft.Build.Evaluation.ConditionEvaluator.IConditionEvaluationState)">
            <summary>
            Should this node be treated as an expansion of VisualStudioVersion, rather than
            its literal meaning?
            </summary>
            <remarks>
            Needed to provide a compat shim for numeric/version comparisons
            on MSBuildToolsVersion, which were fine when it was a number
            but now cause the project to throw InvalidProjectException when
            ToolsVersion is "Current". https://github.com/Microsoft/msbuild/issues/4150
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Token">
            <summary>
            This class represents a token in the Complex Conditionals grammar.  It's
            really just a bag that contains the type of the token and the string that
            was parsed into the token.  This isn't very useful for operators, but
            is useful for strings and such.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Token.TokenType">
            <summary>
            Valid tokens
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Token.#ctor(Microsoft.Build.Evaluation.Token.TokenType)">
            <summary>
            Constructor for types that don't have values
            </summary>
            <param name="tokenType"></param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Token.#ctor(Microsoft.Build.Evaluation.Token.TokenType,System.String)">
            <summary>
            Constructor takes the token type and the string that
            represents the token
            </summary>
            <param name="type"></param>
            <param name="tokenString"></param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Token.#ctor(Microsoft.Build.Evaluation.Token.TokenType,System.String,System.Boolean)">
            <summary>
            Constructor takes the token type and the string that
            represents the token.
            If the string may contain content that needs expansion, expandable is set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Token.Expandable">
            <summary>
            Whether the content potentially has expandable content,
            such as a property expression or escaped character.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Token.IsToken(Microsoft.Build.Evaluation.Token.TokenType)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EvaluatorMetadataTable">
            <summary>
            Implementation of a metadata table for use by the evaluator.
            Accumulates ProjectMetadataElement objects and their evaluated value,
            overwriting any previous metadata with that name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.EvaluatorMetadataTable._metadata">
            <summary>
            The actual metadata dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.EvaluatorMetadataTable._implicitItemType">
            <summary>
            The type of item the metadata should be considered to apply to.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluatorMetadataTable.#ctor(System.String)">
            <summary>
            Creates a new table using the specified item type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.EvaluatorMetadataTable.Entries">
            <summary>
            Enumerator over the entries in this table
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluatorMetadataTable.GetEscapedValue(System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name specified,
            whatever the item type.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluatorMetadataTable.GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluatorMetadataTable.GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If no value is available, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluatorMetadataTable.SetValue(Microsoft.Build.Construction.ProjectMetadataElement,System.String)">
            <summary>
            Adds a metadata entry to the table
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.EvaluatorMetadataTable.EvaluatorMetadata">
            <summary>
            An entry in the evaluator's metadata table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.EvaluatorMetadataTable.EvaluatorMetadata.#ctor(Microsoft.Build.Construction.ProjectMetadataElement,System.String)">
            <summary>
            Construct a new EvaluatorMetadata
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.EvaluatorMetadataTable.EvaluatorMetadata.Xml">
            <summary>
            Gets or sets the metadata Xml
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.EvaluatorMetadataTable.EvaluatorMetadata.EvaluatedValue">
            <summary>
            Gets or sets the evaluated value, unescaped
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.EvaluatorMetadataTable.EvaluatorMetadata.EvaluatedValueEscaped">
            <summary>
            Gets or sets the evaluated value, escaped as necessary
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IEvaluatorData`4">
            <summary>
            An interface for objects which the Evaluator can use as a destination for evaluation of ProjectRootElement.
            </summary>
            <typeparam name="P">The type of properties to be produced.</typeparam>
            <typeparam name="I">The type of items to be produced.</typeparam>
            <typeparam name="M">The type of metadata on those items.</typeparam>
            <typeparam name="D">The type of item definitions to be produced.</typeparam>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.EvaluationId">
            <summary>
            The ID of this evaluation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.Directory">
            <summary>
            The (project) directory that should be used during evaluation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.TaskRegistry">
            <summary>
            Task classes and locations known to this project. 
            This is the project-specific task registry, which is consulted before
            the toolset's task registry.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.Toolset">
            <summary>
            The toolset data used during evaluation, and which should be used for build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.SubToolsetVersion">
            <summary>
            The sub-toolset version that should be used with this toolset to determine 
            the full set of properties to be used by the build. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.ExplicitToolsVersion">
            <summary>
            The externally specified tools version to evaluate with, if any.
            For example, the tools version from a /tv switch.
            This is not the tools version specified on the Project tag, if any.
            May be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.GlobalPropertiesDictionary">
            <summary>
            Gets the global properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.GlobalPropertiesToTreatAsLocal">
            <summary>
            List of names of the properties that, while global, are still treated as overridable 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.InitialTargets">
            <summary>
            Sets the initial targets
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.DefaultTargets">
            <summary>
            Sets the default targets
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.BeforeTargets">
            <summary>
            Sets or retrieves the list of targets which run before the keyed target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.AfterTargets">
            <summary>
            Sets or retrieves the list of targets which run after the keyed target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.ConditionedProperties">
            <summary>
            List of possible values for properties inferred from certain conditions,
            keyed by the property name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.ShouldEvaluateForDesignTime">
            <summary>
            Whether evaluation should collect items ignoring condition,
            as well as items respecting condition; and collect
            conditioned properties, as well as regular properties
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.CanEvaluateElementsWithFalseConditions">
            <summary>
            Tells the evaluator whether it should evaluate elements with false conditions
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.Properties">
            <summary>
            Enumerator over properties in this project.
            Exposed for debugging display.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.ItemDefinitionsEnumerable">
            <summary>
            Enumerator over all item definitions.
            Exposed for debugging display.
            Ideally the dictionary would be exposed, but there are 
            covariance problems. (A dictionary of Key, Value cannot be upcast
            to a Dictionary of Key, IValue).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.Items">
            <summary>
            Enumerator over all items.
            Exposed for debugging display.
            Ideally the dictionary would be exposed, but there are 
            covariance problems. (A dictionary of Key, Value cannot be upcast
            to a Dictionary of Key, IValue).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.EvaluatedItemElements">
            <summary>
            Evaluation ordered list of project item elements that were evaluated by the Evaluator
            It means that both the item element's condition and the item group element's conditions evaluated to true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IEvaluatorData`4.EnvironmentVariablePropertiesDictionary">
            <summary>
            A dictionary of all of the environment variable properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.InitializeForEvaluation(Microsoft.Build.Evaluation.IToolsetProvider,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Prepares the data block for a new evaluation pass
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.FinishEvaluation">
            <summary>
            Indicates to the data block that evaluation has completed,
            so for example it can mark datastructures read-only.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.AddItem(`1)">
            <summary>
            Adds a new item
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.AddItemIgnoringCondition(`1)">
            <summary>
            Adds a new item to the collection of all items ignoring condition
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.AddItemDefinition(System.String)">
            <summary>
            Adds a new item definition
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.AddToAllEvaluatedPropertiesList(`0)">
            <summary>
            Properties encountered during evaluation. These are read during the first evaluation pass.
            Unlike those returned by the Properties property, these are ordered, and include any properties that
            were subsequently overridden by others with the same name. It does not include any 
            properties whose conditions did not evaluate to true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.AddToAllEvaluatedItemDefinitionMetadataList(`2)">
            <summary>
            Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
            Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
            were subsequently overridden by others with the same name and item type. It does not include any 
            elements whose conditions did not evaluate to true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.AddToAllEvaluatedItemsList(`1)">
            <summary>
            Items encountered during evaluation. These are read during the third evaluation pass.
            Unlike those returned by the Items property, these are ordered.
            It does not include any elements whose conditions did not evaluate to true.
            It does not include any items added since the last evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.GetItemDefinition(System.String)">
            <summary>
            Retrieves an existing item definition, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.SetProperty(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets a property which does not come from the Xml.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.SetProperty(Microsoft.Build.Construction.ProjectPropertyElement,System.String)">
            <summary>
            Sets a property which comes from the Xml.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.GetTarget(System.String)">
            <summary>
            Retrieves an existing target, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.AddTarget(Microsoft.Build.Execution.ProjectTargetInstance)">
            <summary>
            Adds a new target, overwriting any existing target with the same name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.RecordImport(Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32,Microsoft.Build.BackEnd.SdkResolution.SdkResult)">
            <summary>
            Record an import opened during evaluation, if appropriate.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.RecordImportWithDuplicates(Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.Construction.ProjectRootElement,System.Int32)">
            <summary>
            Record an import opened during evaluation, if appropriate.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.ExpandString(System.String)">
            <summary>
            Evaluates the provided string by expanding items and properties,
            using the current items and properties available.
            This is useful for the immediate window.
            Does not expand bare metadata expressions.
            </summary>
            <comment>
            Not for internal use.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IEvaluatorData`4.EvaluateCondition(System.String)">
            <summary>
            Evaluates the provided string as a condition by expanding items and properties,
            using the current items and properties available, then doing a logical evaluation.
            This is useful for the immediate window.
            Does not expand bare metadata expressions.
            </summary>
            <comment>
            Not for internal use.
            </comment>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IItem">
            <summary>
            This interface represents an item without exposing its type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IItem.EvaluatedInclude">
            <summary>
            Gets the evaluated include value for this item, unescaped.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IItem.EvaluatedIncludeEscaped">
            <summary>
            Gets the evaluated include value for this item, escaped as necessary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IItem.ProjectDirectory">
            <summary>
            The directory of the project being built
            If there is no project filename defined, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItem.GetMetadataValue(System.String)">
            <summary>
            Returns the metadata with the specified key.
            Returns null if it does not exist.
            Attempting to get built-in metadata on a value that is not a valid path throws InvalidOperationException.
            Metadata value is unescaped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItem.GetMetadataValueEscaped(System.String)">
            <summary>
            Returns the metadata with the specified key.
            Returns null if it does not exist.
            Attempting to get built-in metadata on a value that is not a valid path throws InvalidOperationException.
            Metadata value is the escaped value initially set.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IItemDefinition`1">
            <summary>
            Interface representing item definition objects for use by the Evaulator.
            </summary>
            <typeparam name="M">Type of metadata objects.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemDefinition`1.GetMetadata(System.String)">
            <summary>
            Gets any metadatum on this item definition with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemDefinition`1.SetMetadata(Microsoft.Build.Construction.ProjectMetadataElement,System.String,`0)">
            <summary>
            Adds the specified metadata to the item definition.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IItemFactory`2">
            <summary>
            This interface is used to describe a class which can act as a factory for creating
            items when the Expander expands certain expressions.
            </summary>
            <typeparam name="S">The type of items this factory can clone from.</typeparam>
            <typeparam name="T">The type of items this factory will create.</typeparam>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IItemFactory`2.ItemType">
            <summary>
            The item type of the items that this factory will create.
            May be null, if the items will not have an itemtype (ie., for ITaskItems)
            May not be settable (eg., for ITaskItems and for ProjectItems)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IItemFactory`2.ItemElement">
            <summary>
            Used in the evaluator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemFactory`2.CreateItem(System.String,System.String)">
            <summary>
            Creates an item with the specified evaluated include and defining project.
            Include must not be zero length.
            </summary>
            <param name="include">The include</param>
            <param name="definingProject">The project from which this item was created</param>
            <returns>A new item instance</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemFactory`2.CreateItem(`0,System.String)">
            <summary>
            Creates an item based off the provided item, with cloning semantics.
            New item is associated with the passed in defining project, not that of the original item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemFactory`2.CreateItem(System.String,`0,System.String)">
            <summary>
            Creates an item with the specified include and the metadata from the specified base item
            New item is associated with the passed in defining project, not that of the original item. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemFactory`2.CreateItem(System.String,System.String,System.String)">
            <summary>
            Creates an item using the specified evaluated include, include before wildcard expansion, 
            and defining project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemFactory`2.SetMetadata(System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{Microsoft.Build.Construction.ProjectMetadataElement,System.String}},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Applies the supplied metadata to the destination items.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IItem`1">
            <summary>
            This interface represents an item without exposing its type.
            It's convenient to not genericise the base interface, to make it easier to use
            for the majority of code that doesn't call these methods.
            </summary>
            <typeparam name="M">Type of metadata object.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItem`1.GetMetadata(System.String)">
            <summary>
            Gets any existing metadatum on the item, or
            else any on an applicable item definition.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItem`1.SetMetadata(Microsoft.Build.Construction.ProjectMetadataElement,System.String)">
            <summary>
            Sets the specified metadata.
            Predecessor is any preceding overridden metadata
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IItemProvider`1">
            <summary>
            This interface represents an object which can act as a source of items for the Expander.
            </summary>
            <typeparam name="T">The type of items provided by the implementation.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IItemProvider`1.GetItems(System.String)">
            <summary>
            Returns a list of items with the specified item type.
            
            If there are no items of this type, returns an empty list.
            </summary>
            <param name="itemType">The item type of items to return.</param>
            <returns>A list of matching items.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IMetadataTable">
            <summary>
            Table of metadata useable to expand expressions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name specified.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If item type is null, it is ignored.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Returns the value if it exists, null otherwise.
            If item type is null, it is ignored.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IntrinsicFunctions">
            <summary>
            The Intrinsic class provides static methods that can be accessed from MSBuild's
            property functions using $([MSBuild]::Function(x,y))
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Add(System.Double,System.Double)">
            <summary>
            Add two doubles
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Add(System.Int64,System.Int64)">
            <summary>
            Add two longs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Subtract(System.Double,System.Double)">
            <summary>
            Subtract two doubles
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Subtract(System.Int64,System.Int64)">
            <summary>
            Subtract two longs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Multiply(System.Double,System.Double)">
            <summary>
            Multiply two doubles
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Multiply(System.Int64,System.Int64)">
            <summary>
            Multiply two longs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Divide(System.Double,System.Double)">
            <summary>
            Divide two doubles
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Divide(System.Int64,System.Int64)">
            <summary>
            Divide two longs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Modulo(System.Double,System.Double)">
            <summary>
            Modulo two doubles
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Modulo(System.Int64,System.Int64)">
            <summary>
            Modulo two longs
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Escape(System.String)">
            <summary>
            Escape the string according to MSBuild's escaping rules
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.Unescape(System.String)">
            <summary>
            Unescape the string according to MSBuild's escaping rules
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.BitwiseOr(System.Int32,System.Int32)">
            <summary>
            Perform a bitwise OR on the first and second (first | second)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.BitwiseAnd(System.Int32,System.Int32)">
            <summary>
            Perform a bitwise AND on the first and second (first &amp; second)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.BitwiseXor(System.Int32,System.Int32)">
            <summary>
            Perform a bitwise XOR on the first and second (first ^ second)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.BitwiseNot(System.Int32)">
            <summary>
            Perform a bitwise NOT on the first and second (~first)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.GetRegistryValue(System.String,System.String)">
            <summary>
            Get the value of the registry key and value, default value is null
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.GetRegistryValue(System.String,System.String,System.Object)">
            <summary>
            Get the value of the registry key and value
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.GetRegistryValueFromView(System.String,System.String,System.Object,System.ArraySegment{System.Object})">
            <summary>
            Get the value of the registry key from one of the RegistryView's specified
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.MakeRelative(System.String,System.String)">
            <summary>
            Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
            Throws UriFormatException.
            </summary>
            <param name="basePath">
            The base path we want to relativize to. Must be absolute.
            Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
            </param>
            <param name="path">
            The path we need to make relative to basePath.  The path can be either absolute path or a relative path in which case it is relative to the base path.
            If the path cannot be made relative to the base path (for example, it is on another drive), it is returned verbatim.
            </param>
            <returns>relative path (can be the full path)</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.GetDirectoryNameOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Searches upward for a directory containing the specified file, beginning in the specified directory.
            </summary>
            <param name="startingDirectory">The directory to start the search in.</param>
            <param name="fileName">The name of the file to search for.</param>
            <returns>The full path of the directory containing the file if it is found, otherwise an empty string. </returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.GetPathOfFileAbove(System.String,System.String,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Searches upward for the specified file, beginning in the specified <see cref="T:Microsoft.Build.Shared.IElementLocation"/>.
            </summary>
            <param name="file">The name of the file to search for.</param>
            <param name="startingDirectory">An optional directory to start the search in.  The default location is the directory
            of the file containing the property function.</param>
            <returns>The full path of the file if it is found, otherwise an empty string.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.ValueOrDefault(System.String,System.String)">
            <summary>
            Return the string in parameter 'defaultValue' only if parameter 'conditionValue' is empty
            else, return the value conditionValue
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.DoesTaskHostExist(System.String,System.String)">
            <summary>
            Returns true if a task host exists that can service the requested runtime and architecture
            values, and false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.EnsureTrailingSlash(System.String)">
            <summary>
            If the given path doesn't have a trailing slash then add one.
            If the path is an empty string, does not modify it.
            </summary>
            <param name="path">The path to check.</param>
            <returns>The specified path with a trailing slash.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.NormalizeDirectory(System.String[])">
            <summary>
            Gets the canonicalized full path of the provided directory and ensures it contains the correct directory separator characters for the current operating system
            while ensuring it has a trailing slash.
            </summary>
            <param name="path">One or more directory paths to combine and normalize.</param>
            <returns>A canonicalized full directory path with the correct directory separators and a trailing slash.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.NormalizePath(System.String[])">
            <summary>
            Gets the canonicalized full path of the provided path and ensures it contains the correct directory separator characters for the current operating system.
            </summary>
            <param name="path">One or more paths to combine and normalize.</param>
            <returns>A canonicalized full path with the correct directory separators.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.IsOSPlatform(System.String)">
            <summary>
            Specify whether the current OS platform is <paramref name="platformString"/>
            </summary>
            <param name="platformString">The platform string. Must be a member of <see cref="T:System.Runtime.InteropServices.OSPlatform"/>. Case Insensitive</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.IsOsUnixLike">
            <summary>
            True if current OS is a Unix system.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.IsOsBsdLike">
            <summary>
            True if current OS is a BSD system.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.__GetListTest">
            <summary>
            returns if the string contains escaped wildcards
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IntrinsicFunctions.GetBaseKeyFromKeyName(System.String,Microsoft.Win32.RegistryView,System.String@)">
            <summary>
            Following function will parse a keyName and returns the basekey for it.
            It will also store the subkey name in the out parameter.
            If the keyName is not valid, we will throw ArgumentException.
            The return value shouldn't be null.
            Taken from: \ndp\clr\src\BCL\Microsoft\Win32\Registry.cs
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IMetadatum">
            <summary>
            This interface represents a metadata object.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IProjectMetadataParent">
            <summary>
            Represents the parent of a ProjectMetadata object -
            either a ProjectItem or a ProjectItemDefinition.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IProjectMetadataParent.Project">
            <summary>
            The owning project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IProjectMetadataParent.ItemType">
            <summary>
            The item type of the parent item definition or item.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IProperty">
            <summary>
            An interface representing an object which can act as a property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IProperty.Name">
            <summary>
            Name of the property
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IProperty.EvaluatedValue">
            <summary>
            Returns the evaluated, unescaped value for the property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.IProperty.EvaluatedValueEscaped">
            <summary>
            Returns the evaluated, escaped value for the property
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.IPropertyProvider`1">
            <summary>
            An interface representing an object which can provide properties to the Expander.
            </summary>
            <typeparam name="T">The type of properties provided.</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IPropertyProvider`1.GetProperty(System.String)">
            <summary>
            Returns a property with the specified name, or null if it was not found.
            </summary>
            <param name="name">The property name.</param>
            <returns>The property.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.IPropertyProvider`1.GetProperty(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a property with the specified name, or null if it was not found.
            Name is the segment of the provided string with the provided start and end indexes.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Preprocessor">
            <summary>
            Creates a view of an evaluated project's XML as if it had all been loaded from 
            a single file, instead of being assembled by pulling in imported files as it actually was.
            </summary>
            <remarks>
            Ideally the result would be buildable on its own, and *usually* this should be the case.
            Known cases where it wouldn't be buildable:
            -- $(MSBuildThisFile) and similar properties aren't corrected
            -- relative path in exists(..) conditions is relative to the imported file
            -- same for AssemblyFile on UsingTask
            Paths in item includes are relative to the importing project, though.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Preprocessor._project">
            <summary>
            Project to preprocess
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Preprocessor._importTable">
            <summary>
            Table to resolve import tags
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Preprocessor._filePaths">
            <summary>
            Stack of file paths pushed as we follow imports
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Preprocessor._addedNodes">
            <summary>
            Used to keep track of nodes that were added to the document from implicit imports which will be removed later.
            At the time of adding this feature, cloning is buggy so it is easier to just edit the DOM in memory.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Preprocessor._implicitImportsByProject">
            <summary>
            Table of implicit imports by document.  The list per document contains both top and bottom imports.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Preprocessor.#ctor(Microsoft.Build.Evaluation.Project)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Preprocessor.GetPreprocessedDocument(Microsoft.Build.Evaluation.Project)">
            <summary>
            Returns an XmlDocument representing the evaluated project's XML as if it all had 
            been loaded from a single file, instead of being assembled by pulling in imported files.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Preprocessor.Preprocess">
            <summary>
            Root of the preprocessing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Preprocessor.CreateImplicitImportTable">
            <summary>
            Creates a table containing implicit imports by project document.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Preprocessor.AddImplicitImportNodes(System.Xml.XmlElement)">
            <summary>
            Adds all implicit import nodes to the specified document.
            </summary>
            <param name="documentElement">The document element to add nodes to.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Preprocessor.CloneChildrenResolvingImports(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            Recursively called method that clones source nodes into nodes in the destination
            document.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.ProjectRootElementCacheAddEntryHandler">
            <summary>
            Handler for which project root element just got added to the cache
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.StrongCacheEntryRemovedDelegate">
            <summary>
            Delegate for StrongCacheEntryRemoved event
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.OpenProjectRootElement">
            <summary>
            Callback to create a ProjectRootElement if need be
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.StrongCacheEntryRemoved">
            <summary>
            Event that is fired when an entry in the Strong Cache is removed.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.ProjectRootElementAddedHandler">
            <summary>
            Event which is fired when a project root element is added to this cache.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.ProjectRootElementDirtied">
            <summary>
            Event which is fired when a project root element in this cache is dirtied.
            </summary>
        </member>
        <member name="E:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.ProjectDirtied">
            <summary>
            Event which is fired when a project is marked dirty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.OnProjectRootElementDirtied(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs)">
            <summary>
            Raises the <see cref="E:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.ProjectRootElementDirtied"/> event.
            </summary>
            <param name="sender">The dirtied project root element.</param>
            <param name="e">Details on the PRE and the nature of the change.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.OnProjectDirtied(Microsoft.Build.Evaluation.Project,Microsoft.Build.Evaluation.ProjectChangedEventArgs)">
            <summary>
            Raises the <see cref="E:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.ProjectDirtied"/> event.
            </summary>
            <param name="sender">The dirtied project.</param>
            <param name="e">Details on the Project and the change.</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.RaiseProjectRootElementAddedToCacheEvent(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Raises an event which is raised when a project root element is added to the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCacheBase.RaiseProjectRootElementRemovedFromStrongCache(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Raises an event which is raised when a project root element is removed from the strong cache.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectRootElementCacheAddEntryEventArgs">
            <summary>
            This class is an event that holds which ProjectRootElement was added to the root element cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCacheAddEntryEventArgs.#ctor(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Takes the root element which was added to the results cache.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectRootElementCacheAddEntryEventArgs.RootElement">
            <summary>
            Root element which was just added to the cache.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ProjectRootElementCache">
            <summary>
            Maintains a cache of all loaded ProjectRootElement's for design time purposes.
            Weak references are held to add added ProjectRootElement's.
            Strong references are held to a limited number of added ProjectRootElement's.
            
            1. Loads of a ProjectRootElement will share any existing loaded ProjectRootElement, rather
            than loading and parsing a new one. This is the case whether the ProjectRootElement
            is loaded directly or imported.
            
            2. For design time, only a weak reference needs to be held, because all users have a strong reference.
            
            3. Because all loads of a ProjectRootElement consult this cache, they can be assured that any
            entries in this cache are up to date. For example, if a ProjectRootElement is modified and saved,
            the cached ProjectRootElement will be the loaded one that was saved, so it will be up to date.
            
            4. If, after a project has been loaded, an external app changes the project file content on disk, it is
            important that a subsequent load of that project does not return stale ProjectRootElement. To avoid this, the
            timestamp of the file on disk is compared to the timestamp of the file at the time that the ProjectRootElement loaded it.
            
            5. For build time, some strong references need to be held, as otherwise the ProjectRootElement's for reuseable
            imports will be collected, and time will be wasted reparsing them. However we do not want to hold strong references
            to all ProjectRootElement's, consuming memory without end. So a simple priority queue is used. All Adds and Gets boost their
            entry to the top. As the queue gets too big, low priority entries are dropped.
            
            No guesses are made at which files are more interesting to cache, beyond the most-recently-used list. For example, ".targets" files
            or imported files are not treated specially, as this is a potentially unreliable heuristic. Besides, caching a project file itself could
            be useful, if for example you want to build it twice with different sets of properties.
            
            Because of the strongly typed list, some ProjectRootElement's will be held onto indefinitely. This is an acceptable price to pay for
            being able to provide a commonly used ProjectRootElement immediately it's needed. It is mitigated by the list being finite and small, and
            because we allow ProjectCollection.UnloadAllProjects to hint to us to clear the list.
            
            Implicit references are those which were loaded as a result of a build, and not explicitly loaded through, for instance, the project
            collection.
            
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectRootElementCache.s_maximumStrongCacheSize">
            <summary>
            The maximum number of entries to keep strong references to.
            This has to be strong enough to make sure that key .targets files aren't pushed
            off by transient loads of non-reusable files like .user files.
            
            Made this as large as 50 because VC has a large number of
            regularly used property sheets and other imports.
            If you change this, update the unit tests.
            </summary>
            <remarks>
            If this number is increased much higher, the datastructure may
            need to be changed from a linked list, since it's currently O(n).
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectRootElementCache.s_debugLogCacheActivity">
            <summary>
            Whether the cache should log activity to the Debug.Out stream
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectRootElementCache._weakCache">
            <summary>
            The map of weakly-held ProjectRootElement's
            </summary>
            <remarks>
            Be sure that the string keys are strongly held, or unpredictable bad
            behavior will ensue.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectRootElementCache._strongCache">
            <summary>
            The list of strongly-held ProjectRootElement's
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectRootElementCache._autoReloadFromDisk">
            <summary>
            Whether the cache should check the timestamp of the file on disk
            whenever it is requested, and update with the latest content of that
            file if it has changed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ProjectRootElementCache._locker">
            <summary>
            Locking object for this shared cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.#cctor">
            <summary>
            Static constructor to choose cache size.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Creates an empty cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.Get(System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase.OpenProjectRootElement,System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Returns an existing ProjectRootElement for the specified file path, if any.
            If none exists, calls the provided delegate to load one, and adds that to the cache.
            The reason that it calls back to do this is so that the cache is locked between determining
            that the entry does not exist and adding the entry.
            
            If <see cref="F:Microsoft.Build.Evaluation.ProjectRootElementCache._autoReloadFromDisk"/> was set to true, and the file on disk has changed since it was cached,
            it will be reloaded before being returned.
            
            Thread safe.
            </summary>
            <remarks>
            Never needs to consult the strong cache as well, since if the item is in there, it will
            not have left the weak cache.
            If item is found, boosts it to the top of the strong cache.
            </remarks>
            <param name="projectFile">The project file which contains the ProjectRootElement.  Must be a full path.</param>
            <param name="openProjectRootElement">The delegate to use to load if necessary. May be null.</param>
            <param name="isExplicitlyLoaded"><code>true</code> if the project is explicitly loaded, otherwise <code>false</code>.</param>
            <param name="preserveFormatting"><code>true</code> to the project was loaded with the formated preserved, otherwise <code>false</code>.</param>
            <returns>The ProjectRootElement instance if one exists.  Null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.AddEntry(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Add an entry to the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.RenameEntry(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Rename an entry in the cache.
            Entry must already be in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.TryGet(System.String)">
            <summary>
            Returns any a ProjectRootElement in the cache with the provided full path,
            otherwise null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.TryGet(System.String,System.Nullable{System.Boolean})">
            <summary>
            Returns any a ProjectRootElement in the cache with the provided full path,
            otherwise null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.DiscardStrongReferences">
            <summary>
            Discards strong references held by the cache.
            </summary>
            <remarks>
            The weak cache is never cleared, as we need it to guarantee that the appdomain never
            has two ProjectRootElement's for a particular file. Attempts to clear out the weak cache
            resulted in this guarantee being broken and subtle bugs popping up everywhere.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.Clear">
            <summary>
            Clears out the cache.
            Called when all projects are unloaded and possibly when a build is done.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.DiscardImplicitReferences">
            <summary>
            Discard any entries (weak and strong) which do not have the explicitlyLoaded flag set.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.DiscardAnyWeakReference(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Forces a removal of a project root element from the weak cache if it is present.
            </summary>
            <param name="projectRootElement">The project root element to remove.</param>
            <remarks>
            No exception is thrown if this project root element is in use by currently loaded projects
            by this method.  The calling method must know that this is a safe operation.
            There may of course be strong references to the project root element from customer code.
            The assumption is that when they instruct the project collection to unload it, which
            leads to this being called, they are releasing their strong references too (or it doesn't matter)
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.RenameEntryInternal(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Add or rename an entry in the cache.
            Old full path may be null iff it was not already in the cache.
            </summary>
            <remarks>
            Must be called within the cache lock.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.BoostEntryInStrongCache(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Update the strong cache.
            If the item is already a member of the list, move it to the top.
            Otherwise, just add it to the top.
            If the list is too large, remove an entry from the bottom.
            </summary>
            <remarks>
            Must be called within the cache lock.
            If the size of strong cache gets large, this needs a faster data structure
            than a linked list. It's currently O(n).
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.ForgetEntry(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Completely remove an entry from this cache
            </summary>
            <remarks>
            Must be called within the cache lock.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.DebugTraceCache(System.String,System.Boolean)">
            <summary>
            Write debugging messages to the Debug.Out stream.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.DebugTraceCache(System.String,System.Int32)">
            <summary>
            Write debugging messages to the Debug.Out stream.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ProjectRootElementCache.DebugTraceCache(System.String,System.String)">
            <summary>
            Write debugging messages to the Debug.Out stream.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.SimpleProjectRootElementCache">
             <summary>
             Maintains a cache of all loaded ProjectRootElement instances for design time purposes.
            
             This avoids the LRU cache and class-wide lock used within ProjectRootElementCache and replaces these mechanisms
             with a single ConcurrentDictionary as a tradeoff for increased performance when evaluating projects in parallel.
             As a tradeoff, this implementation uses more memory, and is not intended for use when the cache needs to be
             long-lived e.g. within Visual Studio.
            
             SimpleProjectRootElementCache is not currently intended for use outside of evaluation. Several code paths
             executed within a full build take a hard dependency on the strong/weak reference behavior used within
             ProjectRootElementCache, and further investigation is required to determine the best way to hide these behind
             an abstraction. As such, any method unused by evaluation will throw NotImplementedException.
             </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.SemiColonTokenizer">
            <summary>
            Splits an expression into fragments at semicolons, except where the
            semicolons are in a macro or separator expression.
            Fragments are trimmed and empty fragments discarded.
            </summary>
            <remarks>
            These complex cases prevent us from doing a simple split on ';':
             (1) Macro expression: @(foo->'xxx;xxx')
             (2) Separator expression: @(foo, 'xxx;xxx')
             (3) Combination: @(foo->'xxx;xxx', 'xxx;xxx')
             We must not split on semicolons in macro or separator expressions like these.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Evaluation.StringMetadataTable">
            <summary>
            Wraps a table of metadata values in which keys
            may be qualified ("itemtype.name") or unqualified ("name").
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.StringMetadataTable._metadata">
            <summary>
            Table of metadata values. 
            Each key may be qualified ("itemtype.name") or unqualified ("name").
            Unqualified are considered to apply to all item types.
            May be null, if empty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringMetadataTable.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructor taking a table of metadata in which keys
            may be a mixture of qualified ("itemtype.name") and unqualified ("name").
            Unqualified keys are considered to apply to all item types.
            Metadata may be null, indicating it is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringMetadataTable.GetEscapedValue(System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name specified.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringMetadataTable.GetEscapedValue(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If no value is available, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.StringMetadataTable.GetEscapedValueIfPresent(System.String,System.String)">
            <summary>
            Retrieves any value we have in our metadata table for the metadata name and item type specified.
            If no value is available, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ShredderOptions">
            <summary>
            What the shredder should be looking for.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ShredderOptions.Invalid">
            <summary>
            Don't use
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ShredderOptions.ItemTypes">
            <summary>
            Shred item types
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ShredderOptions.MetadataOutsideTransforms">
            <summary>
            Shred metadata not contained inside of a transform.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ShredderOptions.All">
            <summary>
            Shred both items and metadata not contained in a transform.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ExpressionShredder">
            <summary>
            A class which interprets and splits MSBuild expressions
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.SplitSemiColonSeparatedList(System.String)">
            <summary>
            Splits an expression into fragments at semi-colons, except where the
            semi-colons are in a macro or separator expression.
            Fragments are trimmed and empty fragments discarded.
            </summary>
            <remarks>
            See <see cref="T:Microsoft.Build.Evaluation.SemiColonTokenizer"/> for rules.
            </remarks>
            <param name="expression">List expression to split</param>
            <returns>Array of non-empty strings from split list.</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.GetReferencedItemNamesAndMetadata(System.Collections.Generic.List{System.String})">
            <summary>
            Given a list of expressions that may contain item list expressions,
            returns a pair of tables of all item names found, as K=Name, V=String.Empty;
            and all metadata not in transforms, as K=Metadata key, V=MetadataReference,
            where metadata key is like "itemname.metadataname" or "metadataname".
            PERF: Tables are null if there are no entries, because this is quite a common case.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.ContainsMetadataExpressionOutsideTransform(System.String)">
            <summary>
            Returns true if there is a metadata expression (outside of a transform) in the expression.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.GetReferencedItemExpressions(System.String)">
            <summary>
            Given a subexpression, finds referenced sub transform expressions
            itemName and separator will be null if they are not found
            return value will be null if no transform expressions are found
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.GetReferencedItemExpressions(System.String,System.Int32,System.Int32)">
            <summary>
            Given a subexpression, finds referenced sub transform expressions
            itemName and separator will be null if they are not found
            return value will be null if no transform expressions are found
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.GetReferencedItemNamesAndMetadata(System.String,System.Int32,System.Int32,Microsoft.Build.Evaluation.ItemsAndMetadataPair@,Microsoft.Build.Evaluation.ShredderOptions)">
            <summary>
            Given a subexpression, finds referenced item names and inserts them into the table
            as K=Name, V=String.Empty.
            </summary>
            <remarks>
            We can ignore any semicolons in the expression, since we're not itemizing it.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.SinkSingleQuotedExpression(System.String,System.Int32@,System.Int32)">
            <summary>
            Returns true if a single quoted subexpression begins at the specified index
            and ends before the specified end index.
            Leaves index one past the end of the second quote.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.SinkArgumentsInParentheses(System.String,System.Int32@,System.Int32)">
            <summary>
            Scan for the closing bracket that matches the one we've already skipped;
            essentially, pushes and pops on a stack of parentheses to do this.
            Takes the expression and the index to start at.
            Returns the index of the matching parenthesis, or -1 if it was not found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.SinkUntilClosingQuote(System.Char,System.String,System.Int32@,System.Int32)">
            <summary>
            Skip all characters until we find the matching quote character
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.SinkItemFunctionExpression(System.String,System.Int32,System.Int32@,System.Int32)">
            <summary>
            Returns true if a item function subexpression begins at the specified index
            and ends before the specified end index.
            Leaves index one past the end of the closing paren.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.SinkValidName(System.String,System.Int32@,System.Int32)">
            <summary>
            Returns true if a valid name begins at the specified index.
            Leaves index one past the end of the name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.Sink(System.String,System.Int32@,System.Char)">
            <summary>
            Returns true if the character at the specified index 
            is the specified char. 
            Leaves index one past the character.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.Sink(System.String,System.Int32@,System.Int32,System.Char,System.Char)">
            <summary>
            Returns true if the next two characters at the specified index
            are the specified sequence.
            Leaves index one past the second character.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.SinkWhitespace(System.String,System.Int32@)">
            <summary>
            Moves past all whitespace starting at the specified index.
            Returns the next index, possibly the string length.
            </summary>
            <remarks>
            Char.IsWhitespace() is not identical in behavior to regex's \s character class,
            but it's extremely close, and it's what we use in conditional expressions.
            </remarks>
            <param name="expression">The expression to process.</param>
            <param name="i">The start location for skipping whitespace, contains the next non-whitespace character on exit.</param>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture">
            <summary>
            Represents one substring for a single successful capture.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._captures">
            <summary>
            Captures within this capture
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._index">
            <summary>
            The position in the original string where the first character of the captured
            substring was found.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._length">
            <summary>
            The length of the captured substring.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._value">
            <summary>
            The captured substring from the input string.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._itemType">
            <summary>
            The type of the item within this expression
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._separator">
            <summary>
            The separator, if any, within this expression
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._separatorStart">
            <summary>
            The starting character of the separator within the expression
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._functionName">
            <summary>
            The function name, if any, within this expression
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture._functionArguments">
            <summary>
            The function arguments, if any, within this expression
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Create an Expression Capture instance
            Represents a sub expression, shredded from a larger expression
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.Int32,System.Collections.Generic.List{Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture})">
            <summary>
            Create an Expression Capture instance
            Represents a sub expression, shredded from a larger expression
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.Captures">
            <summary>
            Captures within this capture
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.Index">
            <summary>
            The position in the original string where the first character of the captured
            substring was found.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.Length">
            <summary>
            The length of the captured substring.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.Value">
            <summary>
            Gets the captured substring from the input string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.ItemType">
            <summary>
            Gets the captured itemtype.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.Separator">
            <summary>
            Gets the captured itemtype.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.SeparatorStart">
            <summary>
            The starting character of the separator.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.FunctionName">
            <summary>
            The function name, if any, within this expression
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.FunctionArguments">
            <summary>
            The function arguments, if any, within this expression
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture.ToString">
            <summary>
            Gets the captured substring from the input string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Evaluator`4">
            <summary>
            Evaluates a ProjectRootElement, updating the fresh Project.Data passed in.
            Handles evaluating conditions, expanding expressions, and building up the 
            lists of applicable properties, items, and itemdefinitions, as well as gathering targets and tasks
            and creating a TaskRegistry from the using tasks.
            </summary>
            <typeparam name="P">The type of properties to produce.</typeparam>
            <typeparam name="I">The type of items to produce.</typeparam>
            <typeparam name="M">The type of metadata on those items.</typeparam>
            <typeparam name="D">The type of item definitions to be produced.</typeparam>
            <remarks>
            This class could be improved to do partial (minimal) reevaluation: at present we wipe all state and start over.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4.s_splitter">
            <summary>
            Character used to split InitialTargets and DefaultTargets lists
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._expander">
            <summary>
            Expander for evaluating conditions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._data">
            <summary>
            Data containing the ProjectRootElement to evaluate and the slots for
            items, properties, etc originating from the evaluation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._itemGroupElements">
            <summary>
            List of ProjectItemElement's traversing into imports.
            Gathered during the first pass to avoid traversing again.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._itemDefinitionGroupElements">
            <summary>
            List of ProjectItemDefinitionElement's traversing into imports.
            Gathered during the first pass to avoid traversing again.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._usingTaskElements">
            <summary>
            List of ProjectUsingTaskElement's traversing into imports.
            Gathered during the first pass to avoid traversing again.
            Key is the directory of the file importing the usingTask, which is needed
            to handle any relative paths in the usingTask.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._targetElements">
            <summary>
            List of ProjectTargetElement's traversing into imports. 
            Gathered during the first pass to avoid traversing again.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._importsSeen">
            <summary>
            Paths to imports already seen and where they were imported from; used to flag duplicate imports
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._initialTargetsList">
            <summary>
            Depth first collection of InitialTargets strings declared in the main 
            Project and all its imported files, split on semicolons.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._projectSupportsReturnsAttribute">
            <summary>
            Dictionary of project full paths and a boolean that indicates whether at least one 
            of their targets has the "Returns" attribute set.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._projectRootElement">
            <summary>
            The Project Xml to be evaluated.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._itemFactory">
            <summary>
            The item factory used to create items from Xml.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._loadSettings">
            <summary>
            Load settings, such as whether to ignore missing imports.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._maxNodeCount">
            <summary>
            The maximum number of nodes to report for evaluation.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._sdkResolverService">
            <summary>
            The <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> to use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._submissionId">
            <summary>
            The current build submission ID.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._environmentProperties">
            <summary>
            The environment properties with which evaluation should take place.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._projectRootElementCache">
            <summary>
            The cache to consult for any imports that need loading.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._evaluationLoggingContext">
            <summary>
            The logging context to be used and piped down throughout evaluation
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._fallbackSearchPathsCache">
            <summary>
            The search paths are machine specific and should not change during builds
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._lastModifiedProject">
            <summary>
            Keeps track of the project that is last modified of the project and all imports.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Evaluator`4._streamImports">
            <summary>
            Keeps track of the FullPaths of ProjectRootElements that may have been modified as a stream.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.#ctor(Microsoft.Build.Evaluation.IEvaluatorData{`0,`1,`2,`3},Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Evaluation.ProjectLoadSettings,System.Int32,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Evaluation.IItemFactory{`1,`1},Microsoft.Build.Evaluation.IToolsetProvider,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32,Microsoft.Build.Evaluation.Context.EvaluationContext,System.Boolean,System.Boolean,Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Framework.BuildEventContext)">
            <summary>
            Private constructor called by the static Evaluate method.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Evaluator`4.ExpandExpression">
            <summary>
            Delegate passed to methods to provide basic expression evaluation
            ability, without having a language service.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Evaluator`4.EvaluateConditionalExpression">
            <summary>
            Delegate passed to methods to provide basic expression evaluation
            ability, without having a language service.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.Evaluate(Microsoft.Build.Evaluation.IEvaluatorData{`0,`1,`2,`3},Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Evaluation.ProjectLoadSettings,System.Int32,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.BackEnd.Logging.ILoggingService,Microsoft.Build.Evaluation.IItemFactory{`1,`1},Microsoft.Build.Evaluation.IToolsetProvider,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32,Microsoft.Build.Evaluation.Context.EvaluationContext,System.Boolean)">
            <summary>
            Evaluates the project data passed in.
            </summary>
            <remarks>
            This is the only non-private member of this class.
            This is a helper static method so that the caller can just do "Evaluator.Evaluate(..)" without
            newing one up, yet the whole class need not be static.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.CreateItemsFromInclude(System.String,Microsoft.Build.Construction.ProjectItemElement,Microsoft.Build.Evaluation.IItemFactory{`1,`1},System.String,Microsoft.Build.Evaluation.Expander{`0,`1})">
            <summary>
            Helper that creates a list of ProjectItem's given an unevaluated Include and a ProjectRootElement.
            Used by both Evaluator.EvaluateItemElement and by Project.AddItem.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ReadTaskElement(Microsoft.Build.Construction.ProjectTaskElement)">
            <summary>
            Read the task into an instance.
            Do not evaluate anything: this occurs during build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ReadPropertyGroupUnderTargetElement(Microsoft.Build.Construction.ProjectPropertyGroupElement)">
            <summary>
            Read the property-group-under-target into an instance.
            Do not evaluate anything: this occurs during build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ReadOnErrorElement(Microsoft.Build.Construction.ProjectOnErrorElement)">
            <summary>
            Read an onError tag.
            Do not evaluate anything: this occurs during build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ReadItemGroupUnderTargetElement(Microsoft.Build.Construction.ProjectItemGroupElement)">
            <summary>
            Read the item-group-under-target into an instance.
            Do not evaluate anything: this occurs during build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ReadNewTargetElement(Microsoft.Build.Construction.ProjectTargetElement,System.Boolean,Microsoft.Build.Evaluation.EvaluationProfiler)">
            <summary>
            Read the provided target into a target instance.
            Do not evaluate anything: this occurs during build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.Evaluate">
            <summary>
            Do the evaluation.
            Called by the static helper method.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.PerformDepthFirstPass(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Evaluate the properties in the passed in XML, into the project.
            Does a depth first traversal into Imports.
            In the process, populates the item, itemdefinition, target, and usingtask lists as well.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.UpdateDefaultTargets(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Update the default targets value.
            We only take the first DefaultTargets value we encounter in a project or import.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluatePropertyGroupElement(Microsoft.Build.Construction.ProjectPropertyGroupElement)">
            <summary>
            Evaluate the properties in the propertygroup and set the applicable ones on the data passed in
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateItemDefinitionGroupElement(Microsoft.Build.Construction.ProjectItemDefinitionGroupElement)">
            <summary>
            Evaluate the itemdefinitiongroup and update the definitions library
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateItemGroupElement(Microsoft.Build.Construction.ProjectItemGroupElement,Microsoft.Build.Evaluation.LazyItemEvaluator{`0,`1,`2,`3})">
            <summary>
            Evaluate the items in the itemgroup and add the applicable ones to the data passed in
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateUsingTaskElement(System.String,Microsoft.Build.Construction.ProjectUsingTaskElement)">
            <summary>
            Evaluate the usingtask and add the result into the data passed in
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ReadTargetElement(Microsoft.Build.Construction.ProjectTargetElement,System.Collections.Generic.LinkedList{Microsoft.Build.Construction.ProjectTargetElement},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.LinkedListNode{Microsoft.Build.Construction.ProjectTargetElement}})">
            <summary>
            Retrieve the matching ProjectTargetInstance from the cache and add it to the provided collection.
            If it is not cached already, read it and cache it.
            Do not evaluate anything: this occurs during build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.AddBeforeAndAfterTargetMappings(Microsoft.Build.Construction.ProjectTargetElement,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.LinkedListNode{Microsoft.Build.Construction.ProjectTargetElement}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.Build.BackEnd.TargetSpecification}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.Build.BackEnd.TargetSpecification}})">
            <summary>
            Updates the evaluation maps for BeforeTargets and AfterTargets
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.AddBuiltInProperties">
            <summary>
            Set the built-in properties, most of which are read-only 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.AddEnvironmentProperties">
            <summary>
            Pull in all the environment into our property bag
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.AddToolsetProperties">
            <summary>
            Put all the toolset's properties into our property bag
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.AddGlobalProperties">
            <summary>
            Put all the global properties into our property bag
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.SetBuiltInProperty(System.String,System.String)">
            <summary>
            Set a built-in property in the supplied bag.
            NOT to be used for properties originating in XML.
            NOT to be used for global properties.
            NOT to be used for environment properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluatePropertyElement(Microsoft.Build.Construction.ProjectPropertyElement)">
            <summary>
            Evaluate a single ProjectPropertyElement and update the data as appropriate
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateItemDefinitionElement(Microsoft.Build.Construction.ProjectItemDefinitionElement)">
            <summary>
            Evaluates an itemdefinition element, updating the definitions library.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateImportElement(System.String,Microsoft.Build.Construction.ProjectImportElement)">
            <summary>
            Evaluates an import element.
            If the condition is true, loads the import and continues the pass.
            </summary>
            <remarks>
            UNDONE: Protect against overflowing the stack by having too many nested imports.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateImportGroupElement(System.String,Microsoft.Build.Construction.ProjectImportGroupElement)">
            <summary>
            Evaluates an ImportGroup element.
            If the condition is true, evaluates the contained imports and continues the pass.
            </summary>
            <remarks>
            UNDONE: Protect against overflowing the stack by having too many nested imports.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateChooseElement(Microsoft.Build.Construction.ProjectChooseElement)">
            <summary>
            Choose does not accept a condition.
            </summary>
            <remarks>
            We enter here in both the property and item passes, since Chooses can contain both.
            However, we only evaluate the When conditions on the first pass, so we only pulse 
            those states on that pass. On the other pass, it's as if they're not there.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateWhenOrOtherwiseChildren(System.Collections.Generic.IEnumerable{Microsoft.Build.Construction.ProjectElement})">
            <summary>
            Evaluates the children of a When or Choose.
            Returns true if the condition was true, so subsequent
            WhenElements and Otherwise can be skipped.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImports(System.String,Microsoft.Build.Construction.ProjectImportElement,Microsoft.Build.BackEnd.SdkResolution.SdkResult@)">
            <summary>
            Expands and loads project imports.
            <remarks>
            Imports may contain references to "projectImportSearchPaths" defined in the app.config 
            toolset section. If this is the case, this method will search for the imported project
            in those additional paths if the default fails.
            </remarks>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(System.String,Microsoft.Build.Construction.ProjectImportElement,System.Collections.Generic.List{Microsoft.Build.Construction.ProjectRootElement}@,Microsoft.Build.BackEnd.SdkResolution.SdkResult@,System.Boolean)">
            <summary>
            Load and parse the specified project import, which may have wildcards,
            into one or more ProjectRootElements, if it's Condition evaluates to true
            Caches the parsed import into the provided collection, so future
            requests can be satisfied without re-parsing it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImportsFromUnescapedImportExpression(System.String,Microsoft.Build.Construction.ProjectImportElement,System.String,System.Boolean,System.Collections.Generic.List{Microsoft.Build.Construction.ProjectRootElement}@)">
            <summary>
            Load and parse the specified project import, which may have wildcards,
            into one or more ProjectRootElements.
            Caches the parsed import into the provided collection, so future 
            requests can be satisfied without re-parsing it.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.IntroducesCircularity(System.String,Microsoft.Build.Construction.ProjectImportElement)">
            <summary>
            Checks if an import matches with another import in its ancestor line of imports.
            </summary>
            <param name="importFileUnescaped"> The import that is being added. </param>
            <param name="importElement"> The importing element for this import. </param>
            <returns> True, if and only if this import introduces a circularity. </returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateCondition(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Evaluation.ParserOptions)">
            <summary>
            Evaluate a given condition
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.EvaluateConditionCollectingConditionedProperties(Microsoft.Build.Construction.ProjectElement,System.String,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Evaluation.ParserOptions,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Evaluate a given condition, collecting conditioned properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.GetCurrentDirectoryForConditionEvaluation(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            COMPAT: Whidbey used the "current project file/targets" directory for evaluating Import and PropertyGroup conditions
            Orcas broke this by using the current root project file for all conditions
            For Dev10+, we'll fix this, and use the current project file/targets directory for Import, ImportGroup and PropertyGroup
            but the root project file for the rest. Inside of targets will use the root project file as always.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.ThrowForImportedProjectWithSearchPathsNotFound(Microsoft.Build.Evaluation.ProjectImportPathMatch,Microsoft.Build.Construction.ProjectImportElement)">
            <summary>
            Throws InvalidProjectException because we failed to import a project which contained a ProjectImportSearchPath fall-back.
            <param name="searchPathMatch">MSBuildExtensionsPath reference kind found in the Project attribute of the Import element</param>
            <param name="importElement">The importing element for this import</param>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Evaluator`4.StringifyList(System.Collections.Generic.IList{System.String})">
            <summary>
            Stringify a list of strings, like {"abc, "def", "foo"} to "abc, def and foo"
            or {"abc"} to "abc"
            <param name="strings">List of strings to stringify</param>
            <returns>Stringified list</returns>
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.LoadImportsResult">
            <summary>
            Represents result of attempting to load imports (ExpandAndLoadImportsFromUnescapedImportExpression*)
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ExpanderOptions">
            <summary>
            Indicates to the expander what exactly it should expand.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.Invalid">
            <summary>
            Invalid
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandCustomMetadata">
            <summary>
            Expand bare custom metadata, like %(foo), but not built-in
            metadata, such as %(filename) or %(identity)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandBuiltInMetadata">
            <summary>
            Expand bare built-in metadata, such as %(filename) or %(identity)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandMetadata">
            <summary>
            Expand all bare metadata
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandProperties">
            <summary>
            Expand only properties
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandItems">
            <summary>
            Expand only item list expressions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.BreakOnNotEmpty">
            <summary>
            If the expression is going to not be an empty string, break
            out early
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.LeavePropertiesUnexpandedOnError">
            <summary>
            When an error occurs expanding a property, just leave it unexpanded.
            </summary>
            <remarks>
            This should only be used in cases where property evaluation isn't critcal, such as when attempting to log a
            message with a best effort expansion of a string, or when discovering partial information during lazy evaluation.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandPropertiesAndItems">
            <summary>
            Expand only properties and then item lists
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandPropertiesAndMetadata">
            <summary>
            Expand only bare metadata and then properties
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandPropertiesAndCustomMetadata">
            <summary>
            Expand only bare custom metadata and then properties
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ExpanderOptions.ExpandAll">
            <summary>
            Expand bare metadata, then properties, then item expressions
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2">
            <summary>
            Expands item/property/metadata in expressions.
            Encapsulates the data necessary for expansion.
            </summary>
            <remarks>
            Requires the caller to explicitly state what they wish to expand at the point of expansion (explicitly does not have a field for ExpanderOptions). 
            Callers typically use a single expander in many locations, and this forces the caller to make explicit what they wish to expand at the point of expansion.
            
            Requires the caller to have previously provided the necessary material for the expansion requested.
            For example, if the caller requests ExpanderOptions.ExpandItems, the Expander will throw if it was not given items.
            </remarks>
            <typeparam name="P">Type of the properties used</typeparam>
            <typeparam name="I">Type of the items used.</typeparam>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.s_expandableChars">
            <summary>
            Those characters which indicate that an expression may contain expandable
            expressions
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.s_invariantCompareInfo">
            <summary>
            The CultureInfo from the invariant culture. Used to avoid allocations for
            perfoming IndexOf etc.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2._properties">
            <summary>
            Properties to draw on for expansion
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2._items">
            <summary>
            Items to draw on for expansion
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2._metadata">
            <summary>
            Metadata to draw on for expansion
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2._usedUninitializedProperties">
            <summary>
            Set of properties which are null during expansion
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.#ctor(Microsoft.Build.Evaluation.IPropertyProvider{`0},Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Creates an expander passing it some properties to use.
            Properties may be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.#ctor(Microsoft.Build.Evaluation.IPropertyProvider{`0},Microsoft.Build.Evaluation.IItemProvider{`1},Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Creates an expander passing it some properties and items to use.
            Either or both may be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.#ctor(Microsoft.Build.Evaluation.IPropertyProvider{`0},Microsoft.Build.Evaluation.IItemProvider{`1},Microsoft.Build.Evaluation.IMetadataTable,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Creates an expander passing it some properties, items, and/or metadata to use.
            Any or all may be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.WarnForUninitializedProperties">
            <summary>
            Whether to warn when we set a property for the first time, after it was previously used.
            Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.Metadata">
            <summary>
            Accessor for the metadata.
            Set temporarily during item metadata evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.UsedUninitializedProperties">
            <summary>
            If a property is expanded but evaluates to null then it is considered to be un-initialized.
            We want to keep track of these properties so that we can warn if the property gets set later on.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpressionMayContainExpandableExpressions(System.String)">
            <summary>
            Tests to see if the expression may contain expandable expressions, i.e.
            contains $, % or @
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpressionContainsItemVector(System.String)">
            <summary>
            Returns true if the expression contains an item vector pattern, else returns false.
            Used to flag use of item expressions where they are illegal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpandIntoStringAndUnescape(System.String,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options.
            This is the standard form. Before using the expanded value, it must be unescaped, and this does that for you.
            
            If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.        
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpandIntoStringLeaveEscaped(System.String,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options.
            Use this form when the result is going to be processed further, for example by matching against the file system,
            so literals must be distinguished, and you promise to unescape after that.
            
            If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpandPropertiesLeaveTypedAndEscaped(System.String,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Used only for unit tests. Expands the property expression (including any metadata expressions) and returns
            the result typed (i.e. not converted into a string if the result is a function return)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpandIntoStringListLeaveEscaped(System.String,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options,
            then splits on semi-colons into a list of strings.
            Use this form when the result is going to be processed further, for example by matching against the file system,
            so literals must be distinguished, and you promise to unescape after that.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpandIntoTaskItemsLeaveEscaped(System.String,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options
            and produces a list of TaskItems.
            If the expression is empty, returns an empty list.
            If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpandIntoItemsLeaveEscaped``1(System.String,Microsoft.Build.Evaluation.IItemFactory{`1,``0},Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options
            and produces a list of items of the type for which it was specialized.
            If the expression is empty, returns an empty list.
            If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
            
            Use this form when the result is going to be processed further, for example by matching against the file system,
            so literals must be distinguished, and you promise to unescape after that.
            </summary>
            <typeparam name="T">Type of items to return</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExpandSingleItemVectorExpressionIntoItems``1(System.String,Microsoft.Build.Evaluation.IItemFactory{`1,``0},Microsoft.Build.Evaluation.ExpanderOptions,System.Boolean,System.Boolean@,Microsoft.Build.Shared.IElementLocation)">
             <summary>
             This is a specialized method for the use of TargetUpToDateChecker and Evaluator.EvaluateItemXml only.
             
             Extracts the items in the given SINGLE item vector.
             For example, expands @(Compile->'%(foo)') to a set of items derived from the items in the "Compile" list.
            
             If there is in fact more than one vector in the expression, throws InvalidProjectFileException.
             
             If there are no item expressions in the expression (for example a literal "foo.cpp"), returns null.
             If expression expands to no items, returns an empty list.
             If item expansion is not allowed by the provided options, returns null.
             If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
             
             If the expression is a transform, any transformations to an expression that evaluates to nothing (i.e., because
             an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means 
             that the length of the returned list is always the same as the length of the referenced item list in the input string.
             That's important for any correlation the caller wants to do.
             
             If expression was a transform, 'isTransformExpression' is true, otherwise false.
            
             Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
             have an item type set on it, it will be given the item type of the item vector to use.
             </summary>
             <typeparam name="T">Type of the items that should be returned</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.IsValidPropertyName(System.String)">
            <summary>
            Returns true if the supplied string contains a valid property name
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ScanForClosingParenthesis(System.String,System.Int32)">
            <summary>
            Scan for the closing bracket that matches the one we've already skipped;
            essentially, pushes and pops on a stack of parentheses to do this.
            Takes the expression and the index to start at.
            Returns the index of the matching parenthesis, or -1 if it was not found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ScanForClosingParenthesis(System.String,System.Int32,System.Boolean@,System.Boolean@)">
            <summary>
            Scan for the closing bracket that matches the one we've already skipped;
            essentially, pushes and pops on a stack of parentheses to do this.
            Takes the expression and the index to start at.
            Returns the index of the matching parenthesis, or -1 if it was not found.
            Also returns flags to indicate if a propertyfunction or registry property is likely
            to be found in the expression
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ScanForClosingQuote(System.Char,System.String,System.Int32)">
            <summary>
            Skip all characters until we find the matching quote character
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.AddArgument(System.Collections.Generic.List{System.String},Microsoft.Build.Shared.ReuseableStringBuilder)">
            <summary>
            Add the argument in the StringBuilder to the arguments list, handling nulls
            appropriately
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ExtractFunctionArguments(Microsoft.Build.Shared.IElementLocation,System.String,System.String)">
            <summary>
            Extract the first level of arguments from the content.
            Splits the content passed in at commas.
            Returns an array of unexpanded arguments.
            If there are no arguments, returns an empty array.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.MetadataExpander">
            <summary>
            Expands bare metadata expressions, like %(Compile.WarningLevel), or unqualified, like %(Compile).
            </summary>
            <remarks>
            This is a private nested class, exposed only through the Expander class.
            That allows it to hide its private methods even from Expander.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.MetadataExpander.ExpandMetadataLeaveEscaped(System.String,Microsoft.Build.Evaluation.IMetadataTable,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Expands all embedded item metadata in the given string, using the bucketed items.
            Metadata may be qualified, like %(Compile.WarningLevel), or unqualified, like %(Compile)
            </summary>
            <param name="expression">The expression containing item metadata references</param>
            <param name="metadata"></param>
            <param name="options"></param>
            <returns>The string with item metadata expanded in-place, escaped.</returns>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.MetadataExpander.MetadataMatchEvaluator">
            <summary>
            A functor that returns the value of the metadata in the match
            that is contained in the metadata dictionary it was created with.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.MetadataExpander.MetadataMatchEvaluator._metadata">
            <summary>
            Source of the metadata
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.MetadataExpander.MetadataMatchEvaluator._options">
            <summary>
            Whether to expand built-in metadata, custom metadata, or both kinds.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.MetadataExpander.MetadataMatchEvaluator.#ctor(Microsoft.Build.Evaluation.IMetadataTable,Microsoft.Build.Evaluation.ExpanderOptions)">
            <summary>
            Constructor taking a source of metadata
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.MetadataExpander.MetadataMatchEvaluator.ExpandSingleMetadata(System.Text.RegularExpressions.Match)">
            <summary>
            Expands a single item metadata, which may be qualified with an item type.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1">
            <summary>
            Expands property expressions, like $(Configuration) and $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)
            </summary>
            <remarks>
            This is a private nested class, exposed only through the Expander class.
            That allows it to hide its private methods even from Expander.
            </remarks>
            <typeparam name="T">Type of the properties used to expand the expression</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.ExpandPropertiesLeaveEscaped(System.String,Microsoft.Build.Evaluation.IPropertyProvider{`2},Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Evaluation.UsedUninitializedProperties,Microsoft.Build.Shared.FileSystem.IFileSystem)">
             <summary>
             This method takes a string which may contain any number of
             "$(propertyname)" tags in it.  It replaces all those tags with
             the actual property values, and returns a new string.  For example,
            
                 string processedString =
                     propertyBag.ExpandProperties("Value of NoLogo is $(NoLogo).");
            
             This code might produce:
            
                 processedString = "Value of NoLogo is true."
            
             If the sourceString contains an embedded property which doesn't
             have a value, then we replace that tag with an empty string.
            
             This method leaves the result escaped.  Callers may need to unescape on their own as appropriate.
             </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.ExpandPropertiesLeaveTypedAndEscaped(System.String,Microsoft.Build.Evaluation.IPropertyProvider{`2},Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Evaluation.UsedUninitializedProperties,Microsoft.Build.Shared.FileSystem.IFileSystem)">
             <summary>
             This method takes a string which may contain any number of
             "$(propertyname)" tags in it.  It replaces all those tags with
             the actual property values, and returns a new string.  For example,
            
                 string processedString =
                     propertyBag.ExpandProperties("Value of NoLogo is $(NoLogo).");
            
             This code might produce:
            
                 processedString = "Value of NoLogo is true."
            
             If the sourceString contains an embedded property which doesn't
             have a value, then we replace that tag with an empty string.
            
             This method leaves the result typed and escaped.  Callers may need to convert to string, and unescape on their own as appropriate.
             </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.ExpandPropertyBody(System.String,System.Object,Microsoft.Build.Evaluation.IPropertyProvider{`2},Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Evaluation.UsedUninitializedProperties,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Expand the body of the property, including any functions that it may contain
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.ConvertToString(System.Object)">
            <summary>
            Convert the object into an MSBuild friendly string
            Arrays are supported.
            Will not return NULL
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.LookupProperty(Microsoft.Build.Evaluation.IPropertyProvider{`2},System.String,Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Evaluation.UsedUninitializedProperties)">
            <summary>
            Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.LookupProperty(Microsoft.Build.Evaluation.IPropertyProvider{`2},System.String,System.Int32,System.Int32,Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Evaluation.UsedUninitializedProperties)">
            <summary>
            Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.ExpandMSBuildThisFileProperty(System.String,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            If the property name provided is one of the special
            per file properties named "MSBuildThisFileXXXX" then returns the value of that property.
            If the location provided does not have a path (eg., if it comes from a file that has
            never been saved) then returns empty string.
            If the property name is not one of those properties, returns empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.PropertyExpander`1.ExpandRegistryValue(System.String,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Given a string like "Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation", return the value at that location
            in the registry. If the value isn't found, returns String.Empty.
            Properties may refer to a registry location by using the syntax for example
            "$(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)", where "HKEY_LOCAL_MACHINE\Software\Vendor\Tools" is the key and
            "TaskLocation" is the name of the value.  The name of the value and the preceding "@" may be omitted if
            the default value is desired.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.ItemExpander">
             <summary>
             Expands item expressions, like @(Compile), possibly with transforms and/or separators.
            
             Item vectors are composed of a name, an optional transform, and an optional separator i.e.
             
                 @(&lt;name&gt;->'&lt;transform&gt;','&lt;separator&gt;')
                 
             If a separator is not specified it defaults to a semi-colon. The transform expression is also optional, but if
             specified, it allows each item in the vector to have its item-spec converted to a different form. The transform
             expression can reference any custom metadata defined on the item, as well as the pre-defined item-spec modifiers.
             
             NOTE:
             1) white space between &lt;name&gt;, &lt;transform&gt; and &lt;separator&gt; is ignored
                i.e. @(&lt;name&gt;, '&lt;separator&gt;') is valid
             2) the separator is not restricted to be a single character, it can be a string
             3) the separator can be an empty string i.e. @(&lt;name&gt;,'')
             4) specifying an empty transform is NOT the same as specifying no transform -- the former will reduce all item-specs
                to empty strings
            
             if @(files) is a vector for the files a.txt and b.txt, then:
             
                 "my list: @(files)"                                 expands to string     "my list: a.txt;b.txt"
             
                 "my list: @(files,' ')"                             expands to string      "my list: a.txt b.txt"
             
                 "my list: @(files, '')"                             expands to string      "my list: a.txtb.txt"
             
                 "my list: @(files, '; ')"                           expands to string      "my list: a.txt; b.txt"
             
                 "my list: @(files->'%(Filename)')"                  expands to string      "my list: a;b"
             
                 "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to string      "my list: temp\a.xml temp\b.xml"
             
                 "my list: @(files->'')                              expands to string      "my list: ;"
             </summary>
             <remarks>
             This is a private nested class, exposed only through the Expander class.
             That allows it to hide its private methods even from Expander.
             </remarks>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.Transform``1(Microsoft.Build.Evaluation.Expander{`0,`1},System.Boolean,System.Collections.Generic.Stack{Microsoft.Build.Evaluation.Expander{`0,`1}.ItemExpander.TransformFunction{``0}},System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,``0}})">
            <summary>
            Execute the list of transform functions
            </summary>
            <typeparam name="S">class, IItem</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.ExpandSingleItemVectorExpressionIntoItems``2(Microsoft.Build.Evaluation.Expander{`0,`1},System.String,Microsoft.Build.Evaluation.IItemProvider{``0},Microsoft.Build.Evaluation.IItemFactory{``0,``1},Microsoft.Build.Evaluation.ExpanderOptions,System.Boolean,System.Boolean@,Microsoft.Build.Shared.IElementLocation)">
             <summary>
             Expands any item vector in the expression into items.
             
             For example, expands @(Compile->'%(foo)') to a set of items derived from the items in the "Compile" list.
             
             If there is no item vector in the expression (for example a literal "foo.cpp"), returns null.
             If the item vector expression expands to no items, returns an empty list.
             If item expansion is not allowed by the provided options, returns null.
             If there is an item vector but concatenated with something else, throws InvalidProjectFileException.
             If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
             
             If the expression is a transform, any transformations to an expression that evaluates to nothing (i.e., because
             an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means 
             that the length of the returned list is always the same as the length of the referenced item list in the input string.
             That's important for any correlation the caller wants to do.
             
             If expression was a transform, 'isTransformExpression' is true, otherwise false.
            
             Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
             have an item type set on it, it will be given the item type of the item vector to use.
             </summary>
             <typeparam name="S">Type of the items provided by the item source used for expansion</typeparam>
             <typeparam name="T">Type of the items that should be returned</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.ExpandExpressionCapture``1(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture,Microsoft.Build.Evaluation.IItemProvider{``0},Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Evaluation.ExpanderOptions,System.Boolean,System.Boolean@,System.Collections.Generic.List{Microsoft.Build.Shared.Pair{System.String,``0}}@)">
            <summary>
            Expands an expression capture into a list of items
            If the capture uses a separator, then all the items are concatenated into one string using that separator.
            
            Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
            </summary>
            <param name="isTransformExpression"></param>
            <param name="itemsFromCapture">
            List of items.
            
            Item1 represents the item string, escaped
            Item2 represents the original item.
            
            Item1 differs from Item2's string when it is coming from a transform
            
            </param>
            <param name="expander">The expander whose state will be used to expand any transforms</param>
            <param name="expressionCapture">The <see cref="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.ExpandSingleItemVectorExpressionIntoExpressionCapture(System.String,Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)"/> representing the structure of an item expression</param>
            <param name="evaluatedItems"><see cref="T:Microsoft.Build.Evaluation.IItemProvider`1"/> to provide the inital items (which may get subsequently transformed, if <paramref name="expressionCapture"/> is a transform expression)></param>
            <param name="elementLocation">Location of the xml element containing the <paramref name="expressionCapture"/></param>
            <param name="options">expander options</param>
            <param name="includeNullEntries">Wether to include items that evaluated to empty / null</param>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.ExpandItemVectorsIntoString``1(Microsoft.Build.Evaluation.Expander{`0,`1},System.String,Microsoft.Build.Evaluation.IItemProvider{``0},Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Expands all item vectors embedded in the given expression into a single string.
            If the expression is empty, returns empty string.
            If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
            </summary>
            <typeparam name="T">Type of the items provided</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.PrepareTransformStackFromMatch``1(Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture)">
            <summary>
            Prepare the stack of transforms that will be executed on a given set of items
            </summary>
            <typeparam name="S">class, IItem</typeparam>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.ExpandExpressionCaptureIntoStringBuilder``1(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Evaluation.ExpressionShredder.ItemExpressionCapture,Microsoft.Build.Evaluation.IItemProvider{``0},Microsoft.Build.Shared.IElementLocation,Microsoft.Build.Shared.ReuseableStringBuilder,Microsoft.Build.Evaluation.ExpanderOptions)">
            <summary>
            Expand the match provided into a string, and append that to the provided string builder.
            Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
            </summary>
            <typeparam name="S">Type of source items</typeparam>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1">
            <summary>
            The set of functions that called during an item transformation, e.g. @(CLCompile->ContainsMetadata('MetaName', 'metaValue'))
            </summary>
            <typeparam name="S">class, IItem</typeparam>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.s_transformFunctionDelegateCache">
            <summary>
            A cache of previously created item function delegates
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.ItemTransformFunction">
            <summary>
            Delegate that represents the signature of all item transformation functions
            This is used to support calling the functions by name
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.GetItemTransformFunction(Microsoft.Build.Shared.IElementLocation,System.String,System.Type)">
            <summary>
            Get a delegate to the given item transformation function by supplying the name and the
            Item type that should be used
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.GetItemPairEnumerable(System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Create an enumerator from a base IEnumerable of items into an enumerable
            of transformation result which includes the new itemspec and the base item
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.Count(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns the number of items in the list
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.ItemSpecModifierFunction(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
            Tuple is {current item include, item under transformation}
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.Exists(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns the subset of items that actually exist on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.Combine(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that combines the existing paths of the input items with a given relative path.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.GetPathsOfAllDirectoriesAbove(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns all ancestor directories of the given items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.DirectoryName(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns the DirectoryName of the items in itemsOfType
            UNDONE: This can be removed in favor of a built-in %(DirectoryName) metadata in future.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.Metadata(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns the contents of the metadata in specified in argument[0]
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.DistinctWithCase(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
            Using a case sensitive comparison
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.Distinct(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
            Using a case insensitive comparison
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.DistinctWithComparer(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[],System.StringComparer)">
            <summary>
            Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
            Using a case insensitive comparison
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.Reverse(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function reverses the item list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.ExpandQuotedExpressionFunction(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)')
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.ExecuteStringFunction(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that transforms expressions by invoking methods of System.String on the itemspec
            of the item in the pipeline
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.ClearMetadata(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.HasMetadata(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns only those items that have a not-blank value for the metadata specified
            Using a case insensitive comparison
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.WithMetadataValue(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns only those items have the given metadata value
            Using a case insensitive comparison
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.IntrinsicItemFunctions`1.AnyHaveMetadataValue(Microsoft.Build.Evaluation.Expander{`0,`1},Microsoft.Build.Shared.IElementLocation,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}},System.String[])">
            <summary>
            Intrinsic function that returns a boolean to indicate if any of the items have the given metadata value
            Using a case insensitive comparison
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1">
            <summary>
            Represents all the components of a transform function, including the ability to execute it 
            </summary>
            <typeparam name="S">class, IItem</typeparam>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1._transform">
            <summary>
            The delegate that points to the transform function
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1._arguments">
            <summary>
            Arguments to pass to the transform function as parsed out of the project file
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1._elementLocation">
            <summary>
            The element location of the transform expression
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1._functionName">
            <summary>
            The name of the function that this class will call
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1.#ctor(Microsoft.Build.Shared.IElementLocation,System.String,Microsoft.Build.Evaluation.Expander{`0,`1}.ItemExpander.IntrinsicItemFunctions{`2}.ItemTransformFunction,System.String[])">
            <summary>
            TransformFunction constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1.Arguments">
            <summary>
            Arguments to pass to the transform function as parsed out of the project file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1.ElementLocation">
            <summary>
            The element location of the transform expression
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.TransformFunction`1.Execute(Microsoft.Build.Evaluation.Expander{`0,`1},System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.Build.Shared.Pair{System.String,`2}})">
            <summary>
            Execute this transform function with the arguments contained within this TransformFunction instance
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.ItemExpander.MetadataMatchEvaluator">
            <summary>
            A functor that returns the value of the metadata in the match
            that is on the item it was created with.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.MetadataMatchEvaluator._itemSpec">
            <summary>
            The current ItemSpec of the item being matched
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.MetadataMatchEvaluator._sourceOfMetadata">
            <summary>
            Item used as the source of metadata
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.ItemExpander.MetadataMatchEvaluator._elementLocation">
            <summary>
            Location of the match
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.MetadataMatchEvaluator.#ctor(System.String,Microsoft.Build.Evaluation.IItem,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.ItemExpander.MetadataMatchEvaluator.GetMetadataValueFromMatch(System.Text.RegularExpressions.Match)">
            <summary>
            Expands the metadata in the match provided into a string result.
            The match is expected to be the content of a transform.
            For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')"
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.RegularExpressions">
            <summary>
            Regular expressions used by the expander.
            The expander currently uses regular expressions rather than a parser to do its work.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.ItemMetadataPattern">
            <summary>
            Regular expression used to match item metadata references embedded in strings.
            For example, %(Compile.DependsOn) or %(DependsOn).
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.NameGroup">
            <summary>
            Name of the group matching the "name" of a metadatum.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.ItemSpecificationGroup">
            <summary>
            Name of the group matching the prefix on a metadata expression, for example "Compile." in "%(Compile.Object)"
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.ItemTypeGroup">
            <summary>
            Name of the group matching the item type in an item expression or metadata expression.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.NonTransformItemMetadataPattern">
            <summary>
            regular expression used to match item metadata references outside of item vector transforms
            </summary>
            <remarks>PERF WARNING: this Regex is complex and tends to run slowly</remarks>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.ItemMetadataSpecification">
            <summary>
            Complete description of an item metadata reference, including the optional qualifying item type.
            For example, %(Compile.DependsOn) or %(DependsOn).
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.ItemVectorWithTransformLHS">
            <summary>
            description of an item vector with a transform, left hand side 
            </summary> 
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.RegularExpressions.ItemVectorWithTransformRHS">
            <summary>
            description of an item vector with a transform, right hand side 
            </summary> 
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.ReceiverType">
            <summary>
            The type of this function's receiver
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.Name">
            <summary>
            The name of the function
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.Arguments">
            <summary>
            The arguments for the function
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.Expression">
            <summary>
            The expression that this function is part of
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.Receiver">
            <summary>
            The property name that this function is applied on
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.BindingFlags">
            <summary>
            The binding flags that will be used during invocation of this function
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.Remainder">
            <summary>
            The remainder of the body once the function and arguments have been extracted
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.FunctionBuilder`1.UsedUninitializedProperties">
            <summary>
            List of properties which have been used but have not been initialized yet.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.Expander`2.Function`1">
            <summary>
            This class represents the function as extracted from an expression
            It is also responsible for executing the function
            </summary>
            <typeparam name="T">Type of the properties used to expand the expression</typeparam>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._receiverType">
            <summary>
            The type of this function's receiver
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._methodMethodName">
            <summary>
            The name of the function
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._arguments">
            <summary>
            The arguments for the function
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._expression">
            <summary>
            The expression that this function is part of
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._receiver">
            <summary>
            The property name that this function is applied on
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._bindingFlags">
            <summary>
            The binding flags that will be used during invocation of this function
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._remainder">
            <summary>
            The remainder of the body once the function and arguments have been extracted
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.Expander`2.Function`1._usedUninitializedProperties">
            <summary>
            List of properties which have been used but have not been initialized yet.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.#ctor(System.Type,System.String,System.String,System.String,System.String[],System.Reflection.BindingFlags,System.String,Microsoft.Build.Evaluation.UsedUninitializedProperties,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Construct a function that will be executed during property evaluation
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.Expander`2.Function`1.Receiver">
            <summary>
            Part of the extraction may result in the name of the property
            This accessor is used by the Expander
            Examples of expression root:
                [System.Diagnostics.Process]::Start
                SomeMSBuildProperty
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.ExtractPropertyFunction(System.String,Microsoft.Build.Shared.IElementLocation,System.Object,Microsoft.Build.Evaluation.UsedUninitializedProperties,Microsoft.Build.Shared.FileSystem.IFileSystem)">
            <summary>
            Extract the function details from the given property function expression
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.Execute(System.Object,Microsoft.Build.Evaluation.IPropertyProvider{`2},Microsoft.Build.Evaluation.ExpanderOptions,Microsoft.Build.Shared.IElementLocation)">
            <summary>
            Execute the function on the given instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.TryExecuteWellKnownFunction(System.Object@,System.Object,System.Object[])">
            <summary>
            Shortcut to avoid calling into binding if we recognize some most common functions.
            Binding is expensive and throws first-chance MissingMethodExceptions, which is
            bad for debugging experience and has a performance cost.
            A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
            (rough numbers just for comparison).
            See https://github.com/Microsoft/msbuild/issues/2217
            </summary>
            <param name="returnVal">The value returned from the function call</param>
            <param name="objectInstance">Object that the function is called on</param>
            <param name="args">arguments</param>
            <returns>True if the well known function call binding was successful</returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.GetTypeForStaticMethod(System.String,System.String)">
            <summary>
            Given a type name and method name, try to resolve the type.
            </summary>
            <param name="typeName">May be full name or assembly qualified name</param>
            <param name="simpleMethodName">simple name of the method</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.GetTypeFromAssemblyUsingNamespace(System.String)">
            <summary>
            Gets the specified type using the namespace to guess the assembly that its in
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.GetTypeFromAssembly(System.String,System.String)">
            <summary>
            Get the specified type from the assembly partial name supplied
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.ConstructIndexerFunction(System.String,Microsoft.Build.Shared.IElementLocation,System.Object,System.Int32,System.Int32,Microsoft.Build.Evaluation.Expander{`0,`1}.FunctionBuilder{`2}@)">
            <summary>
            Extracts the name, arguments, binding flags, and invocation type for an indexer
            Also extracts the remainder of the expression that is not part of this indexer
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.ConstructFunction(Microsoft.Build.Shared.IElementLocation,System.String,System.Int32,System.Int32,Microsoft.Build.Evaluation.Expander{`0,`1}.FunctionBuilder{`2}@)">
            <summary>
            Extracts the name, arguments, binding flags, and invocation type for a static or instance function.
            Also extracts the remainder of the expression that is not part of this function
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.CoerceArguments(System.Object[],System.Reflection.ParameterInfo[])">
            <summary>
            Coerce the arguments according to the parameter types
            Will only return null if the coercion didn't work due to an InvalidCastException
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.GenerateStringOfMethodExecuted(System.String,System.Object,System.String,System.Object[])">
            <summary>
            Make an attempt to create a string showing what we were trying to execute when we failed.
            This will show any intermediate evaluation which may help the user figure out what happened.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.IsStaticMethodAvailable(System.Type,System.String)">
            <summary>
            Check the property function whitelist whether this method is available.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.Expander`2.Function`1.LateBindExecute(System.Exception,System.Reflection.BindingFlags,System.Object,System.Object[],System.Boolean)">
            <summary>
            Construct and instance of objectType based on the constructor or method arguments provided.
            Arguments must never be null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.UsedUninitializedProperties">
            <summary>
            This class wraps information about properties which have been used before they are initialized 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.UsedUninitializedProperties.#ctor">
            <summary>
            This class wraps information about properties which have been used before they are initialized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.UsedUninitializedProperties.Properties">
            <summary>
            Hash set of properties which have been used before being initialized
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.UsedUninitializedProperties.Warn">
            <summary>
             Are we currently supposed to warn if we used an uninitialized property.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName">
            <summary>
             What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property
            </summary>
        </member>
        <member name="T:Microsoft.Build.Evaluation.ToolsetProvider">
            <summary>
            Class which provides access to toolsets.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Evaluation.ToolsetProvider._toolsets">
            <summary>
            A mapping of tools versions to Toolsets, which contain the public Toolsets.
            This is the collection we use internally.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetProvider.#ctor(System.String,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Evaluation.ToolsetDefinitionLocations)">
            <summary>
            Constructor which will load toolsets from the specified locations.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetProvider.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.Toolset})">
            <summary>
            Constructor from an existing collection of toolsets.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetProvider.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.Evaluation.ToolsetProvider.Toolsets">
            <summary>
            Retrieves the toolsets.
            </summary>
            <comments>
            ValueCollection is already read-only. 
            </comments>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetProvider.GetToolset(System.String)">
            <summary>
            Gets the specified toolset.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetProvider.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Translates to and from binary form.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetProvider.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Evaluation.ToolsetProvider.InitializeToolsetCollection(Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},Microsoft.Build.Evaluation.ToolsetDefinitionLocations)">
            <summary>
            Populate Toolsets with a dictionary of (toolset version, Toolset) 
            using information from the registry and config file, if any.  
            </summary>
        </member>
        <member name="F:Microsoft.Build.Graph.GraphBuilder.ImplicitWorkerCount">
            <summary>
            The thread calling BuildGraph() will act as an implicit worker
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuilder.DetectCycles(System.Collections.Generic.IReadOnlyCollection{Microsoft.Build.Graph.ProjectGraphNode},Microsoft.Build.Graph.ProjectInterpretation,System.Collections.Generic.Dictionary{Microsoft.Build.BackEnd.ConfigurationMetadata,Microsoft.Build.Graph.ParsedProject})">
            <remarks>
                Maintain the state of each node (InProcess and Processed) to detect cycles.
                Assumes edges have been added between nodes.
                Returns false if cycles were detected.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuilder.FindGraphNodes">
            <summary>
                Load a graph with root node at entryProjectFile
                Maintain a queue of projects to be processed and evaluate projects in parallel
                Returns false if loading the graph is not successful
            </summary>
        </member>
        <member name="T:Microsoft.Build.Graph.ParallelWorkSet`2">
            <summary>
            Provides deduping of expensive work by a key, or modeling of a set of deduped work that
            can be awaited as a unit. Completed results are kept in the collection for reuse.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Graph.ParallelWorkSet`2._degreeOfParallelism">
            <summary>
            Number of workers to process work items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ParallelWorkSet`2.CompletedWork">
            <summary>
            Retrieves all completed work items.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ParallelWorkSet`2.IsCompleted">
            <summary>
            Checks if the work set has been marked as completed.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.ParallelWorkSet`2.AddWork(`0,System.Func{`1})">
            <summary>
            Enqueues a work item to the work set.
            </summary>
            <param name="key"></param>
            <param name="workFunc"></param>
        </member>
        <member name="M:Microsoft.Build.Graph.ParallelWorkSet`2.WaitForAllWorkAndComplete">
            <summary>
            Assists processing items until all the items added to the queue are processed, completes the work set, and
            propagates any exceptions thrown by workers.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectInterpretation.PostProcess(System.Collections.Generic.Dictionary{Microsoft.Build.BackEnd.ConfigurationMetadata,Microsoft.Build.Graph.ParsedProject},Microsoft.Build.Graph.GraphBuilder)">
            <summary>
            To avoid calling nuget at graph construction time, the graph is initially constructed with outer build nodes referencing inner build nodes.
            However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the
            outer build. Change the graph to mimic this behaviour.
            Examples
            OuterAsRoot -> Inner stays the same
            Node -> Outer -> Inner goes to: Node -> Outer; Node->Inner; Outer -> empty
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectInterpretation.ProjectReferenceGlobalPropertiesModifier(Microsoft.Build.Graph.ProjectInterpretation.GlobalPropertyPartsForMSBuildTask,Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
                Gets the effective global properties for a project reference item.
            </summary>
            <remarks>
                The behavior of this method should match the logic in the SDK
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectInterpretation.GetGlobalPropertiesForItem(Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Collections.PropertyDictionary{Microsoft.Build.Execution.ProjectPropertyInstance},System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectInterpretation.GlobalPropertiesModifier})">
            <summary>
                Gets the effective global properties for an item that will get passed to <see cref="P:Microsoft.Build.BackEnd.MSBuild.Projects"/>.
            </summary>
            <remarks>
                The behavior of this method matches the hardcoded behaviour of the msbuild task
                and the <paramref name="globalPropertyModifiers"/> parameter can contain other mutations done at build time in targets / tasks
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectInterpretation.TargetsToPropagate.FromProjectAndEntryTargets(Microsoft.Build.Execution.ProjectInstance,System.Collections.Immutable.ImmutableList{System.String})">
             <summary>
             Given a project and a set of entry targets the project would get called with,
             parse the project's project reference target specification and compute how the target would call its references.
            
             The calling code should then call <see cref="M:Microsoft.Build.Graph.ProjectInterpretation.TargetsToPropagate.GetApplicableTargetsForReference(Microsoft.Build.Execution.ProjectInstance)"/> for each of the project's references
             to get the concrete targets for each reference.
             </summary>
             <param name="project">Project containing the PRT protocol</param>
             <param name="entryTargets">Targets with which <paramref name="project"/> will get called</param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildResult.#ctor(System.Int32,System.Collections.Generic.IReadOnlyDictionary{Microsoft.Build.Graph.ProjectGraphNode,Microsoft.Build.Execution.BuildResult})">
            <summary>
            Constructor creates a build result with results for each graph node.
            </summary>
            <param name="submissionId">The id of the build submission.</param>
            <param name="resultsByNode">The set of results for each graph node.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildResult.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructor creates a build result indicating a circular dependency was created.
            </summary>
            <param name="submissionId">The id of the build submission.</param>
            <param name="circularDependency">Set to true if a circular dependency was detected.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildResult.#ctor(System.Int32,System.Exception)">
            <summary>
            Constructs a graph build result with an exception
            </summary>
            <param name="submissionId">The id of the build submission.</param>
            <param name="exception">The exception, if any.</param>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildResult.SubmissionId">
            <summary>
            Returns the submission id.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildResult.CircularDependency">
            <summary>
            Returns a flag indicating if a circular dependency was detected.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildResult.Exception">
            <summary>
            Returns the exception generated while this result was run, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildResult.OverallResult">
            <summary>
            Returns the overall result for this result set.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildResult.ResultsByNode">
            <summary>
            Returns an enumerator for all build results in this graph build result
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildResult.Item(Microsoft.Build.Graph.ProjectGraphNode)">
            <summary>
            Indexer which sets or returns results for the specified node
            </summary>
            <param name="node">The node</param>
            <returns>The results for the specified node</returns>
            <exception>KeyNotFoundException is returned if the specified node doesn't exist when reading this property.</exception>
        </member>
        <member name="T:Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback">
            <summary>
            A callback used to receive notification that a build has completed.
            </summary>
            <remarks>
            When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signalled and the OverallBuildResult will be valid.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Graph.GraphBuildSubmission">
            <summary>
            A GraphBuildSubmission represents a graph build request which has been submitted to the BuildManager for processing.  It may be used to
            execute synchronous or asynchronous graph build requests and provides access to the results upon completion.
            </summary>
            <remarks>
            This class is thread-safe.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Graph.GraphBuildSubmission._completionCallback">
            <summary>
            The callback to invoke when the submission is complete.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Graph.GraphBuildSubmission._completionEvent">
            <summary>
            The completion event.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Graph.GraphBuildSubmission._completionInvoked">
            <summary>
            True if it has been invoked
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildSubmission.#ctor(Microsoft.Build.Execution.BuildManager,System.Int32,Microsoft.Build.Graph.GraphBuildRequestData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.BuildManager">
            <summary>
            The BuildManager with which this submission is associated.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.SubmissionId">
            <summary>
            An ID uniquely identifying this request from among other submissions within the same build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.AsyncContext">
            <summary>
            The asynchronous context provided to <see cref="M:Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback,System.Object)"/>, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.WaitHandle">
            <summary>
            A <see cref="T:System.Threading.WaitHandle"/> which will be signalled when the build is complete.  Valid after <see cref="M:Microsoft.Build.Execution.BuildSubmission.Execute"/> or <see cref="M:Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback,System.Object)"/> returns, otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.IsCompleted">
            <summary>
            Returns true if this submission is complete.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.BuildResult">
            <summary>
            The results of the build per graph node.  Valid only after WaitHandle has become signalled.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.BuildRequestData">
            <summary>
            The BuildRequestData being used for this submission.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildSubmission.IsStarted">
            <summary>
            Whether the graph build has started.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildSubmission.Execute">
            <summary>
            Starts the request and blocks until results are available.
            </summary>
            <exception cref="T:System.InvalidOperationException">The request has already been started or is already complete.</exception>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildSubmission.ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback,System.Object)">
            <summary>
            Starts the request asynchronously and immediately returns control to the caller.
            </summary>
            <exception cref="T:System.InvalidOperationException">The request has already been started or is already complete.</exception>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildSubmission.CompleteResults(Microsoft.Build.Graph.GraphBuildResult)">
            <summary>
            Sets the event signaling that the build is complete.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Graph.GraphBuildRequestData">
            <summary>
            GraphBuildRequestData encapsulates all of the data needed to submit a graph build request.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(Microsoft.Build.Graph.ProjectGraph,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph.
            </summary>
            <param name="projectGraph">The graph to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(Microsoft.Build.Graph.ProjectGraph,System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph.
            </summary>
            <param name="projectGraph">The graph to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(Microsoft.Build.Graph.ProjectGraph,System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph.
            </summary>
            <param name="projectGraph">The graph to build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
            <param name="flags">Flags controlling this build request.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on project files.
            </summary>
            <param name="projectFullPath">The full path to the project file.</param>
            <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use.  May be null.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on project files.
            </summary>
            <param name="projectFullPath">The full path to the project file.</param>
            <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use.  May be null.</param>
            <param name="flags">The <see cref="T:Microsoft.Build.Execution.BuildRequestDataFlags"/> to use.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(Microsoft.Build.Graph.ProjectGraphEntryPoint,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph entry points.
            </summary>
            <param name="projectGraphEntryPoint">The entry point to use in the build.</param>
            <param name="targetsToBuild">The targets to build.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(Microsoft.Build.Graph.ProjectGraphEntryPoint,System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph entry points.
            </summary>
            <param name="projectGraphEntryPoint">The entry point to use in the build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(Microsoft.Build.Graph.ProjectGraphEntryPoint,System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph entry points.
            </summary>
            <param name="projectGraphEntryPoint">The entry point to use in the build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
            <param name="flags">Flags controlling this build request.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectGraphEntryPoint},System.Collections.Generic.ICollection{System.String})">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph entry points.
            </summary>
            <param name="projectGraphEntryPoints">The entry points to use in the build.</param>
            <param name="targetsToBuild">The targets to build.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectGraphEntryPoint},System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph entry points.
            </summary>
            <param name="projectGraphEntryPoints">The entry points to use in the build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectGraphEntryPoint},System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Constructs a GraphBuildRequestData for build requests based on a project graph entry points.
            </summary>
            <param name="projectGraphEntryPoints">The entry points to use in the build.</param>
            <param name="targetsToBuild">The targets to build.</param>
            <param name="hostServices">The host services to use, if any.  May be null.</param>
            <param name="flags">Flags controlling this build request.</param>
        </member>
        <member name="M:Microsoft.Build.Graph.GraphBuildRequestData.#ctor(System.Collections.Generic.ICollection{System.String},Microsoft.Build.Execution.HostServices,Microsoft.Build.Execution.BuildRequestDataFlags)">
            <summary>
            Common constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraph">
            <summary>
            The requested project graph to build.
            May be null.
            </summary>
            <value>The project graph.</value>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraphEntryPoints">
            <summary>
            The project graph entry points.
            May be null.
            </summary>
            <value>The project graph entry points.</value>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildRequestData.TargetNames">
            <summary>
            The name of the targets to build.
            </summary>
            <value>An array of targets in the project to be built.</value>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildRequestData.Flags">
            <summary>
            Extra flags for this BuildRequest.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.GraphBuildRequestData.HostServices">
            <summary>
            Gets the HostServices object for this request.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Graph.ProjectGraphEntryPoint">
            <summary>
            Represents an entry point into the project graph which is comprised of a project file and a set of global properties
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraphEntryPoint.#ctor(System.String)">
            <summary>
            Constructs an entry point with the given project file and no global properties.
            </summary>
            <param name="projectFile">The project file to use for this entry point</param>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraphEntryPoint.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Constructs an entry point with the given project file and global properties.
            </summary>
            <param name="projectFile">The project file to use for this entry point</param>
            <param name="globalProperties">The global properties to use for this entry point. May be null.</param>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectFile">
            <summary>
            Gets the project file to use for this entry point.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraphEntryPoint.GlobalProperties">
            <summary>
            Gets the global properties to use for this entry point.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Graph.ProjectGraph">
            <summary>
                Represents a graph of evaluated projects.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc">
            <summary>
                A callback used for constructing a <see cref="T:Microsoft.Build.Execution.ProjectInstance" /> for a specific
                <see cref="T:Microsoft.Build.Graph.ProjectGraphEntryPoint" /> instance.
            </summary>
            <param name="projectPath">The path to the project file to parse.</param>
            <param name="globalProperties">The global properties to be used for creating the ProjectInstance.</param>
            <param name="projectCollection">The <see cref="T:Microsoft.Build.Evaluation.ProjectCollection" /> context for parsing.</param>
            <returns>A <see cref="T:Microsoft.Build.Execution.ProjectInstance" /> instance. This value must not be null.</returns>
            <remarks>
                The default version of this delegate used by ProjectGraph simply calls the
                ProjectInstance constructor with information from the parameters. This delegate
                is provided as a hook to allow scenarios like creating a <see cref="T:Microsoft.Build.Evaluation.Project" />
                instance before converting it to a ProjectInstance for use by the ProjectGraph.
                The returned ProjectInstance will be stored and provided with the ProjectGraph.
                If this callback chooses to generate an immutable ProjectInstance, e.g. by
                using <see cref="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance" /> with the flag
                <see cref="F:Microsoft.Build.Execution.ProjectInstanceSettings.Immutable" />, the resulting ProjectGraph
                nodes might not be buildable.
                To avoid corruption of the graph and subsequent builds based on the graph:
                - all callback parameters must be utilized for creating the ProjectInstance, without any mutations
                - the project instance should not be mutated in any way, its state should be a
                full fidelity representation of the project file
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraph.EntryPointNodes">
            <summary>
                Gets the project nodes representing the entry points.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraph.ProjectNodes">
            <summary>
                Get an unordered collection of all project nodes in the graph.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraph.ProjectNodesTopologicallySorted">
            <summary>
                Get a topologically sorted collection of all project nodes in the graph.
                Referenced projects appear before the referencing projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.String)">
            <summary>
                Constructs a graph starting from the given project file, evaluating with the global project collection and no
                global properties.
            </summary>
            <param name="entryProjectFile">The project file to use as the entry point in constructing the graph</param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Constructs a graph starting from the given project files, evaluating with the global project collection and no
                global properties.
            </summary>
            <param name="entryProjectFiles">The project files to use as the entry points in constructing the graph</param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
                Constructs a graph starting from the given project file, evaluating with the provided project collection and no
                global properties.
            </summary>
            <param name="entryProjectFile">The project file to use as the entry point in constructing the graph</param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{System.String},Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
                Constructs a graph starting from the given project files, evaluating with the provided project collection and no
                global properties.
            </summary>
            <param name="entryProjectFiles">The project files to use as the entry points in constructing the graph</param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc)" -->
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
                Constructs a graph starting from the given project file, evaluating with the provided global properties and the
                global project collection.
            </summary>
            <param name="entryProjectFile">The project file to use as the entry point in constructing the graph</param>
            <param name="globalProperties">
                The global properties to use for all projects. May be null, in which case no global
                properties will be set.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
                Constructs a graph starting from the given project files, evaluating with the provided global properties and the
                global project collection.
            </summary>
            <param name="entryProjectFiles">The project files to use as the entry points in constructing the graph</param>
            <param name="globalProperties">
                The global properties to use for all projects. May be null, in which case no global
                properties will be set.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
                Constructs a graph starting from the given project file, evaluating with the provided global properties and the
                provided project collection.
            </summary>
            <param name="entryProjectFile">The project file to use as the entry point in constructing the graph</param>
            <param name="globalProperties">
                The global properties to use for all projects. May be null, in which case no global
                properties will be set.
            </param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
                Constructs a graph starting from the given project files, evaluating with the provided global properties and the
                provided project collection.
            </summary>
            <param name="entryProjectFiles">The project files to use as the entry points in constructing the graph</param>
            <param name="globalProperties">
                The global properties to use for all projects. May be null, in which case no global
                properties will be set.
            </param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(Microsoft.Build.Graph.ProjectGraphEntryPoint)">
            <summary>
                Constructs a graph starting from the given graph entry point, evaluating with the global project collection.
            </summary>
            <param name="entryPoint">The entry point to use in constructing the graph</param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectGraphEntryPoint})">
            <summary>
                Constructs a graph starting from the given graph entry points, evaluating with the global project collection.
            </summary>
            <param name="entryPoints">The entry points to use in constructing the graph</param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(Microsoft.Build.Graph.ProjectGraphEntryPoint,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
                Constructs a graph starting from the given graph entry point, evaluating with the provided project collection.
            </summary>
            <param name="entryPoint">The entry point to use in constructing the graph</param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectGraphEntryPoint},Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc)">
            <summary>
                Constructs a graph starting from the given graph entry points, evaluating with the provided project collection.
            </summary>
            <param name="entryPoints">The entry points to use in constructing the graph</param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <param name="projectInstanceFactory">
                A delegate used for constructing a <see cref="T:Microsoft.Build.Execution.ProjectInstance" />, called for each
                project created during graph creation. This value can be null, which uses
                a default implementation that calls the ProjectInstance constructor. See the remarks
                on <see cref="T:Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc" /> for other scenarios.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
            <exception cref="T:System.InvalidOperationException">
                If a null reference is returned from <paramref name="projectInstanceFactory" />
            </exception>
            <exception cref="T:Microsoft.Build.BackEnd.CircularDependencyException">
                If the evaluation is successful but the project graph contains a circular
                dependency
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectGraphEntryPoint},Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc,System.Threading.CancellationToken)">
            <summary>
                Constructs a graph starting from the given graph entry points, evaluating with the provided project collection.
            </summary>
            <param name="entryPoints">The entry points to use in constructing the graph</param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <param name="projectInstanceFactory">
                A delegate used for constructing a <see cref="T:Microsoft.Build.Execution.ProjectInstance" />, called for each
                project created during graph creation. This value can be null, which uses
                a default implementation that calls the ProjectInstance constructor. See the remarks
                on <see cref="T:Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc" /> for other scenarios.
            </param>
            <param name="cancellationToken">
                The <see cref="T:System.Threading.CancellationToken" /> token to observe.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
            <exception cref="T:System.InvalidOperationException">
                If a null reference is returned from <paramref name="projectInstanceFactory" />
            </exception>
            <exception cref="T:Microsoft.Build.BackEnd.CircularDependencyException">
                If the evaluation is successful but the project graph contains a circular
                dependency
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Graph.ProjectGraphEntryPoint},Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Constructs a graph starting from the given graph entry points, evaluating with the provided project collection.
            </summary>
            <param name="entryPoints">The entry points to use in constructing the graph</param>
            <param name="projectCollection">
                The collection with which all projects in the graph should be associated. May not be
                null.
            </param>
            <param name="projectInstanceFactory">
                A delegate used for constructing a <see cref="T:Microsoft.Build.Execution.ProjectInstance" />, called for each
                project created during graph creation. This value can be null, which uses
                a default implementation that calls the ProjectInstance constructor. See the remarks
                on <see cref="T:Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc" /> for other scenarios.
            </param>
            <param name="degreeOfParallelism">
                Number of threads to participate in building the project graph.
            </param>
            <param name="cancellationToken">
                The <see cref="T:System.Threading.CancellationToken" /> token to observe.
            </param>
            <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
                If the evaluation of any project in the graph fails
            </exception>
            <exception cref="T:System.InvalidOperationException">
                If a null reference is returned from <paramref name="projectInstanceFactory" />
            </exception>
            <exception cref="T:Microsoft.Build.BackEnd.CircularDependencyException">
                If the evaluation is successful but the project graph contains a circular
                dependency
            </exception>
        </member>
        <member name="M:Microsoft.Build.Graph.ProjectGraph.GetTargetLists(System.Collections.Generic.ICollection{System.String})">
            <summary>
                Gets the target list to be executed for every project in the graph, given a particular target list for the entry
                project.
            </summary>
            <remarks>
                This method uses the ProjectReferenceTargets items to determine the targets to run per node. The results can then
                be used to start building each project individually, assuming a given project is built after its references.
            </remarks>
            <param name="entryProjectTargets">
                The target list for the <see cref="P:Microsoft.Build.Graph.ProjectGraph.GraphRoots" />. May be null or empty, in which case the entry projects' default
                targets will be used.
            </param>
            <returns>
                A dictionary containing the target list for each node. If a node's target list is empty, then no targets were
                inferred for that node and it should get skipped during a graph based build.
            </returns>
        </member>
        <member name="T:Microsoft.Build.Graph.ProjectGraphNode">
            <summary>
            Represents the node for a particular project in a project graph.
            A node is defined by (ProjectPath, ToolsVersion, GlobalProperties).
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraphNode.ProjectReferences">
            <summary>
            Gets an unordered collection of graph nodes for projects which this project references.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraphNode.ReferencingProjects">
            <summary>
            Gets a list of graph nodes for projects that have a project reference for this project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Graph.ProjectGraphNode.ProjectInstance">
            <summary>
            Gets the evaluated project instance represented by this node in the graph.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.ForwardingLoggerRecord">
            <summary>
            This class descibes a central/forwarding logger pair used in multiproc logging.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ForwardingLoggerRecord.#ctor(Microsoft.Build.Framework.ILogger,Microsoft.Build.Logging.LoggerDescription)">
            <summary>
            Constructor.
            </summary>
            <param name="centralLogger">The central logger</param>
            <param name="forwardingLoggerDescription">The description for the forwarding logger.</param>
        </member>
        <member name="P:Microsoft.Build.Logging.ForwardingLoggerRecord.CentralLogger">
            <summary>
            Retrieves the central logger.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerDescription">
            <summary>
            Retrieves the forwarding logger description.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.EvaluationLocationIdAgnosticComparer">
            <summary>
            Comparer for <see cref="T:Microsoft.Build.Framework.Profiler.EvaluationLocation"/> that ignores 
            both <see cref="P:Microsoft.Build.Framework.Profiler.EvaluationLocation.Id"/> and <see cref="P:Microsoft.Build.Framework.Profiler.EvaluationLocation.ParentId"/>
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.EvaluationLocationIdAgnosticComparer.Singleton">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Logging.EvaluationLocationIdAgnosticComparer.Equals(Microsoft.Build.Framework.Profiler.EvaluationLocation,Microsoft.Build.Framework.Profiler.EvaluationLocation)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Logging.EvaluationLocationIdAgnosticComparer.GetHashCode(Microsoft.Build.Framework.Profiler.EvaluationLocation)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Build.Logging.ProfilerLogger">
            <summary>
            Listens to build evaluation finished events and collects profiling information when available
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ProfilerLogger._profiledResults">
            <summary>
            Accumulates the result of profiling each project. Computing the aggregated result is deferred till the end of the build
            to interfere as less as possible with evaluation times
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ProfilerLogger._aggregatedLocations">
            <summary>
            Aggregation of all profiled locations. Computed the first time <see cref="M:Microsoft.Build.Logging.ProfilerLogger.GetAggregatedResult(System.Boolean)"/> is called.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ProfilerLogger.FileToLog">
            <summary>
            If null, no file is saved to disk
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ProfilerLogger.#ctor(System.String)">
            <nodoc/>
        </member>
        <member name="M:Microsoft.Build.Logging.ProfilerLogger.CreateForTesting">
            <summary>
            Creates a logger for testing purposes that gathers profiling information but doesn't save a file to disk with the report
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ProfilerLogger.Verbosity">
            <summary>
            Verbosity is ignored by this logger
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ProfilerLogger.Parameters">
            <summary>
            No specific parameters are used by this logger
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ProfilerLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Subscribes to status events, which is the category for the evaluation finished event.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ProfilerLogger.Shutdown">
            <summary>
            On shutdown, the profiler report is written to disk
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ProfilerLogger.GetAggregatedResult(System.Boolean)">
            <summary>
            Returns the result of aggregating all profiled projects across a build
            </summary>
            <param name="pruneSmallItems">Whether small items should be pruned. This is called with false on some tests since the result may vary depending on the evaluator speed</param>
            <remarks>
            Not thread safe. After this method is called, the assumption is that no new ProjectEvaluationFinishedEventArgs will arrive.
            In the regular code path, this method is called only once per build. But some test cases may call it multiple times to validate 
            the aggregated data
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Logging.ProfilerLogger.FindBigEnoughParentId(System.Collections.Generic.IDictionary{System.Int64,Microsoft.Build.Shared.Pair{Microsoft.Build.Framework.Profiler.EvaluationLocation,Microsoft.Build.Framework.Profiler.ProfiledLocation}},System.Nullable{System.Int64})">
            <summary>
            Finds the first ancestor of parentId (which could be itself) that is either an evaluation pass location or a big enough profiled data
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ProfilerLogger.GenerateProfilerReport">
            <summary>
            Pretty prints the aggregated results and saves it to disk
            </summary>
            <remarks>
            If the extension of the file to log is 'md', markdown content is generated. Otherwise, it falls 
            back to a tab separated format
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Logging.BinaryLogger">
            <summary>
            A logger that serializes all incoming BuildEventArgs in a compressed binary file (*.binlog). The file
            can later be played back and piped into other loggers (file, console, etc) to reconstruct the log contents
            as if a real build was happening. Additionally, this format can be read by tools for
            analysis or visualization. Since the file format preserves structure, tools don't have to parse
            text logs that erase a lot of useful information.
            </summary>
            <remarks>The logger is public so that it can be instantiated from MSBuild.exe via command-line switch.</remarks>
        </member>
        <member name="T:Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode">
            <summary>
            Describes whether to collect the project files (including imported project files) used during the build.
            If the project files are collected they can be embedded in the log file or as a separate zip archive.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.None">
            <summary>
            Don't collect any files during the build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.Embed">
            <summary>
            Embed all project files directly in the log file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.ZipFile">
            <summary>
            Create an external .ProjectImports.zip archive for the project files.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.BinaryLogger.CollectProjectImports">
            <summary>
            Gets or sets whether to capture and embed project and target source files used during the build.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.BinaryLogger.Verbosity">
            <summary>
            The binary logger Verbosity is always maximum (Diagnostic). It tries to capture as much
            information as possible.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.BinaryLogger.Parameters">
            <summary>
            The only supported parameter is the output log file path (e.g. "msbuild.binlog") 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BinaryLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Initializes the logger by subscribing to events of IEventSource
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BinaryLogger.Shutdown">
            <summary>
            Closes the underlying file stream.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BinaryLogger.ProcessParameters">
            <summary>
            Processes the parameters given to the logger from MSBuild.
            </summary>
            <exception cref="T:Microsoft.Build.Framework.LoggerException">
            </exception>
        </member>
        <member name="T:Microsoft.Build.Logging.BinaryLogReplayEventSource">
            <summary>
            Provides a method to read a binary log file (*.binlog) and replay all stored BuildEventArgs
            by implementing IEventSource and raising corresponding events.
            </summary>
            <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>
        </member>
        <member name="M:Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(System.String)">
            <summary>
            Read the provided binary log file and raise corresponding events for each BuildEventArgs
            </summary>
            <param name="sourceFilePath">The full file path of the binary log file</param>
        </member>
        <member name="M:Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(System.String,System.Threading.CancellationToken)">
            <summary>
            Read the provided binary log file and raise corresponding events for each BuildEventArgs
            </summary>
            <param name="sourceFilePath">The full file path of the binary log file</param>
            <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken"/> indicating the replay should stop as soon as possible.</param>
        </member>
        <member name="T:Microsoft.Build.Logging.EventArgsDispatcher">
            <summary>
            An implementation of IEventSource that raises appropriate events for a provided BuildEventArgs object.
            </summary>
            <remarks>This class is public because BinaryLogReplayEventSource is a derived class.
            This is abstracted into its own class because it's a useful single-purpose helper that
            can be used independently as a generic implementation of IEventSource.</remarks>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.AnyEventRaised">
            <summary>
            This event is raised for all BuildEventArgs objects after a more type-specific event
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.StatusEventRaised">
            <summary>
            Raised for BuildStatusEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.CustomEventRaised">
            <summary>
            Raised for CustomBuildEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.BuildStarted">
            <summary>
            Raised for BuildStartedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.BuildFinished">
            <summary>
            Raised for BuildFinishedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.ProjectStarted">
            <summary>
            Raised for ProjectStartedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.ProjectFinished">
            <summary>
            Raised for ProjectFinishedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.TargetStarted">
            <summary>
            Raised for TargetStartedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.TargetFinished">
            <summary>
            Raised for TargetFinishedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.TaskStarted">
            <summary>
            Raised for TaskStartedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.TaskFinished">
            <summary>
            Raised for TaskFinishedEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.ErrorRaised">
            <summary>
            Raised for BuildErrorEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.WarningRaised">
            <summary>
            Raised for BuildWarningEventArgs instances
            </summary>
        </member>
        <member name="E:Microsoft.Build.Logging.EventArgsDispatcher.MessageRaised">
            <summary>
            Raised for BuildMessageEventArgs instances
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.EventArgsDispatcher.Dispatch(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Raise one of the events that is appropriate for the type of the BuildEventArgs
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.BuildEventArgsFieldFlags">
            <summary>
            A bitmask to specify which fields on a BuildEventArgs object are present; used in serialization
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.BuildEventArgsFields">
            <summary>
            Represents a collective set of common properties on BuildEventArgs. Used for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.BuildEventArgsReader">
            <summary>
            Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BuildEventArgsReader.#ctor(System.IO.BinaryReader,System.Int32)">
            <summary>
            Initializes a new instance of BuildEventArgsReader using a BinaryReader instance
            </summary>
            <param name="binaryReader">The BinaryReader to read BuildEventArgs from</param>
            <param name="fileFormatVersion">The file format version of the log file being read.</param>
        </member>
        <member name="E:Microsoft.Build.Logging.BuildEventArgsReader.OnBlobRead">
            <summary>
            Raised when the log reader encounters a binary blob embedded in the stream.
            The arguments include the blob kind and the byte buffer with the contents.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BuildEventArgsReader.Read">
            <summary>
            Reads the next log record from the binary reader. If there are no more records, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BuildEventArgsReader.IsBlob(Microsoft.Build.Logging.BinaryLogRecordKind)">
            <summary>
            For now it's just the ProjectImportArchive.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BuildEventArgsReader.ReadDiagnosticFields(Microsoft.Build.Logging.BuildEventArgsFields)">
            <summary>
            For errors and warnings these 8 fields are written out explicitly
            (their presence is not marked as a bit in the flags). So we have to
            read explicitly.
            </summary>
            <param name="fields"></param>
        </member>
        <member name="T:Microsoft.Build.Logging.BuildEventArgsWriter">
            <summary>
            Serializes BuildEventArgs-derived objects into a provided BinaryWriter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.BuildEventArgsWriter.#ctor(System.IO.BinaryWriter)">
            <summary>
            Initializes a new instance of BuildEventArgsWriter with a BinaryWriter
            </summary>
            <param name="binaryWriter">A BinaryWriter to write the BuildEventArgs instances to</param>
        </member>
        <member name="M:Microsoft.Build.Logging.BuildEventArgsWriter.Write(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Write a provided instance of BuildEventArgs to the BinaryWriter
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.ProjectImportsCollector">
            <summary>
            Creates a zip archive with all the .csproj and .targets encountered during the build.
            The internal .zip file structure matches closely the layout of the original sources on disk.
            The .zip file can be used to correlate the file names and positions in the build log file with the
            actual sources.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ProjectImportsCollector._processedFiles">
            <summary>
            Avoid visiting each file more than once.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ProjectImportsCollector.AddFileCore(System.String)">
            <remarks>
            This method doesn't need locking/synchronization because it's only called
            from a task that is chained linearly
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Logging.ProjectImportsCollector.AddFileFromMemoryCore(System.String,System.String)">
            <remarks>
            This method doesn't need locking/synchronization because it's only called
            from a task that is chained linearly
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Logging.WriteHandler">
            <summary>
            Delegate to use for writing a string to some location like
            the console window or the IDE build window.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Microsoft.Build.Logging.ColorSetter">
            <summary>
            Type of delegate used to set console color.
            </summary>
            <param name="color">Text color</param>
        </member>
        <member name="T:Microsoft.Build.Logging.ColorResetter">
            <summary>
            Type of delegate used to reset console color.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.ConsoleLogger">
            <summary>
            This class implements the default logger that outputs event data
            to the console (stdout). 
            It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger, 
            either SerialConsoleLogger or ParallelConsoleLogger.
            </summary>
            <remarks>This class is not thread safe.</remarks>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.#ctor(Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Create a logger instance with a specific verbosity.  This logs to
            the default console.
            </summary>
            <param name="verbosity">Verbosity level.</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.#ctor(Microsoft.Build.Framework.LoggerVerbosity,Microsoft.Build.Logging.WriteHandler,Microsoft.Build.Logging.ColorSetter,Microsoft.Build.Logging.ColorResetter)">
            <summary>
            Initializes the logger, with alternate output handlers.
            </summary>
            <param name="verbosity"></param>
            <param name="write"></param>
            <param name="colorSet"></param>
            <param name="colorReset"></param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.InitializeBaseConsoleLogger">
            <summary>
            This is called by every event handler for compat reasons -- see DDB #136924
            However it will skip after the first call
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ConsoleLogger.Verbosity">
            <summary>
            Gets or sets the level of detail to show in the event log.
            </summary>
            <value>Verbosity level.</value>
        </member>
        <member name="P:Microsoft.Build.Logging.ConsoleLogger.Parameters">
            <summary>
            A semi-colon delimited list of "key[=value]" parameter pairs.
            </summary>
            <value>null</value>
        </member>
        <member name="P:Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText">
            <summary>
            Suppresses the display of project headers. Project headers are
            displayed by default unless this property is set.
            </summary>
            <remarks>This is only needed by the IDE logger.</remarks>
        </member>
        <member name="P:Microsoft.Build.Logging.ConsoleLogger.ShowSummary">
            <summary>
            Suppresses the display of error and warnings summary.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ConsoleLogger.WriteHandler">
            <summary>
            Provide access to the write hander delegate so that it can be redirected
            if necessary (e.g. to a file)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.ApplyParameter(System.String,System.String)">
            <summary>
            Apply a parameter.
            NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has 
            no good reason for being public.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Signs up the console logger for all build events.
            </summary>
            <param name="eventSource">Available events.</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            Initializes the logger.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.Shutdown">
            <summary>
            The console logger does not need to release any resources.
            This method does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Handler for build started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Handler for build finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Handler for project started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Handler for project finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs)">
            <summary>
            Handler for target started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Handler for target finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs)">
            <summary>
            Handler for task started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs)">
            <summary>
            Handler for task finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.ErrorHandler(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Prints an error event
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.WarningHandler(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Prints a warning event
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.MessageHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Prints a message event
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Prints a custom event
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.DistributedFileLogger">
            <summary>
            This class will create a text file which will contain the build log for that node
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.DistributedFileLogger.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            Initializes the logger.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.DistributedFileLogger.ParseFileLoggerParameters">
            <summary>
            Parses out the logger parameters from the Parameters string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.DistributedFileLogger.ApplyFileLoggerParameter(System.String,System.String)">
            <summary>
            Apply a parameter
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Initializes the logger.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.DistributedFileLogger.Shutdown">
            <summary>
            Instructs the logger to shut down.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector">
            <summary>
            Gets or sets the <see cref="T:Microsoft.Build.Framework.IEventRedirector"/> object used to redirect build events.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.DistributedFileLogger.NodeId">
            <summary>
            Gets or sets the identifier of the node which the forwarding logger is attached to.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.DistributedFileLogger.Verbosity">
            <summary>
            Gets or sets <see cref="T:Microsoft.Build.Framework.LoggerVerbosity"/>.  This is currently hard-coded as <see cref="F:Microsoft.Build.Framework.LoggerVerbosity.Detailed"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.DistributedFileLogger.Parameters">
            <summary>
            Gets or sets the parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.ConfigurableForwardingLogger">
            <summary>
            Logger that forwards events to a central logger (e.g ConsoleLogger)
            residing on the parent node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity">
            <summary>
            Gets or sets the level of detail to show in the event log.
            </summary>
            <value>Verbosity level.</value>
        </member>
        <member name="P:Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters">
            <summary>
            The console logger takes a single parameter to suppress the output of the errors
            and warnings summary at the end of a build.
            </summary>
            <value>null</value>
        </member>
        <member name="P:Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector">
            <summary>
            This property is set by the build engine to allow a node loggers to forward messages to the
            central logger
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId">
            <summary>
            The identifier of the node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.InitializeForwardingTable">
            <summary>
            Initialize the Forwarding Table with the default values
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.ParseParameters">
            <summary>
            Parses out the logger parameters from the Parameters string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.ApplyParameter(System.String)">
            <summary>
            Logger parameters can be used to enable and disable specific event types.
            Otherwise, the verbosity is used to choose which events to forward.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Signs up the console logger for all build events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            Signs up the console logger for all build events.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.ResetLoggerState">
            <summary>
            Reset the states of per-build member variables.
            Used when a build is finished, but the logger might be needed for the next build.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown">
            <summary>
            Called when Engine is done with this logger
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs)">
            <summary>
            Handler for build started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs)">
            <summary>
            Handler for build finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs)">
            <summary>
            Handler for project started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs)">
            <summary>
            Handler for project finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs)">
            <summary>
            Handler for target started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs)">
            <summary>
            Handler for target finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs)">
            <summary>
            Handler for task started events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs)">
            <summary>
            Handler for task finished events
            </summary>
            <param name="sender">sender (should be null)</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.ErrorHandler(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs)">
            <summary>
            Prints an error event
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.WarningHandler(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs)">
            <summary>
            Prints a warning event
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.MessageHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs)">
            <summary>
            Prints a message event
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs)">
            <summary>
            Prints a custom event
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs)">
            <summary>
            Forwards the specified event.
            </summary>
            <param name="e">The <see cref="T:Microsoft.Build.Framework.BuildEventArgs"/> to forward.</param>
        </member>
        <member name="M:Microsoft.Build.Logging.ConfigurableForwardingLogger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Determines whether the current verbosity setting is at least the value
            passed in.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._verbosity">
            <summary>
            Controls the amount of text displayed by the logger
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._loggerParameters">
            <summary>
            Console logger parameters.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger.s_parameterDelimiters">
            <summary>
            Console logger parameters delimiters.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildStartedEventDescription">
            <summary>
            Strings that users of this logger can pass in to enable specific events or logger output.
            Also used as keys into our dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._forwardingTable">
            <summary>
            A table indicating if a particular event type should be forwarded
            The value is type int rather than bool to avoid the problem of JITting generics.
            <see cref="T:System.Collections.Generic.Dictionary`2" /> is already compiled into mscorlib.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._buildEventRedirector">
            <summary>
            A pointer to the central logger
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._forwardingSetFromParameters">
            <summary>
            Indicates if the events to forward are being set by the parameters sent to the logger
            if this is false the events to forward are based on verbosity else verbosity settings will be ignored
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._showSummary">
            <summary>
            Console logger should show error and warning summary at the end of build?
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._showPerfSummary">
            <summary>
            When true, accumulate performance numbers.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._showCommandLine">
            <summary>
            When true the commandline message is sent
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.ConfigurableForwardingLogger._nodeId">
            <summary>
            Id of the node the logger is attached to
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.LoggerDescription">
            <summary>
            This class is used to contain information about a logger as a collection of values that
            can be used to instantiate the logger and can be serialized to be passed between different
            processes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.#ctor(System.String,System.String,System.String,System.String,Microsoft.Build.Framework.LoggerVerbosity)">
            <summary>
            Creates a logger description from given data
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.#ctor(System.String,System.String,System.String,System.String,Microsoft.Build.Framework.LoggerVerbosity,System.Boolean)">
            <summary>
            Creates a logger description from given data
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.LoggerDescription.LoggerId">
            <summary>
            This property exposes the logger id which identifies each distributed logger uniquiely
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.LoggerDescription.Name">
            <summary>
            This property generates the logger name by appending together the class name and assembly name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.LoggerDescription.LoggerSwitchParameters">
            <summary>
            Returns the string of logger parameters, null if there are none
            </summary>
        </member>
        <member name="P:Microsoft.Build.Logging.LoggerDescription.Verbosity">
            <summary>
            Return the verbosity for this logger (from command line all loggers get same verbosity)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.CreateForwardingLogger">
            <summary>
            Create an IForwardingLogger out of the data in this description. This method may throw a variety of
            reflection exceptions if the data is invalid. It is the resposibility of the caller to handle these
            exceptions if desired.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.CreateLogger">
            <summary>
            Create an ILogger out of the data in this description. This method may throw a variety of
            reflection exceptions if the data is invalid. It is the resposibility of the caller to handle these
            exceptions if desired.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.CreateLogger(System.Boolean)">
            <summary>
            Loads a logger from its assembly, instantiates it, and handles errors.
            </summary>
            <returns>Instantiated logger.</returns>
        </member>
        <member name="F:Microsoft.Build.Logging.LoggerDescription.s_forwardingLoggerClassFilter">
            <summary>
            Used for finding loggers when reflecting through assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.LoggerDescription.s_loggerClassFilter">
            <summary>
            Used for finding loggers when reflecting through assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.IsForwardingLoggerClass(System.Type,System.Object)">
            <summary>
            Checks if the given type is a logger class.
            </summary>
            <remarks>This method is used as a Type Filter delegate.</remarks>
            <returns>true, if specified type is a logger</returns>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.IsLoggerClass(System.Type,System.Object)">
            <summary>
            Checks if the given type is a logger class.
            </summary>
            <remarks>This method is used as a TypeFilter delegate.</remarks>
            <returns>true, if specified type is a logger</returns>
        </member>
        <member name="M:Microsoft.Build.Logging.LoggerDescription.ConvertPathsToFullPaths">
            <summary>
            Converts the path to the logger assembly to a full path
            </summary>
        </member>
        <member name="T:Microsoft.Build.Logging.FileLogger">
            <summary>
            A specialization of the ConsoleLogger that logs to a file instead of the console.
            The output in terms of what is written and how it looks is identical. For example you can 
            log verbosely to a file using the FileLogger while simultaneously logging only high priority events
            to the console using a ConsoleLogger.
            </summary>
            <remarks>
            It's unfortunate that this is derived from ConsoleLogger, which is itself a facade; it makes things more
            complex -- for example, there is parameter parsing in this class, plus in BaseConsoleLogger. However we have
            to derive FileLogger from ConsoleLogger because it shipped that way in Whidbey.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource)">
            <summary>
            Signs up the console file logger for all build events.
            This is the backward-compatible overload.
            </summary>
            <param name="eventSource">Available events.</param>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.InitializeFileLogger(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            Creates new file for logging
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32)">
            <summary>
            Multiproc aware initialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.Write(System.String)">
            <summary>
            The handler for the write delegate of the console logger we are deriving from.
            </summary>
            <param name="text">The text to write to the log</param>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.Shutdown">
            <summary>
            Shutdown method implementation of ILogger - we need to flush and close our logfile.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.ParseFileLoggerParameters">
            <summary>
            Parses out the logger parameters from the Parameters string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Logging.FileLogger.ApplyFileLoggerParameter(System.String,System.String)">
            <summary>
            Apply a parameter parsed by the file logger.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.FileLogger._logFileName">
            <summary>
            logFileName is the name of the log file that we will generate
            the default value is msbuild.log
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.FileLogger._fileWriter">
            <summary>
            fileWriter is the stream that has been opened on our log file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.FileLogger._append">
            <summary>
            Whether the logger should append to any existing file.
            Default is to overwrite.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.FileLogger._autoFlush">
            <summary>
            Whether the logger should flush aggressively to disk.
            Default is true. This preserves the most information in the case
            of a crash, but may slow the logger down.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.FileLogger._encoding">
            <summary>
            Encoding for the output. Defaults to UTF-8.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.FileLogger.s_fileLoggerParameterDelimiters">
            <summary>
            File logger parameters delimiters.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Logging.FileLogger.s_fileLoggerParameterValueSplitCharacter">
            <summary>
            File logger parameter value split character.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ImplicitImportLocation">
            <summary>
            Represents the location of an implicit import.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ImplicitImportLocation.None">
            <summary>
            The import is not implicitly added and is explicitly added in a user-specified location.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ImplicitImportLocation.Top">
            <summary>
            The import was implicitly added at the top of the project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ImplicitImportLocation.Bottom">
            <summary>
            The import was implicitly added at the bottom of the project.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectSdkElement">
            <summary>
                ProjectSdkElement represents the Sdk element within the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectSdkElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectSdkElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
                Initialize a parented ProjectSdkElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectSdkElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
                Initialize an non-parented ProjectSdkElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectSdkElement.Name">
            <summary>
            Gets or sets the name of the SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectSdkElement.Version">
            <summary>
            Gets or sets the version of the SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion">
            <summary>
            Gets or sets the minimum version of the SDK required to build the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectSdkElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectSdkElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectSdkElement.CreateDisconnected(System.String,System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
                Creates a non-parented ProjectSdkElement, wrapping an non-parented XmlElement.
                Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.SolutionProjectGenerator">
            <summary>
            This class is used to generate an MSBuild wrapper project for a solution file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator.SolutionPathPropertyName">
            <summary>
            Name of the property used to store the path to the solution being built.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator.WebProjectOverrideFolder">
            <summary>
            The path node to add in when the output directory for a website is overridden.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator.SolutionProperties">
            <summary>
            The set of properties all projects in the solution should be built with
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator.SolutionConfigurationAndPlatformProperties">
            <summary>
            The set of properties which identify the configuration and platform to build a project with
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._defaultTargetNames">
            <summary>
            A known list of target names to create.  This is for backwards compatibility.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._version20">
            <summary>
            Version 2.0
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._version40">
            <summary>
            Version 4.0
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._metaprojectGlobalProperties">
            <summary>
            The list of global properties we set on each metaproject and which get passed to each project when building.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._solutionFile">
            <summary>
            The SolutionFile containing information about the solution we're generating a wrapper for.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._globalProperties">
            <summary>
            The global properties passed under which the project should be opened. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._toolsVersionOverride">
            <summary>
            The ToolsVersion passed on the commandline, if any.  May be null.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._projectBuildEventContext">
            <summary>
            The context of this build (used for logging purposes). 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._loggingService">
            <summary>
            The LoggingService used to log messages.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._targetNames">
            <summary>
            The list of targets specified to use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._selectedSolutionConfiguration">
            <summary>
            The solution configuration selected for this build.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._sdkResolverService">
            <summary>
            The <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> to use.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectGenerator._submissionId">
            <summary>
            The current build submission ID.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.#ctor(Microsoft.Build.Construction.SolutionFile,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.BackEnd.Logging.ILoggingService,System.Collections.Generic.IReadOnlyCollection{System.String},Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.Generate(Microsoft.Build.Construction.SolutionFile,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Framework.BuildEventContext,Microsoft.Build.BackEnd.Logging.ILoggingService,System.Collections.Generic.IReadOnlyCollection{System.String},Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService,System.Int32)">
            <summary>
            This method generates an MSBuild project file from the list of projects and project dependencies 
            that have been collected from the solution file.
            </summary>
            <param name="solution">The parser which contains the solution file.</param>
            <param name="globalProperties">The global properties.</param>
            <param name="toolsVersionOverride">Tools Version override (may be null).  This should be any tools version explicitly passed to the command-line or from an MSBuild ToolsVersion parameter.</param>
            <param name="projectBuildEventContext">The logging context for this project.</param>
            <param name="loggingService">The logging service.</param>
            <param name="targetNames">A collection of target names the user requested to be built.</param>
            <param name="sdkResolverService">An <see cref="T:Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService"/> to use.</param>
            <param name="submissionId">The current build submission ID.</param>
            <returns>An array of ProjectInstances.  The first instance is the traversal project, the remaining are the metaprojects for each project referenced in the solution.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.SolutionFile,Microsoft.Build.Construction.SolutionConfigurationInSolution)">
            <summary>
            Adds a new property group with contents of the given solution configuration to the project
            Internal for unit-testing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddErrorWarningMessageElement(Microsoft.Build.Construction.ProjectTargetElement,System.String,System.Boolean,System.String,System.Object[])">
            <summary>
            Add a new error/warning/message tag into the given target
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.PredictActiveSolutionConfigurationName(Microsoft.Build.Construction.SolutionFile,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Normally the active solution configuration/platform is determined when we build the solution
            wrapper project, not when we create it. However, we need to know them to scan project references
            for the right project configuration/platform. It's unlikely that references would be conditional, 
            but still possible and we want to get that case right.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetMetaprojectName(System.String)">
            <summary>
            Returns the name of the metaproject for an actual project.
            </summary>
            <param name="fullPathToProject">The full path to the actual project</param>
            <returns>The metaproject path name</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.DetermineWrapperProjectToolsVersion(System.String,System.Boolean@)">
            <summary>
            Figure out what tools version to build the solution wrapper project with. If a /tv
            switch was passed in, use that; otherwise fall back to the default (12.0).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddTasksToCopyAllDependenciesIntoBinDir(Microsoft.Build.Execution.ProjectTargetInstance,Microsoft.Build.Construction.ProjectInSolution,System.String,System.String)">
            <summary>
            Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced 
            assemblies for the complete list of dependencies, PDBs, satellites, etc.  The invoke
            the Copy task to copy all these files (or at least the ones that RAR determined should
            be copied local) into the web project's bin directory.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddTasksToResolveAutoRefreshFileReferences(Microsoft.Build.Execution.ProjectTargetInstance,Microsoft.Build.Construction.ProjectInSolution,System.String)">
            <summary>
            This code handles the *.REFRESH files that are in the "bin" subdirectory of 
            a web project.  These .REFRESH files are just text files that contain absolute or 
            relative paths to the referenced assemblies.  The goal of these tasks is to 
            search all *.REFRESH files and extract fully-qualified absolute paths for 
            each of the references.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddMSBuildTaskInstance(Microsoft.Build.Execution.ProjectTargetInstance,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Adds an MSBuild task to the specified target
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GenerateSafePropertyName(Microsoft.Build.Construction.ProjectInSolution,System.String)">
            <summary>
            Takes a project in the solution and a base property name, and creates a new property name
            that can safely be used as an XML element name, and is also unique to that project (by
            embedding the project's GUID into the property name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.MakeIntoSafeItemName(System.String)">
            <summary>
            Makes a legal item name from a given string by replacing invalid characters with '_'
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddErrorWarningMessageInstance(Microsoft.Build.Execution.ProjectTargetInstance,System.String,System.String,System.Boolean,System.String,System.Object[])">
            <summary>
            Add a new error/warning/message tag into the given target
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetConditionStringForConfiguration(Microsoft.Build.Construction.SolutionConfigurationInSolution)">
            <summary>
            A helper method for constructing conditions for a solution configuration
            </summary>
            <remarks>
            Sample configuration condition:
            '$(Configuration)' == 'Release' and '$(Platform)' == 'Any CPU'
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.DetermineLikelyActiveSolutionConfiguration(Microsoft.Build.Construction.SolutionFile,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Figure out what solution configuration we are going to build, whether or not it actually exists in the solution
            file.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.WouldProjectBuild(Microsoft.Build.Construction.SolutionFile,System.String,Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Construction.ProjectConfigurationInSolution)">
            <summary>
            Returns true if the specified project will build in the currently selected solution configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.Generate">
            <summary>
            Private method: generates an MSBuild wrapper project for the solution passed in; the MSBuild wrapper
            project to be generated is the private variable "msbuildProject" and the SolutionFile containing information
            about the solution is the private variable "solutionFile"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.CreateSolutionProject(System.String,System.Boolean)">
            <summary>
            Given a parsed solution, generate a top level traversal project and the metaprojects representing the dependencies for each real project
            referenced in the solution.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.EvaluateAndAddProjects(System.Collections.Generic.List{Microsoft.Build.Construction.ProjectInSolution},System.Collections.Generic.List{Microsoft.Build.Execution.ProjectInstance},Microsoft.Build.Execution.ProjectInstance,System.String)">
            <summary>
            Examine each project in the solution, add references and targets for it, and create metaprojects if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddStandardTraversalTargets(Microsoft.Build.Execution.ProjectInstance,System.Collections.Generic.List{Microsoft.Build.Construction.ProjectInSolution})">
            <summary>
            Adds the standard targets to the traversal project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.CreateTraversalInstance(System.String,System.Boolean,System.Collections.Generic.List{Microsoft.Build.Construction.ProjectInSolution})">
            <summary>
            Creates the traversal project instance.  This has all of the properties against which we can perform evaluations for the remainder of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddProjectReference(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Construction.ProjectConfigurationInSolution,System.Boolean)">
            <summary>
            This method adds a new ProjectReference item to the specified instance.  The reference will either be to its metaproject (if the project
            is a web project or has reference of its own) or to the project itself (if it has no references and is a normal MSBuildable project.)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetToolsVersionMetadataForDirectMSBuildTask(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            The value to be passed to the ToolsVersion attribute of the MSBuild task used to directly build a project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetToolsVersionAttributeForDirectMSBuildTask">
            <summary>
            The value to be passed to the ToolsVersion attribute of the MSBuild task used to directly build a project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetPropertiesMetadataForProjectReference(Microsoft.Build.Execution.ProjectInstance,System.String)">
            <summary>
            The value to be assigned to the metadata for a particular project reference.  Contains only configuration and platform specified in the project configuration, evaluated.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetConfigurationAndPlatformPropertiesString(Microsoft.Build.Construction.ProjectConfigurationInSolution)">
            <summary>
            Gets the project configuration and platform values as an attribute string for an MSBuild task used to build the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetPropertiesAttributeForDirectMSBuildTask(Microsoft.Build.Construction.ProjectConfigurationInSolution)">
            <summary>
            The value to be passed to the Properties attribute of the MSBuild task to build a specific project.  Contains reference to project configuration and
            platform as well as the solution configuration bits.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.CanBuildDirectly(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Construction.ProjectConfigurationInSolution)">
            <summary>
            Returns true if the specified project can be built directly, without using a metaproject.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.CreateMetaproject(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Construction.ProjectConfigurationInSolution)">
            <summary>
            Produces a set of targets which allows the MSBuild scheduler to schedule projects in the order automatically by 
            following their dependencies without enforcing build levels.
            </summary>
            <remarks>
            We want MSBuild to be able to parallelize the builds of these projects where possible and still honor references.
            Since the project files referenced by the solution do not (necessarily) themselves contain actual project references
            to the projects they depend on, we need to synthesize this relationship ourselves.  This is done by creating a target
            which first invokes the project's dependencies, then invokes the actual project itself.  However, invoking the 
            dependencies must also invoke their dependencies and so on down the line.  
            
            Additionally, we do not wish to create a separate MSBuild project to contain this target yet we want to parallelize
            calls to these targets.  The way to do this is to pass in different global properties to the same project in the same
            MSBuild call.  MSBuild easily allows this using the AdditionalProperties metadata which can be specified on an Item.
            
            Assuming the solution project we are generating is called "foo.proj", we can accomplish this parallelism as follows:
            <ItemGroup>
                <ProjectReference Include="Project0"/>
                <ProjectReference Include="Project1"/>
                <ProjectReference Include="Project2"/>
            </ItemGroup>
            
            We now have expressed the top level reference to all projects as @(SolutionReference) and each project's
            set of references as @(PROJECTNAMEReference).  We construct our target as:
            
            <Target Name="Build">
                <MSBuild Projects="@(ProjectReference)" Targets="Build" />
                <MSBuild Projects="actualProjectName" Targets="Build" />
            </Target>
            
            The first MSBuild call re-invokes the solution project instructing it to build the reference projects for the
            current project.  The second MSBuild call invokes the actual project itself.  Because all reference projects have
            the same additional properties, MSBuild will only build the first one it comes across and the rest will be
            satisfied from the cache.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetMetaprojectName(Microsoft.Build.Construction.ProjectInSolution)">
            <summary>
            Returns the metaproject name for a given project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddMetaprojectReferenceItems(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution)">
            <summary>
            Adds a set of items which describe the references for this project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddMetaprojectTargetForManagedProject(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Construction.ProjectConfigurationInSolution,System.String,System.String)">
            <summary>
            Adds the targets which build the dependencies and actual project for a metaproject.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddProjectBuildTask(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectConfigurationInSolution,Microsoft.Build.Execution.ProjectTargetInstance,System.String,System.String,System.String,System.String)">
            <summary>
            Adds an MSBuild task to a real project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddMetaprojectBuildTask(Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Execution.ProjectTargetInstance,System.String,System.String)">
            <summary>
            Adds an MSBuild task to a single metaproject.  This is used in the traversal project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddMetaprojectTargetForWebProject(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,System.String)">
            <summary>
            Add a target for a Venus project into the XML doc that's being generated.  This
            target will call the AspNetCompiler task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddTaskForAspNetCompiler(Microsoft.Build.Execution.ProjectTargetInstance,Microsoft.Build.Construction.ProjectInSolution,System.String)">
            <summary>
            Helper method to add a call to the AspNetCompiler task into the given target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddResolveProjectReferenceTasks(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectTargetInstance,Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Construction.SolutionConfigurationInSolution,System.String,System.String@)">
            <summary>
            Adds MSBuild tasks to a project target to pre-resolve its project references
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddPropertyGroupForAspNetConfiguration(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,System.String,Microsoft.Build.Construction.AspNetCompilerParameters,System.String)">
            <summary>
            Add a PropertyGroup to the project for a particular Asp.Net configuration.  This PropertyGroup
            will have the correct values for all the Asp.Net properties for this project and this configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.ComputeTargetConditionForWebProject(Microsoft.Build.Construction.ProjectInSolution)">
            <summary>
            When adding a target to build a web project, we want to put a Condition on the Target node that
            effectively says "Only build this target if the web project is active (marked for building) in the 
            current solution configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddTargetForGetFrameworkPathAndRedistList(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Add a target to the project called "GetFrameworkPathAndRedistList".  This target calls the
            GetFrameworkPath task and then CreateItem to populate @(_CombinedTargetFrameworkDirectoriesItem) and
            @(InstalledAssemblyTables), so that we can pass these into the ResolveAssemblyReference task
            when building web projects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddMetaprojectTargetForUnknownProjectType(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,System.String,System.String)">
            <summary>
            Adds a target for a project whose type is unknown and we cannot build.  We will emit an error or warning as appropriate.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddValidateProjectsTarget(Microsoft.Build.Execution.ProjectInstance,System.Collections.Generic.List{Microsoft.Build.Construction.ProjectInSolution})">
            <summary>
            Adds a target which verifies that all of the project references and configurations are valid.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddTraversalReferencesTarget(Microsoft.Build.Execution.ProjectInstance,System.String,System.String)">
            <summary>
             Creates the target used to build all of the references in the traversal project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddReferencesBuildTask(Microsoft.Build.Execution.ProjectTargetInstance,System.String,System.String)">
            <summary>
            Adds a task which builds the @(ProjectReference) items.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddTraversalTargetForProject(Microsoft.Build.Execution.ProjectInstance,Microsoft.Build.Construction.ProjectInSolution,Microsoft.Build.Construction.ProjectConfigurationInSolution,System.String,System.String,System.Boolean)">
            <summary>
            Adds a traversal target which invokes a specified target on a single project.  This creates targets called "Project", "Project:Rebuild", "Project:Clean", "Project:Publish" etc.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.GetMetaprojectGlobalProperties(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Retrieves a dictionary representing the global properties which should be transferred to a metaproject.
            </summary>
            <param name="traversalProject">The traversal from which the global properties should be obtained.</param>
            <returns>A dictionary of global properties.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.DetermineChildProjectToolsVersion(System.String)">
            <summary>
            Figures out what the ToolsVersion should be for child projects (used when scanning
            for dependencies)
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.PredictActiveSolutionConfigurationName">
            <summary>
            Normally the active solution configuration/platform is determined when we build the solution
            wrapper project, not when we create it. However, we need to know them to scan project references
            for the right project configuration/platform. It's unlikely that references would be conditional, 
            but still possible and we want to get that case right.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.ScanProjectDependencies(System.String,System.String)">
            <summary>
            Loads each MSBuild project in this solution and looks for its project-to-project references so that
            we know what build order we should use when building the solution. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddDependencyByGuid(Microsoft.Build.Construction.ProjectInSolution,System.String)">
            <summary>
            Adds a dependency to the project based on the specified guid string.
            </summary>
            <remarks>
            If the string is null or empty, no dependency is added and this is not considered an error.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddConfigurationPlatformDefaults(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates default Configuration and Platform values based on solution configurations present in the solution
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.SolutionConfigurationInSolution)">
            <summary>
            Adds a new property group with contents of the given solution configuration to the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddVenusConfigurationDefaults(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates the default Venus configuration property based on the selected solution configuration.
            Unfortunately, Venus projects only expose one project configuration in the IDE (Debug) although
            they allow building Debug and Release from command line. This means that if we wanted to use 
            the project configuration from the active solution configuration for Venus projects, we'd always
            end up with Debug and there'd be no way to build the Release configuration. To work around this,
            we use a special mechanism for choosing ASP.NET project configuration: we set it to Release if
            we're building a Release solution configuration, and to Debug if we're building a Debug solution 
            configuration. The property is also settable from the command line, in which case it takes 
            precedence over this algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddGlobalProperties(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Adds solution related build event macros and other global properties to the wrapper project
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddFakeReleaseSolutionConfigurationIfNecessary">
            <summary>
            Special hack for web projects. It can happen that there is no Release configuration for solutions
            containing web projects, yet we still want to be able to build the Release configuration for 
            those projects. Since the ASP.NET project configuration defaults to the solution configuration,
            we allow Release even if it doesn't actually exist in the solution.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddInitialTargets(Microsoft.Build.Execution.ProjectInstance,System.Collections.Generic.List{Microsoft.Build.Construction.ProjectInSolution})">
            <summary>
            Adds the initial target to the solution wrapper project, necessary for a few message/error tags
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddValidateSolutionConfigurationTarget(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Adds the target which validates that the solution configuration specified by the user is supported.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddValidateToolsVersionsTarget(Microsoft.Build.Execution.ProjectInstance)">
            <summary>
            Adds the target which validates that the tools version is supported.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionProjectGenerator.AddGetSolutionConfigurationContentsTarget(Microsoft.Build.Execution.ProjectInstance)">
            <summary> Adds the target to fetch solution configuration contents for given configuration|platform combo. </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectElement">
            <summary>
            Abstract base class for MSBuild construction object model elements. 
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectElement._parent">
            <summary>
            Parent container object.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectElement._condition">
            <summary>
            Condition value cached for performance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.#ctor">
            <summary>
            Constructor called by ProjectRootElement only.
            XmlElement is set directly after construction.
            </summary>
            <comment>
            Should be protected+internal.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Constructor called by derived classes, except from ProjectRootElement.
            Parameters may not be null, except parent.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.ExpressedAsAttribute">
            <summary>
            Allows data (for example, item metadata) to be represented as an attribute on the parent element instead of as a child element.
            </summary>
            <remarks>
            If this is true, then the <see cref="P:Microsoft.Build.Construction.ProjectElement.XmlElement"/> will still be used to hold the data for this (pseudo) ProjectElement, but
            it will not be added to the Xml tree.  
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.Condition">
            <summary>
            Gets or sets the Condition value. 
            It will return empty string IFF a condition attribute is legal but it’s not present or has no value. 
            It will return null IFF a Condition attribute is illegal on that element.
            Removes the attribute if the value to set is empty.
            It is possible for derived classes to throw an <see cref="T:System.InvalidOperationException"/> if setting the condition is
            not applicable for those elements.
            </summary>
            <example> For the "ProjectExtensions" element, the getter returns null and the setter
            throws an exception for any value. </example>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.Label">
            <summary>
            Gets or sets the Label value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.Parent">
            <summary>
            Null if this is a ProjectRootElement.
            Null if this has not been attached to a parent yet.
            </summary>
            <remarks>
            Parent should only be set by ProjectElementContainer.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.OuterElement">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.AllParents">
            <summary>
            All parent elements of this element, going up to the ProjectRootElement.
            None if this itself is a ProjectRootElement.
            None if this itself has not been attached to a parent yet.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.PreviousSibling">
            <summary>
            Previous sibling element.
            May be null.
            </summary>
            <remarks>
            Setter should ideally be "protected AND internal"
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.NextSibling">
            <summary>
            Next sibling element.
            May be null.
            </summary>
            <remarks>
            Setter should ideally be "protected AND internal"
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.ContainingProject">
            <summary>
            ProjectRootElement (possibly imported) that contains this Xml.
            Cannot be null.
            </summary>
            <remarks>
            Setter ideally would be "protected and internal"
            There are some tricks here in order to save the space of a field: there are a lot of these objects.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.ConditionLocation">
            <summary>
            Location of the "Condition" attribute on this element, if any.
            If there is no such attribute, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.LabelLocation">
            <summary>
            Location of the "Label" attribute on this element, if any.
            If there is no such attribute, returns null;
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.Location">
            <summary>
            Location of the corresponding Xml element.
            May not be correct if file is not saved, or 
            file has been edited since it was last saved.
            In the case of an unsaved edit, the location only
            contains the path to the file that the element originates from.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.ElementName">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.Microsoft#Build#ObjectModelRemoting#ILinkableObject#Link">
            <summary>
            <see cref="P:Microsoft.Build.ObjectModelRemoting.ILinkableObject.Link"/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.XmlElement">
            <summary>
            Gets the XmlElement associated with this project element.
            The setter is used when adding new elements.
            Never null except during load or creation.
            </summary>
            <remarks>
            This should be protected, but "protected internal" means "OR" not "AND",
            so this is not possible.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.XmlDocument">
            <summary>
            Gets the XmlDocument associated with this project element.
            </summary>
            <remarks>
            Never null except during load or creation.
            This should be protected, but "protected internal" means "OR" not "AND",
            so this is not possible.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.Clone">
            <summary>
            Returns a shallow clone of this project element.
            </summary>
            <returns>The cloned element.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Applies properties from the specified type to this instance.
            </summary>
            <param name="element">The element to act as a template to copy from.</param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.ShouldCloneXmlAttribute(System.Xml.XmlAttribute)">
            <summary>
            Hook for subclasses to specify whether the given <param name="attribute"></param> should be cloned or not
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.SetProjectRootElementFromParser(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Called only by the parser to tell the ProjectRootElement its backing XmlElement and its own parent project (itself)
            This can't be done during construction, as it hasn't loaded the document at that point and it doesn't have a 'this' pointer either.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.ClearParent">
            <summary>
            Called by ProjectElementContainer to clear the parent when
            removing an element from its parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.ReplaceElement(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Called by a DERIVED CLASS to indicate its XmlElement has changed.
            This normally shouldn't happen, so it's broken out into an explicit method.
            An example of when it has to happen is when an item's type is changed.
            We trust the caller to have fixed up the XmlDocument properly.
            We ASSUME that attributes were copied verbatim. If this is not the case,
            any cached attribute values would have to be cleared.
            If the new element is actually the existing element, does nothing, and does
            not mark the project dirty.
            </summary>
            <remarks>
            This should be protected, but "protected internal" means "OR" not "AND",
            so this is not possible.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.MarkDirty(System.String,System.String)">
            <summary>
            Marks this element as dirty.
            The default implementation simply marks the parent as dirty.
            If there is no parent, because the element has not been parented, do nothing. The parent
            will be dirtied when the element is added.
            Accepts a reason for debugging purposes only, and optional reason parameter.
            </summary>
            <comment>
            Should ideally be protected+internal.
            </comment>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.OnAfterParentChanged(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Called after a new parent is set. Parent may be null.
            By default does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.Clone(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Returns a shallow clone of this project element.
            </summary>
            <param name="factory">The factory to use for creating the new instance.</param>
            <returns>The cloned element.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Returns a new instance of this same type.
            Any properties that cannot be set after creation should be set to copies of values
            as set for this instance.
            </summary>
            <param name="owner">The factory to use for creating the new instance.</param>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectElement.WrapperForProjectRootElement">
            <summary>
            Special derived variation of ProjectElementContainer used to wrap a ProjectRootElement.
            This is part of a trick used in ProjectElement to avoid using a separate field for the containing PRE.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.WrapperForProjectRootElement.#ctor(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElement.WrapperForProjectRootElement.ContainingProject">
            <summary>
            Wrapped ProjectRootElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.WrapperForProjectRootElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Dummy required implementation
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElement.WrapperForProjectRootElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectElementContainer">
            <summary>
            A container for project elements
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.#ctor">
            <summary>
            Constructor called by ProjectRootElement only.
            XmlElement is set directly after construction.
            </summary>
            <comment>
            Should ideally be protected+internal.
            </comment> 
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Constructor called by derived classes, except from ProjectRootElement.
            Parameters may not be null, except parent.
            </summary>
            <comment>
            Should ideally be protected+internal.
            </comment>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.AllChildren">
            <summary>
            Get an enumerator over all children, gotten recursively.
            Walks the children in a depth-first manner.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.Children">
            <summary>
            Get enumerable over all the children
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.ChildrenReversed">
            <summary>
            Get enumerable over all the children, starting from the last
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.Count">
            <summary>
            Number of children of any kind
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.FirstChild">
            <summary>
            First child, if any, otherwise null.
            Cannot be set directly; use <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement)">PrependChild()</see>.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.LastChild">
            <summary>
            Last child, if any, otherwise null.
            Cannot be set directly; use <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement)">AppendChild()</see>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Insert the child after the reference child.
            Reference child if provided must be parented by this element.
            Reference child may be null, in which case this is equivalent to <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement)">PrependChild(child)</see>.
            Throws if the parent is not itself parented.
            Throws if the reference node does not have this node as its parent.
            Throws if the node to add is already parented.
            Throws if the node to add was created from a different project than this node.
            </summary>
            <remarks>
            Semantics are those of XmlNode.InsertAfterChild.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Insert the child before the reference child.
            Reference child if provided must be parented by this element.
            Reference child may be null, in which case this is equivalent to <see cref="M:Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement)">AppendChild(child)</see>.
            Throws if the parent is not itself parented.
            Throws if the reference node does not have this node as its parent.
            Throws if the node to add is already parented.
            Throws if the node to add was created from a different project than this node.
            </summary>
            <remarks>
            Semantics are those of XmlNode.InsertBeforeChild.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Inserts the provided element as the last child.
            Throws if the parent is not itself parented.
            Throws if the node to add is already parented.
            Throws if the node to add was created from a different project than this node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Inserts the provided element as the first child.
            Throws if the parent is not itself parented.
            Throws if the node to add is already parented.
            Throws if the node to add was created from a different project than this node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Removes the specified child.
            Throws if the child is not currently parented by this object.
            This is O(1).
            May be safely called during enumeration of the children.
            </summary>
            <remarks>
            This is actually safe to call during enumeration of children, because it
            doesn't bother to clear the child's NextSibling (or PreviousSibling) pointers.
            To determine whether a child is unattached, check whether its parent is null,
            or whether its NextSibling and PreviousSibling point back at it.
            DO NOT BREAK THIS VERY USEFUL SAFETY CONTRACT.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.RemoveAllChildren">
            <summary>
            Remove all the children, if any.
            </summary>
            <remarks>
            It is safe to modify the children in this way
            during enumeration. See <cref see="RemoveChild">RemoveChild</cref>.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Applies properties from the specified type to this instance.
            </summary>
            <param name="element">The element to act as a template to copy from.</param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.AppendParentedChildNoChecks(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Appends the provided child.
            Does not dirty the project, does not add an element, does not set the child's parent,
            and does not check the parent's future siblings and parent are acceptable.
            Called during project load, when the child can be expected to 
            already have a parent and its element is already connected to the
            parent's element.
            All that remains is to set FirstChild/LastChild and fix up the linked list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.DeepClone(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Returns a clone of this project element and all its children.
            </summary>
            <param name="factory">The factory to use for creating the new instance.</param>
            <param name="parent">The parent to append the cloned element to as a child.</param>
            <returns>The cloned element.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.UpdateElementValue(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            If child "element" is actually represented as an attribute, update the value in the corresponding Xml attribute
            </summary>
            <param name="child">A child element which might be represented as an attribute</param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.AddToXml(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Adds a ProjectElement to the Xml tree
            </summary>
            <param name="child">A child to add to the Xml tree, which has already been added to the ProjectElement tree</param>
            <remarks>
            The MSBuild construction APIs keep a tree of ProjectElements and a parallel Xml tree which consists of
            objects from System.Xml.  This is a helper method which adds an XmlElement or Xml attribute to the Xml
            tree after the corresponding ProjectElement has been added to the construction API tree, and fixes up
            whitespace as necessary.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.AddInitialChild(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Sets the first child in this container
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.VerifyForInsertBeforeAfterFirst(Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Common verification for insertion of an element.
            Reference may be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.VerifyThrowInvalidOperationNotSelfAncestor(Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Verifies that the provided element isn't this element or a parent of it.
            If it is, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.GetChildrenRecursively">
            <summary>
            Recurses into the provided container (such as a choose) and finds all child elements, even if nested.
            Result does NOT include the element passed in.
            The caller could filter these.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable">
            <summary>
            Enumerable over a series of sibling ProjectElement objects
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable._enumerator">
            <summary>
            The enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.#ctor(Microsoft.Build.Construction.ProjectElement,System.Boolean)">
            <summary>
            Constructor allowing reverse enumeration
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get non generic enumerator
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator">
            <summary>
            Enumerator over a series of sibling ProjectElement objects
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator._initial">
            <summary>
            First element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator._forwards">
            <summary>
            Whether enumeration should go forwards or backwards.
            If backwards, the "initial" will be the first returned, then each previous
            node in turn.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator.#ctor(Microsoft.Build.Construction.ProjectElement,System.Boolean)">
            <summary>
            Constructor taking the first element
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator.Current">
            <summary>
            Current element
            Returns null if MoveNext() hasn't been called
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Current element.
            Throws if MoveNext() hasn't been called
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator.Dispose">
            <summary>
            Dispose. Do nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator.MoveNext">
            <summary>
            Moves to the next item if any, otherwise returns false
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectElementContainer.ProjectElementSiblingEnumerable.ProjectElementSiblingEnumerator.Reset">
            <summary>
            Return to start
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectImportElement">
            <summary>
            Initializes a ProjectImportElement instance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Framework.SdkReference)">
            <summary>
            Initialize a parented ProjectImportElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectImportElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.Project">
            <summary>
            Gets or sets the Project value. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.ProjectLocation">
            <summary>
            Location of the project attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.Sdk">
            <summary>
            Gets or sets the SDK that contains the import.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.Version">
            <summary>
            Gets or sets the version associated with this SDK import
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.MinimumVersion">
            <summary>
            Gets or sets the minimum SDK version required by this import.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.SdkLocation">
            <summary>
            Location of the Sdk attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation">
            <summary>
            Gets the <see cref="P:Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation"/> of the import.  This indicates if the import was implicitly
            added because of the <see cref="P:Microsoft.Build.Construction.ProjectRootElement.Sdk"/> attribute and the location where the project was
            imported.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.OriginalElement">
            <summary>
            If the import is an implicit one (<see cref="P:Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation"/> != None) then this element points
            to the original element which generated this implicit import.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportElement.ParsedSdkReference">
            <summary>
            <see cref="T:Microsoft.Build.Framework.SdkReference"/> if applicable to this import element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectImportElement, wrapping an unparented XmlElement.
            Validates the project value.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.CreateImplicit(System.String,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ImplicitImportLocation,Microsoft.Build.Framework.SdkReference,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Creates an implicit ProjectImportElement as if it was in the project.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportElement.CheckUpdatedSdk">
            <summary>
            Helper method to extract attribute values and update the ParsedSdkReference property if
            necessary (update only when changed).
            </summary>
            <returns>True if the ParsedSdkReference was updated, otherwise false (no update necessary).</returns>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectImportGroupElement">
            <summary>
            ProjectImportGroupElement represents the ImportGroup element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportGroupElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectImportGroupElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectImportGroupElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectImportGroupElement.Imports">
            <summary>
            Get any contained properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportGroupElement.AddImport(System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds a new import after the last import in this import group.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportGroupElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectImportGroupElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportGroupElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectImportGroupElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement">
            <summary>
            ProjectItemDefinitionGroupElement represents the ItemGroup element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectItemDefinitionGroupElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectItemDefinitionGroupElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.ItemDefinitions">
            <summary>
            Get a list of child item definitions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.AddItemDefinition(System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds a new item definition after the last child.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectItemDefinitionGroupElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectItemDefinitionElement">
            <summary>
            ProjectItemDefinitionElement class represents the Item Definition element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectItemDefinitionGroupElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a ProjectItemDefinitionElement instance from a node read from a project file
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a ProjectItemDefinitionElement instance from a node read from a project file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemDefinitionElement.ItemType">
            <summary>
            Gets the definition's type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemDefinitionElement.Metadata">
            <summary>
            Get any child metadata definitions.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(System.String,System.String)">
            <summary>
            Convenience method to add a piece of metadata to this item definition.
            Adds after any existing metadata. Does not modify any existing metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(System.String,System.String,System.Boolean)">
            <summary>
            Convenience method to add a piece of metadata to this item definition.
            Adds after any existing metadata. Does not modify any existing metadata.
            </summary>
            <param name="name">The name of the metadata to add</param>
            <param name="unevaluatedValue">The value of the metadata to add</param>
            <param name="expressAsAttribute">If true, then the metadata will be expressed as an attribute instead of a child element, for example
            &lt;Content CopyToOutputDirectory="PreserveNewest" /&gt;
            </param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectItemDefinitionElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemDefinitionElement.ShouldCloneXmlAttribute(System.Xml.XmlAttribute)">
            <summary>
            Do not clone attributes which can be metadata. The corresponding expressed as attribute project elements are responsible for adding their attribute
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectItemGroupElement">
            <summary>
            ProjectItemGroupElement represents the ItemGroup element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectItemGroupElement._definitelyAreNoChildrenWithWildcards">
            <summary>
            True if it is known that no child items have wildcards in their
            include. An optimization helping Project.AddItem.
            Only reliable if it is true.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectItemGroupElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectItemGroupElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemGroupElement.Items">
            <summary>
            Get any child items.
            This is a live collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemGroupElement.DefinitelyAreNoChildrenWithWildcards">
            <summary>
            True if it is known that no child items have wildcards in their
            include. An optimization helping Project.AddItem.
            Only reliable if it is true.
            ONLY TO BE CALLED by ProjectItemElement.
            Should be protected+internal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds a new item ordered by include.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds a new item ordered by include.
            Metadata may be null, indicating no metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectItemGroupElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to the XmlDocument in the appropriate location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemGroupElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectItemElement">
            <summary>
            ProjectItemElement class represents the Item element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectItemElement._include">
            <summary>
            Include value cached for performance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectItemElement._exclude">
            <summary>
            Exclude value cached for performance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectItemElement._remove">
            <summary>
            Remove value cached for performance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectItemElement._update">
            <summary>
            Update value cached for performance
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectItemElement._includeHasWildcards">
            <summary>
            Whether the include value has wildcards, 
            cached for performance.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectItemGroupElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectItemElement instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectItemElement instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.ItemType">
            <summary>
            Gets the item's type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.Include">
            <summary>
            Gets or sets the Include value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty or null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.Exclude">
            <summary>
            Gets or sets the Exclude value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty or null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.Remove">
            <summary>
            Gets or sets the Remove value.
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty or null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.Update">
            <summary>
            Gets or sets the Update value.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.KeepMetadata">
            <summary>
            Gets or sets the KeepMetadata value.
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty or null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata">
            <summary>
            Gets or sets the RemoveMetadata value.
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty or null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates">
            <summary>
            Gets or sets the KeepDuplicates value.
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty or null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.HasMetadata">
            <summary>
            Whether there are any child metadata elements
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.Metadata">
            <summary>
            Get any child metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.IncludeLocation">
            <summary>
            Location of the include attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.ExcludeLocation">
            <summary>
            Location of the exclude attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.RemoveLocation">
            <summary>
            Location of the remove attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.UpdateLocation">
            <summary>
            Location of the update attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.KeepMetadataLocation">
            <summary>
            Location of the keepMetadata attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.RemoveMetadataLocation">
            <summary>
            Location of the removeMetadata attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.KeepDuplicatesLocation">
            <summary>
            Location of the keepDuplicates attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.IncludeHasWildcards">
            <summary>
            Whether the include value has wildcards, 
            cached for performance.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectItemElement.NextItem">
            <summary>
            Internal helper to get the next ProjectItemElement sibling.
            If there is none, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.AddMetadata(System.String,System.String)">
            <summary>
            Convenience method to add a piece of metadata to this item.
            Adds after any existing metadata. Does not modify any existing metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.AddMetadata(System.String,System.String,System.Boolean)">
            <summary>
            Convenience method to add a piece of metadata to this item.
            Adds after any existing metadata. Does not modify any existing metadata.
            </summary>
            <param name="name">The name of the metadata to add</param>
            <param name="unevaluatedValue">The value of the metadata to add</param>
            <param name="expressAsAttribute">If true, then the metadata will be expressed as an attribute instead of a child element, for example
            &lt;Reference Include="Libary.dll" HintPath="..\lib\Library.dll" Private="True" /&gt;
            </param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectItemElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.ChangeItemType(System.String)">
            <summary>
            Changes the item type.
            </summary>
            <remarks>
            The implementation has to actually replace the element to do this.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.OnAfterParentChanged(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Overridden to update the parent's children-have-no-wildcards flag.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectItemElement.ShouldCloneXmlAttribute(System.Xml.XmlAttribute)">
            <summary>
            Do not clone attributes which can be metadata. The corresponding expressed as attribute project elements are responsible for adding their attribute
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectMetadataElement">
            <summary>
            ProjectMetadataElement class represents a Metadata element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectMetadataElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectMetadataElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectMetadataElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectMetadataElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectMetadataElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectMetadataElement.Name">
            <summary>
            Gets or sets the metadata's type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute">
            <summary>
            Gets or sets whether this piece of metadata is expressed as an attribute.
            </summary>
            <remarks>
            If true, then the metadata will be expressed as an attribute instead of a child element, for example
            &lt;Reference Include="Libary.dll" HintPath="..\lib\Library.dll" Private="True" /&gt;
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectMetadataElement.Value">
            <summary>
            Gets or sets the unevaluated value. 
            Returns empty string if it is not present.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectMetadataElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectMetadataElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectMetadataElement.ChangeName(System.String)">
            <summary>
            Changes the name.
            </summary>
            <remarks>
            The implementation has to actually replace the element to do this.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectMetadataElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectMetadataElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectOnErrorElement">
            <summary>
            ProjectUsingTaskElement represents the Import element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOnErrorElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOnErrorElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectTargetElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectOnErrorElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOnErrorElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectOnErrorElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute">
            <summary>
            Gets and sets the value of the ExecuteTargets attribute.
            </summary>
            <remarks>
            'Attribute' suffix is for clarity.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsLocation">
            <summary>
            Location of the "ExecuteTargets" attribute on this element, if any.
            If there is no such attribute, returns null;
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOnErrorElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectOnErrorElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOnErrorElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOnErrorElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectOtherwiseElement">
            <summary>
            ProjectOtherwiseElement represents the Otherwise element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOtherwiseElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOtherwiseElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectOtherwiseElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOtherwiseElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectOtherwiseElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOtherwiseElement.Condition">
            <summary>
            Condition should never be set, but the getter returns null instead of throwing 
            because a nonexistent condition is implicitly true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOtherwiseElement.ItemGroups">
            <summary>
            Get an enumerator over any child item groups
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOtherwiseElement.PropertyGroups">
            <summary>
            Get an enumerator over any child property groups
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOtherwiseElement.ChooseElements">
            <summary>
            Get an enumerator over any child chooses
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOtherwiseElement.ConditionLocation">
            <summary>
            This does not allow conditions, so it should not be called.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOtherwiseElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectOtherwiseElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOtherwiseElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOtherwiseElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectOutputElement">
            <summary>
            ProjectOutputElement represents the Output element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOutputElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOutputElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectTaskElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectOutputElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOutputElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectOutputElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.TaskParameter">
            <summary>
            Gets or sets the TaskParameter value. 
            Returns empty string if it is not present.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.IsOutputItem">
            <summary>
            Whether this represents an output item (as opposed to an output property)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.IsOutputProperty">
            <summary>
            Whether this represents an output property (as opposed to an output item)
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.ItemType">
            <summary>
            Gets or sets the ItemType value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
            <remarks>
            Unfortunately the attribute name chosen in Whidbey was "ItemName" not ItemType.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.PropertyName">
            <summary>
            Gets or sets the PropertyName value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.TaskParameterLocation">
            <summary>
            Location of the task parameter attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.PropertyNameLocation">
            <summary>
            Location of the property name attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectOutputElement.ItemTypeLocation">
            <summary>
            Location of the item type attribute, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOutputElement.CreateDisconnected(System.String,System.String,System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectOutputElement, wrapping an unparented XmlElement.
            Validates the parameters.
            Exactly one of item name and property name must have a value.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOutputElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectOutputElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectExtensionsElement">
            <summary>
            ProjectExtensionsElement represents the ProjectExtensions element in the MSBuild project.
            ProjectExtensions can contain arbitrary XML content.
            The ProjectExtensions element is deprecated and provided only for backward compatibility.
            Use a property instead. Properties can also contain XML content.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectExtensionsElement instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectExtensionsElement instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectExtensionsElement.Condition">
            <summary>
            Condition should never be set, but the getter returns null instead of throwing 
            because a nonexistent condition is implicitly true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectExtensionsElement.Content">
            <summary>
            Gets and sets the raw XML content
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectExtensionsElement.ConditionLocation">
            <summary>
            This does not allow conditions, so it should not be called.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectExtensionsElement.Item(System.String)">
            <summary>
            Get or set the content of the first sub-element 
            with the provided name.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.CreateParented(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates a ProjectExtensionsElement parented by a project
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectExtensionsElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectExtensionsElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectPropertyGroupElement">
            <summary>
            ProjectPropertyGroupElement represents the PropertyGroup element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectPropertyGroupElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectPropertyGroupElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectPropertyGroupElement.Properties">
            <summary>
            Get any contained properties.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectPropertyGroupElement.PropertiesReversed">
            <summary>
            Get any contained properties.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.AddProperty(System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds a new property after the last property in this property group.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.SetProperty(System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            If there is an existing property with the same name and no condition,
            updates its value. Otherwise it adds a new property after the last property.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectPropertyGroupElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyGroupElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectPropertyElement">
            <summary>
            ProjectPropertyElement class represents the Property element in the MSBuild project.
            </summary>
            <remarks>
            We do not need to use or set the PropertyType enumeration in the CM. 
            The CM does not know about Environment or Global properties, and does not create Output properties.
            We can just verify that we haven't read a PropertyType.Reserved property ourselves.
            So the CM only represents Normal properties.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectPropertyGroupElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectPropertyElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectPropertyElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectPropertyElement.Name">
            <summary>
            Gets or sets the property name.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectPropertyElement.Value">
            <summary>
            Gets or sets the unevaluated value. 
            Returns empty string if it is not present.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectPropertyElement, wrapping an unparented XmlElement.
            Validates name.
            Caller should then ensure the element is added to the XmlDocument in the appropriate location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyElement.ChangeName(System.String)">
            <summary>
            Changes the name.
            </summary>
            <remarks>
            The implementation has to actually replace the element to do this.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectPropertyElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectTargetElement">
            <summary>
            ProjectTargetElement represents the Target element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectTargetElement._name">
            <summary>
            Target name cached for performance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectTargetElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectTargetElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.ItemGroups">
            <summary>
            Get an enumerator over any child item groups
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.PropertyGroups">
            <summary>
            Get an enumerator over any child property groups
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.Tasks">
            <summary>
            Get an enumerator over any child tasks
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.OnErrors">
            <summary>
            Get an enumerator over any child onerrors
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.Name">
            <summary>
            Gets and sets the name of the target element.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.Inputs">
            <summary>
            Gets or sets the Inputs value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.Outputs">
            <summary>
            Gets or sets the Outputs value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs">
            <summary>
            Gets or sets the TrimDuplicateOutputs value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets">
            <summary>
            Gets or sets the DependsOnTargets value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets">
            <summary>
            Gets or sets the BeforeTargets value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.AfterTargets">
            <summary>
            Gets or sets the AfterTargets value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.Returns">
            <summary>
            Gets or sets the Returns value. 
            Returns null if the attribute is not present -- empty string is an allowable 
            value for both getting and setting. 
            Removes the attribute only if the value is set to null. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.NameLocation">
            <summary>
            Location of the Name attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.InputsLocation">
            <summary>
            Location of the Inputs attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.OutputsLocation">
            <summary>
            Location of the Outputs attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputsLocation">
            <summary>
            Location of the TrimDuplicateOutputs attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargetsLocation">
            <summary>
            Location of the DependsOnTargets attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.BeforeTargetsLocation">
            <summary>
            Location of the BeforeTargets attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.ReturnsLocation">
            <summary>
            Location of the Returns attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.AfterTargetsLocation">
            <summary>
            Location of the AfterTargets attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTargetElement.TargetInstance">
            <summary>
            A cache of the last instance which was created from this target.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.AddItemGroup">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds an item group after the last child.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.AddPropertyGroup">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds a property group after the last child.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.AddTask(System.String)">
            <summary>
            Convenience method to add a task to this target.
            Adds after any existing task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectTargetElement, wrapping an unparented XmlElement.
            Validates the name.
            Caller should then ensure the element is added to a parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.MarkDirty(System.String,System.String)">
            <summary>
            Marks this element as dirty.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTargetElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectTaskElement">
            <summary>
            ProjectTaskElement represents the Task element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectTaskElement._parameters">
            <summary>
            The parameters (excepting condition and continue-on-error)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectTaskElement._locker">
            <summary>
            Protection for the parameters cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectTargetElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectTaskElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectTaskElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError">
            <summary>
            Gets or sets the continue on error value. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime">
            <summary>
            Gets or sets the runtime value for the task. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture">
            <summary>
            Gets or sets the architecture value for the task. 
            Returns empty string if it is not present.
            Removes the attribute if the value to set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.Name">
            <summary>
            Gets the task name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.Outputs">
            <summary>
            Gets any output children.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.Parameters">
            <summary>
            Enumerable over the unevaluated parameters on the task.
            Attributes with their own properties, such as ContinueOnError, are not included in this collection.
            If parameters differ only by case only the last one will be returned. MSBuild uses only this one.
            Hosts can still remove the other parameters by using RemoveAllParameters().
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations">
            <summary>
            Enumerable over the locations of parameters on the task.
            Condition and ContinueOnError, which have their own properties, are not included in this collection.
            If parameters differ only by case only the last one will be returned. MSBuild uses only this one.
            Hosts can still remove the other parameters by using RemoveAllParameters().
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.ContinueOnErrorLocation">
            <summary>
            Location of the "ContinueOnError" attribute on this element, if any.
            If there is no such attribute, returns null;
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntimeLocation">
            <summary>
            Location of the "MSBuildRuntime" attribute on this element, if any.
            If there is no such attribute, returns null;
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitectureLocation">
            <summary>
            Location of the "MSBuildArchitecture" attribute on this element, if any.
            If there is no such attribute, returns null;
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectTaskElement.ParametersForEvaluation">
            <summary>
            Retrieves a copy of the parameters as used during evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(System.String,System.String)">
            <summary>
            Convenience method to add an Output Item to this task. 
            Adds after the last child. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(System.String,System.String,System.String)">
            <summary>
            Convenience method to add a conditioned Output Item to this task. 
            Adds after the last child. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(System.String,System.String)">
            <summary>
            Convenience method to add an Output Property to this task. 
            Adds after the last child. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(System.String,System.String,System.String)">
            <summary>
            Convenience method to add a conditioned Output Property to this task. 
            Adds after the last child. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.GetParameter(System.String)">
            <summary>
            Gets the value of the parameter with the specified name,
            or empty string if it is not present.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.SetParameter(System.String,System.String)">
            <summary>
            Adds (or modifies the value of) a parameter on this task
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(System.String)">
            <summary>
            Removes any parameter on this task with the specified name.
            If there is no such parameter, does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters">
            <summary>
            Removes all parameters from the task.
            Does not remove any "special" parameters: ContinueOnError, Condition, etc.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.CopyFrom(Microsoft.Build.Construction.ProjectElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectTaskElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to the XmlDocument in the appropriate location.
            </summary>
            <remarks>
            Any legal XML element name is allowed. We can't easily verify if the name is a legal XML element name,
            so this will specifically throw XmlException if it isn't.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectTaskElement.EnsureParametersInitialized">
            <summary>
            Initialize parameters cache.
            Must be called within the lock.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectUsingTaskElement">
            <summary>
            ProjectUsingTaskElement represents the Import element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectUsingTaskElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectUsingTaskElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile">
            <summary>
            Gets the value of the AssemblyFile attribute.
            Returns empty string if it is not present.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName">
            <summary>
            Gets and sets the value of the AssemblyName attribute.
            Returns empty string if it is not present.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName">
            <summary>
            Gets and sets the value of the TaskName attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory">
            <summary>
            Gets and sets the value of the TaskFactory attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime">
            <summary>
            Gets and sets the value of the Runtime attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture">
            <summary>
            Gets and sets the value of the Architecture attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.TaskBody">
            <summary>
            Get any contained TaskElement.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup">
            <summary>
            Get any contained ParameterGroup.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.TaskNameLocation">
            <summary>
            Location of the task name attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation">
            <summary>
            Location of the assembly file attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation">
            <summary>
            Location of the assembly name attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.RuntimeLocation">
            <summary>
            Location of the Runtime attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.ArchitectureLocation">
            <summary>
            Location of the Architecture attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactoryLocation">
            <summary>
            Location of the TaskFactory attribute, if any
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.AddParameterGroup">
            <summary>
            Convenience method that picks a location based on a heuristic:
                Adds a new ParameterGroup to the using task to the end of the using task element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.AddUsingTaskBody(System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
                Adds a new TaskBody to the using task to the end of the using task element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.CreateDisconnected(System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectUsingTaskElement, wrapping an unparented XmlElement.
            Validates the parameters.
            Exactly one of assembly file and assembly name must have a value.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.RenameHandlerDelegate">
            <summary>
            Event handler for the event fired after this project file is named or renamed.
            If the project file has not previously had a name, oldFullPath is null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectRootElement">
            <summary>
            ProjectRootElement class represents an MSBuild project, an MSBuild targets file or any other file that conforms to MSBuild
            project file schema.
            This class and its related classes allow a complete MSBuild project or targets file to be read and written.
            Comments and whitespace cannot be edited through this model at present.
            
            Each project root element is associated with exactly one ProjectCollection. This allows the owner of that project collection
            to control its lifetime and not be surprised by edits via another project collection.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement.EmptyProjectFileContent">
            Constants for default (empty) project file.
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement.s_openLoaderDelegate">
            <summary>
            The singleton delegate that loads projects into the ProjectRootElement
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement.XmlDeclarationRegEx">
            <summary>
            Used to determine if a file is an empty XML file if it ONLY contains an XML declaration like &lt;?xml version="1.0" encoding="utf-8"?&gt;.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement.s_defaultEncoding">
            <summary>
            The default encoding to use / assume for a new project.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement.s_globalVersionCounter">
            <summary>
            A global counter used to ensure each project version is distinct from every other.
            </summary>
            <remarks>
            This number is static so that it is unique across the appdomain. That is so that a host
            can know when a ProjectRootElement has been unloaded (perhaps after modification) and
            reloaded -- the version won't reset to '0'.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._versionOnDisk">
            <summary>
            Version number of this object that was last saved to disk, or last loaded from disk.
            Used to figure whether this object is dirty for saving.
            Saving to or loading from a provided stream reader does not modify this value, only saving to or loading from disk.
            The actual value is meaningless (since the counter is shared with all projects) --
            it should only be compared to a stored value.
            Immediately after loading from disk, this has the same value as <see cref="P:Microsoft.Build.Construction.ProjectRootElement.Version">version</see>.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._encoding">
            <summary>
            The encoding of the project that was (if applicable) loaded off disk, and that will be used to save the project.
            </summary>
            <value>Defaults to UTF8 for new projects.</value>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.XmlNamespace">
            <summary>
            XML namespace specified and used by this project file. If a namespace was not specified in the project file, this
            value will be string.Empty.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._projectFileLocation">
            <summary>
            The project file's location. It can be null if the project is not directly loaded from a file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._escapedFullPath">
            <summary>
            The project file's full path, escaped.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._directory">
            <summary>
            The directory that the project is in. 
            Essential for evaluating relative paths.
            If the project is not loaded from disk, returns the current-directory from 
            the time the project was loaded - this is the same behavior as Whidbey/Orcas.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._timeLastChangedUtc">
            <summary>
            The time that this object was last changed. If it hasn't
            been changed since being loaded or created, its value is <see cref="F:System.DateTime.MinValue"/>.
            Stored as UTC as this is faster when there are a large number of rapid edits.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._lastWriteTimeWhenReadUtc">
            <summary>
            The last-write-time of the file that was read, when it was read.
            This can be used to see whether the file has been changed on disk
            by an external means.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._dirtyReason">
            <summary>
            Reason it was last marked dirty; unlocalized, for debugging
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectRootElement._dirtyParameter">
            <summary>
            Parameter to be formatted into the dirty reason
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.#ctor(System.Xml.XmlReader,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,System.Boolean,System.Boolean)">
            <summary>
            Initialize a ProjectRootElement instance from a XmlReader.
            May throw InvalidProjectFileException.
            Leaves the project dirty, indicating there are unsaved changes.
            Used to create a root element for solutions loaded by the 3.5 version of the solution wrapper.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.#ctor(Microsoft.Build.Evaluation.ProjectRootElementCacheBase,Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
            Leaves the project dirty, indicating there are unsaved changes.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.#ctor(System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,System.Boolean)">
            <summary>
            Initialize a ProjectRootElement instance over a project with the specified file path.
            Assumes path is already normalized.
            May throw InvalidProjectFileException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.#ctor(Microsoft.Build.Construction.XmlDocumentWithLocation,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Initialize a ProjectRootElement instance from an existing document.
            May throw InvalidProjectFileException.
            Leaves the project dirty, indicating there are unsaved changes.
            </summary>
            <remarks>
            Do not make public: we do not wish to expose particular XML API's.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.#ctor(Microsoft.Build.Construction.XmlDocumentWithLocation)">
            <summary>
            Initialize a ProjectRootElement instance from an existing document.
            Helper constructor for the <see cref="M:Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.String,System.Boolean,System.Nullable{System.Boolean})"/>> mehtod which needs to check if the document parses
            </summary>
            <remarks>
            Do not make public: we do not wish to expose particular XML API's.
            </remarks>
        </member>
        <member name="E:Microsoft.Build.Construction.ProjectRootElement.OnAfterProjectRename">
            <summary>
            Event raised after this project is renamed
            </summary>
        </member>
        <member name="E:Microsoft.Build.Construction.ProjectRootElement.OnProjectXmlChanged">
            <summary>
            Event raised after the project XML is changed.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Condition">
            <summary>
            Condition should never be set, but the getter returns null instead of throwing 
            because a nonexistent condition is implicitly true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ChooseElements">
            <summary>
            Get a read-only collection of the child chooses, if any
            </summary>
            <remarks>
            The name is inconsistent to make it more understandable, per API review.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups">
            <summary>
            Get a read-only collection of the child item definition groups, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions">
            <summary>
            Get a read-only collection of the child item definitions, if any, in all item definition groups anywhere in the project file.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ItemGroups">
            <summary>
            Get a read-only collection over the child item groups, if any.
            Does not include any that may not be at the root, i.e. inside Choose elements.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Items">
            <summary>
            Get a read-only collection of the child items, if any, in all item groups anywhere in the project file.
            Not restricted to root item groups: traverses through Choose elements.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ImportGroups">
            <summary>
            Get a read-only collection of the child import groups, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Imports">
            <summary>
            Get a read-only collection of the child imports
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.PropertyGroups">
            <summary>
            Get a read-only collection of the child property groups, if any.
            Does not include any that may not be at the root, i.e. inside Choose elements.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Properties">
            <summary>
            Geta read-only collection of the child properties, if any, in all property groups anywhere in the project file.
            Not restricted to root property groups: traverses through Choose elements.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Targets">
            <summary>
            Get a read-only collection of the child targets
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.UsingTasks">
            <summary>
            Get a read-only collection of the child usingtasks, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed">
            <summary>
            Get a read-only collection of the child item groups, if any, in reverse order
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed">
            <summary>
            Get a read-only collection of the child item definition groups, if any, in reverse order
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed">
            <summary>
            Get a read-only collection of the child import groups, if any, in reverse order
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed">
            <summary>
            Get a read-only collection of the child property groups, if any, in reverse order
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.DirectoryPath">
            <summary>
            The directory that the project is in. 
            Essential for evaluating relative paths.
            Is never null, even if the FullPath does not contain directory information.
            If the project has not been loaded from disk and has not been given a path, returns the current-directory from 
            the time the project was loaded - this is the same behavior as Whidbey/Orcas.
            If the project has not been loaded from disk but has been given a path, this path may not exist.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.FullPath">
            <summary>
            Full path to the project file.
            If the project has not been loaded from disk and has not been given a path, returns null.
            If the project has not been loaded from disk but has been given a path, this path may not exist.
            Setter renames the project, if it already had a name.
            </summary>
            <remarks>
            Updates the ProjectRootElement cache.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Encoding">
            <summary>
            Encoding that the project file is saved in, or will be saved in, unless
            otherwise specified.
            </summary>
            <remarks>
            Returns the encoding from the Xml declaration if any, otherwise UTF8.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.DefaultTargets">
            <summary>
            Gets or sets the value of DefaultTargets. If there is no DefaultTargets, returns empty string.
            If the value is null or empty, removes the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.InitialTargets">
            <summary>
            Gets or sets the value of InitialTargets. If there is no InitialTargets, returns empty string.
            If the value is null or empty, removes the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Sdk">
            <summary>
            Gets or sets a semicolon delimited list of software development kits (SDK) that the project uses.
            If  a value is specified, an Sdk.props is simplicity imported at the top of the project and an
            Sdk.targets is simplicity imported at the bottom from the specified SDK.
            If the value is null or empty, removes the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty">
            <summary>
            Gets or sets the value of TreatAsLocalProperty. If there is no tag, returns empty string.
            If the value being set is null or empty, removes the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ToolsVersion">
            <summary>
            Gets or sets the value of ToolsVersion. If there is no ToolsVersion, returns empty string.
            If the value is null or empty, removes the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.RawXml">
            <summary>
            Gets the XML representing this project as a string.
            Does not remove any dirty flag.
            </summary>
            <remarks>
            Useful for debugging.
            Note that we do not expose an XmlDocument or any other specific XML API.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges">
            <summary>
            Whether the XML has been modified since it was last loaded or saved.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting">
            <summary>
            Whether the XML is preserving formatting or not.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.Version">
            <summary>
            Version number of this object.
            A host can compare this to a stored version number to determine whether
            a project's XML has changed, even if it has also been saved since.
            
            The actual value is meaningless: an edit may increment it more than once,
            so it should only be compared to a stored value.
            </summary>
            <remarks>
            Used by the Project class to figure whether changes have occurred that 
            it might want to pick up by reevaluation.
            
            Used by the ProjectRootElement class to determine whether it needs to save.
            
            This number is unique to the appdomain. That means that it is possible
            to know when a ProjectRootElement has been unloaded (perhaps after modification) and
            reloaded -- the version won't reset to '0'.
            
            We're assuming we don't have over 2 billion edits.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged">
            <summary>
            The time that this object was last changed. If it hasn't
            been changed since being loaded or created, its value is <see cref="F:System.DateTime.MinValue"/>.
            </summary>
            <remarks>
            This is used by the VB/C# project system.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead">
            <summary>
            The last-write-time of the file that was read, when it was read.
            This can be used to see whether the file has been changed on disk
            by an external means.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ConditionLocation">
            <summary>
            This does not allow conditions, so it should not be called.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation">
            <summary>
            Location of the originating file itself, not any specific content within it.
            If the file has not been given a name, returns an empty location.
            This is a case where it is legitimate to "not have a location".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation">
            <summary>
            Location of the toolsversion attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation">
            <summary>
            Location of the defaulttargets attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation">
            <summary>
            Location of the initialtargets attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.SdkLocation">
            <summary>
            Location of the Sdk attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation">
            <summary>
            Location of the TreatAsLocalProperty attribute, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.IsExplicitlyLoaded">
            <summary>
            Has the project root element been explicitly loaded for a build or has it been implicitly loaded
            as part of building another project.
            </summary>
            <remarks>
            Internal code that wants to set this to true should call <see cref="M:Microsoft.Build.Construction.ProjectRootElement.MarkAsExplicitlyLoaded"/>.
            The setter is private to make it more difficult to downgrade an existing PRE to an implicitly loaded state, which should never happen.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ProjectRootElementCache">
            <summary>
            Retrieves the root element cache with which this root element is associated.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.IsMemberOfProjectCollection">
            <summary>
            Gets a value indicating whether this PRE is known by its containing collection.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ContainsTargetsWithReturnsAttribute">
            <summary>
            Indicates whether there are any targets in this project 
            that use the "Returns" attribute.  If so, then this project file
            is automatically assumed to be "Returns-enabled", and the default behavior
            for targets without Returns attributes changes from using the Outputs to 
            returning nothing by default. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.ProjectExtensions">
            <summary>
            Gets the ProjectExtensions child, if any, otherwise null.
            </summary>
            <remarks>
            Not public as we do not wish to encourage the use of ProjectExtensions.
            </remarks>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectRootElement.LastDirtyReason">
            <summary>
            Returns an unlocalized indication of how this file was last dirtied.
            This is for debugging purposes only.
            String formatting only occurs when retrieved.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
            Uses the global project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later using the specified <see cref="T:Microsoft.Build.Evaluation.NewProjectFileOptions"/>.
            Uses the global project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
            Uses the specified project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later using the specified <see cref="T:Microsoft.Build.Evaluation.ProjectCollection"/> and <see cref="T:Microsoft.Build.Evaluation.NewProjectFileOptions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.String)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
            Uses the global project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.String,Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later using the specified path and <see cref="T:Microsoft.Build.Evaluation.NewProjectFileOptions"/>.
            Uses the global project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
            Uses the specified project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
            Uses the specified project collection.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader)">
            <summary>
            Initialize a ProjectRootElement instance from an XmlReader.
            Uses the global project collection.
            May throw InvalidProjectFileException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Initialize a ProjectRootElement instance from an XmlReader.
            Uses the specified project collection.
            May throw InvalidProjectFileException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader,Microsoft.Build.Evaluation.ProjectCollection,System.Boolean)">
            <summary>
            Initialize a ProjectRootElement instance from an XmlReader.
            Uses the specified project collection.
            May throw InvalidProjectFileException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Open(System.String)">
            <summary>
            Initialize a ProjectRootElement instance by loading from the specified file path.
            Uses the global project collection.
            May throw InvalidProjectFileException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Open(System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Initialize a ProjectRootElement instance by loading from the specified file path.
            Uses the specified project collection.
            May throw InvalidProjectFileException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Open(System.String,Microsoft.Build.Evaluation.ProjectCollection,System.Nullable{System.Boolean})">
            <summary>
            Initialize a ProjectRootElement instance by loading from the specified file path.
            Uses the specified project collection and preserves the formatting of the document if specified.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.TryOpen(System.String)">
            <summary>
            Returns the ProjectRootElement for the given path if it has been loaded, or null if it is not currently in memory.
            Uses the global project collection.
            </summary>
            <param name="path">The path of the ProjectRootElement, cannot be null.</param>
            <returns>The loaded ProjectRootElement, or null if it is not currently in memory.</returns>
            <remarks>
            It is possible for ProjectRootElements to be brought into memory and discarded due to memory pressure. Therefore
            this method returning false does not indicate that it has never been loaded, only that it is not currently in memory.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.TryOpen(System.String,Microsoft.Build.Evaluation.ProjectCollection)">
            <summary>
            Returns the ProjectRootElement for the given path if it has been loaded, or null if it is not currently in memory.
            Uses the specified project collection.
            </summary>
            <param name="path">The path of the ProjectRootElement, cannot be null.</param>
            <param name="projectCollection">The <see cref="T:Microsoft.Build.Evaluation.ProjectCollection"/> to load the project into.</param>
            <returns>The loaded ProjectRootElement, or null if it is not currently in memory.</returns>
            <remarks>
            It is possible for ProjectRootElements to be brought into memory and discarded due to memory pressure. Therefore
            this method returning false does not indicate that it has never been loaded, only that it is not currently in memory.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.TryOpen(System.String,Microsoft.Build.Evaluation.ProjectCollection,System.Nullable{System.Boolean})">
            <summary>
            Returns the ProjectRootElement for the given path if it has been loaded, or null if it is not currently in memory.
            Uses the specified project collection.
            </summary>
            <param name="path">The path of the ProjectRootElement, cannot be null.</param>
            <param name="projectCollection">The <see cref="T:Microsoft.Build.Evaluation.ProjectCollection"/> to load the project into.</param>
            <param name="preserveFormatting">
            The formatting to open with. Must match the formatting in the collection to succeed.
            </param>
            <returns>The loaded ProjectRootElement, or null if it is not currently in memory.</returns>
            <remarks>
            It is possible for ProjectRootElements to be brought into memory and discarded due to memory pressure. Therefore
            this method returning false does not indicate that it has never been loaded, only that it is not currently in memory.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddImport(System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            If import groups exist, inserts into the last one without a condition on it.
            Otherwise, creates an import at the end of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddImportGroup">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Creates an import group at the end of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddItem(System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Finds item group with no condition with at least one item of same type, or else adds a new item group;
            adds the item to that item group with items of the same type, ordered by include.
            </summary>
            <remarks>
            Per the previous implementation, it actually finds the last suitable item group, not the first.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Finds first item group with no condition with at least one item of same type, or else an empty item group; or else adds a new item group;
            adds the item to that item group with items of the same type, ordered by include.
            Does not attempt to check whether the item matches an existing wildcard expression; that is only possible
            in the evaluated world.
            </summary>
            <remarks>
            Per the previous implementation, it actually finds the last suitable item group, not the first.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddItemGroup">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds an item group after the last existing item group, if any; otherwise
            adds an item group after the last existing property group, if any; otherwise
            adds a new item group at the end of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Finds first item definition group with no condition with at least one item definition of same item type, or else adds a new item definition group.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds an item definition group after the last existing item definition group, if any; otherwise
            adds an item definition group after the last existing property group, if any; otherwise
            adds a new item definition group at the end of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Adds a new property group after the last existing property group, if any; otherwise
            at the start of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddProperty(System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic.
            Updates the last existing property with the specified name that has no condition on itself or its property group, if any.
            Otherwise, adds a new property in the first property group without a condition, creating a property group if necessary after
            the last existing property group, else at the start of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddTarget(System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Creates a target at the end of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(System.String,System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            Creates a usingtask at the end of the project.
            Exactly one of assemblyName or assemblyFile must be null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement">
            <summary>
            Creates a choose.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(System.String)">
            <summary>
            Creates an import.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(System.String)">
            <summary>
            Creates an item node.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(System.String,System.String)">
            <summary>
            Creates an item node with an include.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(System.String)">
            <summary>
            Creates an item definition.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement">
            <summary>
            Creates an item definition group.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement">
            <summary>
            Creates an item group.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement">
            <summary>
            Creates an import group. 
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(System.String)">
            <summary>
            Creates a metadata node.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(System.String,System.String)">
            <summary>
            Creates a metadata node.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(System.String)">
            <summary>
            Creates an on error node.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement">
            <summary>
            Creates an otherwise node.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(System.String,System.String,System.String)">
            <summary>
            Creates an output node.
            Exactly one of itemType and propertyName must be specified.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement">
            <summary>
            Creates a project extensions node.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement">
            <summary>
            Creates a property group.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(System.String)">
            <summary>
            Creates a property.
            Caller must add it to the location of choice in the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(System.String)">
            <summary>
            Creates a target.
            Caller must add it to the location of choice in this project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(System.String)">
            <summary>
            Creates a task.
            Caller must add it to the location of choice in this project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(System.String,System.String,System.String)">
            <summary>
            Creates a using task.
            Caller must add it to the location of choice in the project.
            Exactly one of assembly file and assembly name must be provided.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a using task.
            Caller must add it to the location of choice in the project.
            Exactly one of assembly file and assembly name must be provided.
            Also allows providing optional runtime and architecture specifiers.  Null is OK. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement">
            <summary>
            Creates a ParameterGroup for use in a using task.
            Caller must add it to the location of choice in the project under a using task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a Parameter for use in a using ParameterGroup.
            Caller must add it to the location of choice in the project under a using task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(System.String,System.String)">
            <summary>
            Creates a Task element for use in a using task.
            Caller must add it to the location of choice in the project under a using task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(System.String)">
            <summary>
            Creates a when.
            Caller must add it to the location of choice in this project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(System.String,System.String)">
            <summary>
            Creates a project SDK element attached to this project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Save">
            <summary>
            Save the project to the file system, if dirty.
            Uses the Encoding returned by the Encoding property.
            Creates any necessary directories.
            May throw IO-related exceptions.
            Clears the dirty flag.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding)">
            <summary>
            Save the project to the file system, if dirty.
            Creates any necessary directories.
            May throw IO-related exceptions.
            Clears the dirty flag.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.String)">
            <summary>
            Save the project to the file system, if dirty or the path is different.
            Creates any necessary directories.
            May throw IO related exceptions.
            Clears the Dirty flag.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.String,System.Text.Encoding)">
            <summary>
            Save the project to the file system, if dirty or the path is different.
            Creates any necessary directories.
            May throw IO related exceptions.
            Clears the Dirty flag.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter)">
            <summary>
            Save the project to the provided TextWriter, whether or not it is dirty.
            Uses the encoding of the TextWriter.
            Clears the Dirty flag.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.DeepClone">
            <summary>
            Returns a clone of this project.
            </summary>
            <returns>The cloned element.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Reload(System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Reload the existing project root element from its file.
            An <see cref="T:System.InvalidOperationException"/> is thrown if the project root element is not associated with any file on disk.
            
            See <see cref="M:Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader,System.Boolean,System.Nullable{System.Boolean})"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.String,System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Reload the existing project root element from the given path
            An <see cref="T:System.InvalidOperationException"/> is thrown if the path does not exist.
            
            See <see cref="M:Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader,System.Boolean,System.Nullable{System.Boolean})"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader,System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Reload the existing project root element from the given <paramref name="reader"/>
            A reload operation completely replaces the state of this <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/> object. This operation marks the 
            object as dirty (see <see cref="M:Microsoft.Build.Construction.ProjectRootElement.MarkDirty(System.String,System.String)"/> for side effects). 
            
            If the new state has invalid XML or MSBuild syntax, then this method throws an <see cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException"/>.
            When this happens, the state of this object does not change.
            
            Reloading from an XMLReader will retain the previous root element location (<see cref="P:Microsoft.Build.Construction.ProjectRootElement.FullPath"/>, <see cref="P:Microsoft.Build.Construction.ProjectRootElement.DirectoryPath"/>, <see cref="P:Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation"/>).
            
            </summary>
            <param name="reader">Reader to read from</param>
            <param name="throwIfUnsavedChanges">
              If set to false, the reload operation will discard any unsaved changes.
              Otherwise, an <see cref="T:System.InvalidOperationException"/> is thrown when unsaved changes are present.
            </param>
            <param name="preserveFormatting">
              Whether the reload should preserve formatting or not. A null value causes the reload to reuse the existing <see cref="P:Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting"/> value.
            </param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
            Uses the specified project root element cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Open(System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Initialize a ProjectRootElement instance by loading from the specified file path.
            Assumes path is already normalized.
            Uses the specified project root element cache.
            May throw InvalidProjectFileException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.Open(Microsoft.Build.Construction.XmlDocumentWithLocation)">
            <summary>
            Initialize a ProjectRootElement instance from an existing document.
            Uses the global project collection.
            May throw InvalidProjectFileException.
            </summary>
            <remarks>
            This is ultimately for unit testing.
            Do not make public: we do not wish to expose particular XML API's.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.OpenProjectOrSolution(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,System.Boolean)">
            <summary>
            Gets a ProjectRootElement representing an MSBuild file.
            Path provided must be a canonicalized full path.
            May throw InvalidProjectFileException or an IO-related exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateElement(System.String)">
            <summary>
            Creates a XmlElement with the specified name in the document
            containing this project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.MarkDirty(System.String,System.String)">
            <summary>
            Marks this project as dirty.
            Typically called by child elements to indicate that they themselves have become dirty.
            Accepts a reason for debugging purposes only, and optional reason parameter.
            </summary>
            <remarks>
            This is sealed because it is virtual and called in a constructor; by sealing it we
            satisfy FXCop that nobody will override it to do something that would rely on
            unconstructed state.
            Should be protected+internal.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.MarkProjectDirty(Microsoft.Build.Evaluation.Project)">
            <summary>
            Bubbles a Project dirty notification up to the ProjectRootElementCacheBase and ultimately to the ProjectCollection.
            </summary>
            <param name="project">The dirtied project.</param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.MarkAsExplicitlyLoaded">
            <summary>
            Sets the <see cref="P:Microsoft.Build.Construction.ProjectRootElement.IsExplicitlyLoaded"/> property to <c>true</c> to indicate that this PRE
            should not be removed from the cache until it is explicitly unloaded by some MSBuild client.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.GetImplicitImportNodes(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates and returns a list of <see cref="T:Microsoft.Build.Construction.ProjectImportElement"/> nodes which are implicitly
            referenced by the Project.
            </summary>
            <param name="currentProjectOrImport">Current project</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing details of the SDKs referenced by the project.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.IsEmptyXmlFile(System.String)">
            <summary>
            Determines if the specified file is an empty XML file meaning it has no contents, contains only whitespace, or
            only an XML declaration.  If the file does not exist, it is not considered empty.
            </summary>
            <param name="path">The full path to a file to check.</param>
            <returns><code>true</code> if the file is an empty XML file, otherwise <code>false</code>.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Returns a new instance of ProjectRootElement that is affiliated with the same ProjectRootElementCache.
            </summary>
            <param name="owner">The factory to use for creating the new instance.</param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.OpenLoader(System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase)">
            <summary>
            Creates a new ProjectRootElement for a specific PRE cache
            </summary>
            <param name="path">The path to the file to load.</param>
            <param name="projectRootElementCache">The cache to load the PRE into.</param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.CreateProjectFromPath(System.String,Microsoft.Build.Evaluation.ProjectRootElementCacheBase,System.Boolean)">
            <summary>
            Creates a ProjectRootElement representing a file, where the file may be a .sln instead of
            an MSBuild format file.
            Assumes path is already normalized.
            If the file is in MSBuild format, may throw InvalidProjectFileException.
            If the file is a solution, will throw an IO-related exception if the file cannot be read.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.LoadDocument(System.String,System.Boolean,System.Boolean)">
            <summary>
            Constructor helper to load an XmlDocumentWithLocation from a path.
            Assumes path is already normalized.
            May throw InvalidProjectFileException.
            Never returns null.
            Does NOT add to the ProjectRootElementCache. Caller should add after verifying subsequent MSBuild parsing succeeds.
            </summary>
            <param name="fullPath">The full path to the document to load.</param>
            <param name="preserveFormatting"><code>true</code> to preserve the formatting of the document, otherwise <code>false</code>.</param>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.LoadDocument(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Constructor helper to load an XmlDocumentWithLocation from an XmlReader.
            May throw InvalidProjectFileException.
            Never returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectRootElement.IncrementVersion">
            <summary>
            Boost the appdomain-unique version counter for this object.
            This is done when it is modified, and also when it is loaded.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectChooseElement">
            <summary>
            ProjectChooseElement represents the Choose element in the MSBuild project.
            Currently it does not allow a Condition.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectChooseElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectChooseElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectChooseElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectChooseElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectChooseElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectChooseElement.Condition">
            <summary>
            Condition should never be set, but the getter returns null instead of throwing 
            because a nonexistent condition is implicitly true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectChooseElement.WhenElements">
            <summary>
            Get the When children.
            Will contain at least one entry.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectChooseElement.OtherwiseElement">
            <summary>
            Get any Otherwise child.
            May be null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectChooseElement.ConditionLocation">
            <summary>
            This does not allow conditions, so it should not be called.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectChooseElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectChooseElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectChooseElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Sets the parent of this element if it is a valid parent,
            otherwise throws.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectChooseElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectWhenElement">
            <summary>
            ProjectWhenElement represents the When element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectWhenElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectWhenElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectChooseElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectWhenElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectWhenElement.#ctor(System.Xml.XmlElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectWhenElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectWhenElement.ChooseElements">
            <summary>
            Get an enumerator over any child chooses
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectWhenElement.ItemGroups">
            <summary>
            Get an enumerator over any child item groups
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectWhenElement.PropertyGroups">
            <summary>
            Get an enumerator over any child property groups
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectWhenElement.CreateDisconnected(System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectPropertyGroupElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectWhenElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectWhenElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.UsingTaskParameterGroupElement">
            <summary>
            UsingTaskParameterGroupElement represents a ParameterGroup under the using task.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.#ctor(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented UsingTaskParameterGroupElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented UsingTaskParameterGroupElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition">
            <summary>
            Condition should never be set, but the getter returns null instead of throwing 
            because a nonexistent condition is implicitly true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.UsingTaskParameterGroupElement.Parameters">
            <summary>
            Get any contained parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.UsingTaskParameterGroupElement.ConditionLocation">
            <summary>
            This does not allow conditions, so it should not be called.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(System.String,System.String,System.String,System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(System.String)">
            <summary>
            Convenience method that picks a location based on a heuristic:
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.CreateDisconnected(Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented UsingTaskParameterGroupElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.UsingTaskParameterGroupElement.VerifyCorrectParent(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Verify the parent is a usingTaskElement and that the taskFactory attribute is set
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectUsingTaskParameterElement">
            <summary>
            UsingTaskParameterElement class represents the Parameter element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.UsingTaskParameterGroupElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented UsingTaskParameterElement instance
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented UsingTaskParameterElement instance
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition">
            <summary>
            Condition should never be set, but the getter returns null instead of throwing 
            because a nonexistent condition is implicitly true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name">
            <summary>
            Gets and sets the name of the parameter's name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType">
            <summary>
            Gets or sets the Type attribute returns "System.String" if not set.
            If null or empty is set the attribute will be removed from the element.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output">
            <summary>
            Gets or sets the output attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required">
            <summary>
            Gets or sets the required attribute
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ConditionLocation">
            <summary>
            This does not allow conditions, so it should not be called.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterTypeLocation">
            <summary>
            Location of the Type attribute.
            If there is no such attribute, returns the location of the element,
            in lieu of the default value it uses for the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.OutputLocation">
            <summary>
            Location of the Output attribute.
            If there is no such attribute, returns the location of the element,
            in lieu of the default value it uses for the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.RequiredLocation">
            <summary>
            Location of the Required attribute.
            If there is no such attribute, returns the location of the element,
            in lieu of the default value it uses for the attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.CreateDisconnected(System.String,System.String,System.String,System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented UsingTaskParameterElement, wrapping an unparented XmlElement.
            Caller should then ensure the element is added to a parent.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskParameterElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectUsingTaskBodyElement">
            <summary>
            ProjectUsingTaskBodyElement class represents the Task element under the using task element in the MSBuild project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.#ctor(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink)">
            <summary>
            External projects support
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectUsingTaskElement,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize a parented ProjectUsingTaskBodyElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.#ctor(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Initialize an unparented ProjectUsingTaskBodyElement
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition">
            <summary>
            Condition should never be set, but the getter returns null instead of throwing 
            because a nonexistent condition is implicitly true
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody">
            <summary>
            Gets or sets the unevaluated value of the contents of the task xml 
            Returns empty string if it is not present.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate">
            <summary>
            Gets the value of the Evaluate attribute.
            Returns true if it is not present.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.ConditionLocation">
            <summary>
            This does not allow conditions, so it should not be called.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.EvaluateLocation">
            <summary>
            Location of the "Condition" attribute on this element, if any.
            If there is no such attribute, returns the location of the element,
            in lieu of the default value it uses for the attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.CreateDisconnected(System.String,System.String,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Creates an unparented ProjectUsingTaskBodyElement, wrapping an unparented XmlElement.
            Validates name.
            Caller should then ensure the element is added to the XmlDocument in the appropriate location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.VerifyThrowInvalidOperationAcceptableLocation(Microsoft.Build.Construction.ProjectElementContainer,Microsoft.Build.Construction.ProjectElement,Microsoft.Build.Construction.ProjectElement)">
            <summary>
            Overridden to verify that the potential parent and siblings
            are acceptable. Throws InvalidOperationException if they are not.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectUsingTaskBodyElement.VerifyCorrectParent(Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Verify the parent is a usingTaskElement and that the taskFactory attribute is set
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.SolutionConfigurationInSolution">
            <summary>
            This represents an entry for a solution configuration
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationPlatformSeparator">
            <summary>
            Default separator between configuration and platform in configuration
            full names
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionConfigurationInSolution.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationName">
            <summary>
            The configuration part of this configuration - e.g. "Debug", "Release"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionConfigurationInSolution.PlatformName">
            <summary>
            The platform part of this configuration - e.g. "Any CPU", "Win32"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionConfigurationInSolution.FullName">
            <summary>
            The full name of this configuration - e.g. "Debug|Any CPU"
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionConfigurationInSolution.ComputeFullName(System.String,System.String)">
            <summary>
            Given a configuration name and a platform name, compute the full name 
            of this configuration
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectConfigurationInSolution">
            <summary>
            This class represents an entry for a project configuration in a solution configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectConfigurationInSolution.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectConfigurationInSolution.ConfigurationName">
            <summary>
            The configuration part of this configuration - e.g. "Debug", "Release"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectConfigurationInSolution.PlatformName">
            <summary>
            The platform part of this configuration - e.g. "Any CPU", "Win32"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectConfigurationInSolution.FullName">
            <summary>
            The full name of this configuration - e.g. "Debug|Any CPU"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectConfigurationInSolution.IncludeInBuild">
            <summary>
            True if this project configuration should be built as part of its parent solution configuration
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectConfigurationInSolution.RemoveSpaceFromAnyCpuPlatform(System.String)">
            <summary>
            This is a hacky method to remove the space in the "Any CPU" platform in project configurations.
            The problem is that this platform is stored as "AnyCPU" in project files, but the project system
            reports it as "Any CPU" to the solution configuration manager. Because of that all solution configurations
            contain the version with a space in it, and when we try and give that name to actual projects, 
            they have no clue what we're talking about. We need to remove the space in project platforms so that
            the platform name matches the one used in projects.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.SolutionProjectType">
            <remarks>
            An enumeration defining the different types of projects we might find in an SLN.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectType.Unknown">
            <summary>
            Everything else besides the below well-known project types.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectType.KnownToBeMSBuildFormat">
            <summary>
            C#, VB, F#, and VJ# projects
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectType.SolutionFolder">
            <summary>
            Solution folders appear in the .sln file, but aren't buildable projects.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectType.WebProject">
            <summary>
            ASP.NET projects
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectType.WebDeploymentProject">
            <summary>
            Web Deployment (.wdproj) projects
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectType.EtpSubProject">
            <summary>
            Project inside an Enterprise Template project
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.SolutionProjectType.SharedProject">
            <summary>
            A shared project represents a collection of shared files that is not buildable on its own.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectInSolution">
            <remarks>
            This class represents a project (or SLN folder) that is read in from a solution file.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectInSolution.s_charsToCleanse">
            <summary>
            Characters that need to be cleansed from a project name.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectInSolution.projectNamesToDisambiguate">
            <summary>
            Project names that need to be disambiguated when forming a target name
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectInSolution.cleanCharacter">
            <summary>
            Character that will be used to replace 'unclean' ones.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectInSolution._projectConfigurations">
            <summary>
            The project configuration in given solution configuration
            K: full solution configuration name (cfg + platform)
            V: project configuration 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.ProjectName">
            <summary>
            This project's name
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.RelativePath">
            <summary>
            The path to this project file, relative to the solution location
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.AbsolutePath">
            <summary>
            Returns the absolute path for this project
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.ProjectGuid">
            <summary>
            The unique guid associated with this project, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.ParentProjectGuid">
            <summary>
            The guid, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, of this project's 
            parent project, if any. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.Dependencies">
            <summary>
            List of guids, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, mapping to projects 
            that this project has a build order dependency on, as defined in the solution file. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.ProjectConfigurations">
            <summary>
            Configurations for this project, keyed off the configuration's full name, e.g. "Debug|x86"
            They contain only the project configurations from the solution file that fully matched (configuration and platform) against the solution configurations.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.Extension">
            <summary>
            Extension of the project file, if any
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.ProjectType">
            <summary>
            This project's type.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectInSolution.ProjectReferences">
            <summary>
            Only applies to websites -- for other project types, references are 
            either specified as Dependencies above, or as ProjectReferences in the
            project file, which the solution doesn't have insight into. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.AddDependency(System.String)">
            <summary>
            Add the guid of a referenced project to our dependencies list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.SetProjectConfiguration(System.String,Microsoft.Build.Construction.ProjectConfigurationInSolution)">
            <summary>
            Set the requested project configuration. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.CanBeMSBuildProjectFile(System.String@)">
            <summary>
            Looks at the project file node and determines (roughly) if the project file is in the MSBuild format.
            The results are cached in case this method is called multiple times.
            </summary>
            <param name="errorMessage">Detailed error message in case we encounter critical problems reading the file</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.GetUniqueProjectName">
            <summary>
            Find the unique name for this project, e.g. SolutionFolder\SubSolutionFolder\ProjectName
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.UpdateUniqueProjectName(System.String)">
            <summary>
            Changes the unique name of the project.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.CleanseProjectName(System.String)">
            <summary>
            Cleanse the project name, by replacing characters like '@', '$' with '_'
            </summary>
            <param name="projectName">The name to be cleansed</param>
            <returns>string</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.DisambiguateProjectTargetName(System.String)">
            <summary>
            If the unique project name provided collides with one of the standard Solution project
            entry point targets (Build, Rebuild, Clean, Publish), then disambiguate it by prepending the string "Solution:"
            </summary>
            <param name="uniqueProjectName">The unique name for the project</param>
            <returns>string</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectInSolution.ElementContainsInvalidNamespaceDefitions(System.Xml.XmlElement)">
            <summary>
            Check a Project element for known invalid namespace definitions.
            </summary>
            <param name="mainProjectElement">Project XML Element</param>
            <returns>True if the element contains known invalid namespace definitions</returns>
        </member>
        <member name="T:Microsoft.Build.Construction.SolutionFile">
            <remarks>
            This class contains the functionality to parse a solution file and return a corresponding
            MSBuild project file containing the projects and dependencies defined in the solution.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.SolutionParserWarnings">
            <summary>
            This property returns the list of warnings that were generated during solution parsing
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.SolutionParserComments">
            <summary>
            This property returns the list of comments that were generated during the solution parsing
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.SolutionParserErrorCodes">
            <summary>
            This property returns the list of error codes for warnings/errors that were generated during solution parsing. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.Version">
            <summary>
            Returns the actual major version of the parsed solution file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.VisualStudioVersion">
            <summary>
            Returns Visual Studio major version
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.ContainsWebProjects">
            <summary>
            Returns true if the solution contains any web projects
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.ContainsWebDeploymentProjects">
            <summary>
            Returns true if the solution contains any .wdproj projects.  Used to determine
            whether we need to load up any projects to examine dependencies. 
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.ProjectsInOrder">
            <summary>
            All projects in this solution, in the order they appeared in the solution file
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.ProjectsByGuid">
            <summary>
            The collection of projects in this solution, accessible by their guids as a 
            string in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.FullPath">
            <summary>
            This is the read/write accessor for the solution file which we will parse.  This
            must be set before calling any other methods on this class.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.SolutionReader">
            <summary>
            For unit-testing only.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Build.Construction.SolutionFile.SolutionConfigurations">
            <summary>
            The list of all full solution configurations (configuration + platform) in this solution
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.Parse(System.String)">
            <summary>
            This method takes a path to a solution file, parses the projects and project dependencies
            in the solution file, and creates internal data structures representing the projects within
            the SLN.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.IsBuildableProject(Microsoft.Build.Construction.ProjectInSolution)">
            <summary>
            Returns "true" if it's a project that's expected to be buildable, or false if it's 
            not (e.g. a solution folder) 
            </summary>
            <param name="project">The project in the solution</param>
            <returns>Whether the project is expected to be buildable</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(System.String,System.Int32@,System.Int32@)">
            <summary>
            Given a solution file, parses the header and returns the major version numbers of the solution file
            and the visual studio. 
            Throws InvalidProjectFileException if the solution header is invalid, or if the version is less than 
            our minimum version. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.AddSolutionConfiguration(System.String,System.String)">
            <summary>
            Adds a configuration to this solution
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ReadLine">
            <summary>
            Reads a line from the StreamReader, trimming leading and trailing whitespace.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseSolutionFileForConversion">
            <summary>
            This method takes a path to a solution file, parses the projects and project dependencies
            in the solution file, and creates internal data structures representing the projects within
            the SLN.  Used for conversion, which means it allows situations that we refuse to actually build. 
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseSolutionFile">
            <summary>
            This method takes a path to a solution file, parses the projects and project dependencies
            in the solution file, and creates internal data structures representing the projects within
            the SLN.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseSolution">
            <summary>
            Parses the SLN file represented by the StreamReader in this.reader, and populates internal
            data structures based on the SLN file contents.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseFileHeader">
            <summary>
            This method searches the first two lines of the solution file opened by the specified
            StreamReader for the solution file header.  An exception is thrown if it is not found.
            
            The solution file header looks like this:
            
                Microsoft Visual Studio Solution File, Format Version 9.00
            
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseVisualStudioVersion(System.String)">
            <summary>
            This method parses the Visual Studio version in Dev 12 solution files
            The version line looks like this:
            
            VisualStudioVersion = 12.0.20311.0 VSPRO_PLATFORM
            
            If such a line is found, the version is stored in this.currentVisualStudioVersion
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ValidateSolutionFileVersion(System.String)">
            <summary>
            This method extracts the whole part of the version number from the specified line
            containing the solution file format header, and throws an exception if the version number
            is outside of the valid range.
            
            The solution file header looks like this:
            
                Microsoft Visual Studio Solution File, Format Version 9.00
            
            </summary>
            <param name="versionString"></param>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseProject(System.String)">
             <summary>
             
             This method processes a "Project" section in the solution file opened by the specified
             StreamReader, and returns a populated ProjectInSolution instance, if successful.
             An exception is thrown if the solution file is invalid.
            
             The format of the parts of a Project section that we care about is as follows:
            
              Project("{Project type GUID}") = "Project name", "Relative path to project file", "{Project GUID}"
                  ProjectSection(ProjectDependencies) = postProject
                      {Parent project unique name} = {Parent project unique name}
                      ...
                  EndProjectSection
              EndProject
             
             </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseEtpProject(Microsoft.Build.Construction.ProjectInSolution)">
            <summary>
            This method will parse a .etp project recursively and 
            add all the projects found to projects and projectsInOrder
            </summary>
            <param name="etpProj">ETP Project</param>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.AddProjectToSolution(Microsoft.Build.Construction.ProjectInSolution)">
            <summary>
            Adds a given project to the project collections of this class
            </summary>
            <param name="proj">proj</param>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.IsEtpProjectFile(System.String)">
            <summary>
            Checks whether a given project has a .etp extension.
            </summary>
            <param name="projectFile"></param>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ValidateProjectRelativePath(Microsoft.Build.Construction.ProjectInSolution)">
            <summary>
            Validate relative path of a project
            </summary>
            <param name="proj">proj</param>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseAspNetCompilerProperty(Microsoft.Build.Construction.ProjectInSolution,System.String,System.String)">
            <summary>
            Takes a property name / value that comes from the SLN file for a Venus project, and
            stores it appropriately in our data structures.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.TrimQuotes(System.String)">
            <summary>
            Strips a single pair of leading/trailing double-quotes from a string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseFirstProjectLine(System.String,Microsoft.Build.Construction.ProjectInSolution)">
             <summary>
             Parse the first line of a Project section of a solution file. This line should look like:
            
              Project("{Project type GUID}") = "Project name", "Relative path to project file", "{Project GUID}"
             
             </summary>
             <param name="firstLine"></param>
             <param name="proj"></param>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseNestedProjects">
            <summary>
            Read nested projects section.
            This is required to find a unique name for each project's target
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseSolutionConfigurations">
            <summary>
            Read solution configuration section. 
            </summary>
            <remarks>
            A sample section:
            
            GlobalSection(SolutionConfigurationPlatforms) = preSolution
                Debug|Any CPU = Debug|Any CPU
                Release|Any CPU = Release|Any CPU
            EndGlobalSection
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ParseProjectConfigurations">
            <summary>
            Read project configurations in solution configurations section.
            </summary>
            <remarks>
            A sample (incomplete) section:
            
            GlobalSection(ProjectConfigurationPlatforms) = postSolution
            	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
            	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
            	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = Release|Any CPU
            	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = Release|Any CPU
            	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Win32.ActiveCfg = Debug|Any CPU
            	{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg = Release|Win32
            	{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Mixed Platforms.ActiveCfg = Release|Win32
            	{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Mixed Platforms.Build.0 = Release|Win32
            	{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Win32.ActiveCfg = Release|Win32
            	{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Win32.Build.0 = Release|Win32
            EndGlobalSection
            </remarks>
            <returns>An unprocessed hashtable of entries in this section</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.ProcessProjectConfigurationSection(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Read the project configuration information for every project in the solution, using pre-cached 
            solution section data. 
            </summary>
            <param name="rawProjectConfigurationsEntries">Cached data from the project configuration section</param>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.GetDefaultConfigurationName">
            <summary>
            Gets the default configuration name for this solution. Usually it's Debug, unless it's not present
            in which case it's the first configuration name we find.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.GetDefaultPlatformName">
            <summary>
            Gets the default platform name for this solution. Usually it's Mixed Platforms, unless it's not present
            in which case it's the first platform name we find.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.GetProjectUniqueNameByGuid(System.String)">
            <summary>
            This method takes a string representing one of the project's unique names (guid), and
            returns the corresponding "friendly" name for this project.
            </summary>
            <param name="projectGuid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Construction.SolutionFile.GetProjectRelativePathByGuid(System.String)">
            <summary>
            This method takes a string representing one of the project's unique names (guid), and
            returns the corresponding relative path to this project.
            </summary>
            <param name="projectGuid"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Construction.ElementLocation">
            <summary>
            The location of an XML node in a file.
            Any editing of the project XML through the MSBuild API's will invalidate locations in that XML until the XML is reloaded.
            </summary>
            <remarks>
            This object is IMMUTABLE, so that it can be passed around arbitrarily.
            DO NOT make these objects any larger. There are huge numbers of them and they are transmitted between nodes.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.ElementLocation.s_emptyElementLocation">
            <summary>
            The singleton empty element location.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.File">
            <summary>
            The file from which this particular element originated.  It may
            differ from the ProjectFile if, for instance, it was part of
            an import or originated in a targets file.
            If not known, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.Line">
            <summary>
            The line number where this element exists in its file.
            The first line is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.Column">
            <summary>
            The column number where this element exists in its file.
            The first column is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.LocationString">
            <summary>
            The location in a form suitable for replacement
            into a message.
            Example: "c:\foo\bar.csproj (12,34)"
            Calling this creates and formats a new string.
            PREFER TO PUT THE LOCATION INFORMATION AT THE START OF THE MESSAGE INSTEAD.
            Only in rare cases should the location go within the message itself.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.EmptyLocation">
            <summary>
            Gets the empty element location.
            This is not to be used when something is "missing": that should have a null location.
            It is to be used for the project location when the project has not been given a name.
            In that case, it exists, but can't have a specific location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.GetHashCode">
            <summary>
            Get reasonable hash code.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.Equals(System.Object)">
            <summary>
            Override Equals so that identical
            fields imply equal objects.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.ToString">
            <summary>
            Location of element.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.Microsoft#Build#BackEnd#ITranslatable#Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Writes the packet to the serializer.
            Always send as ints, even if ushorts are being used: otherwise it'd
            need a byte to discriminate and the savings would be microscopic.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            Custom factory is needed because this class is abstract and uses a factory pattern.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.Create(System.String)">
            <summary>
            Constructor for when we only know the file and nothing else.
            This is the case when we are creating a new item, for example, and it has
            not been evaluated from some XML.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.Create(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor for the case where we have most or all information.
            Numerical values must be 1-based, non-negative; 0 indicates unknown
            File may be null, indicating the file was not loaded from disk.
            </summary>
            <remarks>
            In AG there are 600 locations that have a file but zero line and column.
            In theory yet another derived class could be made for these to save 4 bytes each.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.GetLocationString(System.String,System.Int32,System.Int32)">
            <summary>
            The location in a form suitable for replacement
            into a message.
            Example: "c:\foo\bar.csproj (12,34)"
            Calling this creates and formats a new string.
            PREFER TO PUT THE LOCATION INFORMATION AT THE START OF THE MESSAGE INSTEAD.
            Only in rare cases should the location go within the message itself.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ElementLocation.RegularElementLocation">
            <summary>
            Rarer variation for when the line and column won't each fit in a ushort.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ElementLocation.RegularElementLocation.file">
            <summary>
            The source file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ElementLocation.RegularElementLocation.line">
            <summary>
            The source line.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ElementLocation.RegularElementLocation.column">
            <summary>
            The source column.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.RegularElementLocation.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor for the case where we have most or all information.
            Numerical values must be 1-based, non-negative; 0 indicates unknown
            File may be null, indicating the file was not loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.RegularElementLocation.File">
            <summary>
            The file from which this particular element originated.  It may
            differ from the ProjectFile if, for instance, it was part of
            an import or originated in a targets file.
            If not known, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.RegularElementLocation.Line">
            <summary>
            The line number where this element exists in its file.
            The first line is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.RegularElementLocation.Column">
            <summary>
            The column number where this element exists in its file.
            The first column is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ElementLocation.SmallElementLocation">
            <summary>
            For when the line and column each fit in a short - under 65536
            (almost always will: microsoft.common.targets is less than 5000 lines long)
            When loading Australian Government, for example, there are over 31,000 ElementLocation
            objects so this saves 4 bytes each = 123KB 
            
            A "very small" variation that used two bytes (or halves of a short) would fit about half of them
            and save 4 more bytes each, but the CLR packs each field to 4 bytes, so it isn't actually any smaller.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ElementLocation.SmallElementLocation.file">
            <summary>
            The source file.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ElementLocation.SmallElementLocation.line">
            <summary>
            The source line.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ElementLocation.SmallElementLocation.column">
            <summary>
            The source column.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ElementLocation.SmallElementLocation.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor for the case where we have most or all information.
            Numerical values must be 1-based, non-negative; 0 indicates unknown
            File may be null or empty, indicating the file was not loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.SmallElementLocation.File">
            <summary>
            The file from which this particular element originated.  It may
            differ from the ProjectFile if, for instance, it was part of
            an import or originated in a targets file.
            If not known, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.SmallElementLocation.Line">
            <summary>
            The line number where this element exists in its file.
            The first line is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ElementLocation.SmallElementLocation.Column">
            <summary>
            The column number where this element exists in its file.
            The first column is numbered 1.
            Zero indicates "unknown location".
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.RegistryLocation">
            <summary>
            The location something in the registry
            </summary>
            <remarks>
            This object is IMMUTABLE, so that it can be passed around arbitrarily.
            This is not public because the current implementation only provides correct data for unedited projects.
            DO NOT make it public without considering a solution to this problem.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.RegistryLocation.registryPath">
            <summary>
            The location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.RegistryLocation.#ctor(System.String)">
            <summary>
            Constructor taking the registry location.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.RegistryLocation.#ctor(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Private constructor for deserialization
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.RegistryLocation.File">
            <summary>
            Not relevant, returns empty string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.RegistryLocation.Line">
            <summary>
            Not relevant, returns 0.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.RegistryLocation.Column">
            <summary>
            Not relevant, returns 0.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.RegistryLocation.LocationString">
            <summary>
            The location in a form suitable for replacement
            into a message.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.RegistryLocation.Translate(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Reads or writes the packet to the serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.RegistryLocation.FactoryForDeserialization(Microsoft.Build.BackEnd.ITranslator)">
            <summary>
            Factory for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.XmlAttributeWithLocation">
            <summary>
            Derivation of XmlAttribute to implement IXmlLineInfo
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlAttributeWithLocation._elementLocation">
            <summary>
            Line, column, file information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlAttributeWithLocation.#ctor(System.String,System.String,System.String,System.Xml.XmlDocument)">
            <summary>
            Constructor without location information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlAttributeWithLocation.#ctor(System.String,System.String,System.String,System.Xml.XmlDocument,System.Int32,System.Int32)">
            <summary>
            Constructor with location information
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlAttributeWithLocation.LineNumber">
            <summary>
            Returns the line number if available, else 0.
            IXmlLineInfo member.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlAttributeWithLocation.LinePosition">
            <summary>
            Returns the column number if available, else 0.
            IXmlLineInfo member.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlAttributeWithLocation.Location">
            <summary>
            Provides an ElementLocation for this attribute.
            </summary>
            <remarks>
            Should have at least the file name if the containing project has been given a file name,
            even if it wasn't loaded from disk, or has been edited since. That's because we set that
            path on our XmlDocumentWithLocation wrapper class.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlAttributeWithLocation.HasLineInfo">
            <summary>
            Whether location is available.
            IXmlLineInfo member.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.XmlDocumentWithLocation">
            <summary>
            Improvement to XmlDocument that during load attaches location information to all elements and attributes.
            We don't need a real XmlDocument, as we are careful not to expose Xml types in our public API.
            </summary>
            <remarks>
            XmlDocument has many members, and this can't substitute for all of them. Location finding probably won't work if
            certain XmlDocument members are used. So for extra robustness, this could wrap an XmlDocument instead,
            and expose the small number of members that the MSBuild code actually uses. 
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation.s_globalStringCache">
            <summary>
            Used to cache strings used in attribute values and comments.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation.s_nameTable">
            <summary>
            Used to cache tag names in loaded files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation.s_readOnlyFlags">
            <summary>
            Whether we can selectively load as read-only (eg just when in program files directory)
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation._reader">
            <summary>
            Reader we've hooked
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation._fullPath">
            <summary>
            Path to the file loaded, if any, otherwise null.
            Easier to intercept and store than to derive it from the XmlDocument.BaseUri property.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation._stringCache">
            <summary>
            Local cache of strings for attribute values and comments. Used for testing.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation._loadAsReadOnly">
            <summary>
            Whether we can expect to never save this file.
            In such a case, we can discard as much as possible on load, like comments and whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.#ctor(System.Nullable{System.Boolean})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.XmlDocumentWithLocation.ReadOnlyLoadFlags">
            <summary>
            Whether to load files read only
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation.ReadOnlyLoadFlags.Undefined">
            <summary>
            Not determined
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation.ReadOnlyLoadFlags.LoadAllWriteable">
            <summary>
            Always load writeable
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation.ReadOnlyLoadFlags.LoadAllReadOnly">
            <summary>
            Always load read-only, to save memory
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlDocumentWithLocation.ReadOnlyLoadFlags.LoadReadOnlyIfAppropriate">
            <summary>
            Load read only selectively, Eg., just when file names begin with "Microsoft."
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlDocumentWithLocation.FullPath">
            <summary>
            Path to the file loaded if any, otherwise null.
            If the XmlDocument hasn't been loaded from a file, we wouldn't have a full path.
            However the project might actually have been given a path - it might even have been saved.
            In order to allow created elements to be able to provide a location with at least
            that path, the setter here should be called when the project is given a path.
            It may be set to null.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlDocumentWithLocation.StringCache">
            <summary>
            Sets or gets the string cache used by this XmlDocument.
            </summary>
            <remarks>
            When a particular instance has not been set will use the global string cache. The ability
            to use a particular instance is useful for tests.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.Load(System.Xml.XmlReader)">
            <summary>
            Loads from an XmlReader, intercepting the reader.
            </summary>
            <remarks>
            This method is called within XmlDocument by all other
            Load(..) overloads, and by LoadXml(..), so however the client loads XML,
            we will grab the reader.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.Load(System.String)">
            <summary>
            Grab the path to the file, for use in our location information.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.CreateElement(System.String,System.String,System.String)">
            <summary>
            Called during load, to add an element.
            </summary>
            <remarks>
            We create our own kind of element, that we can give location information to.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.CreateAttribute(System.String,System.String,System.String)">
            <summary>
            Called during load, to add an attribute.
            </summary>
            <remarks>
            We create our own kind of attribute, that we can give location information to.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.CreateWhitespace(System.String)">
            <summary>
            Create a whitespace node.
            Overridden to cache attribute values.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.CreateSignificantWhitespace(System.String)">
            <summary>
            Create a whitespace node. The definition of "significant" whitespace is obscure
            and does not include whitespace in text values in element content, which we always want to keep.
            Overridden to cache attribute values.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.CreateTextNode(System.String)">
            <summary>
            Create a text node.
            Overridden to cache attribute values.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.CreateComment(System.String)">
            <summary>
            Create a comment node.
            Overridden in order to cache comment strings.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.Save(System.IO.Stream)">
            <summary>
            Override Save to verify file was not loaded as readonly
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.Save(System.String)">
            <summary>
            Override Save to verify file was not loaded as readonly
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.Save(System.IO.TextWriter)">
            <summary>
            Override Save to verify file was not loaded as readonly
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.Save(System.Xml.XmlWriter)">
            <summary>
            Override Save to verify file was not loaded as readonly
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlDocumentWithLocation.IsReadOnly">
            <summary>
            Override IsReadOnly property to correctly indicate the mode to callers
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly">
            <summary>
            Reset state for unit tests that want to set the env var
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.ClearAnyCachedStrings">
            <summary>
            Called when the XmlDocument is unloaded to remove this XML's
            contribution to the string interning cache.
            Does NOT zombie the ProjectRootElement or anything else.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.DetermineWhetherToLoadReadOnly(System.String)">
            <summary>
            Determine whether we should load this file read only.
            We decide yes if it is in program files or the OS directory, and the file name starts with "microsoft", else no.
            We are very selective because we don't want to load files read only that the host might want to save, nor
            any files in which comments within property/metadata values might be significant - MSBuild does not discard those, normally.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.DetermineWhetherToLoadReadOnlyIfPossible">
            <summary>
            Determine whether we would ever load read only
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlDocumentWithLocation.VerifyThrowNotReadOnly">
            <summary>
            Throw if this was loaded read only
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.XmlElementWithLocation">
            <summary>
            Derivation of XmlElement to implement IXmlLineInfo
            </summary>
            <remarks>
            It would be nice to add some helper overloads of base class members that
            downcast their return values to XmlElement/AttributeWithLocation. However
            C# doesn't currently allow covariance in method overloading, only on delegates.
            The caller must bravely downcast.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlElementWithLocation._elementLocation">
            <summary>
            Line, column, file information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlElementWithLocation.#ctor(System.String,System.String,System.String,Microsoft.Build.Construction.XmlDocumentWithLocation)">
            <summary>
            Constructor without location information
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlElementWithLocation.#ctor(System.String,System.String,System.String,Microsoft.Build.Construction.XmlDocumentWithLocation,System.Int32,System.Int32)">
            <summary>
            Constructor with location information
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlElementWithLocation.LineNumber">
            <summary>
            Returns the line number if available, else 0.
            IXmlLineInfo member.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlElementWithLocation.LinePosition">
            <summary>
            Returns the column number if available, else 0.
            IXmlLineInfo member.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.XmlElementWithLocation.Location">
            <summary>
            Provides an ElementLocation for this element, using the path to the file containing
            this element as the project file entry.
            Element location may be incorrect, if it was not loaded from disk.
            Does not return null.
            </summary>
            <remarks>
            Should have at least the file name if the containing project has been given a file name,
            even if it wasn't loaded from disk, or has been edited since. That's because we set that
            path on our XmlDocumentWithLocation wrapper class.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlElementWithLocation.HasLineInfo">
            <summary>
            Whether location is available.
            IXmlLineInfo member.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlElementWithLocation.GetAttributeWithLocation(System.String)">
            <summary>
            Returns the XmlAttribute with the specified name or null if a matching attribute was not found.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlElementWithLocation.RemoveChild(System.Xml.XmlNode)">
            <summary>
            Overridden to convert the display of the element from open form (separate open and closed tags) to closed form 
            (single closed tag) if the last child is being removed. This is simply for tidiness of the project file.
            For example, removing the only piece of metadata from an item will leave behind one tag instead of two.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlElementWithLocation.GetAttributeLocation(System.String)">
            <summary>
            Gets the location of any attribute on this element with the specified name.
            If there is no such attribute, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.XmlNameTableThreadSafe">
            <summary>
            XmlNameTable that is thread safe for concurrent users.
            </summary>
            <remarks>
            Fortunately the standard implementation has only four accessible members
            and all of them are virtual so we can easily add locks.
            </remarks>
        </member>
        <member name="F:Microsoft.Build.Construction.XmlNameTableThreadSafe._locker">
            <summary>
            Synchronization object.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlNameTableThreadSafe.Add(System.String)">
            <summary>
            Add a string to the table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlNameTableThreadSafe.Add(System.Char[],System.Int32,System.Int32)">
            <summary>
            Add a string to the table, passed in as
            an extent in a char array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlNameTableThreadSafe.Get(System.String)">
            <summary>
            Get a string from the table.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.XmlNameTableThreadSafe.Get(System.Char[],System.Int32,System.Int32)">
            <summary>
            Get a string from the table, passed in as
            an extent in a char array.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectParser">
            <summary>
            Parses a project from raw XML into strongly typed objects
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.MaximumChooseNesting">
            <summary>
            Maximum nesting level of Choose elements. No reasonable project needs more than this
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnlyConditionAndLabel">
            <summary>
            Valid attribute list when only Condition and Label are valid
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.KnownAttributesOnItem">
            <summary>
            Valid attribute list for item
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.KnownAttributesOnItemIgnoreCase">
            <summary>
            Valid attributes list for item which is case-insensitive.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnImport">
            <summary>
            Valid attributes on import element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnUsingTask">
            <summary>
            Valid attributes on usingtask element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnTarget">
            <summary>
            Valid attributes on target element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnOnError">
            <summary>
            Valid attributes on on error element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnOutput">
            <summary>
            Valid attributes on output element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnUsingTaskParameter">
            <summary>
            Valid attributes on UsingTaskParameter element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser.ValidAttributesOnUsingTaskBody">
            <summary>
            Valid attributes on UsingTaskTask element
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser._project">
            <summary>
            The ProjectRootElement to parse into
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser._document">
            <summary>
            The document to parse from
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectParser._seenProjectExtensions">
            <summary>
            Whether a ProjectExtensions node has been encountered already.
            It's not supposed to appear more than once.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.#ctor(Microsoft.Build.Construction.XmlDocumentWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Private constructor to give static semantics
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.Parse(Microsoft.Build.Construction.XmlDocumentWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Parses the document into the provided ProjectRootElement.
            Throws InvalidProjectFileExceptions for syntax errors.
            </summary>
            <remarks>
            The code markers here used to be around the Project class constructor in the old code.
            In the new code, that's not very interesting; we are repurposing to wrap parsing the XML.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.Parse">
            <summary>
            Parses the project into the ProjectRootElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectPropertyGroupElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Parse a ProjectPropertyGroupElement from the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectItemGroupElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Parse a ProjectItemGroupElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectItemElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectItemGroupElement)">
            <summary>
            Parse a ProjectItemElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectMetadataElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Parse a ProjectMetadataElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectImportGroupElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Parse a ProjectImportGroupElement
            </summary>
            <param name="element">The XML element to parse</param>
            <param name="parent">The parent <see cref="T:Microsoft.Build.Construction.ProjectRootElement"/>.</param>
            <returns>A ProjectImportGroupElement derived from the XML element passed in</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectImportElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Parse a ProjectImportElement that is contained in an ImportGroup
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseUsingTaskParameterGroupElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer)">
            <summary>
            Parse a UsingTaskParameterGroupElement from the element
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectUsingTaskElement(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Parse a ProjectUsingTaskElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectTargetElement(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Parse a ProjectTargetElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectTaskElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectTargetElement)">
            <summary>
            Parse a ProjectTaskElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectOutputElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectTaskElement)">
            <summary>
            Parse a ProjectOutputElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectItemDefinitionGroupElement(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Parse a ProjectItemDefinitionGroupElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectItemDefinitionXml(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectItemDefinitionGroupElement)">
            <summary>
            Pasre a ProjectItemDefinitionElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectChooseElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,System.Int32)">
            <summary>
            Parse a ProjectChooseElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectWhenElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectChooseElement,System.Int32)">
            <summary>
            Parse a ProjectWhenElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectOtherwiseElement(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectChooseElement,System.Int32)">
            <summary>
            Parse a ProjectOtherwiseElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseWhenOtherwiseChildren(Microsoft.Build.Construction.XmlElementWithLocation,Microsoft.Build.Construction.ProjectElementContainer,System.Int32)">
            <summary>
            Parse the children of a When or Otherwise
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectExtensionsElement(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Parse a ProjectExtensionsElement
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectParser.ParseProjectSdkElement(Microsoft.Build.Construction.XmlElementWithLocation)">
            <summary>
            Parse a ProjectSdkElement
            </summary>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectStringCache">
            <summary>
            This class will cache string values for loaded Xml files.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectStringCache.InitialSize">
            <summary>
            Start off with a large size as there are very many strings in common scenarios and resizing is expensive.
            Note that there is a single instance of this cache for the lifetime of the process (albeit cleared out on XML unload)
            Australian Govt has about 3000 strings; a single VC project with all its various XML files has about 4000 strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectStringCache._strings">
            <summary>
            Store interned strings, and also a ref count, one per document using them.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectStringCache._documents">
            <summary>
            Store all the strings a document is using, so their ref count can be decremented.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectStringCache._locker">
            <summary>
            Locking object for this shared cache
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.#ctor">
            <summary>
            Public constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectStringCache.Count">
            <summary>
            Obtain the number of entries contained in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.Add(System.String,System.Xml.XmlDocument)">
            <summary>
            Add the given string to the cache or return the existing string if it is already
            in the cache.
            Constant time operation.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.Get(System.String)">
            <summary>
            Find the matching string in the cache.
            Constant time operation.
            </summary>
            <param name="key">String to find in the cache.</param>
            <returns>Existing string in the cache, or null if it is not contained.</returns>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.Clear(System.Xml.XmlDocument)">
            <summary>
            Indicates that a document's entries should be removed.
            If document is unknown, does nothing.
            Complexity proportional to the number of strings in the document,
            if the document is anywhere in the cache, otherwise O(1).
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.VerifyState">
            <summary>
            Verifies that each string entry has only one instance in the system.
            Enable the conditional if and while you make any modifications to the class, then disable as it is very slow.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.OnStrongCacheEntryRemoved(System.Object,Microsoft.Build.Construction.ProjectRootElement)">
            <summary>
            Handle event that is fired when an entry in the project root element cache is removed 
            from its strong cache.
            </summary>
            <remarks>
            When an entry is removed from a project root element cache's strong cache, we will remove
            its entries from our string cache. Otherwise the string cache ends up being the only one
            holding references to the Xml documents that have already been dropped.
            </remarks>
        </member>
        <member name="T:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry">
            <summary>
            Represents an entry in the ProjectStringCache.
            Can't be a struct because the copy-by-value and the ref counting don't go well together.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry._cachedString">
            <summary>
            Cached string
            </summary>
        </member>
        <member name="F:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry._refCount">
            <summary>
            Number of XmlDocuments where this string is included.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry.#ctor(System.String)">
            <summary>
            Constructor.
            Caller must then do Increment().
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry.Key">
            <summary>
            Key to find it
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry.RefCount">
            <summary>
            Number of documents using this string
            </summary>
        </member>
        <member name="P:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry.CachedString">
            <summary>
            Get the cached string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry.Increment">
            <summary>
            Indicates that this entry is included in the given document.
            Callers must verify that we were not already adreffed for this document.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Construction.ProjectStringCache.StringCacheEntry.Decrement">
            <summary>
            Removes a container for this entry.
            Callers must verify that this was not already reffed and not subsequently dereffed.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Definition.ProjectOptions">
            <summary>
                Common <see cref="T:Microsoft.Build.Evaluation.Project" /> constructor arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Definition.ProjectOptions.GlobalProperties">
            <summary>
            Global properties to evaluate with.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Definition.ProjectOptions.ToolsVersion">
            <summary>
            Tools version to evaluate with
            </summary>
        </member>
        <member name="P:Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion">
            <summary>
            Sub-toolset version to explicitly evaluate the toolset with.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Definition.ProjectOptions.ProjectCollection">
            <summary>
            The <see cref="P:Microsoft.Build.Definition.ProjectOptions.ProjectCollection"/> the project is added to. Default is <see cref="P:Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection"/>/>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Definition.ProjectOptions.LoadSettings">
            <summary>
            The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings"/> to use for evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Definition.ProjectOptions.EvaluationContext">
            <summary>
            The <see cref="P:Microsoft.Build.Definition.ProjectOptions.EvaluationContext"/> to use for evaluation.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Exceptions.BuildAbortedException">
            <summary>
            An exception representing the case where the build was aborted by request, as opposed to being
            unceremoniously shut down due to another kind of error exception.
            </summary>
            <remarks>
            This is public because it may be returned in the Exceptions collection of a BuildResult.
            If you add fields to this class, add a custom serialization constructor and override GetObjectData().
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Exceptions.BuildAbortedException.#ctor">
            <summary>
            Constructs a standard BuildAbortedException.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.BuildAbortedException.#ctor(System.String)">
            <summary>
            Constructs a BuildAbortedException with an additional message attached.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.BuildAbortedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs a BuildAbortedException with an additional message attached and an inner exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.BuildAbortedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Protected constructor used for (de)serialization. 
            If we ever add new members to this class, we'll need to update this.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Exceptions.BuildAbortedException.ErrorCode">
            <summary>
            Gets the error code (if any) associated with the exception message.
            </summary>
            <value>Error code string, or null.</value>
        </member>
        <member name="M:Microsoft.Build.Exceptions.BuildAbortedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            ISerializable method which we must override since Exception implements this interface
            If we ever add new members to this class, we'll need to update this.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Exceptions.InternalLoggerException">
            <summary>
            This exception is used to wrap an unhandled exception from a logger. This exception aborts the build, and it can only be
            thrown by the MSBuild engine.
            </summary>
            <remarks>
            WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
            promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
            without following certain special FX guidelines, can break both forward and backward compatibility
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            This constructor only exists to satisfy .NET coding guidelines. Use the rich constructor instead.
            </remarks>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.#ctor(System.String)">
            <summary>
            Creates an instance of this exception using the specified error message.
            </summary>
            <remarks>
            This constructor only exists to satisfy .NET coding guidelines. Use the rich constructor instead.
            </remarks>
            <param name="message"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using the specified error message and inner exception.
            </summary>
            <remarks>
            This constructor only exists to satisfy .NET coding guidelines. Use the rich constructor instead.
            </remarks>
            <param name="message"></param>
            <param name="innerException"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.#ctor(System.String,System.Exception,Microsoft.Build.Framework.BuildEventArgs,System.String,System.String,System.Boolean)">
            <summary>
            Creates an instance of this exception using rich error information.
            Internal for unit testing
            </summary>
            <remarks>This is the only usable constructor.</remarks>
            <param name="message"></param>
            <param name="innerException"></param>
            <param name="e">Can be null.</param>
            <param name="errorCode"></param>
            <param name="helpKeyword"></param>
            <param name="initializationException"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Protected constructor used for (de)serialization. 
            If we ever add new members to this class, we'll need to update this.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            ISerializable method which we must override since Exception implements this interface
            If we ever add new members to this class, we'll need to update this.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.SetDefaultsBeforeSerialization(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Provide default values for optional members
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.SetValueAfterDeserialization(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Don't actually have anything to do in the method, but the method is required when implementing an optional field
            </summary>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InternalLoggerException.BuildEventArgs">
            <summary>
            Gets the details of the build event (if any) that was being logged.
            </summary>
            <value>The build event args, or null.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InternalLoggerException.ErrorCode">
            <summary>
            Gets the error code associated with this exception's message (not the inner exception).
            </summary>
            <value>The error code string.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InternalLoggerException.HelpKeyword">
            <summary>
            Gets the F1-help keyword associated with this error, for the host IDE.
            </summary>
            <value>The keyword string.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InternalLoggerException.InitializationException">
            <summary>
            True if the exception occurred during logger initialization
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InternalLoggerException.Throw(System.Exception,Microsoft.Build.Framework.BuildEventArgs,System.String,System.Boolean,System.String[])">
            <summary>
            Throws an instance of this exception using rich error information.
            </summary>
            <param name="innerException"></param>
            <param name="e">Can be null.</param>
            <param name="messageResourceName"></param>
            <param name="initializationException"></param>
            <param name="messageArgs"></param>
        </member>
        <member name="T:Microsoft.Build.Exceptions.InvalidProjectFileException">
            <summary>
            This exception is thrown whenever there is a problem with the user's XML project file. The problem might be semantic or
            syntactical. The latter would be of a type typically caught by XSD validation (if it was performed by the project writer).
            </summary>
            <remarks>
            WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
            promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
            without following certain special FX guidelines, can break both forward and backward compatibility
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            This constructor only exists to satisfy .NET coding guidelines. Use a rich constructor whenever possible.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.#ctor(System.String)">
            <summary>
            Creates an instance of this exception using the specified error message.
            </summary>
            <remarks>
            This constructor only exists to satisfy .NET coding guidelines. Use a rich constructor whenever possible.
            </remarks>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using the specified error message and inner exception.
            </summary>
            <remarks>
            This constructor only exists to satisfy .NET coding guidelines. Use a rich constructor whenever possible.
            </remarks>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.#ctor(System.String,Microsoft.Build.Exceptions.InvalidProjectFileException)">
            <summary>
            Creates an instance of this exception using the specified error message and inner invalid project file exception.
            This is used in order to wrap and exception rather than rethrow it verbatim, which would reset the callstack.
            The assumption is that all the metadata for the outer exception comes from the inner exception, eg., they have the same error code.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Protected constructor used for (de)serialization. 
            If we ever add new members to this class, we'll need to update this.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            ISerializable method which we must override since Exception implements this interface
            If we ever add new members to this class, we'll need to update this.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
            Creates an instance of this exception using rich error information.
            </summary>
            <remarks>This constructor is preferred over the basic constructors.</remarks>
            <param name="projectFile">The invalid project file (can be empty string).</param>
            <param name="lineNumber">The invalid line number in the project (set to zero if not available).</param>
            <param name="columnNumber">The invalid column number in the project (set to zero if not available).</param>
            <param name="endLineNumber">The end of a range of invalid lines in the project (set to zero if not available).</param>
            <param name="endColumnNumber">The end of a range of invalid columns in the project (set to zero if not available).</param>
            <param name="message">Error message for exception.</param>
            <param name="errorSubcategory">Error sub-category that describes the error (can be null).</param>
            <param name="errorCode">The error code (can be null).</param>
            <param name="helpKeyword">The F1-help keyword for the host IDE (can be null).</param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidProjectFileException.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.String,System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using rich error information.
            </summary>
            <remarks>This constructor is preferred over the basic constructors.</remarks>
            <param name="projectFile">The invalid project file (can be empty string).</param>
            <param name="lineNumber">The invalid line number in the project (set to zero if not available).</param>
            <param name="columnNumber">The invalid column number in the project (set to zero if not available).</param>
            <param name="endLineNumber">The end of a range of invalid lines in the project (set to zero if not available).</param>
            <param name="endColumnNumber">The end of a range of invalid columns in the project (set to zero if not available).</param>
            <param name="message">Error message for exception.</param>
            <param name="errorSubcategory">Error sub-category that describes the error (can be null).</param>
            <param name="errorCode">The error code (can be null).</param>
            <param name="helpKeyword">The F1-help keyword for the host IDE (can be null).</param>
            <param name="innerException">Any inner exception. May be null.</param>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.Message">
            <summary>
            Gets the exception message including the affected project file (if any).
            </summary>
            <value>The complete message string.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.BaseMessage">
            <summary>
            Gets the exception message not including the project file.
            </summary>
            <value>The error message string only.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.ProjectFile">
            <summary>
            Gets the file (if any) associated with this exception.
            This may be an imported file.
            </summary>
            <remarks>
            The name is poorly chosen as this may be a targets file,
            but the name has shipped now.
            </remarks>
            <value>Project filename/path string, or null.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.LineNumber">
            <summary>
            Gets the invalid line number (if any) in the project.
            </summary>
            <value>The invalid line number, or zero.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.ColumnNumber">
            <summary>
            Gets the invalid column number (if any) in the project.
            </summary>
            <value>The invalid column number, or zero.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.EndLineNumber">
            <summary>
            Gets the last line number (if any) of a range of invalid lines in the project.
            </summary>
            <value>The last invalid line number, or zero.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.EndColumnNumber">
            <summary>
            Gets the last column number (if any) of a range of invalid columns in the project.
            </summary>
            <value>The last invalid column number, or zero.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorSubcategory">
            <summary>
            Gets the error sub-category (if any) that describes the type of this error.
            </summary>
            <value>The sub-category string, or null.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorCode">
            <summary>
            Gets the error code (if any) associated with the exception message.
            </summary>
            <value>Error code string, or null.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.HelpKeyword">
            <summary>
            Gets the F1-help keyword (if any) associated with this error, for the host IDE.
            </summary>
            <value>The keyword string, or null.</value>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidProjectFileException.HasBeenLogged">
            <summary>
            Whether the exception has already been logged. Allows the exception to be logged at the 
            most appropriate location, but continue to be propagated.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException">
            <summary>
            Exception subclass that ToolsetReaders should throw.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.errorCode">
            <summary>
            The MSBuild error code corresponding with this exception.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.#ctor">
            <summary>
            Basic constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.#ctor(System.String)">
            <summary>
            Basic constructor.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.#ctor(System.String,System.Exception)">
            <summary>
            Basic constructor.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Basic constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.#ctor(System.String,System.String)">
            <summary>
            Constructor that takes an MSBuild error code
            </summary>
            <param name="message"></param>
            <param name="errorCode"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructor that takes an MSBuild error code
            </summary>
            <param name="message"></param>
            <param name="errorCode"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            ISerializable method which we must override since Exception implements this interface
            If we ever add new members to this class, we'll need to update this.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.ErrorCode">
            <summary>
            The MSBuild error code corresponding with this exception, or
            null if none was specified.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.Throw(System.String,System.String[])">
            <summary>
            Throws an InvalidToolsetDefinitionException.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
            <param name="resourceName"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.Throw(System.Exception,System.String,System.String[])">
            <summary>
            Throws an InvalidToolsetDefinitionException including a specified inner exception,
            which may be interesting to hosts.
            
            PERF WARNING: calling a method that takes a variable number of arguments
            is expensive, because memory is allocated for the array of arguments -- do
            not call this method repeatedly in performance-critical scenarios
            </summary>
        </member>
        <member name="T:Microsoft.Build.Exceptions.RegistryException">
            <summary>
            Generic exception used to wrap exceptions thrown during Registry access.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.RegistryException.#ctor">
            <summary>
            Basic constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.RegistryException.#ctor(System.String)">
            <summary>
            Basic constructor.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.RegistryException.#ctor(System.String,System.Exception)">
            <summary>
            Basic constructor.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.RegistryException.#ctor(System.String,System.String)">
            <summary>
            Constructor that takes a string description of the registry
            key or value causing the error.
            </summary>
            <param name="message"></param>
            <param name="source"></param>
        </member>
        <member name="M:Microsoft.Build.Exceptions.RegistryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Since this class implements Iserializable this constructor is required to be implemented.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Exceptions.RegistryException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructor that takes a string description of the registry
            key or value causing the error.
            </summary>
            <param name="message"></param>
            <param name="source"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern">
             <summary>
             This class is used to selectively intern strings. It should be used at the point of new string creation.
             For example,
            
                 string interned = OpportunisticIntern.Intern(String.Join(",",someStrings));
            
             This class uses heuristics to decide whether it will be efficient to intern a string or not. There is no
             guarantee that a string will intern.
            
             The thresholds and sizes were determined by experimentation to give the best number of bytes saved
             at reasonable elapsed time cost.
             </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_smallMruSize">
            <summary>
            The size of the small mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_largeMruSize">
            <summary>
            The size of the large mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_hugeMruSize">
            <summary>
            The size of the huge mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_smallMruThreshold">
            <summary>
            The smallest size a string can be to be considered small.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_largeMruThreshold">
            <summary>
            The smallest size a string can be to be considered large.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_hugeMruThreshold">
            <summary>
            The smallest size a string can be to be considered huge.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_ginormousThreshold">
            <summary>
            The smallest size a string can be to be ginormous.
            8K for large object heap.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_si">
            <summary>
            Manages the separate MRU lists.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfInfinite">
            <summary>
            What if Mru lists were infinitely long?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfDoubled">
            <summary>
            What if we doubled the size of the Mru lists?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfHalved">
            <summary>
            What if we halved the size of the Mru lists?
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.s_whatIfZero">
            <summary>
            What if the size of Mru lists was zero? (We still intern tiny strings in this case)
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.IInternable">
            <summary>
            Define the methods needed to intern something.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.IInternable.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.IInternable.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.IInternable.ReferenceEquals(System.String)">
            <summary>
            Reference compare target to string. If target is non-string this should return false.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.AssignViaEnvironment(System.String,System.Int32)">
            <summary>
            Assign an int from an environment variable. If its not present, use the default.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.EnableStatisticsGathering">
            <summary>
            Turn on statistics gathering.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.InternableToString(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Intern the given internable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderToString(System.Text.StringBuilder)">
            <summary>
            Potentially Intern the given string builder.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayToString(System.Char[],System.Int32)">
            <summary>
            Potentially Intern the given char array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayToString(System.Char[],System.Int32,System.Int32)">
            <summary>
            Potentially Intern the given char array.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.InternStringIfPossible(System.String)">
            <summary>
            Potentially Intern the given string.
            </summary>
            <param name="candidate">The string to intern.</param>
            <returns>The interned string, or the same string if it could not be interned.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.ReportStatistics">
            <summary>
            Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget">
            <summary>
            A wrapper over StringBuilder.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget._target">
            <summary>
            The held StringBuilder
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.#ctor(System.Text.StringBuilder)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ReferenceEquals(System.String)">
            <summary>
            Never reference equals to string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringBuilderInternTarget.ToString">
            <summary>
            Don't use this function. Use ExpensiveConvertToString
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget">
            <summary>
            A wrapper over char[].
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget._startIndex">
            <summary>
            Start index for the string
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget._target">
            <summary>
            The held array
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.#ctor(System.Char[],System.Int32)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Pointless comment about constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.Length">
            <summary>
            The length of the target.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.Item(System.Int32)">
            <summary>
            Indexer into the target. Presumed to be fast.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ReferenceEquals(System.String)">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ExpensiveConvertToString">
            <summary>
            Convert target to string. Presumed to be slow (and will be called just once).
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare target to string. Assumes lengths are equal.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.CharArrayInternTarget.ToString">
            <summary>
            Don't use this function. Use ExpensiveConvertToString
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.StringInternTarget">
            <summary>
            Wrapper over a string.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.StringInternTarget._target">
            <summary>
            Stores the wrapped string.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.#ctor(System.String)">
            <summary>
            Constructor of the class
            </summary>
            <param name="target">The string to wrap</param>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringInternTarget.Length">
            <summary>
            Gets the length of the target string.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.StringInternTarget.Item(System.Int32)">
            <summary>
            Gets the n character in the target string.
            </summary>
            <param name="index">Index of the character to gather.</param>
            <returns>The character in the position marked by index.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.ExpensiveConvertToString">
            <summary>
            Returns the target which is already a string.
            </summary>
            <returns>The target string.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.IsOrdinalEqualToStringOfSameLength(System.String)">
            <summary>
            Compare if the target string is equal to the given string.
            </summary>
            <param name="other">The string to compare with the target.</param>
            <returns>True if the strings are equal, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.StringInternTarget.ReferenceEquals(System.String)">
            <summary>
            Verifies if the reference of the target string is the same of the given string.
            </summary>
            <param name="other">The string reference to compare to.</param>
            <returns>True if both references are equal, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList">
            <summary>
            Manages a set of mru lists that hold strings in varying size ranges.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._smallMru">
            <summary>
            The small string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._largeMru">
            <summary>
            The large string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._hugeMru">
            <summary>
            The huge string Mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormous">
            <summary>
            Three most recently used strings over 8K.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._smallMruThreshold">
            <summary>
            The smallest size a string can be to be considered small.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._largeMruThreshold">
            <summary>
            The smallest size a string can be to be considered large.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._hugeMruThreshold">
            <summary>
            The smallest size a string can be to be considered huge.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousThreshold">
            <summary>
            The smallest size a string can be to be ginormous.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._gatherStatistics">
            <summary>
            Whether or not to gather statistics
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internHits">
            <summary>
            Number of times interning worked.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internMisses">
            <summary>
            Number of times interning didn't work.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internRejects">
            <summary>
            Number of times interning wasn't attempted.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internEliminatedStrings">
            <summary>
            Total number of strings eliminated by interning.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._internEliminatedChars">
            <summary>
            Total number of chars eliminated across all strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousHits">
            <summary>
            Number of times the ginourmous string hit.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousMisses">
            <summary>
            Number of times the ginourmous string missed.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._ginormousCharsSaved">
            <summary>
            Chars interned for ginormous range.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._dontTrack">
            <summary>
            Whether or not to track ginormous strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._stopwatch">
            <summary>
            The time spent interning.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._missedStrings">
            <summary>
            Strings which did not intern
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList._rejectedStrings">
            <summary>
            Strings which we didn't attempt to intern
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.GinormousSize">
            <summary>
            Number of ginormous strings to keep
            By observation of Auto7, there are about three variations of the huge solution config blob
            There aren't really any other strings of this size, but make it 10 to be sure. (There will barely be any misses)
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Construct.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.InterningToString(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Intern the given internable.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.ReportStatistics(System.String)">
            <summary>
            Report statistics to the console.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.TryIntern(Microsoft.Build.OpportunisticIntern.IInternable,System.String@)">
            <summary>
            Try to intern the string.
            Return true if an interned value could be returned.
            Return false if it was added to the intern list, but wasn't there already.
            Return null if it didn't meet the length criteria for any of the buckets. Interning was rejected
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.InternWithStatistics(Microsoft.Build.OpportunisticIntern.IInternable)">
            <summary>
            Version of Intern that gathers statistics
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList">
            <summary>
            A singly linked list of strings where the most recently accessed string is at the top.
            Size expands up to a fixed number of strings.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList._size">
            <summary>
            Maximum size of the mru list.
            </summary>
        </member>
        <member name="F:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList._mru">
            <summary>
            Head of the mru list.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.#ctor(System.Int32)">
            <summary>
            Construct an Mru list with a fixed maximum size.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.TryGet(Microsoft.Build.OpportunisticIntern.IInternable,System.String@)">
            <summary>
            Try to get one element from the list. Upon leaving the function 'candidate' will be at the head of the Mru list.
            This function is not thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Statistics">
            <summary>
            Returns the number of strings held and the total number of chars held.
            </summary>
        </member>
        <member name="T:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node">
            <summary>
            Singly linked list node.
            </summary>
        </member>
        <member name="M:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.#ctor(System.String)">
            <summary>
            Construct a Node
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.Next">
            <summary>
            The next node in the list.
            </summary>
        </member>
        <member name="P:Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.PrioritizedStringList.Node.Value">
            <summary>
            The held string.
            </summary>
        </member>
        <member name="T:Microsoft.Build.Globbing.CompositeGlob">
            <summary>
                A Composite glob
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.CompositeGlob.Globs">
            <summary>
            The direct children of this composite
            </summary>
        </member>
        <member name="M:Microsoft.Build.Globbing.CompositeGlob.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Build.Globbing.IMSBuildGlob})">
            <summary>
                Constructor
            </summary>
            <param name="globs">Children globs. Input gets shallow cloned</param>
        </member>
        <member name="M:Microsoft.Build.Globbing.CompositeGlob.#ctor(Microsoft.Build.Globbing.IMSBuildGlob[])">
            <summary>
                Constructor
            </summary>
            <param name="globs">Children globs. Input gets shallow cloned</param>
        </member>
        <member name="M:Microsoft.Build.Globbing.CompositeGlob.IsMatch(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions">
            <summary>
            Extensions for <see cref="T:Microsoft.Build.Globbing.IMSBuildGlob"/>
            </summary>
        </member>
        <member name="M:Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(Microsoft.Build.Globbing.IMSBuildGlob)">
            <summary>
            Retrieve all the <see cref="T:Microsoft.Build.Globbing.MSBuildGlob"/> objects from the given <paramref name="glob"/> composite.
            </summary>
            <param name="glob">A glob composite</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Globbing.MSBuildGlobWithGaps">
            <summary>
                A glob with gaps. The gaps are represented as other globs.
                For example, to express a glob that matches all .cs files except the ones containing "foo" and the ones under bin directories, one can use:
                <code>
            new MSBuildGlobWithGaps(
               MSBuildGlob.Parse("**/*.cs"),            // matches all .cs files
               new CompositeGlob(                       // a composite glob to combine all the gaps
                  MSBuildGlob.Parse("**/*foo*.cs"),     // matches .cs files containing "foo"
                  MSBuildGlob.Parse("**/bin/**/*.cs")   // matches .cs files under bin directories
               )
            )
                </code>
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob">
            <summary>
                The main glob used for globbing operations.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlobWithGaps.Gaps">
            <summary>
                Glob which will be subtracted from the <see cref="P:Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob" />.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Globbing.MSBuildGlobWithGaps.#ctor(Microsoft.Build.Globbing.IMSBuildGlob,System.Collections.Generic.IEnumerable{Microsoft.Build.Globbing.IMSBuildGlob})">
            <summary>
                Constructor
            </summary>
            <param name="mainGlob">The main glob</param>
            <param name="gaps">The gap glob</param>
        </member>
        <member name="M:Microsoft.Build.Globbing.MSBuildGlobWithGaps.#ctor(Microsoft.Build.Globbing.IMSBuildGlob,Microsoft.Build.Globbing.IMSBuildGlob[])">
            <summary>
                Constructor
            </summary>
            <param name="mainGlob">The main glob</param>
            <param name="gaps">The gap glob</param>
        </member>
        <member name="M:Microsoft.Build.Globbing.MSBuildGlobWithGaps.IsMatch(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Build.Globbing.MSBuildGlob">
            <summary>
                Represents a parsed MSBuild glob.
                An MSBuild glob is composed of three parts:
                - fixed directory part: "a/b/" in "a/b/**/*test*/**/*.cs"
                - wildcard directory part: "**/*test*/**/" in "a/b/**/*test*/**/*.cs"
                - file name part: "*.cs" in "a/b/**/*test*/**/*.cs"
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.FixedDirectoryPart">
            <summary>
                The fixed directory part.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.WildcardDirectoryPart">
            <summary>
                The wildcard directory part
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.FilenamePart">
            <summary>
                The file name part
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.IsLegal">
            <summary>
                Whether the glob was parsed sucsesfully from a string.
                Illegal glob strings contain:
                - invalid path characters (other than the wildcard characters themselves)
                - "..."
                - ":"
                In addition, the wildcard directory part:
                - cannot contain ".."
                - if ** is present it must appear alone between slashes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Globbing.MSBuildGlob.IsMatch(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(System.String)">
            <summary>
                Similar to <see cref="M:Microsoft.Build.Globbing.MSBuildGlob.IsMatch(System.String)" /> but also provides the match groups for the glob parts
            </summary>
            <param name="stringToMatch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Globbing.MSBuildGlob.Parse(System.String,System.String)">
            <summary>
                Parse the given <paramref name="fileSpec" /> into a <see cref="T:Microsoft.Build.Globbing.MSBuildGlob" /> using a given
                <paramref name="globRoot" />.
            </summary>
            <param name="globRoot">
                The root of the glob.
                The fixed directory part of the glob and the match arguments (<see cref="M:Microsoft.Build.Globbing.MSBuildGlob.IsMatch(System.String)" /> and <see cref="M:Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(System.String)" />)
                will get normalized against this root.
                If empty, the current working directory is used.
                Cannot be null, and cannot contain invalid path arguments.
            </param>
            <param name="fileSpec">The string to parse</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Build.Globbing.MSBuildGlob.Parse(System.String)">
            <summary>
                See <see cref="M:Microsoft.Build.Globbing.MSBuildGlob.Parse(System.String,System.String)" />.
                The glob root, if the glob is not fully qualified, will be the current working directory.
            </summary>
            <param name="fileSpec"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult">
            <summary>
                Return type of <see cref="M:Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(System.String)" />
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.IsMatch">
            <summary>
                Whether the <see cref="M:Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(System.String)" /> argument was matched against the glob
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FixedDirectoryPartMatchGroup">
            <summary>
                The fixed directory part match
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.WildcardDirectoryPartMatchGroup">
            <summary>
                The wildcard directory part match
            </summary>
        </member>
        <member name="P:Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FilenamePartMatchGroup">
            <summary>
                The file name part match
            </summary>
        </member>
        <member name="T:Microsoft.Build.Globbing.IMSBuildGlob">
            <summary>
                Exposes the globbing semantics of the MSBuild engine.
            </summary>
        </member>
        <member name="M:Microsoft.Build.Globbing.IMSBuildGlob.IsMatch(System.String)">
            <summary>
                Matches the given <paramref name="stringToMatch" /> against the glob.
                Matching is path aware:
                - slashes are normalized
                - arguments representing relative paths are normalized against the glob's root.
                For example, the glob **/*.cs does not match ../a.cs, since ../a.cs points outside of the glob root.
            
                Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters>
            </summary>
            <param name="stringToMatch">The string to match. If the string represents a relative path, it will get normalized against the glob's root. Cannot be null.</param>
            <returns></returns>
        </member>
    </members>
</doc>
