using System;
using System.Collections.Generic;
using ScriptableFramework;

namespace DotnetStoryScript
{
    /// <summary>
    /// Plot command interface, the basic unit of plot script (some commands are compound commands, composed of basic commands).
    /// The value used in the command is described by the IStoryValue<T> interface, which supports parameters,
    /// local variables and built-in functions (returning the value used by a plot command).
    /// </summary>
    public interface IStoryCommand
    {
        bool Init(Dsl.ISyntaxComponent config);//Initialize command instance from DSL language
        string GetId();//Get command id
        Dsl.FunctionData GetComments();//Get command annotation dsl
        Dsl.ISyntaxComponent GetConfig();//Get command configuration dsl
        void ShareConfig(IStoryCommand cloner);
        IStoryCommand Clone();//Clone a new instance. Each command is only initialized once from the DSL language.
                              //Subsequent instances are generated by cloning to improve performance.
        IStoryCommand PrologueCommand { get; }   //The command implemented using DSL supports recursion.
                                                 //Because it is allowed to run across Ticks, the pop-up
                                                 //and stack-out operations cannot be performed within Ticks.
                                                 //The stack environment is maintained with the help of
                                                 //entry commands and exit commands.
        IStoryCommand EpilogueCommand { get; }   //The command implemented using DSL supports recursion.
                                                 //Because it is allowed to run across Ticks, the pop-up
                                                 //and stack-out operations cannot be performed within Ticks.
                                                 //The stack environment is maintained with the help of
                                                 //entry commands and exit commands.
        void Reset();//Reset the instance to ensure that the instance state is the initial state.
        bool Execute(StoryInstance instance, StoryMessageHandler handler, long delta, BoxedValue iterator, BoxedValueList args);//Execute commands, including processing parameters, variables and command logic
        bool ExecDebugger(StoryInstance instance, StoryMessageHandler handler, long delta, BoxedValue iterator, BoxedValueList args);
    }
    public abstract class AbstractStoryCommand : IStoryCommand
    {
        //Whether this command is a compound command.
        //Note: Compound commands need to manually call the Evaluate method.
        //The system does not call this method for compound commands.
        //(That is to say, in this case Evaluate only recommends
        //a method interface similar to other commands)!
        public virtual bool IsCompositeCommand
        {
            get { return false; }
        }
        public string GetId()
        {
            return m_Id;
        }
        public Dsl.FunctionData GetComments()
        {
            return m_Comments;
        }
        public Dsl.ISyntaxComponent GetConfig()
        {
            return m_Config;
        }
        public void ShareConfig(IStoryCommand cloner)
        {
            m_Comments = cloner.GetComments();
            m_Config = cloner.GetConfig();
            m_Id = cloner.GetId();
        }
        public bool Init(Dsl.ISyntaxComponent config)
        {
            bool ret = true;
            m_Config = config;
            m_Id = config.GetId();
            Dsl.FunctionData funcData = config as Dsl.FunctionData;
            if (null != funcData) {
                Load(funcData);
            }
            else {
                Dsl.StatementData statementData = config as Dsl.StatementData;
                if (null != statementData) {
                    int funcNum = statementData.GetFunctionNum();
                    var lastFunc = statementData.Last.AsFunction;
                    var id = lastFunc.GetId();
                    if (funcNum >= 2 && (id == "comment" || id == "comments")) {
                        m_Comments = lastFunc;
                        statementData.Functions.RemoveAt(funcNum - 1);
                        if (statementData.GetFunctionNum() == 1) {
                            funcData = statementData.GetFunction(0).AsFunction;
                            ret = Load(funcData);
                        }
                        else {
                            ret = Load(statementData);
                        }
                    }
                    else {
                        ret = Load(statementData);
                    }
                }
                else {
                    //keyword
                }
            }
            if (ScriptableFramework.GlobalVariables.Instance.IsDevice) {
                //Configuration information is no longer retained on the device
                m_Comments = null;
                m_Config = null;
            }
            return ret;
        }
        public void Reset()
        {
            if (!IsCompositeCommand) {
                m_LastExecResult = false;
            }
            ResetState();
        }
        public bool Execute(StoryInstance instance, StoryMessageHandler handler, long delta, BoxedValue iterator, BoxedValueList args)
        {
            if (IsCompositeCommand) {
                try {
                    return ExecCommand(instance, handler, delta, iterator, args);
                }
                catch (Exception ex) {
                    ScriptableFramework.LogSystem.Error("AbstractStoryCommand Composite Command ExecCommand Exception:{0}\n{1}", ex.Message, ex.StackTrace);
                    return false;
                }
            }
            else {
                if (!m_LastExecResult) {
                    //When executing repeatedly, the variable value does not need to be updated every tick.
                    //Each command is executed and the variable value is only read once.
                    try {
                        Evaluate(instance, handler, iterator, args);
                    }
                    catch (Exception ex) {
                        ScriptableFramework.LogSystem.Error("AbstractStoryCommand Evaluate Exception:{0}\n{1}", ex.Message, ex.StackTrace);
                        return false;
                    }
                }
                try {
                    if (instance.IsDebug && ExecDebugger(instance, handler, delta, iterator, args))
                        return true;
                    m_LastExecResult = ExecCommand(instance, handler, delta);
                }
                catch (Exception ex) {
                    ScriptableFramework.LogSystem.Error("AbstractStoryCommand ExecCommand Exception:{0}\n{1}", ex.Message, ex.StackTrace);
                    m_LastExecResult = false;
                }
                return m_LastExecResult;
            }
        }
        public bool ExecDebugger(StoryInstance instance, StoryMessageHandler handler, long delta, BoxedValue iterator, BoxedValueList args)
        {
            if (null != instance.OnExecDebugger) {
                return instance.OnExecDebugger(instance, handler, this, delta, iterator, args);
            }
            return false;
        }
        public IStoryCommand Clone()
        {
            var cmd = CloneCommand();
            cmd.ShareConfig(this);
            return cmd;
        }
        public virtual IStoryCommand PrologueCommand
        {
            get { return null; }
        }
        public virtual IStoryCommand EpilogueCommand
        {
            get { return null; }
        }
        protected abstract IStoryCommand CloneCommand();
        protected virtual void ResetState() { }
        protected virtual void Evaluate(StoryInstance instance, StoryMessageHandler handler, BoxedValue iterator, BoxedValueList args) { }
        protected virtual bool ExecCommand(StoryInstance instance, StoryMessageHandler handler, long delta)
        {
            return false;
        }
        protected virtual bool ExecCommand(StoryInstance instance, StoryMessageHandler handler, long delta, BoxedValue iterator, BoxedValueList args)
        {
            return false;
        }
        protected virtual bool Load(Dsl.FunctionData funcData)
        {
            bool ret = true;
            if (funcData.IsHighOrder) {
                if (funcData.LowerOrderFunction.GetParamNum() > 0 || funcData.HaveStatement() || funcData.HaveExternScript()) {
                    ret = false;
                }
            }
            else if (funcData.HaveStatement() || funcData.HaveExternScript()) {
                ret = false;
            }
            else if (funcData.HaveParam()) {
                ret = true;
            }
            return ret;
        }
        protected virtual bool Load(Dsl.StatementData statementData)
        {
            bool v = true;
            foreach (var f in statementData.Functions) {
                var func = f.AsFunction;
                if (func.IsHighOrder) {
                    if (func.LowerOrderFunction.GetParamNum() > 0 || func.HaveStatement() || func.HaveExternScript()) {
                        v = false;
                    }
                }
                else if (func.HaveStatement() || func.HaveExternScript()) {
                    v = false;
                }
            }
            return v;
        }

        private Dsl.FunctionData m_Comments;
        private Dsl.ISyntaxComponent m_Config;
        private string m_Id;
        private bool m_LastExecResult = false;
    }
}
